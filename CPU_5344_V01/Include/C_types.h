//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
typedef UDINT _DRIVETYPE; 
    #define _NotFound 0
    #define _SDD_310 1
    #define _SDD_315 2
    #define _SDD_105 3
    #define _SDD_120 4
    #define _SDD_305 5
    #define _SDD_335 6
    #define _SDD_215 7
    #define _SDD_205 8
    #define _SDD_210 9
    #define _MDD_100 10
    #define _S_340 11
    #define _SDD_115 12
    #define _SDD_1300 811237
    #define _SDD_1400 811238
    #define _SDD_1500 811239
    #define _SDD_1600 811240
    #define _MDD_2000 811300
    #define _VSDC_151 811301
    #define _DC061 881042
    #define _DC062 881801
    #define _SR011 881802
    #define _SR012 881803
    #define _DC101 881804
    #define _DC102 881805
    #define _WA011 991800
    #define _WA012 991801

#pragma pack(push, 1)
typedef struct _I_HC_Type   //! <Type Comment="Hardware Code an axis&#13;&#10;&#13;&#10;Bit 31..16 Hardware Code of the Control Board&#13;&#10;Bit 15...8 Software version of the feedback CPLD&#13;&#10;Bit   7...0 Hardware Code of the Power Stage" Name="_I_HC_Type"/>
  {
    HSINT HardwareCodePowerStage;  //! <Type Comment="Hardware Code of the Power Stage (Default: 16#80)" Name="_I_HC_Type.HardwareCodePowerStage"/>
    HSINT FPGAVersion;  //! <Type Comment="Software version of the feedback CPLD" Name="_I_HC_Type.FPGAVersion"/>
    HINT HardwareCodeControlBoard;  //! <Type Comment="Hardware Code of the Control Board (Default: 16#0000)" Name="_I_HC_Type.HardwareCodeControlBoard"/>
  } _I_HC_Type;
#pragma pack(pop)

typedef UDINT _LMC_DYN_SWLIMITS;   //! <Type Comment="Dynamic software end positions" Name="_LMC_DYN_SWLIMITS"/>
    #define _LMC_DynSWLimitMin 0
    #define _LMC_DynSWLimitMax 1

typedef struct   //! <Type Comment="Status flags" Name="_LMCAXIS_CMDERROR"/>
  {
    long PowerOff : 1;  //! <Type Comment="1 --&gt; Position controller is off" Name="_LMCAXIS_CMDERROR.PowerOff"/>
    long NoReference : 1;  //! <Type Comment="1 --&gt; The axis is not referenced" Name="_LMCAXIS_CMDERROR.NoReference"/>
    long HWError : 1;  //! <Type Comment="1 --&gt; Servo hardware error" Name="_LMCAXIS_CMDERROR.HWError"/>
    long ActPosError : 1;  //! <Type Comment="1 --&gt; Invalid position of the hardware" Name="_LMCAXIS_CMDERROR.ActPosError"/>
    long ContouringError : 1;  //! <Type Comment="1 --&gt; Tracking limit exceeded" Name="_LMCAXIS_CMDERROR.ContouringError"/>
    long CommandError : 1;  //! <Type Comment="1 --&gt; Command not allowed or &#13;&#10;within the CNC RTWork cycle more than one command has been set&#13;&#10;" Name="_LMCAXIS_CMDERROR.CommandError"/>
    long SWMinError : 1;  //! <Type Comment="1 --&gt; Software endswitch minimum active" Name="_LMCAXIS_CMDERROR.SWMinError"/>
    long SWMaxError : 1;  //! <Type Comment="1 --&gt; Software endswitch maximum active" Name="_LMCAXIS_CMDERROR.SWMaxError"/>
    long vError : 1;  //! <Type Comment="1 --&gt; Selected speed too high" Name="_LMCAXIS_CMDERROR.vError"/>
    long aError : 1;  //! <Type Comment="1 --&gt; Selected acceleration / deceleration too high" Name="_LMCAXIS_CMDERROR.aError"/>
    long HWMinError : 1;  //! <Type Comment="1 --&gt; Hardware endswitch minimum active" Name="_LMCAXIS_CMDERROR.HWMinError"/>
    long HWMaxError : 1;  //! <Type Comment="1 --&gt; Hardware endswitch maximum active" Name="_LMCAXIS_CMDERROR.HWMaxError"/>
    long DirError : 1;  //! <Type Comment="1 --&gt; The direction of motion is not allowed" Name="_LMCAXIS_CMDERROR.DirError"/>
    long EmergencyError : 1;  //! <Type Comment="when Client _LMCSafety.Emergency goes to 1&#13;&#10; 0 -&gt; StopMove&#13;&#10; 1 -&gt; PowerOff" Name="_LMCAXIS_CMDERROR.EmergencyError"/>
    long ResolutionError : 1;  //! <Type Comment="1 -&gt; An overflow by multiplication with the value of the server: Resolution occurred&#13;&#10;" Name="_LMCAXIS_CMDERROR.ResolutionError"/>
    long GlobalError : 1;  //! <Type Comment="1 --&gt; Global error" Name="_LMCAXIS_CMDERROR.GlobalError"/>
    long JError : 1;  //! <Type Comment="1--&gt; Selected jerk is too high or low." Name="_LMCAXIS_CMDERROR.JError"/>
  }_LMCAXIS_CMDERROR;

typedef struct   //! <Type Comment="Control-Bits" Name="_LMCAXIS_CONTROLBITS"/>
  {
    long SetPowerOn : 1;  //! <Type Comment="Set if the clients &quot;LMCController&quot; and &quot;ActPosition&quot; are not connected or &#13;&#10;the axis is active" Name="_LMCAXIS_CONTROLBITS.SetPowerOn"/>
    long SetFollowMode : 1;  //! <Type Comment="Set if the axis is in operationmode: &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_CONTROLBITS.SetFollowMode"/>
    long ReadActPosFromController : 1;
    long CallReadPDO : 1;
  }_LMCAXIS_CONTROLBITS;

typedef UDINT _LMCAXIS_COUPLE_GEAR_MODE;   //! <Type Comment="Parameter of the methods &quot;CoupleUserPos&quot; and &quot;CoupleProfilePos&quot;" Name="_LMCAXIS_COUPLE_GEAR_MODE"/>
    #define LMCAXIS_COUPLE_PROFILE_GEAR 0
    #define LMCAXIS_COUPLE_PROFILE_NO_GEAR 1

typedef UDINT _LMCAXIS_COUPLEERROR;   //! <Type Comment="Errorlist returned by the function: &quot;CoupleGearPolynom&quot;" Name="_LMCAXIS_COUPLEERROR"/>
    #define LMCAXIS_NO_ERROR_OCCURED 0
    #define LMCAXIS_MASTERPOINTER_INVALID 1
    #define LMCAXIS_SELFCOUPLING 2
    #define LMCAXIS_SOFTWARE_ERROR 3
    #define LMCAXIS_VEL_MASTER_NOT_POSITIVE 4
    #define LMCAXIS_PATH_MASTER_NOT_POSITIVE 5
    #define LMCAXIS_PATH_SLAVE_NOT_POSITIVE 6
    #define LMCAXIS_VEL_MASTER_DEFINITION_ERROR 7
    #define LMCAXIS_JERK_MAX_DEFINITION_ERROR 8
    #define LMCAXIS_ACC_ANNIHILATION_FAILED_3_5 9
    #define LMCAXIS_PATH_SX_NEGATIVE_3_5 10
    #define LMCAXIS_VEL_COUPLE_NEGATIVE_3_5 11
    #define LMCAXIS_VEL_COUPLE_EXCEED_3_5 12
    #define LMCAXIS_PATH_SZ_NEGATIVE_3_5 13
    #define LMCAXIS_TIME_SZ_NEGATIVE_3_5 14
    #define LMCAXIS_VEL_MIN_NEGATIVE_3_5 15
    #define LMCAXIS_VEL_MAX_EXCEED_3_5 16
    #define LMCAXIS_ACC_MAX_EXCEED_3_5 17
    #define LMCAXIS_JERK_MAX_SLAVE_EXCEED_3_5 18
    #define LMCAXIS_ACC_ANNIHILATION_FAILED_4_1_4 19
    #define LMCAXIS_VEL_ACCNIHIL_NEGATIVE 20
    #define LMCAXIS_VEL_ACCNIHIL_EXCEED 21
    #define LMCAXIS_ACC_MAX_DEFINITION_ERROR 22
    #define LMCAXIS_VEL_COUPLE_NEGATIVE_4_1_4 23
    #define LMCAXIS_VEL_COUPLE_EXCEED_4_1_4 24
    #define LMCAXIS_PATH_SX_NEGATIVE_4_1_4 25
    #define LMCAXIS_PATH_SY_NEGATIVE_4_1_4 26
    #define LMCAXIS_PATH_SZ_NEGATIVE_4_1_4 27
    #define LMCAXIS_VEL_MIN_NEGATIVE_4_1_4 28
    #define LMCAXIS_VEL_MAX_EXCEED_4_1_4 29
    #define LMCAXIS_ACC_MAX_1_EXCEED_4_1_4 30
    #define LMCAXIS_ACC_MAX_2_EXCEED_4_1_4 31
    #define LMCAXIS_JERK_MAX_1_EXCEED_4_1_4 32
    #define LMCAXIS_JERK_MAX_2_EXCEED_4_1_4 33
    #define LMCAXIS_TRAPEZOIDSPLINE_DISABLED 34
    #define LMCAXIS_VEL_COUPLE_NO_SOLUTION 35
    #define LMCAXIS_VEL_COUPLE_NEGATIVE_2_1_2 36
    #define LMCAXIS_VEL_COUPLE_EXCEED_2_1_2 37
    #define LMCAXIS_TIME_SX_NEGATIVE_2_1_2 38
    #define LMCAXIS_TIME_SY_NEGATIVE_2_1_2 39
    #define LMCAXIS_TIME_SZ_NEGATIVE_2_1_2 40
    #define LMCAXIS_PATH_SX_NEGATIVE_2_1_2 41
    #define LMCAXIS_PATH_SY_NEGATIVE_2_1_2 42
    #define LMCAXIS_PATH_SZ_NEGATIVE_2_1_2 43
    #define LMCAXIS_DURATION_ERROR 44

#pragma pack(push, 1)
typedef struct CurveTable   //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="CurveTable"/>
  {
    DINT MasterPos;  //! <Type Comment="Master axis position [Application units]" Name="CurveTable.MasterPos"/>
    DINT SlavePos;  //! <Type Comment="Slave axis position [Application units]" Name="CurveTable.SlavePos"/>
  } CurveTable;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _LMCAXIS_CURVE   //! <Type Comment="Motion type curve data" Name="_LMCAXIS_CURVE"/>
  {
    DINT modulo;  //! <Type Comment="Lead axis modulo value" Name="_LMCAXIS_CURVE.modulo"/>
    DINT points;  //! <Type Comment="number of curve points" Name="_LMCAXIS_CURVE.points"/>
    DINT mul;  //! <Type Comment="Numerator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.mul"/>
    DINT div;  //! <Type Comment="Denominator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.div"/>
    DINT offset;  //! <Type Comment="Position offset in the slave axis of the cam definition [Internal units].&#13;&#10;Added to the slave value of the cam table." Name="_LMCAXIS_CURVE.offset"/>
    CurveTable table [1023+1-0];  //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="_LMCAXIS_CURVE.table"/>
  } _LMCAXIS_CURVE;
#pragma pack(pop)

typedef struct   //! <Type Comment="Slave axis operating mode" Name="_LMCAXIS_CURVETABMODE"/>
  {
    long bStopAxisNoMod : 1;  //! <Type Comment="Parameter of the function &quot;CoupleCurveTab&quot; / &quot;CoupleCAM&quot;&#13;&#10;0 --&gt; Normal operation. Slave follows the master over the curve definition, including a master axis position overflow.&#13;&#10;1 --&gt; Stop slave axis immediately when master axis position overflows." Name="_LMCAXIS_CURVETABMODE.bStopAxisNoMod"/>
    long bRecoupleCamMod : 1;  //! <Type Comment="Parameter of the function &quot;CoupleCurveTab&quot; / &quot;CoupleCAM&quot;. This parameter defines the coupling mode for a master modulo axis and a slave modulo axis,&#13;&#10;0 --&gt; Normal coupling (first coupling)&#13;&#10;1 --&gt; Recouple to a different CAM table or couple after a successfull decouple to the given CAM table." Name="_LMCAXIS_CURVETABMODE.bRecoupleCamMod"/>
  }_LMCAXIS_CURVETABMODE;

typedef struct   //! <Type Comment="Error-Bits" Name="_LMCAXIS_ERROR"/>
  {
    long HwError : 1;  //! <Type Comment="Set if a general Hardware-Error occured" Name="_LMCAXIS_ERROR.HwError"/>
    long SwMinError : 1;  //! <Type Comment="Set if the Software-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.SwMinError"/>
    long SwMaxError : 1;  //! <Type Comment="Set if the Software-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.SwMaxError"/>
    long HwMinError : 1;  //! <Type Comment="Set if the Hardware-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.HwMinError"/>
    long HwMaxError : 1;  //! <Type Comment="Set if the Hardware-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.HwMaxError"/>
    long ReferenceError : 1;  //! <Type Comment="Set if an error occured during the reference-run" Name="_LMCAXIS_ERROR.ReferenceError"/>
    long ContouringError : 1;  //! <Type Comment="Set if a tracking-error occured" Name="_LMCAXIS_ERROR.ContouringError"/>
    long ActPosError : 1;  //! <Type Comment="Set if the Hardware-Position is invalid" Name="_LMCAXIS_ERROR.ActPosError"/>
    long AbsOffsetError : 1;  //! <Type Comment="Set if an Offset-Error occured" Name="_LMCAXIS_ERROR.AbsOffsetError"/>
    long OverFlowError : 1;  //! <Type Comment="Set if a Position-Overflow occured" Name="_LMCAXIS_ERROR.OverFlowError"/>
    long EmergencyError : 1;  //! <Type Comment="Set if the _LMCSafety.Emergency is active" Name="_LMCAXIS_ERROR.EmergencyError"/>
    long ResolutionError : 1;  //! <Type Comment="Set if the Resolution causes an overflow error&#13;&#10;" Name="_LMCAXIS_ERROR.ResolutionError"/>
    long PowerOnError : 1;  //! <Type Comment="Set, if the enable signal of the hardware was cleared during operation, or if after calling PowerOn() the axis has not been enabled before a timeout of 30 seconds occured." Name="_LMCAXIS_ERROR.PowerOnError"/>
    long PowerOffError : 1;  //! <Type Comment="Set, if after calling PowerOff() the axis has not been disabled before a timeout occured." Name="_LMCAXIS_ERROR.PowerOffError"/>
    long dummy0 : 1;
    long GlobErr : 1;  //! <Type Comment="Set if a global error is active" Name="_LMCAXIS_ERROR.GlobErr"/>
  }_LMCAXIS_ERROR;

typedef struct   //! <Type Comment="Error-Config Bits" Name="_LMCAXIS_ERROR_CONFIG"/>
  {
    long vError : 1;  //! <Type Comment="when programmed speed is too high:&#13;&#10; 0 ... the speed will be limited (default)&#13;&#10; 1 ... set the vError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.vError"/>
    long aError : 1;  //! <Type Comment="when programmed acceleration is too high:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the aError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.aError"/>
    long SWMinError : 1;  //! <Type Comment="when position would be smaller than SWMinPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMinError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMinError"/>
    long SWMaxError : 1;  //! <Type Comment="when position would be bigger than SWMaxPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMaxError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMaxError"/>
    long CommandError : 1;  //! <Type Comment="when the deltaposition is bigger than the&#13;&#10;MaxModulo during coupling:&#13;&#10; 0 ... no check (default)&#13;&#10; 1 ... set the CommandError flag in the command result" Name="_LMCAXIS_ERROR_CONFIG.CommandError"/>
    long EmergencyError : 1;  //! <Type Comment="when Emergency goes to 1:&#13;&#10; 0 ... StopMove() (default)&#13;&#10; 1 ... PowerOff()&#13;&#10;" Name="_LMCAXIS_ERROR_CONFIG.EmergencyError"/>
    long CoupleMonitoring : 1;  //! <Type Comment="0: Monitoring the coupled axes is disabled. This axis does not recognise an error of its master axis and also does not report its own errors to the master. Furthermore, there is no reaction on errors of its slaves.&#13;&#10;1: Monitoring of all coupled master and slave axes for errors is enabled. The error handling can be configured with SetParameter with modes LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR, LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR, and LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG." Name="_LMCAXIS_ERROR_CONFIG.CoupleMonitoring"/>
    long JError : 1;  //! <Type Comment="when programmed jerk is too high or low:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the JError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.JError"/>
  }_LMCAXIS_ERROR_CONFIG;

typedef UDINT _LMCAXIS_FOLLOW_MODE;   //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;" Name="_LMCAXIS_FOLLOW_MODE"/>
    #define LMCAXIS_DEACTIVATE_FOLLOW_MODE 0
    #define LMCAXIS_ACTIVATE_FOLLOW_MODE 1

typedef UDINT _LMCAXIS_MOVE_RELATIVE_MODE;   //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;" Name="_LMCAXIS_MOVE_RELATIVE_MODE"/>
    #define LMCAXIS_MOVE_RELATIVE_TO_DESTINATION 0
    #define LMCAXIS_MOVE_RELATIVE_TO_POSITION 1

typedef UDINT _LMCAXIS_MOVEDIRECTION;   //! <Type Comment="Set direction of movement for the axis&#13;&#10;" Name="_LMCAXIS_MOVEDIRECTION"/>
    #define LMCAXIS_MOVE_ANY_WAY 0
    #define LMCAXIS_MOVE_NEG_DIR 1
    #define LMCAXIS_MOVE_SHORTEST_WAY 2
    #define LMCAXIS_MOVE_POS_DIR 3

typedef UDINT _LMCAXIS_MOVEPROFILE;   //! <Type Comment="Velocity-profile" Name="_LMCAXIS_MOVEPROFILE"/>
    #define _RAMP_PROFILE 0
    #define _SCURVE_PROFILE 1
    #define _JERK_PROFILE 10

typedef UDINT _LMCAXIS_MOVINGTIMEERROR;   //! <Type Comment="Errorlist returned by the function: &quot;CalcMovingTime&quot;" Name="_LMCAXIS_MOVINGTIMEERROR"/>
    #define LMCAXIS_NO_ERROR_ 0
    #define LMCAXIS_MAXVEL_NOT_POSITIV 1
    #define LMCAXIS_STARTVEL_TO_BIG 2
    #define LMCAXIS_ENDVEL_TO_BIG 3
    #define LMCAXIS_PATH_IS_ZERO 4
    #define LMCAXIS_STARTVEL_NEGATIVE 5
    #define LMCAXIS_OVERFLOW_ERROR 6
    #define LMCAXIS_TIME_ERROR_1 7
    #define LMCAXIS_TIME_ERROR_2 8
    #define LMCAXIS_TIME_ERROR_3 9
    #define LMCAXIS_POINTER_ERROR 10
    #define LMCAXIS_ENDVEL_NEGATIVE 11
    #define LMCAXIS_ACCEL_NOT_POSITIV 12
    #define LMCAXIS_DECEL_NOT_POSITIV 13
    #define LMCAXIS_PATH_ERROR 14
    #define LMCAXIS_GLOBAL_ERROR 15
    #define LMCAXIS_NUMERIC_ERROR 16
    #define LMCAXIS_MATH_ERROR 17
    #define LMCAXIS_NO_SOLUTION 18

typedef UDINT _LMCAXIS_OPMODE;   //! <Type Comment="Current state of the axis" Name="_LMCAXIS_OPMODE"/>
    #define PASSIVE_LMCAXIS 0
    #define WAITIDLE_LMCAXIS 1
    #define IDLE_LMCAXIS 2
    #define MOVE_LMCAXIS 3
    #define FOLLOW_LMCAXIS 4
    #define STOPED_LMCAXIS 5
    #define LOCKED_LMCAXIS 6
    #define REFRUN_LMCAXIS 7
    #define TUNEPOS_LMCAXIS 8
    #define TUNENEG_LMCAXIS 9
    #define ERROR_LMCAXIS 10
    #define WAITPASSIVE_LMCAXIS 11

typedef UDINT _LMCAXIS_POSMODE;   //! <Type Comment="Positionmode" Name="_LMCAXIS_POSMODE"/>
    #define _Positioning 0
    #define _NCPositioning 1
    #define _StdSyncPositioning 2
    #define _UserSyncPositioning 3
    #define _CAMSyncPositioning 4
    #define _ProfileSyncPositioning 5
    #define _SyncVelocity 6
    #define _StartPolynomPositioning 7
    #define _SyncPolynomPositioning 8

typedef UDINT _LMCAXIS_POWER_OFF_MODE;   //! <Type Comment="Parameter of the function: &quot;PowerOff&quot;" Name="_LMCAXIS_POWER_OFF_MODE"/>
    #define LMCAXIS_IMMEDIATE_STOPP 0
    #define LMCAXIS_SMOOTH_STOPP 1

typedef DINT _LMCAXIS_QUERY_POSITION_MODE;   //! <Type Comment="Parameter of the function &quot;InPosition&quot;" Name="_LMCAXIS_QUERY_POSITION_MODE"/>
    #define LMCAXIS_NO_JERK_FILTER -2
    #define LMCAXIS_NO_POSITIONWINDOW -1
    #define LMCAXIS_POSITIONWINDOW_APP_UNITS 0
    #define LMCAXIS_POSITIONWINDOW_INT_UNITS 1
    #define LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS 2
    #define LMCAXIS_SETPOS_IN_WINDOW_INT_UNITS 3
    #define LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS 4
    #define LMCAXIS_ACTPOS_IN_WINDOW_INT_UNITS 5

typedef UDINT _LMCAXIS_READPARAMETER;   //! <Type Comment="Parameter-ID" Name="_LMCAXIS_READPARAMETER"/>
    #define LMCAXIS_PAR_RD_V_MAX 0
    #define LMCAXIS_PAR_RD_A_MAX 1
    #define LMCAXIS_PAR_RD_EXTUNITS 2
    #define LMCAXIS_PAR_RD_INTUNITS 3
    #define LMCAXIS_PAR_RD_RESFACT 4
    #define LMCAXIS_PAR_RD_SEMAPHOR 5
    #define LMCAXIS_PAR_RD_REFPOS 6
    #define LMCAXIS_PAR_RD_MODULO 7
    #define LMCAXIS_PAR_RD_MASTERLOCK_11 8
    #define LMCAXIS_PAR_RD_MASTERLOCK_12 9
    #define LMCAXIS_PAR_RD_MAX_MODULO 10
    #define LMCAXIS_PAR_RD_BINOFFSET 11
    #define LMCAXIS_PAR_RD_POSMODE 12
    #define LMCAXIS_PAR_RD_CONTROLLERTYPE 13
    #define LMCAXIS_PAR_RD_TIMEBASE 14
    #define LMCAXIS_PAR_RD_CONTROLLERPAR 15
    #define LMCAXIS_PAR_RD_J_MAX 16
    #define LMCAXIS_PAR_RD_MOVETYPE 17
    #define LMCAXIS_PAR_RD_T_JERK 18
    #define LMCAXIS_PAR_RD_HARDLOCK 19
    #define LMCAXIS_PAR_RD_SHAPE_SPLINE 20
    #define LMCAXIS_PAR_RD_COUPLE_ERROR 21
    #define LMCAXIS_PAR_RD_MOVEDIRECTION 22
    #define LMCAXIS_PAR_RD_SWLIMWINDOW 23
    #define LMCAXIS_PAR_RD_MASTER_DELAY 24
    #define LMCAXIS_PAR_RD_DEC 25
    #define LMCAXIS_PAR_RD_DYN_SW_LIMIT 26
    #define LMCAXIS_PAR_RD_MAX_OVERRIDE 27
    #define LMCAXIS_PAR_RD_NORM_OVERRIDE 28
    #define LMCAXIS_PAR_RD_OVERRIDE 29
    #define LMCAXIS_PAR_RD_DELAYEDMASTERLOCK 30
    #define LMCAXIS_PAR_RD_OVERFLOW_POS 31
    #define LMCAXIS_PAR_RD_MIN_POSITION 32
    #define LMCAXIS_PAR_RD_MAX_POSITION 33
    #define LMCAXIS_PAR_RD_ZPULSE_DIST 34
    #define LMCAXIS_PAR_RD_ALLOWED_ACC_JUMP 35
    #define LMCAXIS_PAR_RD_SIMULATE_MODE 36
    #define LMCAXIS_PAR_RD_ERROR_CONFIG 37
    #define LMCAXIS_PAR_RD_AEMERGENCY 38
    #define LMCAXIS_PAR_RD_ABS_ENCODER 39
    #define LMCAXIS_PAR_RD_AXISERROR 40

typedef UDINT _LMCAXIS_READPOS;   //! <Type Comment="Type of the position that should be read" Name="_LMCAXIS_READPOS"/>
    #define LMCAXIS_SETPOS_APPUNIT 0
    #define LMCAXIS_SETPOS_INTUNIT 1
    #define LMCAXIS_SETPOS_INTUNIT_WO_MOD 2
    #define LMCAXIS_DESTPOS_INTUNIT 3
    #define LMCAXIS_SETPOS_INTUNIT_JERK_WO_MOD 4
    #define LMCAXIS_SETPOS_INTUNIT_JERK 5
    #define LMCAXIS_SETPOS_APPUNIT_JERK 6
    #define LMCAXIS_SETPOS_APPUNIT_SPEC1 7
    #define LMCAXIS_ACTPOS_APPUNIT 8
    #define LMCAXIS_ACTPOS_INTUNIT 9
    #define LMCAXIS_ACTPOS_INTUNIT_WO_MOD 10
    #define LMCAXIS_BRAKEPOS_APPUNIT 11
    #define LMCAXIS_MASTERPOS_INTUNIT 12
    #define LMCAXIS_XW_TO_DESTPOS_INTUNIT 13

typedef UDINT _LMCAXIS_READSWENDPOS;   //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;" Name="_LMCAXIS_READSWENDPOS"/>
    #define LMCAXIS_RD_SWMAX_APPUNIT 0
    #define LMCAXIS_RD_SWMIN_APPUNIT 1
    #define LMCAXIS_RD_SWMAX_INTUNIT 2
    #define LMCAXIS_RD_SWMIN_INTUNIT 3

typedef UDINT _LMCAXIS_READVELOCITY;   //! <Type Comment="Type of the axis velocity that should be read" Name="_LMCAXIS_READVELOCITY"/>
    #define LMCAXIS_SETVEL_APPUNIT_SEC 0
    #define LMCAXIS_SETVEL_INTUNIT_SEC 1
    #define LMCAXIS_SETVEL_APPUNIT_NCMODE 2
    #define LMCAXIS_SETVEL_INTUNIT_NCMODE 3
    #define LMCAXIS_ACTVEL_APPUNIT_MS 4
    #define LMCAXIS_ACTVEL_INTUNIT_MS 5
    #define LMCAXIS_SETVEL_INTUNIT_TICK_JERK 6
    #define LMCAXIS_SETVEL_APPUNIT_SEC_JERK 7
    #define LMCAXIS_SETVEL_INTUNIT_TICK 8
    #define LMCAXIS_ACTVEL_APPUNIT_SEC 9
    #define LMCAXIS_ACTVEL_INTUNIT_SEC 10
    #define LMCAXIS_ACTVEL_APPUNIT_SEC_FILT 11
    #define LMCAXIS_ACTVEL_INTUNIT_SEC_FILT 12
    #define LMCAXIS_CMDVEL_APPUNIT 13

#pragma pack(push, 1)
typedef struct _LMCAXIS_REFDATA   //! <Type Comment="Parameters of the functions: &#13;&#10;&quot;MoveReference&quot;, &quot;ReferenceAxis&quot; and &quot;_LMCAxisRef::control&quot;" Name="_LMCAXIS_REFDATA"/>
  {
    iprStates Status;
    DINT Velocity;  //! <Type Comment="Velocity during the refernce run" Name="_LMCAXIS_REFDATA.Velocity"/>
    DINT Acc;  //! <Type Comment="Acceleration during the refernce run" Name="_LMCAXIS_REFDATA.Acc"/>
    DINT vSetRef1;  //! <Type Comment="Velocity during the movement to the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef1"/>
    DINT vSetRef2;  //! <Type Comment="Velocity during the movement away from the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef2"/>
    DINT PosWindow;  //! <Type Comment="Position window for the Z-Impuls" Name="_LMCAXIS_REFDATA.PosWindow"/>
    DINT LatchPosRef;  //! <Type Comment="External position used in mode &quot;RefLatchPos&quot;" Name="_LMCAXIS_REFDATA.LatchPosRef"/>
  } _LMCAXIS_REFDATA;
#pragma pack(pop)

typedef struct   //! <Type Comment="Reference mode" Name="_LMCAXIS_REFMODE"/>
  {
    long NoZImpulse : 1;  //! <Type Comment="0 --&gt; Referencing with referencing impulse&#13;&#10;1 --&gt; Referencing without referencing impulse" Name="_LMCAXIS_REFMODE.NoZImpulse"/>
    long NoEndSwitch : 1;  //! <Type Comment="0 --&gt; Referencing with endswitches&#13;&#10;1 --&gt; Referencing without endswitches" Name="_LMCAXIS_REFMODE.NoEndSwitch"/>
    long RefDirection : 1;  //! <Type Comment="1 --&gt; Referencing on positive direction&#13;&#10;0 --&gt; Referencing on negative direction" Name="_LMCAXIS_REFMODE.RefDirection"/>
    long NoTurnOnSwitch : 1;  //! <Type Comment="0 --&gt; Reverse direction at the reference switch&#13;&#10;1 --&gt; Do not reverse direction at the reference switch" Name="_LMCAXIS_REFMODE.NoTurnOnSwitch"/>
    long ESEqualRef : 1;  //! <Type Comment="1 --&gt; Hardware end switch is used as reference switch" Name="_LMCAXIS_REFMODE.ESEqualRef"/>
    long NoSet : 1;  //! <Type Comment="0 --&gt; The transmitted position is the reference position&#13;&#10;1 --&gt; The actual position is the reference position" Name="_LMCAXIS_REFMODE.NoSet"/>
    long RefLatchPos : 1;  //! <Type Comment="1 --&gt; Read reference position from client cLatchPos. If value changes, do a MoveAbsolute(cLatchPos) and set cLatchPos as current position." Name="_LMCAXIS_REFMODE.RefLatchPos"/>
    long RefFirstEdge : 1;  //! <Type Comment="1 --&gt; Go back to first edge of ref.switch or end switch" Name="_LMCAXIS_REFMODE.RefFirstEdge"/>
  }_LMCAXIS_REFMODE;

typedef UDINT _LMCAXIS_SETPARAMETER;   //! <Type Comment="Parameter-ID" Name="_LMCAXIS_SETPARAMETER"/>
    #define LMCAXIS_PAR_SET_COUPLING_MODE 0
    #define LMCAXIS_PAR_SET_DESTINATION 1
    #define LMCAXIS_PAR_SET_OVERRIDE 2
    #define LMCAXIS_PAR_SET_LOGMODE 3
    #define LMCAXIS_PAR_RESET_REF_STATE 4
    #define LMCAXIS_PAR_SET_CHANGE_SW_LIMITS 5
    #define LMCAXIS_PAR_SET_JERK_LIMITATION 6
    #define LMCAXIS_PAR_SET_SHIFT_BREAKPOS 7
    #define LMCAXIS_PAR_SET_OVERFLOW_POS 8
    #define LMCAXIS_PAR_SET_MIN_POSITION 9
    #define LMCAXIS_PAR_SET_MAX_POSITION 10
    #define LMCAXIS_PAR_SET_HARDLOCK 11
    #define LMCAXIS_PAR_SET_SWLIM_STANDSTILL 12
    #define LMCAXIS_PAR_SET_SWLIM_DIR_CHANGE 13
    #define LMCAXIS_PAR_SET_SWLIM_MOVING 14
    #define LMCAXIS_PAR_SET_INIT_JERK_FILTER 15
    #define LMCAXIS_PAR_SET_BINOFFSET 16
    #define LMCAXIS_PAR_SET_VJUMP 17
    #define LMCAXIS_PAR_SET_SW_LIMIT_FLAGS 18
    #define LMCAXIS_PAR_SET_SW_LIM_WINDOW 19
    #define LMCAXIS_PAR_SET_MOVE_DIR 20
    #define LMCAXIS_PAR_SET_TIMEBASE 21
    #define LMCAXIS_PAR_SET_CONTROLLERPAR 22
    #define LMCAXIS_PAR_SET_ACTVELFILTER 23
    #define LMCAXIS_PAR_SET_SHAPE_SPLINE 24
    #define LMCAXIS_PAR_SET_NO_OVERFLOWERROR 25
    #define LMCAXIS_PAR_SET_MASTERPOS_OLD 26
    #define LMCAXIS_PAR_SET_MASTER_DELAY 27
    #define LMCAXIS_PAR_SET_MAXMODULO 28
    #define LMCAXIS_PAR_SET_MAX_OVERRIDE 29
    #define LMCAXIS_PAR_SET_NORM_OVERRIDE 30
    #define LMCAXIS_PAR_SET_MASTERLOCK_DELAYCYCLES 31
    #define LMCAXIS_PAR_SET_ALLOWED_ACC_JUMP 32
    #define LMCAXIS_PAR_SET_SIMULATE_MODE 33
    #define LMCAXIS_PAR_SET_DEACTIVATE_CALC_BRAKEPOS 34
    #define LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR 35
    #define LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR 36
    #define LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG 37
    #define LMCAXIS_PAR_SET_DELAYEDMASTERLOCK_WINDOW 38
    #define LMCAXIS_PAR_SET_MASTERVEL_OLD 39
    #define LMCAXIS_PAR_SET_POWERON_TIMEOUT 40

typedef UDINT _LMCAXIS_SETPOSITION;   //! <Type Comment="Type of the position that should be set" Name="_LMCAXIS_SETPOSITION"/>
    #define LMCAXIS_SET_ACTPOS_APPUNIT 0
    #define LMCAXIS_SET_SETPOS_APPUNIT 1
    #define LMCAXIS_SET_ACTPOS_INTUNIT 2
    #define LMCAXIS_SET_SETPOS_INTUNIT 3
    #define LMCAXIS_SET_SETPOS_INTUNIT_SPEC 4
    #define LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD 5
    #define LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD 6
    #define LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD_SW 7
    #define LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD_SW 8
    #define LMCAXIS_SET_ACTPOS_APPUNIT_DEST 9
    #define LMCAXIS_SET_SETPOS_APPUNIT_DEST 10
    #define LMCAXIS_SET_ACTPOS_APPUNIT_WO_MOD_SW 11
    #define LMCAXIS_SET_SETPOS_APPUNIT_WO_MOD_SW 12

typedef UDINT _LMCAXIS_SETSERVER;   //! <Type Comment="Server-ID" Name="_LMCAXIS_SETSERVER"/>
    #define LMCAXIS_SET_EXUNIT 0
    #define LMCAXIS_SET_INTUNIT 1
    #define LMCAXIS_SET_VMAX 2
    #define LMCAXIS_SET_AMAX 3
    #define LMCAXIS_SET_SWMINPOS 4
    #define LMCAXIS_SET_SWMAXPOS 5
    #define LMCAXIS_SET_MODULO 6
    #define LMCAXIS_SET_T_JERK 7
    #define LMCAXIS_SET_MOVETYPE 8
    #define LMCAXIS_SET_AEMERGENCY 9
    #define LMCAXIS_SET_JMAX 10
    #define LMCAXIS_SET_ERROR_CONFIG 11
    #define LMCAXIS_SET_ABS_ENCODER 12

typedef UDINT _LMCAXIS_SETSWENDPOS;   //! <Type Comment="LMCAXIS_SET_SWMAX_APPUNIT&#13;&#10;New SW max end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_APPUNIT&#13;&#10;New SW min end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT&#13;&#10;New SW max end position = Position&#13;&#10;This value is set based on Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT&#13;&#10;New SW min end position = Position &#13;&#10;This value is set based on Modulo.(new SW min end position = Position)&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD&#13;&#10;New SW Max end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD&#13;&#10;New SW min end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS"/>
    #define LMCAXIS_SET_SWMAX_APPUNIT 0
    #define LMCAXIS_SET_SWMIN_APPUNIT 1
    #define LMCAXIS_SET_SWMAX_INTUNIT 2
    #define LMCAXIS_SET_SWMIN_INTUNIT 3
    #define LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD 4
    #define LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD 5

typedef struct   //! <Type Comment="Status-Bits of the axis" Name="_LMCAXIS_STATUS"/>
  {
    long PowerOn : 1;  //! <Type Comment="Set if axis is activated" Name="_LMCAXIS_STATUS.PowerOn"/>
    long IsReferenced : 1;  //! <Type Comment="Set if axis is referenced" Name="_LMCAXIS_STATUS.IsReferenced"/>
    long InPosition : 1;  //! <Type Comment="Set if axis is in correct position" Name="_LMCAXIS_STATUS.InPosition"/>
    long FiltRdy : 1;  //! <Type Comment="Set if axis is in correct position an the jerkfilter is ready" Name="_LMCAXIS_STATUS.FiltRdy"/>
    long Decell : 1;  //! <Type Comment="Set if axis is braking" Name="_LMCAXIS_STATUS.Decell"/>
    long PosLimActive : 1;  //! <Type Comment="Set if axis has reached one of its endpositions" Name="_LMCAXIS_STATUS.PosLimActive"/>
    long SetFlg : 1;  //! <Type Comment="Set by calling one of the functions: SetPosition or ReferenceAxis&#13;&#10;Reset if the axis is activated" Name="_LMCAXIS_STATUS.SetFlg"/>
    long EnLesFlg : 1;  //! <Type Comment="Set if the axis moves endless / infinitely" Name="_LMCAXIS_STATUS.EnLesFlg"/>
    long DirFlg : 1;  //! <Type Comment="Set if the axis moves in negative direction - speed is negative" Name="_LMCAXIS_STATUS.DirFlg"/>
    long EmergStop : 1;  //! <Type Comment="Set if the axis stops because an error occured or the axis is deactivated" Name="_LMCAXIS_STATUS.EmergStop"/>
    long Overflow : 1;  //! <Type Comment="Set if a position-overflow occured" Name="_LMCAXIS_STATUS.Overflow"/>
    long MasterLock : 1;  //! <Type Comment="Set if the slave-axis is coupled onto a master-axis" Name="_LMCAXIS_STATUS.MasterLock"/>
    long DirLock : 1;  //! <Type Comment="the direction is locked&#13;&#10;(because of HWMin, HWMax&#13;&#10; or by PowerOnMode)" Name="_LMCAXIS_STATUS.DirLock"/>
    long DynSwLimit : 1;
    long ActDirFlg : 1;  //! <Type Comment="Set if the speed of the axis is negative" Name="_LMCAXIS_STATUS.ActDirFlg"/>
    long HandFlg : 1;  //! <Type Comment="Set if one of the functions: PowerOff or MoveHand is called" Name="_LMCAXIS_STATUS.HandFlg"/>
    long ModuloFlg : 1;  //! <Type Comment="Set if the axis is defined as a modulo-axis" Name="_LMCAXIS_STATUS.ModuloFlg"/>
    long NCMotion : 1;  //! <Type Comment="Set if the axis is in NC postion mode: &quot;_NCPositioning&quot;" Name="_LMCAXIS_STATUS.NCMotion"/>
    long NoActPosMeth : 1;  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoActPosMeth"/>
    long NoControlMeth : 1;  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;LMCController&quot; is not connected" Name="_LMCAXIS_STATUS.NoControlMeth"/>
    long NoRefMeth : 1;  //! <Type Comment="Set if the client &quot;LMCReference&quot; is not connected or&#13;&#10;the function &quot;CheckConnection&quot; returns &quot;FALSE&quot; or&#13;&#10;the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoRefMeth"/>
    long NoActPosChk : 1;  //! <Type Comment="Set if the client LMCSafety is connected and the function &quot;ChkHWReadyConnect&quot; returns &quot;FALSE&quot; or&#13;&#10;the client LMCSafety is not connected or&#13;&#10;the SimulateMode is active" Name="_LMCAXIS_STATUS.NoActPosChk"/>
    long NoPreRtWork : 1;  //! <Type Comment="Set if the client &quot;LMCPreRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPreRtWork"/>
    long NoPostRtWork : 1;  //! <Type Comment="Set if the client &quot;LMCPostRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPostRtWork"/>
    long DelayedMasterLock : 1;  //! <Type Comment="Mode 1: Set if the slave-axis is coupled onto a master-axis and reset when the MasterLock is 0 a configurableamount of cycles&#13;&#10;Mode 2: Set if the the position and velocity is in a window within the master." Name="_LMCAXIS_STATUS.DelayedMasterLock"/>
    long Standstill : 1;  //! <Type Comment="Set if axis is not moving." Name="_LMCAXIS_STATUS.Standstill"/>
    long BrakeForPowerOff : 1;  //! <Type Comment="Set, if the axis is currently stoping for power off." Name="_LMCAXIS_STATUS.BrakeForPowerOff"/>
    long MasterError : 1;  //! <Type Comment="Set, if some error of the master axis occured." Name="_LMCAXIS_STATUS.MasterError"/>
    long SlaveError : 1;  //! <Type Comment="Set, if some error of a coupled slave axis occured." Name="_LMCAXIS_STATUS.SlaveError"/>
    long ReadyToPowerOn : 1;  //! <Type Comment="Set, if the axis is ready to poweron&#13;&#10; =&gt; HWReady is okay&#13;&#10; =&gt; _DriveAxis.StateWord.SwitchedOn is 1" Name="_LMCAXIS_STATUS.ReadyToPowerOn"/>
  }_LMCAXIS_STATUS;

typedef DINT _LMCAXIS_TUNE_MODE;   //! <Type Comment="Parameter of the function: &quot;TuneAxis&quot;&#13;&#10;Movement for the purpose of optimization of the control parameters" Name="_LMCAXIS_TUNE_MODE"/>
    #define LMCAXIS_TUNE_POSITON_IN_NEGATIVE_DIRECTION -2
    #define LMCAXIS_TUNE_ZERO_TO_NEGATIVE_POSITION -1
    #define LMCAXIS_TUNE_ACTPOSITION_POSITION 0
    #define LMCAXIS_TUNE_ZERO_TO_POSITIVE_POSITION 1
    #define LMCAXIS_TUNE_POSITON_IN_POSITIVE_DIRECTION 2

#pragma pack(push, 1)
typedef struct _LMCCommonCalcParas   //! <Type Comment="Common calculation parameters." Name="_LMCCommonCalcParas"/>
  {
    DINT ResolutionInt;  //! <Type Comment="Internal scale factor" Name="_LMCCommonCalcParas.ResolutionInt"/>
    UDINT Hires;  //! <Type Comment="Number of RtWork() cycles per second." Name="_LMCCommonCalcParas.Hires"/>
  } _LMCCommonCalcParas;
#pragma pack(pop)

typedef UDINT _LMCCONTROLLERTYPE; 
    #define _LMCNOCONTROLLER 0
    #define _LMCUSERCONTROLLER 1
    #define _LMCDUMMYCONTROLLER 2
    #define _LMCHYDROCONTROLLER 3
    #define _LMCKV_CONTROLLER 4
    #define _LMCNCCONTROLLER 5
    #define _LMCPOSCONTROLLER 6
    #define _LMCDRIVEPOSONTROL 7
    #define _LMCSTEPPERCONTROL 8
    #define _LMCVFDCONTROL 9
    #define _LMCUSERCONTROLLER_NEW 101
    #define _LMCKV_CONTROLLER_NEW 104
    #define _LMCPOSCONTROLLER_NEW 106
    #define _LMCSIGMATEKCONTROLLER 107
    #define _LMCCALCMODEL_CONTROLLER 108

typedef UDINT _LMCPROF_ACTUALVALUES; 
    #define _LMCPROF_ACTUALPATH 0
    #define _LMCPROF_PATHLENGTH 1
    #define _LMCPROF_V_PATH 2
    #define _LMCPROF_ACTUALPATH_ORIG 3
    #define _LMCPROF_PATHLENGTH_ORIG 4
    #define _LMCPROF_DELTA_S 5

#pragma pack(push, 1)
typedef struct _LMCPROF_CIRCLEPOINT   //! <Type Comment="Absolute Position of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT"/>
  {
    DINT Point1;  //! <Type Comment="Absolute 1st coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point1"/>
    DINT Point2;  //! <Type Comment="Absolute 2nd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point2"/>
    DINT Point3;  //! <Type Comment="Absolute 3rd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point3"/>
  } _LMCPROF_CIRCLEPOINT;
#pragma pack(pop)

typedef UDINT _LMCPROF_CMDINDEX; 
    #define _LMCPROF_LASTLOADED 0
    #define _LMCPROF_ACTCMD 1
    #define _LMCPROF_VORANZ 2
    #define _LMCPROF_SUMINDEX 3
    #define _LMCPROF_LASTLOADED_I 4
    #define _LMCPROF_ACTCMD_I 5

typedef UDINT _LMCPROF_EXECUTE;   //! <Type Comment="Time of command execution" Name="_LMCPROF_EXECUTE"/>
    #define LMCPROF_BUFFERED 0
    #define LMCPROF_IMMEDIATE 1

typedef UDINT _LMCPROFCMDTYPES;   //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES"/>
    #define CMD_Nothing 0
    #define CMD_Linear 2
    #define CMD_CircleCW 5
    #define CMD_CircleCCW 4
    #define CMD_MoveCurve 12
    #define CMD_Circle3D 13
    #define CMD_SetProfPos 20

typedef struct   //! <Type Comment="Move command flags" Name="_LMCPROFINTCMDCONFIG"/>
  {
    long CmdActive : 1;  //! <Type Comment="1: the movement calculations are finished." Name="_LMCPROFINTCMDCONFIG.CmdActive"/>
    long RapidTraverse : 1;  //! <Type Comment="1: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFINTCMDCONFIG.RapidTraverse"/>
    long FeedRateInterpolation : 1;  //! <Type Comment="1: feed rate interpolation selected" Name="_LMCPROFINTCMDCONFIG.FeedRateInterpolation"/>
    long SecondTransition : 1;  //! <Type Comment="0: this is the first transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected&#13;&#10;1: this is the second transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected" Name="_LMCPROFINTCMDCONFIG.SecondTransition"/>
    long IsProgrammedExactStop : 1;  //! <Type Comment="this path segment was programmed with TransitionMode:=_LMCPROF_EXACT_STOP" Name="_LMCPROFINTCMDCONFIG.IsProgrammedExactStop"/>
    long AfterSetPosCmd : 1;  //! <Type Comment="The command before this one is a SetProfilePositions(). This command maybe needs to be recomputed." Name="_LMCPROFINTCMDCONFIG.AfterSetPosCmd"/>
    long MoveCurveSplineInserted : 1;
    long MoveCurveSplineExecuting : 1;
    long MoveCurvePathPerThousand : 1;
    long CmdActivated : 1;
    long dummy0 : 1;
    long SpecialLinear_OrientateTangAx : 1;
    long EndlessMovement : 1;
    long dummy1 : 3;
    long PathLenReduced : 1;  //! <Type Comment="this bit is only used in internal buffer" Name="_LMCPROFINTCMDCONFIG.PathLenReduced"/>
    long dummy2 : 7;
    long Activated : 1;
    long WaitFinish : 1;
    long CmdStarted : 1;
  }_LMCPROFINTCMDCONFIG;

typedef UDINT _LMCPROFTRANSMODES;   //! <Type Comment="Transition type between path segments" Name="_LMCPROFTRANSMODES"/>
    #define _LMCPROF_EXACT_STOP 0
    #define _LMCPROF_CONT_DIRECT 2
    #define _LMCPROF_SMOOTH_PARAB 3
    #define _LMCPROF_SMOOTH_CUBIC 4
    #define _LMCPROF_SMOOTH_QUINT 5

typedef struct   //! <Type Comment="Circle axes definition" Name="_LMCPROFCIRCLEDEF"/>
  {
    long Axis1 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis1"/>
    long Axis2 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis2"/>
    long Axis3 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis3"/>
    long Axis4 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis4"/>
    long Axis5 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis5"/>
    long Axis6 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis6"/>
    long Axis7 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis7"/>
    long Axis8 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis8"/>
    long Axis9 : 1;  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis9"/>
  }_LMCPROFCIRCLEDEF;

#pragma pack(push, 1)
typedef struct _LMCPROF_POSITIONS   //! <Type Comment="Start and end positions of an axis [Internal units]" Name="_LMCPROF_POSITIONS"/>
  {
    DINT start;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.start"/>
    DINT end;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.end"/>
  } _LMCPROF_POSITIONS;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _LMCPROF_OBSTACLE   //! <Type Comment="Data for MoveCurve definition" Name="_LMCPROF_OBSTACLE"/>
  {
    BOOL PathPerThousand;  //! <Type Comment="FALSE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in application units.&#13;&#10;TRUE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in parts per thousand of the path length." Name="_LMCPROF_OBSTACLE.PathPerThousand"/>
    DINT AxisNr;  //! <Type Comment="Number of axis, in which direction the evasive movement should be performed [1-9]." Name="_LMCPROF_OBSTACLE.AxisNr"/>
    DINT HeightStart_relativ;  //! <Type Comment="The evasive movement starts with an &quot;linear up movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_relativ"/>
    DINT HeightEnd_relativ;  //! <Type Comment="The evasive movement ends with a &quot;linear down movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightEnd_relativ"/>
    DINT PathStart;  //! <Type Comment="position, where the HeightStart_absolute should be reached.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement." Name="_LMCPROF_OBSTACLE.PathStart"/>
    DINT HeightStart_absolut;  //! <Type Comment="position of the evasive axis at PathStart [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_absolut"/>
    DINT PathEnd;  //! <Type Comment="position, where the HeightEnd_absolute should be reached. The distance is measured from the end of the vertical movement.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement.&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.PathEnd"/>
    DINT HeightEnd_absolut;  //! <Type Comment="position of the evasive axis at PathEnd [application units]&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.HeightEnd_absolut"/>
    DINT VelStart_relativ_ppT;  //! <Type Comment="value &gt; 0: maximal velocity of the starting linear up movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the starting linear up movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelStart_relativ_ppT"/>
    DINT VelEnd_relativ_ppT;  //! <Type Comment="value &gt; 0: maximal velocity of the ending linear down movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the ending linear down movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelEnd_relativ_ppT"/>
  } _LMCPROF_OBSTACLE;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct _LMCPROF_MoveData   //! <Type Comment="Element of the profile buffer " Name="_LMCPROF_MoveData"/>
  {
    _LMCPROF_MoveData *pPrevMoveUncommon;  //! <Type Comment="Pointer to the previous movement if it is not commonly determined.&#13;&#10;It is used during reverse drive or if the next movement is saved in different buffer than this one. &#13;&#10;There are three buffer types:&#13;&#10;Profile&#13;&#10;Temporary&#13;&#10;Restart" Name="_LMCPROF_MoveData.pPrevMoveUncommon"/>
    _LMCPROF_MoveData *pNextMoveUncommon;  //! <Type Comment="Pointer to the next movement if it is not commonly determined.&#13;&#10;It is used during reverse drive or if the next movement is saved in different buffer than this one. &#13;&#10;There are three buffer types:&#13;&#10;Profile&#13;&#10;Temporary&#13;&#10;Restart" Name="_LMCPROF_MoveData.pNextMoveUncommon"/>
    UDINT index;  //! <Type Comment="Index in the profile buffer" Name="_LMCPROF_MoveData.index"/>
    _LMCPROFCMDTYPES enCmdType;  //! <Type Comment="Move command type" Name="_LMCPROF_MoveData.enCmdType"/>
    _LMCPROFINTCMDCONFIG bsCmdFlags;  //! <Type Comment="Move command flags" Name="_LMCPROF_MoveData.bsCmdFlags"/>
    _LMCPROFTRANSMODES enTransitionMode;  //! <Type Comment="Type of transition between path segments" Name="_LMCPROF_MoveData.enTransitionMode"/>
    DINT dTransitionRadius;  //! <Type Comment="Radius of the tolerance sphere. Used for the smooth rounding mode, the rounding mode with tolerance sphere and for the rounding mode with cubic spline." Name="_LMCPROF_MoveData.dTransitionRadius"/>
    _LMCPROFCIRCLEDEF bdCirAxis;  //! <Type Comment="Defines the circle axes." Name="_LMCPROF_MoveData.bdCirAxis"/>
    _LMCPROF_POSITIONS stPositions [_LMC_MAX_AXIS-1+1-0];  //! <Type Comment="Start and end positions of all axes [Internal units]" Name="_LMCPROF_MoveData.stPositions"/>
    DINT xMp;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the first circle axis [Internal units]" Name="_LMCPROF_MoveData.xMp"/>
    DINT yMp;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the second circle axis [Internal units]" Name="_LMCPROF_MoveData.yMp"/>
    DINT zMP;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the third circle axis [Internal units]" Name="_LMCPROF_MoveData.zMP"/>
    DINT PathLength;  //! <Type Comment="Path length [Internal units]" Name="_LMCPROF_MoveData.PathLength"/>
    DINT vMax;  //! <Type Comment="Max. allowed path speed [Internal units/tick]" Name="_LMCPROF_MoveData.vMax"/>
    DINT aMax;  //! <Type Comment="Max. allowed path acceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.aMax"/>
    DINT dMax;  //! <Type Comment="Max. allowed path deceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.dMax"/>
    DINT jMax;  //! <Type Comment="Max. allowed path jerk [Internal units/tick²/sec]" Name="_LMCPROF_MoveData.jMax"/>
    _LMCPROF_CIRCLEPOINT sCircleIPSpec;  //! <Type Comment="Interpoint of the circle movement." Name="_LMCPROF_MoveData.sCircleIPSpec"/>
    BOOL bIPnil;  //! <Type Comment="TRUE .. Interpoint was not specified." Name="_LMCPROF_MoveData.bIPnil"/>
    BOOL CircleCCW;  //! <Type Comment="Flag is set if this is a counter-clockwise circle movement. It is used for eventual reverse drive." Name="_LMCPROF_MoveData.CircleCCW"/>
    _LMCPROF_OBSTACLE sObstacleSpec;  //! <Type Comment="Obstacle specification of the curve movement." Name="_LMCPROF_MoveData.sObstacleSpec"/>
    BOOL SplineMove;  //! <Type Comment="Is this a (Curve)Spline move?" Name="_LMCPROF_MoveData.SplineMove"/>
    DINT SplineCornerOverdrive;  //! <Type Comment="Corner overdrive property if the move is a spline one." Name="_LMCPROF_MoveData.SplineCornerOverdrive"/>
  } _LMCPROF_MoveData;
#pragma pack(pop)

typedef UDINT _LMCPROF_OPMODE;   //! <Type Comment="Operating mode" Name="_LMCPROF_OPMODE"/>
    #define _LMC_AUTOMATIC 0
    #define _LMC_MANUAL 1

#pragma pack(push, 1)
typedef struct _LMCPROF_POS   //! <Type Comment="Absolute Endpositions / relative distances of all Axes [Application Units]" Name="_LMCPROF_POS"/>
  {
    DINT Pos1;  //! <Type Comment="Absolute Endposition of Axis1 [Application Units]" Name="_LMCPROF_POS.Pos1"/>
    DINT Pos2;  //! <Type Comment="Absolute Endposition of Axis2 [Application Units]" Name="_LMCPROF_POS.Pos2"/>
    DINT Pos3;  //! <Type Comment="Absolute Endposition of Axis3 [Application Units]" Name="_LMCPROF_POS.Pos3"/>
    DINT Pos4;  //! <Type Comment="Absolute Endposition of Axis4 [Application Units]" Name="_LMCPROF_POS.Pos4"/>
    DINT Pos5;  //! <Type Comment="Absolute Endposition of Axis5 [Application Units]" Name="_LMCPROF_POS.Pos5"/>
    DINT Pos6;  //! <Type Comment="Absolute Endposition of Axis6 [Application Units]" Name="_LMCPROF_POS.Pos6"/>
    DINT Pos7;  //! <Type Comment="Absolute Endposition of Axis7 [Application Units]" Name="_LMCPROF_POS.Pos7"/>
    DINT Pos8;  //! <Type Comment="Absolute Endposition of Axis8 [Application Units]" Name="_LMCPROF_POS.Pos8"/>
    DINT Pos9;  //! <Type Comment="Absolute Endposition of Axis9 [Application Units]" Name="_LMCPROF_POS.Pos9"/>
  } _LMCPROF_POS;
#pragma pack(pop)

typedef UDINT _LMCPROF_RECOUPLEMODE; 
    #define _LMCPROF_RECOUPLE_TO_PROFILE 0
    #define _LMCPROF_RECOUPLE_TO_ACTPOS 1

typedef UDINT _LMCPROF_RESTIME_CALCMODE;   //! <Type Comment="Modus of calculation of the Residualtime" Name="_LMCPROF_RESTIME_CALCMODE"/>
    #define LMCPROF_TONEXT_STOPP 0
    #define LMCPROF_TO_NEXT_PATH_SEGMENT 1
    #define LMCPROF_TO_NEXT_PATH_SEGMENT_ORIG 2
    #define LMCPROF_LAST_PATH_SEGMENT 3
    #define LMCPROF_TOLAST_STOPP 4

typedef UDINT _LMCPROF_SETPOS_MODE;   //! <Type Comment="Mode defines how we get the set positions." Name="_LMCPROF_SETPOS_MODE"/>
    #define _LMCPROF_SETPOS_TO_AXES_POS 0
    #define _LMCPROF_SETPOS_TO_USER_POS 1
    #define _LMCPROF_SETPOS_TO_USER_POS_NO_AX_TRAVEL 2

typedef struct   //! <Type Comment="Move command flags" Name="_LMCPROFCMDCONFIG"/>
  {
    long RapidTraverse : 1;  //! <Type Comment="True: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFCMDCONFIG.RapidTraverse"/>
    long CircleCW : 1;  //! <Type Comment="True: circular movement clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement dromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCW"/>
    long CircleCCW : 1;  //! <Type Comment="True: circular movement counter clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement antidromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCCW"/>
    long FeedRateInterpolation : 1;  //! <Type Comment="True: feed rate interpolation selected. The feedrate changes linearly over the path length." Name="_LMCPROFCMDCONFIG.FeedRateInterpolation"/>
    long MoveImmediately : 1;  //! <Type Comment="False: Command will be inserted in the movement buffer after the last inserted movement&#13;&#10;True: Command shall be immediately executed. Buffer will be deleted and actual movement interrupted. " Name="_LMCPROFCMDCONFIG.MoveImmediately"/>
  }_LMCPROFCMDCONFIG;

typedef UDINT _LMCPROFCMDTYPES_INTERN;   //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES_INTERN"/>
    #define _LMCPROF_CMD_Nothing 0
    #define _LMCMT_NoPosChange 1
    #define _LMCMT_Linear 2
    #define _LMCMT_SpeedLimit 3
    #define _LMCMT_CircleCCW 4
    #define _LMCMT_CircleCW 5
    #define _LMCMT_Round_All 6
    #define _LMCMT_Lin_Round_Aux 7
    #define _LMCMT_Circle_Lin_Round_Aux 8
    #define _LMCMT_SplineCub 9
    #define _LMCMT_SplineQuint 10
    #define _LMCMT_Fourier 11
    #define _LMCMT_MoveCurve 12
    #define _LMCMT_Circle3D 13
    #define _LMCMT_MoveCurveAuxRound 14
    #define _LMCMT_SetProfPos 20

typedef UDINT _LMCPROFERRORTYPES;   //! <Type Comment="Error numbers" Name="_LMCPROFERRORTYPES"/>
    #define _LMCPROF_NoError 0
    #define _LMCPROF_INIT_ERROR 1
    #define _LMCPROF_MOVECMD_ERROR 2
    #define _LMCPROF_INT_POINTER_ERROR 3
    #define _LMCPROF_JUMP_CMD_ERROR 4
    #define _LMCPROF_POS_OVERRUN_ERROR 5
    #define _LMCPROF_AXIS_ERROR 6
    #define _LMCPROF_SWE_ERROR 7
    #define _LMCPROF_CIRDEF_ERROR 8
    #define _LMCPROF_NO_POS_CHANGE 9
    #define _LMCPROF_GROUP_ERROR 10
    #define _LMCPROF_KOFAC_ERROR 11
    #define _LMCPROF_VEL_CMD_ERROR 12
    #define _LMCPROF_ACC_CMD_ERROR 13
    #define _LMCPROF_JERK_CMD_ERROR 14
    #define _LMCPROF_RESOLUTION_ERROR 15
    #define _LMCPROF_SAFETY_ZONES_REACHED 16
    #define _LMCPROF_INSERT_ERROR 17
    #define _LMCPROF_AXIS_NOT_CONNECTED 18
    #define _LMCPROF_GROUP_NOT_FOUND 19
    #define _LMCPROF_PARAMETER_NOT_FOUND 20
    #define _LMCPROF_PARAMETER_ERROR 21
    #define _LMCPROF_ERROR_BUSY 22
    #define _LMCPROF_OUT_OF_RANGE 23
    #define _LMCPROF_RADIUS_ERROR 24
    #define _LMCPROF_ARCLEN_ERROR 25
    #define _LMCPROF_RES_PATHLEN_ERROR 26
    #define _LMCPROF_ENDPOS_ERROR 27
    #define _LMCPROF_AXTRAVEL_ERROR 28
    #define _LMCPROF_AX_COUPLE_ERROR 29
    #define _LMCPROF_PLAINEDEF_ERROR 30
    #define _LMCPROF_VEC_ERROR 31
    #define _LMCPROF_LOCKGROUP_ERROR 32
    #define _LMCPROF_LINEDEF_ERROR 33
    #define _LMCPROF_CHORDLEN_ERROR 34
    #define _LMCPROF_LOCKGROUP_DIFF_RESTART 35
    #define _LMCPROF_REFPOINT_DIFF_RESTART 36
    #define _LMCPROF_AXIS_POS_ERROR 37
    #define _LMCPROF_INPOSITION_TIMEOUT_ERROR 38
    #define _LMCPROF_MATH_ERROR 39
    #define _LMCPROF_CALC_ITERATION_ERROR 40
    #define _LMCPROF_REVERSE_ONGOING 41
    #define _LMCPROF_REVERSE_INSERT_ERROR 42
    #define _LMCROBOT_REF_ERROR 1000
    #define _LMCROBOT_AX_COUPLING_ERROR 1001
    #define _LMCROBOT_BACKUP_POS_ERROR 1002
    #define _LMCROBOT_POWERON_ERROR 1003
    #define _LMCROBOT_POS_CHECK_ERROR 1004
    #define _LMCROBOT_LINEUP_AX_ERROR 1005
    #define _LMCROBOT_COUPLE_TIMEOUT 1006
    #define _LMCROBOT_AX_COUPLING_LOST 1007
    #define _LMCROBOT_AXIS_ERROR 1008
    #define _LMCROBOT_BELTCOUPLING_ERROR 1009
    #define _LMCROBOT_COORDSYSTEM_ERROR 1010
    #define _LMCROBOT_AX_CMD_ERROR 1011
    #define _LMCROBOT_KINEMATIC_ERROR 1012

#pragma pack(push, 1)
typedef struct _LMCPROFERRORDEF   //! <Type Comment="Error information" Name="_LMCPROFERRORDEF"/>
  {
    DINT LineNo;  //! <Type Comment="Number of the source code line where the error was reported" Name="_LMCPROFERRORDEF.LineNo"/>
    _LMCPROFERRORTYPES ErrorNo;  //! <Type Comment="Error number" Name="_LMCPROFERRORDEF.ErrorNo"/>
    DINT SubErrorNo;  //! <Type Comment="Additional error information" Name="_LMCPROFERRORDEF.SubErrorNo"/>
  } _LMCPROFERRORDEF;
#pragma pack(pop)

typedef struct   //! <Type Comment="User defined error message configuration" Name="_LMCPROFERRWARNCONFIG"/>
  {
    long bPosChangeWarning : 1;  //! <Type Comment="FALSE: no warning is issued when a movement with zero path length is encountered &#13;&#10;TRUE : a warning is issued when a movement with zero path length is encountered" Name="_LMCPROFERRWARNCONFIG.bPosChangeWarning"/>
    long bResolutionError : 1;  //! <Type Comment="FALSE: a warning is issued when a parameter value * resolution does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when a parameter value * resolution does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bResolutionError"/>
    long bPosLimitError : 1;  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is ouside of the software end position&#13;&#10;TRUE : an error is issued when the endpoint of a movement is ouside of the software end position" Name="_LMCPROFERRWARNCONFIG.bPosLimitError"/>
    long bCircleError : 1;  //! <Type Comment="FALSE: a warning is issued when the number of circle axes is not equal two.&#13;&#10;TRUE : an error is issued when the number of circle axes is not equal two." Name="_LMCPROFERRWARNCONFIG.bCircleError"/>
    long bCmdLimitError : 1;  //! <Type Comment="FALSE: a warning is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis&#13;&#10;TRUE : an error is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis" Name="_LMCPROFERRWARNCONFIG.bCmdLimitError"/>
    long bKoFacError : 1;  //! <Type Comment="FALSE: a warning is issued when the coupling factor does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when the coupling factor does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bKoFacError"/>
    long bSafetyZonesError : 1;  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is inside of a safety zone&#13;&#10;TRUE : an error is issued when the endpoint of a movement is inside of a safety zone" Name="_LMCPROFERRWARNCONFIG.bSafetyZonesError"/>
  }_LMCPROFERRWARNCONFIG;

typedef struct   //! <Type Comment="Profile States" Name="_LMCPROFILESTATES"/>
  {
    long bProfileLocked : 1;  //! <Type Comment="TRUE  .. All required axes are coupled to the profile.&#13;&#10;FALSE .. Axes are not coupled." Name="_LMCPROFILESTATES.bProfileLocked"/>
    long bProfileStoped : 1;  //! <Type Comment="TRUE ... command StopMove() is active and axes are not moving.&#13;&#10;FALSE .. command StopMove() is not active or at least the profile has not stopped now." Name="_LMCPROFILESTATES.bProfileStoped"/>
    long bProfileBraking : 1;  //! <Type Comment="TRUE ... The profile is reducing its speed.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bProfileBraking"/>
    long bNoPreRtWork : 1;  //! <Type Comment="TRUE ... LMCPreRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPreRtWorkTrigger is connected&#13;&#10;" Name="_LMCPROFILESTATES.bNoPreRtWork"/>
    long bNoPostRtWork : 1;  //! <Type Comment="TRUE ... LMCPostRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPostRtWorkTrigger is connected" Name="_LMCPROFILESTATES.bNoPostRtWork"/>
    long bBraketoExactStop : 1;  //! <Type Comment="TRUE ... The profile is reducing its speed due to stoping at an exact stop point.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoExactStop"/>
    long bDynSWLimit : 1;  //! <Type Comment="TRUE ... maximumum or minimum dynamic software limit has been reached&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimit"/>
    long bBraketoDynSWLimit : 1;  //! <Type Comment="TRUE ... The profile is reducing its speed due to a dynamic software limit&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoDynSWLimit"/>
    long bDynSWLimitViolation : 1;  //! <Type Comment="TRUE ... The dynamic software limit is violated or we probably cannot stop before violating it.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimitViolation"/>
  }_LMCPROFILESTATES;

typedef UDINT _LMCPROFINPOSTYPES;   //! <Type Comment="Mode" Name="_LMCPROFINPOSTYPES"/>
    #define _LMCPROF_ProfileInPosition 0
    #define _LMCPROF_ProfileFinished 1
    #define _LMCPROF_ProfileAxisInPos 2
    #define _LMCPROF_ProfileAxisFinished 3
    #define _LMCPROF_ProfileInWindow 4
    #define _LMCPROF_ProfileInWindowFinished 5
    #define _LMCPROF_ProfileAndAxisInWindow 6
    #define _LMCPROF_ProfileAndAxisInWindowFinished 7
    #define _LMCPROF_ProfileStandstill 8

#pragma pack(push, 1)
typedef struct _LMCPROFINTCMDCONFIG_THREADSAFE   //! <Type Comment="Move command flags" Name="_LMCPROFINTCMDCONFIG_THREADSAFE"/>
  {
    struct 
    {
      char CmdActive : 1;  //! <Type Comment="1: the movement calculations are finished." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.CmdActive"/>
      char RapidTraverse : 1;  //! <Type Comment="1: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.RapidTraverse"/>
      char FeedRateInterpolation : 1;  //! <Type Comment="1: feed rate interpolation selected" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.FeedRateInterpolation"/>
      char SecondTransition : 1;  //! <Type Comment="0: this is the first transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected&#13;&#10;1: this is the second transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.SecondTransition"/>
      char IsProgrammedExactStop : 1;  //! <Type Comment="1: this path segment was programmed with TransitionMode:=_LMCPROF_EXACT_STOP" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.IsProgrammedExactStop"/>
      char AfterSetPosCmd : 1;  //! <Type Comment="1: The command before this one is a SetProfilePositions(). This command maybe needs to be recomputed." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.AfterSetPosCmd"/>
    }Byte1;
    struct 
    {
      char MoveCurvePathPerThousand : 1;
      char FreezeTangentialAxis : 1;
      char BackwardMovement : 1;
      char SpecialLinear_OrientateTangAx : 1;
      char EndlessMovement : 1;
      char MoveCurveStartPosAdaption : 1;
      char MoveCurveRotAxisCorrection : 1;  //! <Type Comment="If this bit is set, then the position of axis 4 is determined with a 5th order spline to correct the rotatory axis position for decoupling from a rotatory disc." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte2.MoveCurveRotAxisCorrection"/>
      char Bit8 : 1;
    }Byte2;
    struct 
    {
      char PathLenReduced : 1;  //! <Type Comment="1: The pathlength was reduced when inserting a transition movement (spline etc.).&#13;&#10;The attainable leaving speed must be calculated new." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte3.PathLenReduced"/>
      char SmallPath : 1;  //! <Type Comment="If the SmallLines functionality is enabled this bit indcates that the MoveSection is shorter than the maximum length for a SmallLine section.&#13;&#10;This bit may only be set for Moves of type _LMCMT_Linear" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte3.SmallPath"/>
      char Bit3 : 1;
      char Bit4 : 1;
      char Bit5 : 1;
      char Bit6 : 1;
      char Bit7 : 1;
      char Bit8 : 1;
    }Byte3;
    struct 
    {
      char RESERVED_Activated : 1;  //! <Type Comment="this bit is only used in user buffer" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte4.RESERVED_Activated"/>
      char RESERVED_WaitFinish : 1;  //! <Type Comment="this bit is only used in user buffer" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte4.RESERVED_WaitFinish"/>
      char CmdStarted : 1;  //! <Type Comment="1: " Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte4.CmdStarted"/>
      char Bit4 : 1;
      char Bit5 : 1;
      char Bit6 : 1;
      char Bit7 : 1;
      char Bit8 : 1;
    }Byte4;
  } _LMCPROFINTCMDCONFIG_THREADSAFE;
#pragma pack(pop)

typedef UDINT _LMCPROFMOVEPROFILE;   //! <Type Comment="Type of profile" Name="_LMCPROFMOVEPROFILE"/>
    #define RAMP_PROFILE 0
    #define JERK_PROFILE 1

typedef UDINT _LMCPROFPARAMETER;   //! <Type Comment="_LMCProfile parameters" Name="_LMCPROFPARAMETER"/>
    #define _LMCPROF_MaxOverride 0
    #define _LMCPROF_MinOverride 1
    #define _LMCPROF_SafetyZones 2
    #define _LMCPROF_Max_Entries 3
    #define _LMCPROF_NoOverrideChange 4
    #define _LMCPROF_ChkArcLength 9
    #define _LMCPROF_NoChkAuxAxis 10
    #define _LMCPROF_OverrideType 11
    #define _LMCPROF_RoundConnectMode 13
    #define _LMCPROF_aMinOverride 14
    #define _LMCPROF_ActVel 15
    #define _LMCPROF_ActAcc 16
    #define _LMCPROF_MoveType 17
    #define _LMCPROF_LockState 21
    #define _LMCPROF_Window 22
    #define _LMCPROF_vSTART_F_IPO 23
    #define _LMCPROF_NormOverride 24
    #define _LMCPROF_CheckAxisGroup 25
    #define _LMCPROF_AxisCount 26
    #define _LMCPROF_AddOffset 27
    #define _LMCPROF_Read_Decel 28
    #define _LMCPROF_Read_Timebase 29
    #define _LMCPROF_LookAhead 30
    #define _LMCPROF_HalfCircleTolerance 31
    #define _LMCPROF_TransRad_ppTh 32
    #define _LMCPROF_Set_LogMode 33
    #define _LMCPROF_ChkEndPosForSwLimit 34
    #define _LMCPROF_ProfileInPos 35
    #define _LMCPROF_ProfileInPos_Timeout 36
    #define _LMCPROF_UNUSED 37
    #define _LMCPROF_IncreaseLimit_SpeedWindow 38
    #define _LMCPROF_IncreaseLimit_FastAccel 39
    #define _LMCPROF_IncreaseLimit_FastJerk 40
    #define _LMCPROF_AllowBigTransitionRadius 41
    #define _LMCPROF_SmallLines 42
    #define _LMCPROF_SmallLines_Dist 43
    #define _LMCPROF_DynamicType 44
    #define _LMCPROF_MinMoveDistance 45

typedef UDINT _LMCPROFPARAMETERAXIS;   //! <Type Comment="Type of axis parameter" Name="_LMCPROFPARAMETERAXIS"/>
    #define _LMCPROF_AX_VEL_LIMIT 0
    #define _LMCPROF_AX_ACCEL_LIMIT 1
    #define _LMCPROF_AX_TJERK 2
    #define _LMCPROF_AX_UNLOCK_DECEL 3
    #define _LMCPROF_AX_MAX_VEL_JUMP 4
    #define _LMCPROF_AX_INPOS_WINDOW 5
    #define _LMCPROF_AX_LOCK_GRP 6
    #define _LMCPROF_AX_MAX_ACCEL_JUMP 7
    #define _LMCPROF_AX_DEC 8
    #define _LMCPROF_AX_NOT_CHECK_SWLIMIT 9
    #define _LMCPROF_AX_SW_MIN_LIMIT 10
    #define _LMCPROF_AX_SW_MAX_LIMIT 11
    #define _LMCPROF_AX_INPOS_WIN_ADDITIVELYCOUPLED 12
    #define _LMCPROF_AX_VEL_LIMIT_RAPID_TRAVERSE 13
    #define _LMCPROF_AX_ACCEL_LIMIT_RAPID_TRAVERSE 14
    #define _LMCPROF_AX_TJERK_RAPID_TRAVERSE 15

typedef UDINT _LMCPROFPARAMETERGROUPS;   //! <Type Comment="Type of axes group parameter" Name="_LMCPROFPARAMETERGROUPS"/>
    #define _LMCPROF_GRP_VEL_LIMIT 0
    #define _LMCPROF_GRP_ACCEL_LIMIT 1
    #define _LMCPROF_GRP_TJERK 2

typedef struct   //! <Type Comment="Currently active profile settings." Name="_LMCPROFSETTINGS"/>
  {
    long bInitDone : 1;  //! <Type Comment="Set if the Last Init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bInitDone"/>
    long bFirstInitDone : 1;  //! <Type Comment="Set if the first init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bFirstInitDone"/>
    long bOverrideTyp : 1;  //! <Type Comment="0: Default value. The type of Override is always based on the actual speed of the path segment. &#13;&#10;1: The type of Override is based on the specified speed of the path segment only. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation." Name="_LMCPROFSETTINGS.bOverrideTyp"/>
    long bNoOverrideChange : 1;  //! <Type Comment="0: Default value. When calling the LockProfile() method, the override is set to the maximum value automatically.&#13;&#10;1: When calling the LockProfile() method, the override is not changed and therefore remains at the last values set." Name="_LMCPROFSETTINGS.bNoOverrideChange"/>
    long bNoChkSWLimit : 1;
    long LogReadMethods : 1;  //! <Type Comment="Additionally log request method calls" Name="_LMCPROFSETTINGS.LogReadMethods"/>
    long LogMethodCallPlusParam : 1;  //! <Type Comment="Additionally log the method parameters" Name="_LMCPROFSETTINGS.LogMethodCallPlusParam"/>
    long bFatalError : 1;  //! <Type Comment="Is set if the Init was not OK ... We have no Buffer memory" Name="_LMCPROFSETTINGS.bFatalError"/>
    long bExtTrigger : 1;  //! <Type Comment="0: RtWork() is called by the the operating system (default)&#13;&#10;1: RtWork() has to be called by the application" Name="_LMCPROFSETTINGS.bExtTrigger"/>
    long bAxCount : 1;  //! <Type Comment="This Bit indicates, if the user already set the number of used axis with the methode SetProfileParameter - _LMCPROF_AxisCount." Name="_LMCPROFSETTINGS.bAxCount"/>
    long bChkArcLength : 1;  //! <Type Comment="0: Default value. Whether the arc length is the same as the chord length, is not tested.&#13;&#10;1: If the arc length is the same as the chord length + 1, a linear movement is executed instead of a circular movement." Name="_LMCPROFSETTINGS.bChkArcLength"/>
    long bNoChkAuxAxis : 1;  //! <Type Comment="0: Default value. Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes and the limit values of the auxiliary axes.&#13;&#10;1: Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes only." Name="_LMCPROFSETTINGS.bNoChkAuxAxis"/>
    long bWaitActPosition : 1;  //! <Type Comment="0: the exact stop functions with the set position (default)&#13;&#10;1: the exact stop functions with the actual position" Name="_LMCPROFSETTINGS.bWaitActPosition"/>
    long bNoLookAhead : 1;  //! <Type Comment="0: Default value. the move-command must calculate a&#13;&#10;   vNext, so it takes a bit more time, but the speed&#13;&#10;   of connected move-commands can be reached exactly at&#13;&#10;   the end of the further command&#13;&#10;1: there is no calculation of vNext, so the velocity&#13;&#10;   reaches the new target-velocity, when it would go&#13;&#10;   down to standstill" Name="_LMCPROFSETTINGS.bNoLookAhead"/>
    long bOverrideInitialized : 1;
    long bRoundConnectMode : 1;  //! <Type Comment="FALSE: Default value. The single axis movement at the segment transfer with tolerance sphere is always trapezoidal.&#13;&#10;TRUE : The single axis movement at the segment transfer with tolerance sphere is executed with a &quot;softer&quot; movement.&#13;&#10;       As the duration of the movement remains unchanged compared to the trapezoidal movement, temporarily the acceleration is higher than defined but the jerk is minimized." Name="_LMCPROFSETTINGS.bRoundConnectMode"/>
    long bCheckAxisGroup : 1;  //! <Type Comment="False: the AxisGroup where checked&#13;&#10;True : no check of the AxisGroup" Name="_LMCPROFSETTINGS.bCheckAxisGroup"/>
    long bNoOffsetposition : 1;  //! <Type Comment="false = the Offsetposition is added to the server Position/Destination&#13;&#10;true = the Offsetposition is not added to the server Position/Destination" Name="_LMCPROFSETTINGS.bNoOffsetposition"/>
    long dummy0 : 2;
    long bOverrideAxLimit : 1;  //! <Type Comment="just has an effect with bOverrideTyp = 1&#13;&#10;FALSE --&gt; Default: The type of Override is based on the specified speed of the path segment only.&#13;&#10;TRUE  --&gt; The type of Override is based on the actual speed of the path segment." Name="_LMCPROFSETTINGS.bOverrideAxLimit"/>
    long Axis_1_IsConnected : 1;
    long Axis_2_IsConnected : 1;
    long Axis_3_IsConnected : 1;
    long Axis_4_IsConnected : 1;
    long Axis_5_IsConnected : 1;
    long Axis_6_IsConnected : 1;
    long Axis_7_IsConnected : 1;
    long Axis_8_IsConnected : 1;
    long Axis_9_IsConnected : 1;
    long bLMCCNCIprMode : 1;
    long bAutoActivateCmd : 1;  //! <Type Comment="This bit is used in in _LMCCNCInterpreter mode (bdProfileSettings.bLMCCNCIprMode=1). If set, a move cmd is activated immediately." Name="_LMCPROFSETTINGS.bAutoActivateCmd"/>
  }_LMCPROFSETTINGS;

typedef struct 
  {
    long SetSFF : 1;  //! <Type Comment="0 .. the set velocity isn&apos;t written to the drive axis object (SFF)&#13;&#10;1 .. default :the set velocity is written to the drive axis object (SFF)" Name="_POSFLAGS.SetSFF"/>
    long XWCalcInt : 1;  //! <Type Comment="0 .. default : the contouring error is read directly from the drive axis object&#13;&#10;1 .. the contouring error is calculated in the DrivePosControl object&#13;&#10;" Name="_POSFLAGS.XWCalcInt"/>
    long WaitPowerOff : 1;  //! <Type Comment="0 ... do not wait for the OperationEnabled-Bit of the controlword&#13;&#10;1 .. default: wait for the OperationEnabled-Bit while poweroff" Name="_POSFLAGS.WaitPowerOff"/>
  }_POSFLAGS;

typedef USINT *_PVOIDL;

typedef struct 
  {
    long NoHW : 1;
    long NoParameter : 1;
    long NotOnline : 1;
    long NotInitialized : 1;
    long SFFLimitationActive : 1;
    long DiagModeActive : 1;
  }_SDDAXISSTATE;

typedef UDINT _SDDUSERCMD;   //! <Type Comment="Type for user commands to the drive. See Server &apos;SDDCmdIntfc&apos; of the &apos;_DriveAxis&apos; class." Name="_SDDUSERCMD"/>
    #define _SDDIDLE 0
    #define _SDDREADALL 1
    #define _SDDINIT 2
    #define _SDDURINIT 3
    #define _SDDEXDATA 4
    #define _SDDEXDATAXML 6
    #define _SDDIMDATAXML 7
    #define _SDDERROR 8

typedef UDINT CanDeviceStateTxt; 
    #define cInitialising 0
    #define cDisconnecting 1
    #define cConnecting 2
    #define cPreparing 3
    #define cStopped 4
    #define cOperational 5
    #define cPreOperational 127
    #define cIdle 255

typedef struct CanObjStr   //! <Type Comment="Can object ( ID, Size and Data)" Name="CanObjStr"/>
  {
    HDINT ID;  //! <Type Comment="CAN ID of the message" Name="CanObjStr.ID"/>
    DINT Size;  //! <Type Comment="The size of CAN data message" Name="CanObjStr.Size"/>
    HSINT Data [cMaxCanData+1-1];  //! <Type Comment="The Data in CAN message" Name="CanObjStr.Data"/>
  } CanObjStr;

typedef UDINT cilPos;   //! <Type Comment="JdK 7-10-2019: changed for cilinder with 3 positions&#13;&#10;" Name="cilPos"/>
    #define cilUnKnown 0
    #define cilIn 1
    #define cilOut 2
    #define cilMovingOut 3
    #define cilMovingOutShort 4
    #define cilOutShort 5
    #define cilMovingInShort 6
    #define cilInShort 7
    #define cilMovingIn 8
    #define cilNotConnected 10
    #define cilMovingMiddle 11
    #define cilMiddle 12

typedef struct 
  {
    long HwError : 1;  //! <Type Comment="Hardware error Flag" Name="CncFlags.HwError"/>
    long SwMin : 1;  //! <Type Comment="Software endswitch minimum active" Name="CncFlags.SwMin"/>
    long SwMax : 1;  //! <Type Comment="Software endswitch maximum active" Name="CncFlags.SwMax"/>
    long v_error : 1;  //! <Type Comment="velocity setting error" Name="CncFlags.v_error"/>
    long a_error : 1;  //! <Type Comment="Acceleration / deceleration setting error" Name="CncFlags.a_error"/>
    long ContrOff : 1;  //! <Type Comment="position controller off" Name="CncFlags.ContrOff"/>
    long NoRef : 1;  //! <Type Comment="no position reference" Name="CncFlags.NoRef"/>
    long DragLim : 1;  //! <Type Comment="contouring error" Name="CncFlags.DragLim"/>
    long ComandErr : 1;  //! <Type Comment="Command is not exepted" Name="CncFlags.ComandErr"/>
    long ActPosError : 1;  //! <Type Comment="invalid position of the hardware" Name="CncFlags.ActPosError"/>
    long IsNotControlling : 1;  //! <Type Comment="wake and shake is active" Name="CncFlags.IsNotControlling"/>
    long Follow : 1;
    long OverFlowError : 1;
    long dummy0 : 2;
    long GlobErr : 1;  //! <Type Comment="Any other errors is active" Name="CncFlags.GlobErr"/>
  }CncFlags;

#pragma pack(push, 1)
typedef struct CNCInternalStruct 
  {
    DINT *ptrExt;
    DINT *ptrInt;
    DINT *ptrBinOffset;
    DINT NowOverflow;
    DINT OverflowDelta;
    DINT SetPos;
  } CNCInternalStruct;
#pragma pack(pop)

typedef struct 
  {
    long InPosition : 1;  //! <Type Comment="Axis is in position" Name="CntrFlgs.InPosition"/>
    long FiltRdy : 1;  //! <Type Comment="Axis is in position and jerk filter is ready" Name="CntrFlgs.FiltRdy"/>
    long PosLimActive : 1;  //! <Type Comment="Position limit is active, set position is over the SW end position" Name="CntrFlgs.PosLimActive"/>
    long Decell : 1;  //! <Type Comment="Deceleration is active" Name="CntrFlgs.Decell"/>
    long bDynSWLimit : 1;  //! <Type Comment="Set if axis has reached one of its dynamic SW endpositions" Name="CntrFlgs.bDynSWLimit"/>
    long dummy0 : 1;
    long SetFlg : 1;  //! <Type Comment="Set by calling the SetPositon, CNCRefRun and NCRefRun functions Reset after activating the controller." Name="CntrFlgs.SetFlg"/>
    long dummy1 : 2;
    long EnLesFlg : 1;  //! <Type Comment="Endless positioning is active" Name="CntrFlgs.EnLesFlg"/>
    long DirFlg : 1;  //! <Type Comment="Commanded axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.DirFlg"/>
    long ActDirFlg : 1;  //! <Type Comment="Actual axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.ActDirFlg"/>
    long EmergStop : 1;  //! <Type Comment="Emergency stop is active" Name="CntrFlgs.EmergStop"/>
    long AutoRun : 1;  //! <Type Comment="Controller output autotuning is running" Name="CntrFlgs.AutoRun"/>
    long AutoStop : 1;  //! <Type Comment="Controller output autotuning is ready" Name="CntrFlgs.AutoStop"/>
    long Test : 1;  //! <Type Comment="Is only queried when ControllerOn is set to 0." Name="CntrFlgs.Test"/>
    long NoActpos : 1;  //! <Type Comment="The Client &quot;iActPosition&quot; is not connected" Name="CntrFlgs.NoActpos"/>
    long Overflow : 1;  //! <Type Comment="The axis has an internal position overflow." Name="CntrFlgs.Overflow"/>
    long NoControl : 1;  //! <Type Comment="The axis is not connected to a controller and the CNC therefore operates as a profile generator only." Name="CntrFlgs.NoControl"/>
    long ModuloFlg : 1;  //! <Type Comment="The axis is defined as a modulo axis." Name="CntrFlgs.ModuloFlg"/>
    long NoActPosMeth : 1;  //! <Type Comment="The &quot;iActPosition&quot; client is not connected to a server (axis operates without posi-tion feedback)." Name="CntrFlgs.NoActPosMeth"/>
    long NoRefMeth : 1;  //! <Type Comment="The &quot;iRefChannal&quot; is not connected" Name="CntrFlgs.NoRefMeth"/>
    long NoControlMeth : 1;  //! <Type Comment="The &quot;oSignalchannal&quot; client is not connected" Name="CntrFlgs.NoControlMeth"/>
    long NoSpecial : 1;  //! <Type Comment="The &quot;oPrecyclictrigger&quot; client is not connected" Name="CntrFlgs.NoSpecial"/>
    long NCMotion : 1;  //! <Type Comment="The CNC class is operated in NC mode" Name="CntrFlgs.NCMotion"/>
    long NoActPosChk : 1;
  }CntrFlgs;

typedef struct 
  {
    long SwitchOn : 1;
    long EnableVoltage : 1;
    long QuickStop : 1;
    long EnableOperation : 1;
    long OperationModeSpec1 : 1;
    long OperationModeSpec2 : 1;
    long OperationModeSpec3 : 1;
    long ResetFault : 1;
    long Halt : 1;
    long Reserved1 : 1;
    long Reserved2 : 1;
    long ManufactureSpec1 : 1;
    long ManufactureSpec2 : 1;
    long ManufactureSpec3 : 1;
    long ManufactureSpec4 : 1;
    long ManufactureSpec5 : 1;
  }DS402_Control;

typedef struct 
  {
    long ReadyToSwitchOn : 1;
    long SwitchedOn : 1;
    long OperationEnabled : 1;
    long Fault : 1;
    long VoltageEnabled : 1;
    long QuickStop : 1;
    long SwitchOnDisabled : 1;
    long Warning : 1;
    long ManufactureSpec1 : 1;
    long Remote : 1;
    long TargetReached : 1;
    long InternalLimitActive : 1;
    long OperationModeSpec1 : 1;
    long OperationModeSpec2 : 1;
    long ManufactureSpec2 : 1;
    long ManufactureSpec3 : 1;
  }DS402_State;

typedef UDINT eHMI_CmdPML;   //! <Type Comment="Standard command from HMI. Not all commands are&#13;&#10;meant for all kind off modules. But they just are ignored.&#13;&#10;&#13;&#10;Don&apos;t change numbers, they are used to convert the one&#13;&#10;type to the other" Name="eHMI_CmdPML"/>
    #define nul 0
    #define mdReqAuto 1
    #define mdReqManual 2
    #define mdReqHalfAuto 3
    #define mdReqService 4
    #define mdReqReserve 5
    #define resetAlarms 6
    #define start 7
    #define stop 8
    #define cmd1 9
    #define cmd2 10
    #define cmd3 11
    #define cmd4 12
    #define stReqReset 101
    #define stReqStart 103
    #define stReqHold 107
    #define stReqUnHold 109
    #define stReqSuspend 114
    #define stReqUnSuspend 116
    #define stReqStop 113
    #define stReqAbort 110
    #define stReqClear 112

typedef UDINT eMillToolComp; 
    #define noComp 0
    #define compPositiveMovement 1
    #define compNegativeMovement 2

typedef UDINT eMillType; 
    #define line 0
    #define circleCW 1
    #define circleCCW 2
    #define highSpeedLine 3

typedef UDINT eModePML; 
    #define auto 0
    #define manual 1
    #define halfAuto 2
    #define service 3
    #define reserve 4

typedef UDINT eSimuState; 
    #define noneSimu 0
    #define allSimu 1
    #define noMatSimu 2
    #define noActiveSimu -1

typedef UDINT eStatePML; 
    #define Stopped 0
    #define Resetting 1
    #define Idle 2
    #define Starting 3
    #define Execute 4
    #define Completing 5
    #define Complete 6
    #define Holding 7
    #define Held 8
    #define UnHolding 9
    #define Aborting 10
    #define Aborted 11
    #define Clearing 12
    #define Stopping 13
    #define Suspending 14
    #define Suspended 15
    #define UnSuspending 16
    #define NotActive -1

typedef UDINT eTypeMillProg; 
    #define normalProg 0
    #define lineProg 1
    #define squareProg 2
    #define circleProg 3
    #define drillProg 4

typedef UDINT EventModeTxt; 
    #define Event01Log 0
    #define Event1xLog 1
    #define TraceLog 2

#pragma pack(push, 1)
typedef struct Failure 
  {
    struct 
    {
    }One;
    struct 
    {
    }Two;
  } Failure;
#pragma pack(pop)

typedef UDINT feedPos; 
    #define fdUnKnown 0
    #define fdMovingFastFwd 1
    #define fdMovingFwd 2
    #define fdMovingBack 4
    #define fdWaitStopBack 5
    #define fdStopBack 6
    #define fdCompleteBack 7

typedef struct 
  {
    long Valid : 1;  //! <Type Comment="must be 1 to Start FileEx work" Name="FeSetup.Valid"/>
    long FileorRam : 1;  //! <Type Comment="0= work in File 1= Work File" Name="FeSetup.FileorRam"/>
    long EnableChecksum : 1;  //! <Type Comment="0=no Checksum; 1=Calculate Checksum, increased write access on the CF card" Name="FeSetup.EnableChecksum"/>
    long Encrypt : 1;  //! <Type Comment="0=no encryption; 1=encrypt file, increased write access on the CF card" Name="FeSetup.Encrypt"/>
  }FeSetup;

typedef struct   //! <Type Comment="Status Flag für IO Daten" Name="IO_FLAG"/>
  {
    short WrongHW : 1;  //! <Type Comment="Falsche Hardware verbunden" Name="IO_FLAG.WrongHW"/>
    short NoHW : 1;  //! <Type Comment="Keine Hardware verbunden" Name="IO_FLAG.NoHW"/>
    short NoCalibration : 1;  //! <Type Comment="Keine Kalibrierungsdaten im Modul-EEPROM" Name="IO_FLAG.NoCalibration"/>
    short ParaChkWrong : 1;  //! <Type Comment="Die Parameter-Checksumme ist falsch" Name="IO_FLAG.ParaChkWrong"/>
    short PhysicHiLimit : 1;  //! <Type Comment="IO ist am oberen physikalischen Limit" Name="IO_FLAG.PhysicHiLimit"/>
    short PhysicLoLimit : 1;  //! <Type Comment="IO ist am unteren physikalischen Limit" Name="IO_FLAG.PhysicLoLimit"/>
    short Invert : 1;  //! <Type Comment="Daten sind invertiert" Name="IO_FLAG.Invert"/>
    short dummy0 : 6;
    short OnDummyMode : 1;  //! <Type Comment="1 = Objekt ist im Dummymodus (nicht refreshed)" Name="IO_FLAG.OnDummyMode"/>
    short NotConnected : 1;  //! <Type Comment="1 = Objekt ist nicht verbunden" Name="IO_FLAG.NotConnected"/>
    short PhysicAccessOff : 1;  //! <Type Comment="1 = kein physikalischer Zugriff erlaubt" Name="IO_FLAG.PhysicAccessOff"/>
  }IO_FLAG;

#pragma pack(push, 1)
typedef struct IO_State 
  {
    IO_FLAG uiIO_Flags;
    UINT uiChNo;
  } IO_State;
#pragma pack(pop)

typedef CHAR IpAdrStr [15+1-0];

#pragma pack(push, 1)
typedef struct LogRecStr 
  {
    DINT Stepper;
    UDINT tElapsTime;
    UDINT tOpsTime;
  } LogRecStr;
#pragma pack(pop)

typedef CHAR longText [80+1-0];

typedef struct MasterStruct   //! <Type Comment="Pointers to the master axis data" Name="MasterStruct"/>
  {
    DINT *pos;  //! <Type Comment="Pointer to the master axis position [internal units]" Name="MasterStruct.pos"/>
    DINT *Speed;  //! <Type Comment="Pointer to the master axis speed [internal units / tick]" Name="MasterStruct.Speed"/>
    DINT *ModuloMaster;  //! <Type Comment="Pointer to ModuloInt of master axis [internal units]" Name="MasterStruct.ModuloMaster"/>
    pVoid PosLREAL;  //! <Type Comment="pointer to a LREAL value cointainig the master position [internal units]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.PosLREAL"/>
    pVoid SpeedLREAL;  //! <Type Comment="pointer to a LREAL value cointainig the master speed [internal units /tick]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.SpeedLREAL"/>
    pVoid pMasterThis;  //! <Type Comment="pointer to the _LMCAxis master object" Name="MasterStruct.pMasterThis"/>
  } MasterStruct;

typedef UDINT motorPos; 
    #define moOff 0
    #define moChangeDir 1
    #define moWaitFeedback 2
    #define moStarting 3
    #define moRunning 4

typedef UDINT pcPlaneType; 
    #define top 1
    #define behind 2
    #define bottom 3
    #define front 4
    #define all 5

typedef UDINT pcUnitTypes; 
    #define sawUnit 1
    #define millUnit 2
    #define punchUnit 3
    #define drillUnit 4
    #define markUnit 5
    #define loaderUnit 6
    #define positionUnit 7
    #define clampUnit 8
    #define measureUnit 9

#pragma pack(push, 1)
typedef struct PDOStr 
  {
    INT Val1;
    INT Val2;
    INT Val3;
    INT Val4;
  } PDOStr;
#pragma pack(pop)

typedef HwBase *pHwBase;

typedef HwBaseCDIAS *pHwBaseCDIAS;

typedef UDINT ProfileCommandStatus; 
    #define PassiveProfile 0
    #define IdleProfile 1
    #define RunProfile 2
    #define EndProfile 3
    #define ErrorProfile 4
    #define IdleProfileRestart 5
    #define WaitProfileRestart 6
    #define WaitProfileForAxInPos 7

typedef UDINT rollersState; 
    #define rsUnknown 0
    #define rsEmpty 1
    #define rsFilled 2
    #define rsMatAtTarget 3

typedef UDINT SafetyConfigStateType; 
    #define _ModuleNotFound 0
    #define _SafetyClassOK 1
    #define _ReinitConfig 2
    #define _UnsafeVarNotFound 3
    #define _ModFromCfgNotFound 4
    #define _MemAllocFailed 5
    #define _ReadFWVerFailed 6
    #define _UnknownCfgError 7
    #define _WaitForSynchronicity 8
    #define _AsyncComError 9
    #define _DOsIncreasedRestartApp 10
    #define _LostPowerSupply 11
    #define _WrongSafetyHW 12

#pragma pack(push, 1)
typedef struct SafetyDiagInfo 
  {
    USINT uControllerID;  //! <Type Comment="ID of µController (0 = µC1, else µC2)" Name="SafetyDiagInfo.uControllerID"/>
    USINT ActErrorCode;  //! <Type Comment="actual error code" Name="SafetyDiagInfo.ActErrorCode"/>
    USINT FirstErrorCode;  //! <Type Comment="code of first error that lead to an error state" Name="SafetyDiagInfo.FirstErrorCode"/>
    UDINT ReasonCode0;  //! <Type Comment="reason for error (meaning depends on actual error code)" Name="SafetyDiagInfo.ReasonCode0"/>
    UDINT ReasonCode1;  //! <Type Comment="reason for error (meaning depends on actual error code)" Name="SafetyDiagInfo.ReasonCode1"/>
  } SafetyDiagInfo;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct SafetyDiagState 
  {
    USINT RunState;  //! <Type Comment=" 1..POST&#13;&#10; 2..SERVICE&#13;&#10; 4..ERROR&#13;&#10; 8..IDLE&#13;&#10;16..CHK_CFG&#13;&#10;32..OP_TEMP&#13;&#10;64..OP" Name="SafetyDiagState.RunState"/>
    USINT ConfigState;  //! <Type Comment=" 1..INVALID&#13;&#10; 2..NOT_CONFIGURED&#13;&#10; 4..CONFIGURED_NOT_DEPLOYED_NOT_VERIFIED&#13;&#10; 8..CONFIGURED_AND_VERIFIED&#13;&#10;16..CONFIGURED_DEPLOYED_NOT_VERIFIED&#13;&#10;36..CONFIGURED_NOT_DEPLOYED_NOT_VERIFIED_DEV&#13;&#10;48..CONFIGURED_DEPLOYED_NOT_VERIFIED_DEV" Name="SafetyDiagState.ConfigState"/>
    USINT LoginLevel;  //! <Type Comment="0..not logged in&#13;&#10;1..debug&#13;&#10;2..configuration&#13;&#10;3..general" Name="SafetyDiagState.LoginLevel"/>
    UINT ErrorCounterIOState;  //! <Type Comment="Is increased on change of the error state of any input or output" Name="SafetyDiagState.ErrorCounterIOState"/>
  } SafetyDiagState;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct SDOStr   //! <Type Comment="SDO communication struct" Name="SDOStr"/>
  {
    HINT SdoId;  //! <Type Comment="CAN ID number" Name="SDOStr.SdoId"/>
    struct   //! <Type Comment="SDO action code" Name="SDOStr.CmndCode"/>
    {
    }CmndCode;
    UINT Index;  //! <Type Comment="Paramtere index" Name="SDOStr.Index"/>
    USINT SIndex;  //! <Type Comment="Parameter sub index" Name="SDOStr.SIndex"/>
    DINT Value;  //! <Type Comment="Value" Name="SDOStr.Value"/>
  } SDOStr;
#pragma pack(pop)

typedef UDINT servoPos; 
    #define seStop 0
    #define seWaitReset 1
    #define seIdle 2
    #define seWaitStartMoveRef 3
    #define seStartMoveRef 4
    #define seMoveRef 5
    #define seWaitStartMove 6
    #define seStartMove 7
    #define seMove 8
    #define seMoveLastPiece 9
    #define seWaitInPos 10
    #define seWaitStartJogPos 11
    #define seStartJogPos 12
    #define seJogPos 13
    #define seWaitStartJogNeg 14
    #define seStartJogNeg 15
    #define seJogNeg 16
    #define seStartCoupling 19
    #define seWaitCoupling 20
    #define seWaitUnCoupling 21
    #define seCoupled 22

typedef struct 
  {
    long BU1 : 1;  //! <Type Comment="Bewerkingsunit 1 tot 10&#13;&#10;verwachting is dat dit genoeg is&#13;&#10;dit gaat om boor pons en zaagunits&#13;&#10;" Name="Units.BU1"/>
    long BU2 : 1;
    long BU3 : 1;
    long BU4 : 1;
    long BU5 : 1;
    long BU6 : 1;
    long BU7 : 1;
    long BU8 : 1;
    long BU9 : 1;
    long BU10 : 1;
    long AV1 : 1;  //! <Type Comment="av staat voor ??&#13;&#10;dit gaat om het aanvoer- of afvoermagazijn" Name="Units.AV1"/>
    long AV2 : 1;
    long PU1 : 1;  //! <Type Comment="POSITIONEERUNIT, maximaal 2 beschikbaar&#13;&#10;eentje aan de aanvoer en eentje aan de afvoerkant" Name="Units.PU1"/>
    long PU2 : 1;
    long CL1 : 1;  //! <Type Comment="KLEM, van 1 tot 5 dit lijkt&#13;&#10;voorlopig genoeg.&#13;&#10;Misschien dat er nog meer bewerkings&#13;&#10;units of klemmen nodig zijn.&#13;&#10;Er is op deze manier ruimte tot 30 stuks" Name="Units.CL1"/>
    long CL2 : 1;
    long CL3 : 1;
    long CL4 : 1;
    long CL5 : 1;
    long MU1 : 1;
    long MU2 : 1;
    long AV4 : 1;
    long BU11 : 1;
    long WaitForOutputList : 1;
    long AV3 : 1;
    long BU12 : 1;
    long BU13 : 1;
    long CL6 : 1;
    long CL7 : 1;
    long CL8 : 1;
    long CL9 : 1;
    long DoWithOutput : 1;
  }Units;

typedef CHAR tekst [24+1-0];

#pragma pack(push, 1)
typedef struct SRegelInfo 
  {
    DINT Rnr;
    DINT Command;
    DINT Amount;
    Units Units;
    DINT Offset;
    DINT x1Pos;
    DINT y1Pos;
    DINT z1Pos;
    DINT zy1Angle;
    DINT xz1Angle;
    DINT xy1Angle;
    DINT actione;
    DINT speed;
    DINT toolID;
    tekst tekst;
    DINT level;
  } SRegelInfo;
#pragma pack(pop)

typedef SRegelInfo SRegelInfoArray [cMaxRegel+1-0];

#pragma pack(push, 1)
typedef struct StepLogStr 
  {
    DINT Nr;  //! <Type Comment="Array offset for the next step.&#13;&#10;So this is the oldest step number in the FIFO." Name="StepLogStr.Nr"/>
    LogRecStr Logger [cSCbMaxLogArray+1-0];  //! <Type Comment="Step numbers in sequance." Name="StepLogStr.Logger"/>
  } StepLogStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct StepperDataStr 
  {
    DINT First;  //! <Type Comment="First time in this step." Name="StepperDataStr.First"/>
    UDINT tTime;  //! <Type Comment="Time this step is active in mSec." Name="StepperDataStr.tTime"/>
    StepLogStr StepLog;  //! <Type Comment="Step numbers in sequance of excecution." Name="StepperDataStr.StepLog"/>
    DINT StepperOld;  //! <Type Comment="Internal, Old stepper value." Name="StepperDataStr.StepperOld"/>
    UDINT tMark;  //! <Type Comment="Internal, Ops.tAbsolute time when step was enterd for the first time." Name="StepperDataStr.tMark"/>
    DINT OerInit;  //! <Type Comment="Internal, Detection this function is called for the first time." Name="StepperDataStr.OerInit"/>
    LogRecStr *pActLog;
  } StepperDataStr;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct strMillLine 
  {
    eMillType millType;
    DINT xGoal;
    DINT yGoal;
    DINT radius;
    DINT middleX;
    DINT middleY;
  } strMillLine;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct strMillPlane 
  {
    DINT depth;
    DINT amount;
    DINT feedRate;  //! <Type Comment="speed in material in 1/10mm/s" Name="strMillPlane.feedRate"/>
    DINT lowerRate;  //! <Type Comment="speed going into material in 1/10 mm/sec" Name="strMillPlane.lowerRate"/>
    strMillLine lines [cMaxMillLinesInPlane+1-0];
  } strMillPlane;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct strMillRecipe 
  {
    CHAR description [20+1-0];
    DINT reqRPM;
    DINT startX;  //! <Type Comment="for milling X is the way how the material is going through the machine,&#13;&#10;where positive is into the direction the material comes from &#13;&#10;(material is always going negative through the machine)" Name="strMillRecipe.startX"/>
    DINT startY;  //! <Type Comment="for milling y direction is perpendicular to the x direction&#13;&#10;(of course, z direction is to) but also along the material" Name="strMillRecipe.startY"/>
    DINT startZ;  //! <Type Comment="z direction for milling is into the material,&#13;&#10;negative movement is into it, so a value of +5mm &#13;&#10;means starting 5mm above the material" Name="strMillRecipe.startZ"/>
    DINT xDimension;
    DINT yDimension;
    eMillToolComp yToolComp;  //! <Type Comment="needed to know if we have to calculate tool diam on positive or negative side&#13;&#10;" Name="strMillRecipe.yToolComp"/>
    DINT offsetForXmovement;  //! <Type Comment="we try to start at maximum x position, but this doesn&apos;t always fit, because we can only go negative then&#13;&#10;" Name="strMillRecipe.offsetForXmovement"/>
    strMillPlane planes [cMaxMillPlanesInRecipe+1-0];
    DINT ToolId;
    eTypeMillProg typeMillProg;
    DINT Reserve1;
    DINT Reserve2;
    DINT Reserve3;
  } strMillRecipe;
#pragma pack(pop)

#pragma pack(push, 4)
typedef struct strStateReqPML 
  {
    DINT ID;
    eStatePML state;
  } strStateReqPML;
#pragma pack(pop)

#pragma pack(push, 4)
typedef struct strPmlCom 
  {
    DINT Active;
    #pragma pack(push, 1)
struct cmd 
    {
      DINT interlock;
      eModePML mode;
      eStatePML state;
      eSimuState simulation;
      DINT reRun;
      DINT resetAlarms;
    } cmd;
#pragma pack(pop)
    struct sts 
    {
      strStateReqPML stateReq;
      DINT inAlarm;
      DINT isInterlocked;
      DINT stateCompleted;
      eStatePML state;
      eModePML mode;
      DINT modesNotEqual;  //! <Type Comment="gives signal that modes of underlaying system are not equal" Name="strPmlCom.sts.modesNotEqual"/>
      Units moveReady;
      Units actionReady;
      DINT allReady;
    } sts;
  } strPmlCom;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct strProfileRecipe 
  {
    CHAR description [20+1-0];
    CHAR reserveText [20+1-0];
    DINT exchangePartInputWagon;
    DINT vertPosInputWagon;
    DINT horPosInputWagon;
    DINT heightBundleMagazin;
    DINT widthBundleMagazin;
    DINT exchangePrintPos;
    DINT exchangePartMillPos1;
    DINT exchangePartMillPos2;
    DINT exchangePartMillPos3;
    DINT exchangePartSaw1;
    DINT exchangePartSaw2;
    DINT posMillClampsXdirection;
    DINT posVertMillClamps;
    DINT posHorMillClamps;
    DINT posHorSawClamps;
    DINT posGuidingRolSaw;
    DINT guidingRolSawUpOrDown;
    DINT posClampOutputWagon;
    DINT useLeftBGsaw;
    DINT useRightBGsaw;
    DINT workSpeed;
    DINT useBundleInput;
    DINT startSawPos;
    DINT endSawPos;
    DINT sawSpeed;
    DINT useDeburHoldCils;
    DINT useBackGuidingMills;
    DINT reserve1;
    DINT reserve2;
    DINT reserve3;
  } strProfileRecipe;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct strTimer 
  {
    UDINT tmpTime;
    DINT done;
    UDINT lastTime;
  } strTimer;
#pragma pack(pop)

#pragma pack(push, 1)
typedef struct strToolRecipe 
  {
    CHAR description [20+1-0];
    CHAR reserveText [20+1-0];
    DINT Id;
    DINT diameter;
    DINT length;
    DINT speedRPM;
    DINT reserve1;
    DINT reserve2;
    DINT reserve3;
    DINT reserve4;
  } strToolRecipe;
#pragma pack(pop)

typedef UDINT t_e_VaranErrors; 
    #define _ClassOk 0
    #define _NotInitialized 1
    #define _CallBackError 2
    #define _RequiredError 3
    #define _RootError 4
    #define _NoHardware 5
    #define _WrongHardware 6
    #define _CreateDOFailed 7
    #define _DirectAccessFailed 8
    #define _PllError 9
    #define _TimeoutInInit 10
    #define _HardwareRequiredIRQ 11
    #define _HardwareNotRequiredIRQ 12
    #define _HardwareFatalErrorIRQ 13
    #define _ManagerError 14
    #define _DisableError 15
    #define _EnableError 16
    #define _MultipleError 17
    #define _SPIError 18
    #define _ErrorBootImageFPGA 19
    #define _NoCDIASInterface 20
    #define _EEPromError 21
    #define _NoVaranInterface 22
    #define _MemoryFault 23
    #define _TimesliceError 24
    #define _TimesliceErrorIRQ 25
    #define _WatchdogError 26
    #define _VaranTimeError 27
    #define _DiasTimeError 28
    #define _DORamFull 29
    #define _PortNoLink 30
    #define _VaranDriverNotExists 31
    #define _WrongDOLType 32
    #define _WrongRunStatus 33
    #define _DOHandleInvalid 34
    #define _DOCmdInvalid 35
    #define _ManagerNotExists 36
    #define _DOLAddressInvalid 37
    #define _UnknownCommand 38
    #define _ComponentNotExists 39
    #define _ClientNotExists 40
    #define _CdiasEEPromNotExists 41
    #define _CdiasEEPromNoGrant 42
    #define _CdiasEEPromNack 43
    #define _PortNotExists 44
    #define _PortIsUplink 45
    #define _NoMutex 46
    #define _NoTask 47
    #define _IDNotFound 48
    #define _IDNotInitialized 49
    #define _InvalidDeviceAddress 50
    #define _CallbackNotHandled 51
    #define _NoMem 52
    #define _NoLegacyWd 53
    #define _AdminDOLExecutionError 54
    #define _DADOLExecutionError 55
    #define _SPIFlashNoAccess 56
    #define _ClientNotready 57
    #define _TimeoutVaran 58
    #define _UnknownFault 59
    #define _DiasError 60
    #define _DeviceError 61
    #define _VaranTimeWarning 62
    #define _OnlyASYSupported 63
    #define _InvalidSerialNo 64
    #define _CDIASRequiredError 65
    #define _DIASRequiredError 66
    #define _NoCalibDataFound 67
    #define _ModuleFoundButManagerIsOff 68
    #define _InvalidConfguration 69
    #define _ClientDisabled 70
    #define _ClientCantEnable 71
    #define _CdiasAddressInvalid 72
    #define _SPIFlashInvalid 73
    #define _SPIDOLIDInvalid 74
    #define _SPIDOLInvalid 75
    #define _SPIRequiredListError 76
    #define _SPIChksumError 77
    #define _ParameterInvalid 78
    #define _DOTypeNotSupported 79
    #define _DMAError 80
    #define _PropertyIDInvalid 81
    #define _PropertyValueInvalid 82
    #define _DONumberOverflow 83
    #define _APIUsageNotAllowed 84
    #define _NodeTypeWrong 85
    #define _DataLengthInvalid 86
    #define _DOTypeInvalid 87
    #define _OperationNotAllowed 88
    #define _NodeNumberOverflow 89
    #define _NoHandleFound 90
    #define _TopologyNotAllowed 91

#pragma pack(push, 1)
typedef struct t_s_ModulInfo 
  {
    HINT Kennung;
    void *p_This;
  } t_s_ModulInfo;
#pragma pack(pop)

typedef struct 
  {
    long BU1_saw : 1;
    long BU2_undersaw : 1;
    long BU3_sdrill : 1;
    long BU4_udrill : 1;
    long BU5_sdrill : 1;
    long BU6_sdrill : 1;
    long BU7_udrill : 1;
    long BU8_sdrill : 1;
    long BU9_sdrill : 1;
    long BU10_umill : 1;
    long BU11_sdrill : 1;
    long BU12_umill : 1;
    long BU13_udrill : 1;
    long frontPiece : 1;
    long endPiece : 1;
    long wastePiece : 1;
    long wasteStop : 1;
    long transfer : 1;
  }tBewerkingType;

typedef struct 
  {
    long b0 : 1;
    long b1 : 1;
    long b2 : 1;
    long b3 : 1;
    long b4 : 1;
    long b5 : 1;
    long b6 : 1;
    long b7 : 1;
    long b8 : 1;
    long b9 : 1;
    long b10 : 1;
    long b11 : 1;
    long b12 : 1;
    long b13 : 1;
    long b14 : 1;
    long b15 : 1;
    long b16 : 1;
    long b17 : 1;
    long b18 : 1;
    long b19 : 1;
    long b20 : 1;
    long b21 : 1;
    long b22 : 1;
    long b23 : 1;
    long b24 : 1;
    long b25 : 1;
    long b26 : 1;
    long b27 : 1;
    long b28 : 1;
    long b29 : 1;
    long b30 : 1;
    long b31 : 1;
  }tMyBDint;

