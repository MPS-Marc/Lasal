//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
TYPE
  _DRIVETYPE :
  (
    _NotFound,
    _SDD_310,
    _SDD_315,
    _SDD_105,
    _SDD_120,
    _SDD_305,
    _SDD_335,
    _SDD_215,
    _SDD_205,
    _SDD_210,
    _MDD_100,
    _S_340,
    _SDD_115,
    _SDD_1300:=811237,
    _SDD_1400:=811238,
    _SDD_1500:=811239,
    _SDD_1600:=811240,
    _MDD_2000:=811300,
    _VSDC_151:=811301,
    _DC061:=881042,
    _DC062:=881801,
    _SR011:=881802,
    _SR012:=881803,
    _DC101:=881804,
    _DC102:=881805,
    _WA011:=991800,
    _WA012:=991801
  )$UDINT;
#pragma pack(push, 1)
  _I_HC_Type : STRUCT  //! <Type Comment="Hardware Code an axis&#13;&#10;&#13;&#10;Bit 31..16 Hardware Code of the Control Board&#13;&#10;Bit 15...8 Software version of the feedback CPLD&#13;&#10;Bit   7...0 Hardware Code of the Power Stage" Name="_I_HC_Type"/>
    HardwareCodePowerStage : HSINT;  //! <Type Comment="Hardware Code of the Power Stage (Default: 16#80)" Name="_I_HC_Type.HardwareCodePowerStage"/>
    FPGAVersion : HSINT;  //! <Type Comment="Software version of the feedback CPLD" Name="_I_HC_Type.FPGAVersion"/>
    HardwareCodeControlBoard : HINT;  //! <Type Comment="Hardware Code of the Control Board (Default: 16#0000)" Name="_I_HC_Type.HardwareCodeControlBoard"/>
  END_STRUCT;
#pragma pack(pop)
  _LMC_DYN_SWLIMITS :  //! <Type Comment="Dynamic software end positions" Name="_LMC_DYN_SWLIMITS"/>
  (
    _LMC_DynSWLimitMin,  //! <Type Comment="Choose minimum dynamic SW end position" Name="_LMC_DYN_SWLIMITS._LMC_DynSWLimitMin"/>
    _LMC_DynSWLimitMax  //! <Type Comment="Choose maximum dynamic SW end position" Name="_LMC_DYN_SWLIMITS._LMC_DynSWLimitMax"/>
  )$UDINT;
  _LMCAXIS_CMDERROR : BDINT  //! <Type Comment="Status flags" Name="_LMCAXIS_CMDERROR"/>
  [
    1 PowerOff,  //! <Type Comment="1 --&gt; Position controller is off" Name="_LMCAXIS_CMDERROR.PowerOff"/>
    2 NoReference,  //! <Type Comment="1 --&gt; The axis is not referenced" Name="_LMCAXIS_CMDERROR.NoReference"/>
    3 HWError,  //! <Type Comment="1 --&gt; Servo hardware error" Name="_LMCAXIS_CMDERROR.HWError"/>
    4 ActPosError,  //! <Type Comment="1 --&gt; Invalid position of the hardware" Name="_LMCAXIS_CMDERROR.ActPosError"/>
    5 ContouringError,  //! <Type Comment="1 --&gt; Tracking limit exceeded" Name="_LMCAXIS_CMDERROR.ContouringError"/>
    6 CommandError,  //! <Type Comment="1 --&gt; Command not allowed or &#13;&#10;within the CNC RTWork cycle more than one command has been set&#13;&#10;" Name="_LMCAXIS_CMDERROR.CommandError"/>
    7 SWMinError,  //! <Type Comment="1 --&gt; Software endswitch minimum active" Name="_LMCAXIS_CMDERROR.SWMinError"/>
    8 SWMaxError,  //! <Type Comment="1 --&gt; Software endswitch maximum active" Name="_LMCAXIS_CMDERROR.SWMaxError"/>
    9 vError,  //! <Type Comment="1 --&gt; Selected speed too high" Name="_LMCAXIS_CMDERROR.vError"/>
    10 aError,  //! <Type Comment="1 --&gt; Selected acceleration / deceleration too high" Name="_LMCAXIS_CMDERROR.aError"/>
    11 HWMinError,  //! <Type Comment="1 --&gt; Hardware endswitch minimum active" Name="_LMCAXIS_CMDERROR.HWMinError"/>
    12 HWMaxError,  //! <Type Comment="1 --&gt; Hardware endswitch maximum active" Name="_LMCAXIS_CMDERROR.HWMaxError"/>
    13 DirError,  //! <Type Comment="1 --&gt; The direction of motion is not allowed" Name="_LMCAXIS_CMDERROR.DirError"/>
    14 EmergencyError,  //! <Type Comment="when Client _LMCSafety.Emergency goes to 1&#13;&#10; 0 -&gt; StopMove&#13;&#10; 1 -&gt; PowerOff" Name="_LMCAXIS_CMDERROR.EmergencyError"/>
    15 ResolutionError,  //! <Type Comment="1 -&gt; An overflow by multiplication with the value of the server: Resolution occurred&#13;&#10;" Name="_LMCAXIS_CMDERROR.ResolutionError"/>
    16 GlobalError,  //! <Type Comment="1 --&gt; Global error" Name="_LMCAXIS_CMDERROR.GlobalError"/>
    17 JError,  //! <Type Comment="1--&gt; Selected jerk is too high or low." Name="_LMCAXIS_CMDERROR.JError"/>
  ];
  _LMCAXIS_CONTROLBITS : BDINT  //! <Type Comment="Control-Bits" Name="_LMCAXIS_CONTROLBITS"/>
  [
    1 SetPowerOn,  //! <Type Comment="Set if the clients &quot;LMCController&quot; and &quot;ActPosition&quot; are not connected or &#13;&#10;the axis is active" Name="_LMCAXIS_CONTROLBITS.SetPowerOn"/>
    2 SetFollowMode,  //! <Type Comment="Set if the axis is in operationmode: &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_CONTROLBITS.SetFollowMode"/>
    3 ReadActPosFromController,
    4 CallReadPDO,
  ];
  _LMCAXIS_COUPLE_GEAR_MODE :  //! <Type Comment="Parameter of the methods &quot;CoupleUserPos&quot; and &quot;CoupleProfilePos&quot;" Name="_LMCAXIS_COUPLE_GEAR_MODE"/>
  (
    LMCAXIS_COUPLE_PROFILE_GEAR,  //! <Type Comment="Couple to master with user supplied gearfactor" Name="_LMCAXIS_COUPLE_GEAR_MODE.LMCAXIS_COUPLE_PROFILE_GEAR"/>
    LMCAXIS_COUPLE_PROFILE_NO_GEAR  //! <Type Comment="Couple to master with gearfactor := 1" Name="_LMCAXIS_COUPLE_GEAR_MODE.LMCAXIS_COUPLE_PROFILE_NO_GEAR"/>
  )$UDINT;
  _LMCAXIS_COUPLEERROR :  //! <Type Comment="Errorlist returned by the function: &quot;CoupleGearPolynom&quot;" Name="_LMCAXIS_COUPLEERROR"/>
  (
    LMCAXIS_NO_ERROR_OCCURED,  //! <Type Comment="No Error Occured" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_NO_ERROR_OCCURED"/>
    LMCAXIS_MASTERPOINTER_INVALID,  //! <Type Comment="Pointer to Master-Axis is invalid" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_MASTERPOINTER_INVALID"/>
    LMCAXIS_SELFCOUPLING,  //! <Type Comment="Master-Axis and Slave-Axis are identically - Selfcoupling is not allowed" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_SELFCOUPLING"/>
    LMCAXIS_SOFTWARE_ERROR,  //! <Type Comment="Pointer to Velocity in Data of Master-Axis is invalid" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_SOFTWARE_ERROR"/>
    LMCAXIS_VEL_MASTER_NOT_POSITIVE,  //! <Type Comment="Velocity of Master-Axis is zero or negative" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MASTER_NOT_POSITIVE"/>
    LMCAXIS_PATH_MASTER_NOT_POSITIVE,  //! <Type Comment="Path of Master is zero or negative" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_MASTER_NOT_POSITIVE"/>
    LMCAXIS_PATH_SLAVE_NOT_POSITIVE,  //! <Type Comment="Path of Slave is zero or negative" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SLAVE_NOT_POSITIVE"/>
    LMCAXIS_VEL_MASTER_DEFINITION_ERROR,  //! <Type Comment="Master overrides his maximal allowed velocity (Input-Error)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MASTER_DEFINITION_ERROR"/>
    LMCAXIS_JERK_MAX_DEFINITION_ERROR,  //! <Type Comment="Maximal allowed Jerk of Slave is negative or zero" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_DEFINITION_ERROR"/>
    LMCAXIS_ACC_ANNIHILATION_FAILED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: The initial-acceleration / initial-deceleration can not be recuced &#13;&#10;to zero without the fact, that the maximal allowed velocity of the slave is exceeded or the velocitiy of the slave &#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_ANNIHILATION_FAILED_3_5"/>
    LMCAXIS_PATH_SX_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the path of the Spline of 3rd order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SX_NEGATIVE_3_5"/>
    LMCAXIS_VEL_COUPLE_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the coupling-velocity becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NEGATIVE_3_5"/>
    LMCAXIS_VEL_COUPLE_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the couple-velocity exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_EXCEED_3_5"/>
    LMCAXIS_PATH_SZ_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the path of the spline of 5th order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SZ_NEGATIVE_3_5"/>
    LMCAXIS_TIME_SZ_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the duration of the spline of 5th order becomes negative (mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SZ_NEGATIVE_3_5"/>
    LMCAXIS_VEL_MIN_NEGATIVE_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the minimal velocitiy of the spline of 5th order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MIN_NEGATIVE_3_5"/>
    LMCAXIS_VEL_MAX_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the velocitiy of the spline of 5th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MAX_EXCEED_3_5"/>
    LMCAXIS_ACC_MAX_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the acceleration of the spline of 5th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_EXCEED_3_5"/>
    LMCAXIS_JERK_MAX_SLAVE_EXCEED_3_5,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 5th order: the jerk of the spline of 5th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_SLAVE_EXCEED_3_5"/>
    LMCAXIS_ACC_ANNIHILATION_FAILED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: The initial-acceleration / initial-deceleration can not &#13;&#10;be recuced to zero without the fact, that the maximal allowed velocity of the slave is exceeded or the velocitiy of the slave &#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_ANNIHILATION_FAILED_4_1_4"/>
    LMCAXIS_VEL_ACCNIHIL_NEGATIVE,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the coupling-velocity of the&#13;&#10;spline of 3rd order with the spline of 4th order becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_ACCNIHIL_NEGATIVE"/>
    LMCAXIS_VEL_ACCNIHIL_EXCEED,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the coupling-velocity of the&#13;&#10;spline of 3rd order with the spline of 4th order exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_ACCNIHIL_EXCEED"/>
    LMCAXIS_ACC_MAX_DEFINITION_ERROR,  //! <Type Comment="Maximal allowed acceleration is negative (input-error)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_DEFINITION_ERROR"/>
    LMCAXIS_VEL_COUPLE_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the linear spline&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NEGATIVE_4_1_4"/>
    LMCAXIS_VEL_COUPLE_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the linear spline&#13;&#10;exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_EXCEED_4_1_4"/>
    LMCAXIS_PATH_SX_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the path of the first spline of 4t order&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SX_NEGATIVE_4_1_4"/>
    LMCAXIS_PATH_SY_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the path of the linear spline&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SY_NEGATIVE_4_1_4"/>
    LMCAXIS_PATH_SZ_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the path of the second spline of 4th order&#13;&#10;becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SZ_NEGATIVE_4_1_4"/>
    LMCAXIS_VEL_MIN_NEGATIVE_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the first spline of 4th order&#13;&#10;becomes negative (has a negative extremum - backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MIN_NEGATIVE_4_1_4"/>
    LMCAXIS_VEL_MAX_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the velocity of the first spline of 4th order&#13;&#10;overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_MAX_EXCEED_4_1_4"/>
    LMCAXIS_ACC_MAX_1_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the acceleration of the first spline of 4th order&#13;&#10;overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_1_EXCEED_4_1_4"/>
    LMCAXIS_ACC_MAX_2_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the acceleration of the second &#13;&#10;spline of 4th order overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_ACC_MAX_2_EXCEED_4_1_4"/>
    LMCAXIS_JERK_MAX_1_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the jerk of the first&#13;&#10;spline of 4th order overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_1_EXCEED_4_1_4"/>
    LMCAXIS_JERK_MAX_2_EXCEED_4_1_4,  //! <Type Comment="In Couplemode Spline 3rd order with Spline 4th order with lineare Spline with Spline 4th order: the jerk of the second &#13;&#10;spline of 4th order overrides its masimal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_JERK_MAX_2_EXCEED_4_1_4"/>
    LMCAXIS_TRAPEZOIDSPLINE_DISABLED,  //! <Type Comment="Trapezoid-Spline is disabled (by user of by default-value)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TRAPEZOIDSPLINE_DISABLED"/>
    LMCAXIS_VEL_COUPLE_NO_SOLUTION,  //! <Type Comment="No real solution for the coupling-velocity exist (math.: is a complex number)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NO_SOLUTION"/>
    LMCAXIS_VEL_COUPLE_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the coupling-velocity becomes negative (backdriving is not allowed)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_NEGATIVE_2_1_2"/>
    LMCAXIS_VEL_COUPLE_EXCEED_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the velocity of the linear spline&#13;&#10;exceeds its maximal allowed value" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_VEL_COUPLE_EXCEED_2_1_2"/>
    LMCAXIS_TIME_SX_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of the first spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SX_NEGATIVE_2_1_2"/>
    LMCAXIS_TIME_SY_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of the lineare spline becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SY_NEGATIVE_2_1_2"/>
    LMCAXIS_TIME_SZ_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of the 3rd spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_TIME_SZ_NEGATIVE_2_1_2"/>
    LMCAXIS_PATH_SX_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the path of the first spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SX_NEGATIVE_2_1_2"/>
    LMCAXIS_PATH_SY_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the path of the lineare spline becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SY_NEGATIVE_2_1_2"/>
    LMCAXIS_PATH_SZ_NEGATIVE_2_1_2,  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the path of the 3rd spline of 2nd order becomes negative&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_PATH_SZ_NEGATIVE_2_1_2"/>
    LMCAXIS_DURATION_ERROR  //! <Type Comment="In Couplemode Spline 2nd order with linear Spline and Spline 2nd order: the duration of spline is zero&#13;&#10;(mathematical inconsistent - no solution exists)" Name="_LMCAXIS_COUPLEERROR.LMCAXIS_DURATION_ERROR"/>
  )$UDINT;
#pragma pack(push, 1)
  CurveTable : STRUCT  //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="CurveTable"/>
    MasterPos : DINT;  //! <Type Comment="Master axis position [Application units]" Name="CurveTable.MasterPos"/>
    SlavePos : DINT;  //! <Type Comment="Slave axis position [Application units]" Name="CurveTable.SlavePos"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _LMCAXIS_CURVE : STRUCT  //! <Type Comment="Motion type curve data" Name="_LMCAXIS_CURVE"/>
    modulo : DINT;  //! <Type Comment="Lead axis modulo value" Name="_LMCAXIS_CURVE.modulo"/>
    points : DINT;  //! <Type Comment="number of curve points" Name="_LMCAXIS_CURVE.points"/>
    mul : DINT;  //! <Type Comment="Numerator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.mul"/>
    div : DINT;  //! <Type Comment="Denominator of the slave axis scale factor.&#13;&#10;The scale factor is used on the slave value of the cam table." Name="_LMCAXIS_CURVE.div"/>
    offset : DINT;  //! <Type Comment="Position offset in the slave axis of the cam definition [Internal units].&#13;&#10;Added to the slave value of the cam table." Name="_LMCAXIS_CURVE.offset"/>
    table : ARRAY [0..1023] OF CurveTable;  //! <Type Comment="Table curve points (Masterpos, Slavepos)" Name="_LMCAXIS_CURVE.table"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCAXIS_CURVETABMODE : BDINT  //! <Type Comment="Slave axis operating mode" Name="_LMCAXIS_CURVETABMODE"/>
  [
    1 bStopAxisNoMod,  //! <Type Comment="Parameter of the function &quot;CoupleCurveTab&quot; / &quot;CoupleCAM&quot;&#13;&#10;0 --&gt; Normal operation. Slave follows the master over the curve definition, including a master axis position overflow.&#13;&#10;1 --&gt; Stop slave axis immediately when master axis position overflows." Name="_LMCAXIS_CURVETABMODE.bStopAxisNoMod"/>
    2 bRecoupleCamMod,  //! <Type Comment="Parameter of the function &quot;CoupleCurveTab&quot; / &quot;CoupleCAM&quot;. This parameter defines the coupling mode for a master modulo axis and a slave modulo axis,&#13;&#10;0 --&gt; Normal coupling (first coupling)&#13;&#10;1 --&gt; Recouple to a different CAM table or couple after a successfull decouple to the given CAM table." Name="_LMCAXIS_CURVETABMODE.bRecoupleCamMod"/>
  ];
  _LMCAXIS_ERROR : BDINT  //! <Type Comment="Error-Bits" Name="_LMCAXIS_ERROR"/>
  [
    1 HwError,  //! <Type Comment="Set if a general Hardware-Error occured" Name="_LMCAXIS_ERROR.HwError"/>
    2 SwMinError,  //! <Type Comment="Set if the Software-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.SwMinError"/>
    3 SwMaxError,  //! <Type Comment="Set if the Software-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.SwMaxError"/>
    4 HwMinError,  //! <Type Comment="Set if the Hardware-Endswitch Minimum is active" Name="_LMCAXIS_ERROR.HwMinError"/>
    5 HwMaxError,  //! <Type Comment="Set if the Hardware-Endswitch Maximum is active" Name="_LMCAXIS_ERROR.HwMaxError"/>
    6 ReferenceError,  //! <Type Comment="Set if an error occured during the reference-run" Name="_LMCAXIS_ERROR.ReferenceError"/>
    7 ContouringError,  //! <Type Comment="Set if a tracking-error occured" Name="_LMCAXIS_ERROR.ContouringError"/>
    8 ActPosError,  //! <Type Comment="Set if the Hardware-Position is invalid" Name="_LMCAXIS_ERROR.ActPosError"/>
    9 AbsOffsetError,  //! <Type Comment="Set if an Offset-Error occured" Name="_LMCAXIS_ERROR.AbsOffsetError"/>
    10 OverFlowError,  //! <Type Comment="Set if a Position-Overflow occured" Name="_LMCAXIS_ERROR.OverFlowError"/>
    11 EmergencyError,  //! <Type Comment="Set if the _LMCSafety.Emergency is active" Name="_LMCAXIS_ERROR.EmergencyError"/>
    12 ResolutionError,  //! <Type Comment="Set if the Resolution causes an overflow error&#13;&#10;" Name="_LMCAXIS_ERROR.ResolutionError"/>
    13 PowerOnError,  //! <Type Comment="Set, if the enable signal of the hardware was cleared during operation, or if after calling PowerOn() the axis has not been enabled before a timeout of 30 seconds occured." Name="_LMCAXIS_ERROR.PowerOnError"/>
    14 PowerOffError,  //! <Type Comment="Set, if after calling PowerOff() the axis has not been disabled before a timeout occured." Name="_LMCAXIS_ERROR.PowerOffError"/>
    16 GlobErr,  //! <Type Comment="Set if a global error is active" Name="_LMCAXIS_ERROR.GlobErr"/>
  ];
  _LMCAXIS_ERROR_CONFIG : BDINT  //! <Type Comment="Error-Config Bits" Name="_LMCAXIS_ERROR_CONFIG"/>
  [
    1 vError,  //! <Type Comment="when programmed speed is too high:&#13;&#10; 0 ... the speed will be limited (default)&#13;&#10; 1 ... set the vError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.vError"/>
    2 aError,  //! <Type Comment="when programmed acceleration is too high:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the aError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.aError"/>
    3 SWMinError,  //! <Type Comment="when position would be smaller than SWMinPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMinError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMinError"/>
    4 SWMaxError,  //! <Type Comment="when position would be bigger than SWMaxPos:&#13;&#10; 0 ... position will be limited (default)&#13;&#10; 1 ... set the SWMaxError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.SWMaxError"/>
    5 CommandError,  //! <Type Comment="when the deltaposition is bigger than the&#13;&#10;MaxModulo during coupling:&#13;&#10; 0 ... no check (default)&#13;&#10; 1 ... set the CommandError flag in the command result" Name="_LMCAXIS_ERROR_CONFIG.CommandError"/>
    6 EmergencyError,  //! <Type Comment="when Emergency goes to 1:&#13;&#10; 0 ... StopMove() (default)&#13;&#10; 1 ... PowerOff()&#13;&#10;" Name="_LMCAXIS_ERROR_CONFIG.EmergencyError"/>
    7 CoupleMonitoring,  //! <Type Comment="0: Monitoring the coupled axes is disabled. This axis does not recognise an error of its master axis and also does not report its own errors to the master. Furthermore, there is no reaction on errors of its slaves.&#13;&#10;1: Monitoring of all coupled master and slave axes for errors is enabled. The error handling can be configured with SetParameter with modes LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR, LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR, and LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG." Name="_LMCAXIS_ERROR_CONFIG.CoupleMonitoring"/>
    8 JError,  //! <Type Comment="when programmed jerk is too high or low:&#13;&#10; 0 ... the acceleration will be limited (default)&#13;&#10; 1 ... set the JError flag in the result" Name="_LMCAXIS_ERROR_CONFIG.JError"/>
  ];
  _LMCAXIS_FOLLOW_MODE :  //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;" Name="_LMCAXIS_FOLLOW_MODE"/>
  (
    LMCAXIS_DEACTIVATE_FOLLOW_MODE,  //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;:&#13;&#10;Deactivate the operationmode &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_FOLLOW_MODE.LMCAXIS_DEACTIVATE_FOLLOW_MODE"/>
    LMCAXIS_ACTIVATE_FOLLOW_MODE  //! <Type Comment="Parameter of the function &quot;SetFollowMode&quot;:&#13;&#10;Activate the operationmode &quot;FOLLOW_LMCAXIS&quot;" Name="_LMCAXIS_FOLLOW_MODE.LMCAXIS_ACTIVATE_FOLLOW_MODE"/>
  )$UDINT;
  _LMCAXIS_MOVE_RELATIVE_MODE :  //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;" Name="_LMCAXIS_MOVE_RELATIVE_MODE"/>
  (
    LMCAXIS_MOVE_RELATIVE_TO_DESTINATION,  //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;:&#13;&#10;Move relative to destination" Name="_LMCAXIS_MOVE_RELATIVE_MODE.LMCAXIS_MOVE_RELATIVE_TO_DESTINATION"/>
    LMCAXIS_MOVE_RELATIVE_TO_POSITION  //! <Type Comment="Parameter of the function &quot;MoveRelative&quot;:&#13;&#10;Move relative to position" Name="_LMCAXIS_MOVE_RELATIVE_MODE.LMCAXIS_MOVE_RELATIVE_TO_POSITION"/>
  )$UDINT;
  _LMCAXIS_MOVEDIRECTION :  //! <Type Comment="Set direction of movement for the axis&#13;&#10;" Name="_LMCAXIS_MOVEDIRECTION"/>
  (
    LMCAXIS_MOVE_ANY_WAY,  //! <Type Comment="The axis can move in any direction." Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_ANY_WAY"/>
    LMCAXIS_MOVE_NEG_DIR,  //! <Type Comment="The axis can move in the negative direction only." Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_NEG_DIR"/>
    LMCAXIS_MOVE_SHORTEST_WAY,  //! <Type Comment="The axis moves over the shortest distance (both directions)" Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_SHORTEST_WAY"/>
    LMCAXIS_MOVE_POS_DIR  //! <Type Comment="The axis can move in the positive direction only." Name="_LMCAXIS_MOVEDIRECTION.LMCAXIS_MOVE_POS_DIR"/>
  )$UDINT;
  _LMCAXIS_MOVEPROFILE :  //! <Type Comment="Velocity-profile" Name="_LMCAXIS_MOVEPROFILE"/>
  (
    _RAMP_PROFILE,  //! <Type Comment="Velocity-profile resembles a linear ramp" Name="_LMCAXIS_MOVEPROFILE._RAMP_PROFILE"/>
    _SCURVE_PROFILE,  //! <Type Comment="Velocity-profile resembles a sigmoide (S-Curve)&#13;&#10;using a position filtering." Name="_LMCAXIS_MOVEPROFILE._SCURVE_PROFILE"/>
    _JERK_PROFILE:=10  //! <Type Comment="Velocity-profile resembles a sigmoide (S-Curve)&#13;&#10;using exact calculation of a trapezoide acceleration/deceleration" Name="_LMCAXIS_MOVEPROFILE._JERK_PROFILE"/>
  )$UDINT;
  _LMCAXIS_MOVINGTIMEERROR :  //! <Type Comment="Errorlist returned by the function: &quot;CalcMovingTime&quot;" Name="_LMCAXIS_MOVINGTIMEERROR"/>
  (
    LMCAXIS_NO_ERROR_,  //! <Type Comment="No Error occured - a solution is found" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_NO_ERROR_"/>
    LMCAXIS_MAXVEL_NOT_POSITIV,  //! <Type Comment="Input-Error: Maximal allowed velocity &lt;= 0" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_MAXVEL_NOT_POSITIV"/>
    LMCAXIS_STARTVEL_TO_BIG,  //! <Type Comment="Input-Error: Velocitiy at Startposition &gt; Maximal allowed velocity" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_STARTVEL_TO_BIG"/>
    LMCAXIS_ENDVEL_TO_BIG,  //! <Type Comment="Input-Error: Velocitiy at Endposition &gt; Maximal allowed velocity" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_ENDVEL_TO_BIG"/>
    LMCAXIS_PATH_IS_ZERO,  //! <Type Comment="Input-Error: Startposition is identically equal to Endposition but one velocity &lt;&gt; 0" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_PATH_IS_ZERO"/>
    LMCAXIS_STARTVEL_NEGATIVE,  //! <Type Comment="Start-Velocity is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_STARTVEL_NEGATIVE"/>
    LMCAXIS_OVERFLOW_ERROR,  //! <Type Comment="Overflow-Error during calculation occured" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_OVERFLOW_ERROR"/>
    LMCAXIS_TIME_ERROR_1,  //! <Type Comment="Time of first part of triangel/trapez is negative " Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_TIME_ERROR_1"/>
    LMCAXIS_TIME_ERROR_2,  //! <Type Comment="Time of second part of trapez is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_TIME_ERROR_2"/>
    LMCAXIS_TIME_ERROR_3,  //! <Type Comment="Time of third part of triangel/trapez is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_TIME_ERROR_3"/>
    LMCAXIS_POINTER_ERROR,  //! <Type Comment="Pointer to Parameter is NIL " Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_POINTER_ERROR"/>
    LMCAXIS_ENDVEL_NEGATIVE,  //! <Type Comment="End-Velocity is negative" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_ENDVEL_NEGATIVE"/>
    LMCAXIS_ACCEL_NOT_POSITIV,  //! <Type Comment="Start-Acceleration is not positive" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_ACCEL_NOT_POSITIV"/>
    LMCAXIS_DECEL_NOT_POSITIV,  //! <Type Comment="End-Deceleration is not positive" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_DECEL_NOT_POSITIV"/>
    LMCAXIS_PATH_ERROR,  //! <Type Comment="Endposition cannot be reached - Parameter inconsitent" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_PATH_ERROR"/>
    LMCAXIS_GLOBAL_ERROR,  //! <Type Comment="The resulting time is negative - Parameter inconsitent" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_GLOBAL_ERROR"/>
    LMCAXIS_NUMERIC_ERROR,  //! <Type Comment="A numerical error has appeared" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_NUMERIC_ERROR"/>
    LMCAXIS_MATH_ERROR,  //! <Type Comment="A mathematical error has appeared" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_MATH_ERROR"/>
    LMCAXIS_NO_SOLUTION  //! <Type Comment="No solution found or does not exist" Name="_LMCAXIS_MOVINGTIMEERROR.LMCAXIS_NO_SOLUTION"/>
  )$UDINT;
  _LMCAXIS_OPMODE :  //! <Type Comment="Current state of the axis" Name="_LMCAXIS_OPMODE"/>
  (
    PASSIVE_LMCAXIS,  //! <Type Comment="The axis is in passive hibernation" Name="_LMCAXIS_OPMODE.PASSIVE_LMCAXIS"/>
    WAITIDLE_LMCAXIS,  //! <Type Comment="The axis is in passive waiting state until the hardware reports" Name="_LMCAXIS_OPMODE.WAITIDLE_LMCAXIS"/>
    IDLE_LMCAXIS,  //! <Type Comment="The axis is in active waiting state" Name="_LMCAXIS_OPMODE.IDLE_LMCAXIS"/>
    MOVE_LMCAXIS,  //! <Type Comment="The axis is in movement state" Name="_LMCAXIS_OPMODE.MOVE_LMCAXIS"/>
    FOLLOW_LMCAXIS,  //! <Type Comment="The axis is in state &quot;FOLLOW_LMCAXIS&quot;:&#13;&#10;Axis follows the actual position (defaulted by a controller) passively&#13;&#10;" Name="_LMCAXIS_OPMODE.FOLLOW_LMCAXIS"/>
    STOPED_LMCAXIS,  //! <Type Comment="The axis is stopping the movement (braking)" Name="_LMCAXIS_OPMODE.STOPED_LMCAXIS"/>
    LOCKED_LMCAXIS,  //! <Type Comment="The axis is coupled to a master-axis" Name="_LMCAXIS_OPMODE.LOCKED_LMCAXIS"/>
    REFRUN_LMCAXIS,  //! <Type Comment="The axis is performing a reference run" Name="_LMCAXIS_OPMODE.REFRUN_LMCAXIS"/>
    TUNEPOS_LMCAXIS,  //! <Type Comment="Movement for the purpose of optimization of the control parameters in positive direction" Name="_LMCAXIS_OPMODE.TUNEPOS_LMCAXIS"/>
    TUNENEG_LMCAXIS,  //! <Type Comment="Movement for the purpose of optimization of the control parameters in negative direction" Name="_LMCAXIS_OPMODE.TUNENEG_LMCAXIS"/>
    ERROR_LMCAXIS,  //! <Type Comment="An error occurred" Name="_LMCAXIS_OPMODE.ERROR_LMCAXIS"/>
    WAITPASSIVE_LMCAXIS  //! <Type Comment="The axis is in idle waiting state until the hardware reports" Name="_LMCAXIS_OPMODE.WAITPASSIVE_LMCAXIS"/>
  )$UDINT;
  _LMCAXIS_POSMODE :  //! <Type Comment="Positionmode" Name="_LMCAXIS_POSMODE"/>
  (
    _Positioning,  //! <Type Comment="The axis is not coupled" Name="_LMCAXIS_POSMODE._Positioning"/>
    _NCPositioning,  //! <Type Comment="The axis is controlled by a NCController" Name="_LMCAXIS_POSMODE._NCPositioning"/>
    _StdSyncPositioning,  //! <Type Comment="The axis is coupled by calling one of this functions:&#13;&#10;CoupleDeltaPos, CoupleGearAbsolute or CoupleGearRelative" Name="_LMCAXIS_POSMODE._StdSyncPositioning"/>
    _UserSyncPositioning,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleUserPos" Name="_LMCAXIS_POSMODE._UserSyncPositioning"/>
    _CAMSyncPositioning,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleCurveTab" Name="_LMCAXIS_POSMODE._CAMSyncPositioning"/>
    _ProfileSyncPositioning,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleProfilePos" Name="_LMCAXIS_POSMODE._ProfileSyncPositioning"/>
    _SyncVelocity,  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleGearVelocity" Name="_LMCAXIS_POSMODE._SyncVelocity"/>
    _StartPolynomPositioning,  //! <Type Comment="The axis is coupling by calling the function: &#13;&#10;CoupleGearPolynom" Name="_LMCAXIS_POSMODE._StartPolynomPositioning"/>
    _SyncPolynomPositioning  //! <Type Comment="The axis is coupled by calling the function: &#13;&#10;CoupleGearPolynom" Name="_LMCAXIS_POSMODE._SyncPolynomPositioning"/>
  )$UDINT;
  _LMCAXIS_POWER_OFF_MODE :  //! <Type Comment="Parameter of the function: &quot;PowerOff&quot;" Name="_LMCAXIS_POWER_OFF_MODE"/>
  (
    LMCAXIS_IMMEDIATE_STOPP,  //! <Type Comment="&quot;PowerOff(IMMEDIATE_STOPP)&quot; stopps the controller by the moment&#13;&#10;" Name="_LMCAXIS_POWER_OFF_MODE.LMCAXIS_IMMEDIATE_STOPP"/>
    LMCAXIS_SMOOTH_STOPP  //! <Type Comment="&quot;PowerOff(SMOOTH_STOPP)&quot;    stopps the controller smoothly by a ramp" Name="_LMCAXIS_POWER_OFF_MODE.LMCAXIS_SMOOTH_STOPP"/>
  )$UDINT;
  _LMCAXIS_QUERY_POSITION_MODE :  //! <Type Comment="Parameter of the function &quot;InPosition&quot;" Name="_LMCAXIS_QUERY_POSITION_MODE"/>
  (
    LMCAXIS_NO_JERK_FILTER:=4294967294,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;&#13;&#10;Jerkfilter remains unconsidered" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_NO_JERK_FILTER"/>
    LMCAXIS_NO_POSITIONWINDOW:=4294967295,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;:&#13;&#10;Positionwindow remains unconsidered&#13;&#10;" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_NO_POSITIONWINDOW"/>
    LMCAXIS_POSITIONWINDOW_APP_UNITS,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;:&#13;&#10;Positionwindow in application units" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_POSITIONWINDOW_APP_UNITS"/>
    LMCAXIS_POSITIONWINDOW_INT_UNITS,  //! <Type Comment="Parameter of the function &quot;InPosition&quot;:&#13;&#10;Positionwindow in intern units" Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_POSITIONWINDOW_INT_UNITS"/>
    LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS:=2,  //! <Type Comment="Checks if the distance between the set position and the target position is within the position window.&#13;&#10;The position window is given in application units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_SETPOS_IN_WINDOW_APP_UNITS"/>
    LMCAXIS_SETPOS_IN_WINDOW_INT_UNITS:=3,  //! <Type Comment="Checks if the distance between the set position and the target position is within the position window.&#13;&#10;The position window is given in internal units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_SETPOS_IN_WINDOW_INT_UNITS"/>
    LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS:=4,  //! <Type Comment="Checks if the distance between the actual position and the target position is within the position window.&#13;&#10;The position window is given in application units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_ACTPOS_IN_WINDOW_APP_UNITS"/>
    LMCAXIS_ACTPOS_IN_WINDOW_INT_UNITS:=5  //! <Type Comment="Checks if the distance between the actual position and the target position is within the position window.&#13;&#10;The position window is given in internal units." Name="_LMCAXIS_QUERY_POSITION_MODE.LMCAXIS_ACTPOS_IN_WINDOW_INT_UNITS"/>
  )$DINT;
  _LMCAXIS_READPARAMETER :  //! <Type Comment="Parameter-ID" Name="_LMCAXIS_READPARAMETER"/>
  (
    LMCAXIS_PAR_RD_V_MAX,  //! <Type Comment="Read maximum axis velocity [Application units/s] or [Internal units/s] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_V_MAX"/>
    LMCAXIS_PAR_RD_A_MAX,  //! <Type Comment="Read maximum axis acceleration / deceleration [Application units/s²] or [Internal units/s²] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_A_MAX"/>
    LMCAXIS_PAR_RD_EXTUNITS,  //! <Type Comment="Read value of server ExUnit [Increments]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_EXTUNITS"/>
    LMCAXIS_PAR_RD_INTUNITS,  //! <Type Comment="Read value of server IntUnit" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_INTUNITS"/>
    LMCAXIS_PAR_RD_RESFACT,  //! <Type Comment="Read the value of server Resolution" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_RESFACT"/>
    LMCAXIS_PAR_RD_SEMAPHOR,  //! <Type Comment="Read the value of the command semaphore" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_SEMAPHOR"/>
    LMCAXIS_PAR_RD_REFPOS,  //! <Type Comment="Read the reference position [Application units] or [Internal units] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_REFPOS"/>
    LMCAXIS_PAR_RD_MODULO,  //! <Type Comment="Read the value of the server Modulo [Application units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MODULO"/>
    LMCAXIS_PAR_RD_MASTERLOCK_11,  //! <Type Comment="Read MasterLock, 0 = not locked to master, 1 = synchronized with master" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MASTERLOCK_11"/>
    LMCAXIS_PAR_RD_MASTERLOCK_12,  //! <Type Comment="If the axis is not coupled, 0 is returned. Otherwise the value of MasterLock is returned (see parameter LMCAXIS_PAR_RD_MASTERLOCK_11)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MASTERLOCK_12"/>
    LMCAXIS_PAR_RD_MAX_MODULO,  //! <Type Comment="Read the internal overflow position [internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MAX_MODULO"/>
    LMCAXIS_PAR_RD_BINOFFSET,  //! <Type Comment="Read the binary position offset [external units] ([encoder increments])" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_BINOFFSET"/>
    LMCAXIS_PAR_RD_POSMODE,  //! <Type Comment="Read the type of the currently active positioning (see server PosMode)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_POSMODE"/>
    LMCAXIS_PAR_RD_CONTROLLERTYPE,  //! <Type Comment="Read which type of controller is connected to client LMCController" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_CONTROLLERTYPE"/>
    LMCAXIS_PAR_RD_TIMEBASE,  //! <Type Comment="Read the RtWork() cycle time&#13;&#10;in [microseconds] if the most significant bit is set&#13;&#10;or in [milliseconds] otherwise" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_TIMEBASE"/>
    LMCAXIS_PAR_RD_CONTROLLERPAR,  //! <Type Comment="Read a parameter value from the controller connected to client LMCController.&#13;&#10;If no controller is connected, then -1 is returned.&#13;&#10;Mode contains the number of the controller parameter that should be read." Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_CONTROLLERPAR"/>
    LMCAXIS_PAR_RD_J_MAX,  //! <Type Comment="Read the maximum jerk [Application units / s² / ms] = [Application units / s^3 * 1000]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_J_MAX"/>
    LMCAXIS_PAR_RD_MOVETYPE,  //! <Type Comment="Read moving profile of the axis&#13;&#10;====================&#13;&#10; 0 = _RAMP_PROFILE - axis moves without jerk limitation&#13;&#10; 1 = _SCURVE_PROFILE - axis moves with jerk filter (jerk limitation through position filter)&#13;&#10;10 = _JERK_PROFILE - axis moves with jerk limitation (calculated limitation)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MOVETYPE"/>
    LMCAXIS_PAR_RD_T_JERK,  //! <Type Comment="Read the jerk time (server Tjerk) [ms].&#13;&#10;This is the time for the acceleration to attain its maximum value." Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_T_JERK"/>
    LMCAXIS_PAR_RD_HARDLOCK,  //! <Type Comment="Read the HardLock flag.&#13;&#10;0: the slave always adheres to its speed, acceleration and deceleration limits&#13;&#10;1: when the slave is synchronized with the master, it may exceed its acceleration and deceleration limits but not the speed limit" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_HARDLOCK"/>
    LMCAXIS_PAR_RD_SHAPE_SPLINE,  //! <Type Comment="Parameter of the function &quot;ReadParameter&quot;:&#13;&#10;Read spline-configuration (See function &quot;ReadParameter&quot;)" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_SHAPE_SPLINE"/>
    LMCAXIS_PAR_RD_COUPLE_ERROR,  //! <Type Comment="Parameter of the function &quot;ReadParameter&quot;:&#13;&#10;Read the last Couping-Error that occured by calling &quot;CoupleGearPolynom&quot;&#13;&#10;" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_COUPLE_ERROR"/>
    LMCAXIS_PAR_RD_MOVEDIRECTION,  //! <Type Comment="Read direction of movement for the axis&#13;&#10;0 = AXIS_MOVE_ANY_WAY axis may move in any direction&#13;&#10;1 = AXIS_MOVE_NEG_DIR axis may only move in the negative direction&#13;&#10;3 = AXIS_MOVE_POS_DIR axis may only move in the positive direction&#13;&#10;2 = AXIS_MOVE_SHORTEST_WAY axis takes the shortest way to the destination" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MOVEDIRECTION"/>
    LMCAXIS_PAR_RD_SWLIMWINDOW,  //! <Type Comment="Read Endpostion-Tolerance-Window [application units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_SWLIMWINDOW"/>
    LMCAXIS_PAR_RD_MASTER_DELAY,  //! <Type Comment="Read the max Delay of the MasterPointer [ticks]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MASTER_DELAY"/>
    LMCAXIS_PAR_RD_DEC,  //! <Type Comment="Read deceleration [Application units/s²] or [Internal units/tick²] depending on mode" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_DEC"/>
    LMCAXIS_PAR_RD_DYN_SW_LIMIT,  //! <Type Comment="Is a min/max dynamic software limit monitored?" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_DYN_SW_LIMIT"/>
    LMCAXIS_PAR_RD_MAX_OVERRIDE,  //! <Type Comment="Reads the maximal allowed value for the override&#13;&#10;&#13;&#10;Mode=0: absolute max override value&#13;&#10;Mode=1: max override value in a tenth of percent" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MAX_OVERRIDE"/>
    LMCAXIS_PAR_RD_NORM_OVERRIDE,  //! <Type Comment="Reads the override value, which represents 100%." Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_NORM_OVERRIDE"/>
    LMCAXIS_PAR_RD_OVERRIDE,  //! <Type Comment="Reads the actual override value.&#13;&#10;&#13;&#10;Mode=0: absolute override value&#13;&#10;Mode=1: override value in a tenth of percent" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_OVERRIDE"/>
    LMCAXIS_PAR_RD_DELAYEDMASTERLOCK,  //! <Type Comment="Read DelayedMasterLock, 0 = not locked to master, 1 = synchronized with master" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_DELAYEDMASTERLOCK"/>
    LMCAXIS_PAR_RD_OVERFLOW_POS,  //! <Type Comment="read the internal position overflow limit [Internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_OVERFLOW_POS"/>
    LMCAXIS_PAR_RD_MIN_POSITION,  //! <Type Comment="read the minimum internal end position  [Internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MIN_POSITION"/>
    LMCAXIS_PAR_RD_MAX_POSITION,  //! <Type Comment="read the maximum internal end position [Internal units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_MAX_POSITION"/>
    LMCAXIS_PAR_RD_ZPULSE_DIST,  //! <Type Comment="read the distance from refswitch to zpulse [application units]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_ZPULSE_DIST"/>
    LMCAXIS_PAR_RD_ALLOWED_ACC_JUMP,  //! <Type Comment="Read the maximal allowed accel jump for the slave. [application units / sec^2 / tick]" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_ALLOWED_ACC_JUMP"/>
    LMCAXIS_PAR_RD_SIMULATE_MODE,
    LMCAXIS_PAR_RD_ERROR_CONFIG,  //! <Type Comment="Set user defined error configuration&#13;&#10;" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_ERROR_CONFIG"/>
    LMCAXIS_PAR_RD_AEMERGENCY,  //! <Type Comment="Read emergency deccelarition. If Emergency &lt;&gt; 0 [Application units / s²]&#13;&#10;if AEmergency is smaller AMax, the deceleration is AMax" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_AEMERGENCY"/>
    LMCAXIS_PAR_RD_ABS_ENCODER,  //! <Type Comment="This parameter is used for the activation (AbsEncoder = 1) / deactivation (AbsEncoder = 0) of reading encoder-values from a motor" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_ABS_ENCODER"/>
    LMCAXIS_PAR_RD_AXISERROR  //! <Type Comment="Read error flags of the Axis&#13;&#10;" Name="_LMCAXIS_READPARAMETER.LMCAXIS_PAR_RD_AXISERROR"/>
  )$UDINT;
  _LMCAXIS_READPOS :  //! <Type Comment="Type of the position that should be read" Name="_LMCAXIS_READPOS"/>
  (
    LMCAXIS_SETPOS_APPUNIT,  //! <Type Comment="Set position with or without jerk limitation (depending on coupler mode), bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_APPUNIT"/>
    LMCAXIS_SETPOS_INTUNIT,  //! <Type Comment="Set position with or without jerk limitation (depending on coupler mode), bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT"/>
    LMCAXIS_SETPOS_INTUNIT_WO_MOD,  //! <Type Comment="Set position without jerk limitation, NOT bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_DESTPOS_INTUNIT,  //! <Type Comment="Actual target position [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_DESTPOS_INTUNIT"/>
    LMCAXIS_SETPOS_INTUNIT_JERK_WO_MOD,  //! <Type Comment="Set position with or without jerk limitation (depending on coupler mode), NOT bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT_JERK_WO_MOD"/>
    LMCAXIS_SETPOS_INTUNIT_JERK,  //! <Type Comment="Set position with jerk limitation, bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_INTUNIT_JERK"/>
    LMCAXIS_SETPOS_APPUNIT_JERK,  //! <Type Comment="Set position with jerk limitation, bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_APPUNIT_JERK"/>
    LMCAXIS_SETPOS_APPUNIT_SPEC1,  //! <Type Comment="Set position with or without jerk limitation (see parameter LMCAXIS_PAR_SET_JERK_LIMITATION), bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_SETPOS_APPUNIT_SPEC1"/>
    LMCAXIS_ACTPOS_APPUNIT,  //! <Type Comment="Actual position, bounded by Modulo [Application units]" Name="_LMCAXIS_READPOS.LMCAXIS_ACTPOS_APPUNIT"/>
    LMCAXIS_ACTPOS_INTUNIT,  //! <Type Comment="Actual position, bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_ACTPOS_INTUNIT"/>
    LMCAXIS_ACTPOS_INTUNIT_WO_MOD,  //! <Type Comment="Actual position, NOT bounded by Modulo [Internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_ACTPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_BRAKEPOS_APPUNIT,  //! <Type Comment="the position, where the axis can stop, if it starts braking immediately.[application units]" Name="_LMCAXIS_READPOS.LMCAXIS_BRAKEPOS_APPUNIT"/>
    LMCAXIS_MASTERPOS_INTUNIT,  //! <Type Comment="current position of the master axis [internal units]" Name="_LMCAXIS_READPOS.LMCAXIS_MASTERPOS_INTUNIT"/>
    LMCAXIS_XW_TO_DESTPOS_INTUNIT  //! <Type Comment="internal mode for _LMCProfile." Name="_LMCAXIS_READPOS.LMCAXIS_XW_TO_DESTPOS_INTUNIT"/>
  )$UDINT;
  _LMCAXIS_READSWENDPOS :  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;" Name="_LMCAXIS_READSWENDPOS"/>
  (
    LMCAXIS_RD_SWMAX_APPUNIT,  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the maximal software-endposition in application units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMAX_APPUNIT"/>
    LMCAXIS_RD_SWMIN_APPUNIT,  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the minimal software-endposition in application units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMIN_APPUNIT"/>
    LMCAXIS_RD_SWMAX_INTUNIT,  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the maximal software-endposition in intern units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMAX_INTUNIT"/>
    LMCAXIS_RD_SWMIN_INTUNIT  //! <Type Comment="Parameter of the function &quot;ReadSWEndPos&quot;:&#13;&#10;Read the minimal software-endposition in intern units" Name="_LMCAXIS_READSWENDPOS.LMCAXIS_RD_SWMIN_INTUNIT"/>
  )$UDINT;
  _LMCAXIS_READVELOCITY :  //! <Type Comment="Type of the axis velocity that should be read" Name="_LMCAXIS_READVELOCITY"/>
  (
    LMCAXIS_SETVEL_APPUNIT_SEC,  //! <Type Comment="Set velocity without jerk limitation [Application units/s]&#13;&#10;" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_APPUNIT_SEC"/>
    LMCAXIS_SETVEL_INTUNIT_SEC,  //! <Type Comment="Set velocity without jerk limitation [Internal units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_SEC"/>
    LMCAXIS_SETVEL_APPUNIT_NCMODE,  //! <Type Comment="Set velocity + start velocity in NC mode [Application units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_APPUNIT_NCMODE"/>
    LMCAXIS_SETVEL_INTUNIT_NCMODE,  //! <Type Comment="Set velocity + start velocity in NC mode [Internal units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_NCMODE"/>
    LMCAXIS_ACTVEL_APPUNIT_MS,  //! <Type Comment="Unfiltered actual velocity [Application units/ms]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_APPUNIT_MS"/>
    LMCAXIS_ACTVEL_INTUNIT_MS,  //! <Type Comment="Unfiltered actual velocity [Internal units/ms]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_INTUNIT_MS"/>
    LMCAXIS_SETVEL_INTUNIT_TICK_JERK,  //! <Type Comment="Set velocity with jerk limitation [Internal units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_TICK_JERK"/>
    LMCAXIS_SETVEL_APPUNIT_SEC_JERK,  //! <Type Comment="Set velocity with jerk limitation [Application units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_APPUNIT_SEC_JERK"/>
    LMCAXIS_SETVEL_INTUNIT_TICK,  //! <Type Comment="Set velocity without jerk limitation [Internal units/tick]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_SETVEL_INTUNIT_TICK"/>
    LMCAXIS_ACTVEL_APPUNIT_SEC,  //! <Type Comment="Unfiltered actual velocity [Application units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_APPUNIT_SEC"/>
    LMCAXIS_ACTVEL_INTUNIT_SEC,  //! <Type Comment="Unfiltered actual velocity [Internal units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_INTUNIT_SEC"/>
    LMCAXIS_ACTVEL_APPUNIT_SEC_FILT,  //! <Type Comment="Filtered actual velocity [Application units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_APPUNIT_SEC_FILT"/>
    LMCAXIS_ACTVEL_INTUNIT_SEC_FILT,  //! <Type Comment="Filtered actual velocity [Internal units/s]" Name="_LMCAXIS_READVELOCITY.LMCAXIS_ACTVEL_INTUNIT_SEC_FILT"/>
    LMCAXIS_CMDVEL_APPUNIT  //! <Type Comment="Maximal " Name="_LMCAXIS_READVELOCITY.LMCAXIS_CMDVEL_APPUNIT"/>
  )$UDINT;
#pragma pack(push, 1)
  _LMCAXIS_REFDATA : STRUCT  //! <Type Comment="Parameters of the functions: &#13;&#10;&quot;MoveReference&quot;, &quot;ReferenceAxis&quot; and &quot;_LMCAxisRef::control&quot;" Name="_LMCAXIS_REFDATA"/>
    Status : iprStates;
    Velocity : DINT;  //! <Type Comment="Velocity during the refernce run" Name="_LMCAXIS_REFDATA.Velocity"/>
    Acc : DINT;  //! <Type Comment="Acceleration during the refernce run" Name="_LMCAXIS_REFDATA.Acc"/>
    vSetRef1 : DINT;  //! <Type Comment="Velocity during the movement to the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef1"/>
    vSetRef2 : DINT;  //! <Type Comment="Velocity during the movement away from the refernce-switch" Name="_LMCAXIS_REFDATA.vSetRef2"/>
    PosWindow : DINT;  //! <Type Comment="Position window for the Z-Impuls" Name="_LMCAXIS_REFDATA.PosWindow"/>
    LatchPosRef : DINT;  //! <Type Comment="External position used in mode &quot;RefLatchPos&quot;" Name="_LMCAXIS_REFDATA.LatchPosRef"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCAXIS_REFMODE : BDINT  //! <Type Comment="Reference mode" Name="_LMCAXIS_REFMODE"/>
  [
    1 NoZImpulse,  //! <Type Comment="0 --&gt; Referencing with referencing impulse&#13;&#10;1 --&gt; Referencing without referencing impulse" Name="_LMCAXIS_REFMODE.NoZImpulse"/>
    2 NoEndSwitch,  //! <Type Comment="0 --&gt; Referencing with endswitches&#13;&#10;1 --&gt; Referencing without endswitches" Name="_LMCAXIS_REFMODE.NoEndSwitch"/>
    3 RefDirection,  //! <Type Comment="1 --&gt; Referencing on positive direction&#13;&#10;0 --&gt; Referencing on negative direction" Name="_LMCAXIS_REFMODE.RefDirection"/>
    4 NoTurnOnSwitch,  //! <Type Comment="0 --&gt; Reverse direction at the reference switch&#13;&#10;1 --&gt; Do not reverse direction at the reference switch" Name="_LMCAXIS_REFMODE.NoTurnOnSwitch"/>
    5 ESEqualRef,  //! <Type Comment="1 --&gt; Hardware end switch is used as reference switch" Name="_LMCAXIS_REFMODE.ESEqualRef"/>
    6 NoSet,  //! <Type Comment="0 --&gt; The transmitted position is the reference position&#13;&#10;1 --&gt; The actual position is the reference position" Name="_LMCAXIS_REFMODE.NoSet"/>
    7 RefLatchPos,  //! <Type Comment="1 --&gt; Read reference position from client cLatchPos. If value changes, do a MoveAbsolute(cLatchPos) and set cLatchPos as current position." Name="_LMCAXIS_REFMODE.RefLatchPos"/>
    8 RefFirstEdge,  //! <Type Comment="1 --&gt; Go back to first edge of ref.switch or end switch" Name="_LMCAXIS_REFMODE.RefFirstEdge"/>
  ];
  _LMCAXIS_SETPARAMETER :  //! <Type Comment="Parameter-ID" Name="_LMCAXIS_SETPARAMETER"/>
  (
    LMCAXIS_PAR_SET_COUPLING_MODE,  //! <Type Comment="Changes the coupling mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLING_MODE"/>
    LMCAXIS_PAR_SET_DESTINATION,  //! <Type Comment="Sets new target position&#13;&#10;mode  = 0: [Application units]&#13;&#10;mode &lt;&gt; 0: [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_DESTINATION"/>
    LMCAXIS_PAR_SET_OVERRIDE,  //! <Type Comment="Set new override value [0.1%]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_OVERRIDE"/>
    LMCAXIS_PAR_SET_LOGMODE,  //! <Type Comment="Changes data logger settings" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_LOGMODE"/>
    LMCAXIS_PAR_RESET_REF_STATE,  //! <Type Comment="The reference status is reset" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_RESET_REF_STATE"/>
    LMCAXIS_PAR_SET_CHANGE_SW_LIMITS,  //! <Type Comment="Change how the software limits check works" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_CHANGE_SW_LIMITS"/>
    LMCAXIS_PAR_SET_JERK_LIMITATION,  //! <Type Comment="Activates / deactivates jerk filter" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_JERK_LIMITATION"/>
    LMCAXIS_PAR_SET_SHIFT_BREAKPOS,  //! <Type Comment="Brake point shift for NC mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SHIFT_BREAKPOS"/>
    LMCAXIS_PAR_SET_OVERFLOW_POS,  //! <Type Comment="Sets a new internal position overflow limit [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_OVERFLOW_POS"/>
    LMCAXIS_PAR_SET_MIN_POSITION,  //! <Type Comment="Sets a new minimum internal end position  [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MIN_POSITION"/>
    LMCAXIS_PAR_SET_MAX_POSITION,  //! <Type Comment="Sets a new maximum internal end position [Internal units]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MAX_POSITION"/>
    LMCAXIS_PAR_SET_HARDLOCK,  //! <Type Comment="Change monitoring slave acceleration, deceleration, and jerk." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_HARDLOCK"/>
    LMCAXIS_PAR_SET_SWLIM_STANDSTILL,  //! <Type Comment="Activate/deactivate the SW end position monitor during standstill" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SWLIM_STANDSTILL"/>
    LMCAXIS_PAR_SET_SWLIM_DIR_CHANGE,  //! <Type Comment="Enable/disable SW end position monitor with direction reversal" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SWLIM_DIR_CHANGE"/>
    LMCAXIS_PAR_SET_SWLIM_MOVING,  //! <Type Comment="Enable/disable the set position monitor during movement toward the SW end positions" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SWLIM_MOVING"/>
    LMCAXIS_PAR_SET_INIT_JERK_FILTER,  //! <Type Comment="Initialize the jerk filter with ControllerOn" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_INIT_JERK_FILTER"/>
    LMCAXIS_PAR_SET_BINOFFSET,  //! <Type Comment="Set BinOffset [Increments] to a new value and update the position" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_BINOFFSET"/>
    LMCAXIS_PAR_SET_VJUMP,  //! <Type Comment="Enable/disable a jump in speed" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_VJUMP"/>
    LMCAXIS_PAR_SET_SW_LIMIT_FLAGS,  //! <Type Comment="Defines when AxisError.SwMinError and SwMaxError is set" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SW_LIMIT_FLAGS"/>
    LMCAXIS_PAR_SET_SW_LIM_WINDOW,  //! <Type Comment="Set tolerance window to set the SW end position monitor to idle mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SW_LIM_WINDOW"/>
    LMCAXIS_PAR_SET_MOVE_DIR,  //! <Type Comment="Set direction of movement for the axis, if mode = 1 the MoveDirection change possibility is locked so that a following PowerOn() call &quot;mode&quot; will be ignored." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MOVE_DIR"/>
    LMCAXIS_PAR_SET_TIMEBASE,  //! <Type Comment="Set RtWork cycle time of the axis and make it callable from outside the class" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_TIMEBASE"/>
    LMCAXIS_PAR_SET_CONTROLLERPAR,  //! <Type Comment="Set the parameters of the connected controller" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_CONTROLLERPAR"/>
    LMCAXIS_PAR_SET_ACTVELFILTER,  //! <Type Comment="Set whether the server ActVelocity displays the filtered or unfiltered actual velocity" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_ACTVELFILTER"/>
    LMCAXIS_PAR_SET_SHAPE_SPLINE,  //! <Type Comment="Modify the shapes of the splines used in CoupleGearPolynom" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SHAPE_SPLINE"/>
    LMCAXIS_PAR_SET_NO_OVERFLOWERROR,  //! <Type Comment="Suppress OverflowError when a slave axis cannot follow its master axis" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_NO_OVERFLOWERROR"/>
    LMCAXIS_PAR_SET_MASTERPOS_OLD,  //! <Type Comment="For internal use only." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MASTERPOS_OLD"/>
    LMCAXIS_PAR_SET_MASTER_DELAY,  //! <Type Comment="Set the max Delay of the MasterPointer &#13;&#10;default = 0&#13;&#10;max = 6" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MASTER_DELAY"/>
    LMCAXIS_PAR_SET_MAXMODULO,  //! <Type Comment="Set the MaxModule value&#13;&#10;default = 16#06000000" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MAXMODULO"/>
    LMCAXIS_PAR_SET_MAX_OVERRIDE:=29,  //! <Type Comment="Set the maximal allowed Override value." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MAX_OVERRIDE"/>
    LMCAXIS_PAR_SET_NORM_OVERRIDE,  //! <Type Comment="Norm. override value. Default value = 1000" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_NORM_OVERRIDE"/>
    LMCAXIS_PAR_SET_MASTERLOCK_DELAYCYCLES,  //! <Type Comment="set the amount of cycles for the delayed MasterLock&#13;&#10;default = 0" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MASTERLOCK_DELAYCYCLES"/>
    LMCAXIS_PAR_SET_ALLOWED_ACC_JUMP,  //! <Type Comment="Set the maximal allowed accel jump for the slave. [application units / sec^2 / tick]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_ALLOWED_ACC_JUMP"/>
    LMCAXIS_PAR_SET_SIMULATE_MODE,  //! <Type Comment="Value=1: Set the simulation mode&#13;&#10;Value=0: Disable the simulation mode" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_SIMULATE_MODE"/>
    LMCAXIS_PAR_SET_DEACTIVATE_CALC_BRAKEPOS,  //! <Type Comment="1: Deactivates the computation of the master brake position. Software limit violations of the coupled axis may not be averted.&#13;&#10;0: Enables computation of the master brake position. Upcoming software limit violations may be detected and averted." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_DEACTIVATE_CALC_BRAKEPOS"/>
    LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR,  //! <Type Comment="Defines the reaction of this axis in case of an error of a coupled slave axis&#13;&#10;0: ignores the error. &#13;&#10;1: stops the axis with maximal deceleration, but does not disable it (like StopMove())&#13;&#10;2: (DEFAULT) stops with maximal deceleration and disables the axis (like PowerOff(LMCAXIS_SMOOTH_STOP))&#13;&#10;3: disables the axis immediately (like PowerOff(LMCAXIS_IMMEDIATE_STOP))&#13;&#10;&#13;&#10;" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLE_SLAVE_ERROR"/>
    LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR,  //! <Type Comment="Defines the reaction of this axis in case of an error of its MASTER axis or some axis coupled with the master.&#13;&#10;0: ignores the error. &#13;&#10;1: stops the axis with maximal deceleration, but does not disable it (like StopMove())&#13;&#10;2: (DEFAULT) stops with maximal deceleration and disables the axis (like PowerOff(LMCAXIS_SMOOTH_STOP))&#13;&#10;3: disables the axis immediately (like PowerOff(LMCAXIS_IMMEDIATE_STOP))&#13;&#10;&#13;&#10;" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLE_MASTER_ERROR"/>
    LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG,  //! <Type Comment="Extended configuration for couple monitoring&#13;&#10;Bit 1: ReportErrorToMaster&#13;&#10;Bit 2: ReportSlaveErrorToMaster&#13;&#10;Bit 3: ReportMasterErrorToSlave&#13;&#10;Bit 4: ReportSlaveErrorToSlave&#13;&#10;Bit 5: SwLimitMonitoringForMyMaster&#13;&#10;Bit 6: PowerOffMonitoringForMySlave" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_COUPLE_MONITOR_CONFIG"/>
    LMCAXIS_PAR_SET_DELAYEDMASTERLOCK_WINDOW,  //! <Type Comment="alternative mode for AxisStatus.DelayedMasterLock for coupled axes:&#13;&#10;If the master axis is within a position and velocity window, the DelayedMasterLock bit will be set.&#13;&#10;&#13;&#10;input parameter &quot;value&quot; defines a position window [application units]&#13;&#10;input parameter &quot;mode&quot; defines a velocity window [application units / sec]" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_DELAYEDMASTERLOCK_WINDOW"/>
    LMCAXIS_PAR_SET_MASTERVEL_OLD,  //! <Type Comment="For internal use only." Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_MASTERVEL_OLD"/>
    LMCAXIS_PAR_SET_POWERON_TIMEOUT  //! <Type Comment="After a PowerOn(), this is the maximum timeout&#13;&#10;for the hardware to be powered on. For axis with&#13;&#10;commutation-search this can take some time.&#13;&#10;90000ms (default)" Name="_LMCAXIS_SETPARAMETER.LMCAXIS_PAR_SET_POWERON_TIMEOUT"/>
  )$UDINT;
  _LMCAXIS_SETPOSITION :  //! <Type Comment="Type of the position that should be set" Name="_LMCAXIS_SETPOSITION"/>
  (
    LMCAXIS_SET_ACTPOS_APPUNIT,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot;, &quot;Modulo&quot; and the software limits. (New position = position * Resolution)" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_APPUNIT"/>
    LMCAXIS_SET_SETPOS_APPUNIT,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Resolution&quot; ,&quot;Modulo&quot; and the software limits. (New position = position * Resolution)&#13;&#10;" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_APPUNIT"/>
    LMCAXIS_SET_ACTPOS_INTUNIT,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Modulo&quot; and the software limits. (New position = position)" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_INTUNIT"/>
    LMCAXIS_SET_SETPOS_INTUNIT,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Modulo&quot; and the software limits. (New position = position)&#13;&#10;" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT"/>
    LMCAXIS_SET_SETPOS_INTUNIT_SPEC,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Modulo&quot; and the software limits. &#13;&#10;With this variation, the MasterPosition is also reset. (New position = position)" Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT_SPEC"/>
    LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD,  //! <Type Comment="Sets the external position (actual position value) to the specified position.&#13;&#10;This value is set based on the software limits. (New position = position)&#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on the software limits.(New position = position)&#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD"/>
    LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD_SW,  //! <Type Comment="Sets the external position (actual position value) to the specified position (New position = position).&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_INTUNIT_WO_MOD_SW"/>
    LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD_SW,  //! <Type Comment="Sets the internal position (set position value) to the specified position (New position = position).&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_INTUNIT_WO_MOD_SW"/>
    LMCAXIS_SET_ACTPOS_APPUNIT_DEST,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot;, &quot;Modulo&quot; and the software limits. (New position = position * Resolution)&#13;&#10;Sets also the destination to the specified position." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_APPUNIT_DEST"/>
    LMCAXIS_SET_SETPOS_APPUNIT_DEST,  //! <Type Comment="Sets the internal position (set position value) to the given position. &#13;&#10;This value is set based on &quot;Resolution&quot; ,&quot;Modulo&quot; and the software limits. (New position = position * Resolution)&#13;&#10;Sets also the destination to the specified position." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_APPUNIT_DEST"/>
    LMCAXIS_SET_ACTPOS_APPUNIT_WO_MOD_SW,  //! <Type Comment="Sets the external position (actual position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot; and &quot;Modulo&quot;.(New position = position * Resolution)&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_ACTPOS_APPUNIT_WO_MOD_SW"/>
    LMCAXIS_SET_SETPOS_APPUNIT_WO_MOD_SW  //! <Type Comment="Sets the internal position (set position value) to the specified position. &#13;&#10;This value is set based on &quot;Resolution&quot; and &quot;Modulo&quot;.(New position = position * Resolution)&#13;&#10;Here, no difference is made regarding modulo axes and the software limits are not checked." Name="_LMCAXIS_SETPOSITION.LMCAXIS_SET_SETPOS_APPUNIT_WO_MOD_SW"/>
  )$UDINT;
  _LMCAXIS_SETSERVER :  //! <Type Comment="Server-ID" Name="_LMCAXIS_SETSERVER"/>
  (
    LMCAXIS_SET_EXUNIT,  //! <Type Comment="Set new value for server ExUnit [Increments]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_EXUNIT"/>
    LMCAXIS_SET_INTUNIT,  //! <Type Comment="Set new value for server IntUnit [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_INTUNIT"/>
    LMCAXIS_SET_VMAX,  //! <Type Comment="Set new value for server VMax [Application units/s]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_VMAX"/>
    LMCAXIS_SET_AMAX,  //! <Type Comment="Set new value for server AMax [Application units/s²]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_AMAX"/>
    LMCAXIS_SET_SWMINPOS,  //! <Type Comment="Set new value for server SWMinPos [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_SWMINPOS"/>
    LMCAXIS_SET_SWMAXPOS,  //! <Type Comment="Set new value for server SWMaxPos [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_SWMAXPOS"/>
    LMCAXIS_SET_MODULO,  //! <Type Comment="Set new value for server Modulo [Application units]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_MODULO"/>
    LMCAXIS_SET_T_JERK,  //! <Type Comment="Set new value for server Tjerk [ms]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_T_JERK"/>
    LMCAXIS_SET_MOVETYPE,  //! <Type Comment="Set new value for server MoveType" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_MOVETYPE"/>
    LMCAXIS_SET_AEMERGENCY,  //! <Type Comment="Set new value for the server AEmergency [application units / sec²]" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_AEMERGENCY"/>
    LMCAXIS_SET_JMAX,  //! <Type Comment="Set a new value for server JMax [ApplicationUnits/sec²/ms]&#13;&#10;for MoveType = _JERK_PROFILE only." Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_JMAX"/>
    LMCAXIS_SET_ERROR_CONFIG,  //! <Type Comment="Set user defined error configuration&#13;&#10;" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_ERROR_CONFIG"/>
    LMCAXIS_SET_ABS_ENCODER  //! <Type Comment="This parameter is used for the activation (AbsEncoder = 1) / deactivation (AbsEncoder = 0) of reading encoder-values from a motor" Name="_LMCAXIS_SETSERVER.LMCAXIS_SET_ABS_ENCODER"/>
  )$UDINT;
  _LMCAXIS_SETSWENDPOS :  //! <Type Comment="LMCAXIS_SET_SWMAX_APPUNIT&#13;&#10;New SW max end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_APPUNIT&#13;&#10;New SW min end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT&#13;&#10;New SW max end position = Position&#13;&#10;This value is set based on Modulo.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT&#13;&#10;New SW min end position = Position &#13;&#10;This value is set based on Modulo.(new SW min end position = Position)&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD&#13;&#10;New SW Max end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes.&#13;&#10;&#13;&#10;LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD&#13;&#10;New SW min end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS"/>
  (
    LMCAXIS_SET_SWMAX_APPUNIT,  //! <Type Comment="New SW max end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMAX_APPUNIT"/>
    LMCAXIS_SET_SWMIN_APPUNIT,  //! <Type Comment="New SW min end position = Position * Resolution&#13;&#10;This value is set based on Resolution and Modulo." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMIN_APPUNIT"/>
    LMCAXIS_SET_SWMAX_INTUNIT,  //! <Type Comment="New SW max end position = Position&#13;&#10;This value is set based on Modulo." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMAX_INTUNIT"/>
    LMCAXIS_SET_SWMIN_INTUNIT,  //! <Type Comment="New SW min end position = Position &#13;&#10;This value is set based on Modulo.(new SW min end position = Position)" Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMIN_INTUNIT"/>
    LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD,  //! <Type Comment="New SW Max end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMAX_INTUNIT_WO_MOD"/>
    LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD  //! <Type Comment="New SW min end position = Position. &#13;&#10;Here, no difference is made regarding modulo axes." Name="_LMCAXIS_SETSWENDPOS.LMCAXIS_SET_SWMIN_INTUNIT_WO_MOD"/>
  )$UDINT;
  _LMCAXIS_STATUS : BDINT  //! <Type Comment="Status-Bits of the axis" Name="_LMCAXIS_STATUS"/>
  [
    1 PowerOn,  //! <Type Comment="Set if axis is activated" Name="_LMCAXIS_STATUS.PowerOn"/>
    2 IsReferenced,  //! <Type Comment="Set if axis is referenced" Name="_LMCAXIS_STATUS.IsReferenced"/>
    3 InPosition,  //! <Type Comment="Set if axis is in correct position" Name="_LMCAXIS_STATUS.InPosition"/>
    4 FiltRdy,  //! <Type Comment="Set if axis is in correct position an the jerkfilter is ready" Name="_LMCAXIS_STATUS.FiltRdy"/>
    5 Decell,  //! <Type Comment="Set if axis is braking" Name="_LMCAXIS_STATUS.Decell"/>
    6 PosLimActive,  //! <Type Comment="Set if axis has reached one of its endpositions" Name="_LMCAXIS_STATUS.PosLimActive"/>
    7 SetFlg,  //! <Type Comment="Set by calling one of the functions: SetPosition or ReferenceAxis&#13;&#10;Reset if the axis is activated" Name="_LMCAXIS_STATUS.SetFlg"/>
    8 EnLesFlg,  //! <Type Comment="Set if the axis moves endless / infinitely" Name="_LMCAXIS_STATUS.EnLesFlg"/>
    9 DirFlg,  //! <Type Comment="Set if the axis moves in negative direction - speed is negative" Name="_LMCAXIS_STATUS.DirFlg"/>
    10 EmergStop,  //! <Type Comment="Set if the axis stops because an error occured or the axis is deactivated" Name="_LMCAXIS_STATUS.EmergStop"/>
    11 Overflow,  //! <Type Comment="Set if a position-overflow occured" Name="_LMCAXIS_STATUS.Overflow"/>
    12 MasterLock,  //! <Type Comment="Set if the slave-axis is coupled onto a master-axis" Name="_LMCAXIS_STATUS.MasterLock"/>
    13 DirLock,  //! <Type Comment="the direction is locked&#13;&#10;(because of HWMin, HWMax&#13;&#10; or by PowerOnMode)" Name="_LMCAXIS_STATUS.DirLock"/>
    14 DynSwLimit,
    15 ActDirFlg,  //! <Type Comment="Set if the speed of the axis is negative" Name="_LMCAXIS_STATUS.ActDirFlg"/>
    16 HandFlg,  //! <Type Comment="Set if one of the functions: PowerOff or MoveHand is called" Name="_LMCAXIS_STATUS.HandFlg"/>
    17 ModuloFlg,  //! <Type Comment="Set if the axis is defined as a modulo-axis" Name="_LMCAXIS_STATUS.ModuloFlg"/>
    18 NCMotion,  //! <Type Comment="Set if the axis is in NC postion mode: &quot;_NCPositioning&quot;" Name="_LMCAXIS_STATUS.NCMotion"/>
    19 NoActPosMeth,  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoActPosMeth"/>
    20 NoControlMeth,  //! <Type Comment="Set if axis is in &quot;SimulateMode&quot; of the client &quot;LMCController&quot; is not connected" Name="_LMCAXIS_STATUS.NoControlMeth"/>
    21 NoRefMeth,  //! <Type Comment="Set if the client &quot;LMCReference&quot; is not connected or&#13;&#10;the function &quot;CheckConnection&quot; returns &quot;FALSE&quot; or&#13;&#10;the client &quot;ActPosition&quot; is not connected" Name="_LMCAXIS_STATUS.NoRefMeth"/>
    22 NoActPosChk,  //! <Type Comment="Set if the client LMCSafety is connected and the function &quot;ChkHWReadyConnect&quot; returns &quot;FALSE&quot; or&#13;&#10;the client LMCSafety is not connected or&#13;&#10;the SimulateMode is active" Name="_LMCAXIS_STATUS.NoActPosChk"/>
    23 NoPreRtWork,  //! <Type Comment="Set if the client &quot;LMCPreRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPreRtWork"/>
    24 NoPostRtWork,  //! <Type Comment="Set if the client &quot;LMCPostRtWorkTrigger&quot; is not connected" Name="_LMCAXIS_STATUS.NoPostRtWork"/>
    25 DelayedMasterLock,  //! <Type Comment="Mode 1: Set if the slave-axis is coupled onto a master-axis and reset when the MasterLock is 0 a configurableamount of cycles&#13;&#10;Mode 2: Set if the the position and velocity is in a window within the master." Name="_LMCAXIS_STATUS.DelayedMasterLock"/>
    26 Standstill,  //! <Type Comment="Set if axis is not moving." Name="_LMCAXIS_STATUS.Standstill"/>
    27 BrakeForPowerOff,  //! <Type Comment="Set, if the axis is currently stoping for power off." Name="_LMCAXIS_STATUS.BrakeForPowerOff"/>
    28 MasterError,  //! <Type Comment="Set, if some error of the master axis occured." Name="_LMCAXIS_STATUS.MasterError"/>
    29 SlaveError,  //! <Type Comment="Set, if some error of a coupled slave axis occured." Name="_LMCAXIS_STATUS.SlaveError"/>
    30 ReadyToPowerOn,  //! <Type Comment="Set, if the axis is ready to poweron&#13;&#10; =&gt; HWReady is okay&#13;&#10; =&gt; _DriveAxis.StateWord.SwitchedOn is 1" Name="_LMCAXIS_STATUS.ReadyToPowerOn"/>
  ];
  _LMCAXIS_TUNE_MODE :  //! <Type Comment="Parameter of the function: &quot;TuneAxis&quot;&#13;&#10;Movement for the purpose of optimization of the control parameters" Name="_LMCAXIS_TUNE_MODE"/>
  (
    LMCAXIS_TUNE_POSITON_IN_NEGATIVE_DIRECTION:=4294967294,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Relative movement in negative direction" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_POSITON_IN_NEGATIVE_DIRECTION"/>
    LMCAXIS_TUNE_ZERO_TO_NEGATIVE_POSITION:=4294967295,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Movement in negative direction between position-input and zero-position" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_ZERO_TO_NEGATIVE_POSITION"/>
    LMCAXIS_TUNE_ACTPOSITION_POSITION,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Movement between the current position and the position added to the current one" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_ACTPOSITION_POSITION"/>
    LMCAXIS_TUNE_ZERO_TO_POSITIVE_POSITION,  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Movement in positive direction between position-input and zero-position" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_ZERO_TO_POSITIVE_POSITION"/>
    LMCAXIS_TUNE_POSITON_IN_POSITIVE_DIRECTION  //! <Type Comment="Parameter of the function &quot;TuneAxis&quot;:&#13;&#10;Relative movement in positiv direction" Name="_LMCAXIS_TUNE_MODE.LMCAXIS_TUNE_POSITON_IN_POSITIVE_DIRECTION"/>
  )$DINT;
#pragma pack(push, 1)
  _LMCCommonCalcParas : STRUCT  //! <Type Comment="Common calculation parameters." Name="_LMCCommonCalcParas"/>
    ResolutionInt : DINT;  //! <Type Comment="Internal scale factor" Name="_LMCCommonCalcParas.ResolutionInt"/>
    Hires : UDINT;  //! <Type Comment="Number of RtWork() cycles per second." Name="_LMCCommonCalcParas.Hires"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCCONTROLLERTYPE :
  (
    _LMCNOCONTROLLER,  //! <Type Comment="no controller" Name="_LMCCONTROLLERTYPE._LMCNOCONTROLLER"/>
    _LMCUSERCONTROLLER,  //! <Type Comment="user defined controller" Name="_LMCCONTROLLERTYPE._LMCUSERCONTROLLER"/>
    _LMCDUMMYCONTROLLER,  //! <Type Comment="DummyController" Name="_LMCCONTROLLERTYPE._LMCDUMMYCONTROLLER"/>
    _LMCHYDROCONTROLLER,  //! <Type Comment="HydroController" Name="_LMCCONTROLLERTYPE._LMCHYDROCONTROLLER"/>
    _LMCKV_CONTROLLER,  //! <Type Comment="KV_Controller" Name="_LMCCONTROLLERTYPE._LMCKV_CONTROLLER"/>
    _LMCNCCONTROLLER,  //! <Type Comment="NCController" Name="_LMCCONTROLLERTYPE._LMCNCCONTROLLER"/>
    _LMCPOSCONTROLLER,  //! <Type Comment="PosController" Name="_LMCCONTROLLERTYPE._LMCPOSCONTROLLER"/>
    _LMCDRIVEPOSONTROL,  //! <Type Comment="DrivePosController" Name="_LMCCONTROLLERTYPE._LMCDRIVEPOSONTROL"/>
    _LMCSTEPPERCONTROL:=8,  //! <Type Comment="StepperControl" Name="_LMCCONTROLLERTYPE._LMCSTEPPERCONTROL"/>
    _LMCVFDCONTROL:=9,  //! <Type Comment="VFDControl" Name="_LMCCONTROLLERTYPE._LMCVFDCONTROL"/>
    _LMCUSERCONTROLLER_NEW:=101,
    _LMCKV_CONTROLLER_NEW:=104,  //! <Type Comment="_LMCKVController" Name="_LMCCONTROLLERTYPE._LMCKV_CONTROLLER_NEW"/>
    _LMCPOSCONTROLLER_NEW:=106,  //! <Type Comment="_LMCPosController" Name="_LMCCONTROLLERTYPE._LMCPOSCONTROLLER_NEW"/>
    _LMCSIGMATEKCONTROLLER:=107,  //! <Type Comment="_LMCSigController" Name="_LMCCONTROLLERTYPE._LMCSIGMATEKCONTROLLER"/>
    _LMCCALCMODEL_CONTROLLER  //! <Type Comment="_LMCVirtualPosController" Name="_LMCCONTROLLERTYPE._LMCCALCMODEL_CONTROLLER"/>
  )$UDINT;
  _LMCPROF_ACTUALVALUES :
  (
    _LMCPROF_ACTUALPATH,  //! <Type Comment="Path length already travelled within the current internal move segment [internal units].&#13;&#10;" Name="_LMCPROF_ACTUALVALUES._LMCPROF_ACTUALPATH"/>
    _LMCPROF_PATHLENGTH,  //! <Type Comment="Path length of currently travelled internal move segment [internal units]" Name="_LMCPROF_ACTUALVALUES._LMCPROF_PATHLENGTH"/>
    _LMCPROF_V_PATH,  //! <Type Comment="Path speed [internal units/tick]" Name="_LMCPROF_ACTUALVALUES._LMCPROF_V_PATH"/>
    _LMCPROF_ACTUALPATH_ORIG,  //! <Type Comment="Path length already travelled within an NC-block [internal units].&#13;&#10;Starts with 0 at the beginning of an NC-block." Name="_LMCPROF_ACTUALVALUES._LMCPROF_ACTUALPATH_ORIG"/>
    _LMCPROF_PATHLENGTH_ORIG,  //! <Type Comment="Path length of currently travelled NC-block [internal units]" Name="_LMCPROF_ACTUALVALUES._LMCPROF_PATHLENGTH_ORIG"/>
    _LMCPROF_DELTA_S  //! <Type Comment="Path length travelled within the last tick [internal units]." Name="_LMCPROF_ACTUALVALUES._LMCPROF_DELTA_S"/>
  )$UDINT;
#pragma pack(push, 1)
  _LMCPROF_CIRCLEPOINT : STRUCT  //! <Type Comment="Absolute Position of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT"/>
    Point1 : DINT;  //! <Type Comment="Absolute 1st coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point1"/>
    Point2 : DINT;  //! <Type Comment="Absolute 2nd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point2"/>
    Point3 : DINT;  //! <Type Comment="Absolute 3rd coordinate of the Circle-Midpoint or Circle-Inclinepoint[Application Units]" Name="_LMCPROF_CIRCLEPOINT.Point3"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROF_CMDINDEX :
  (
    _LMCPROF_LASTLOADED,  //! <Type Comment="Last loaded command" Name="_LMCPROF_CMDINDEX._LMCPROF_LASTLOADED"/>
    _LMCPROF_ACTCMD,  //! <Type Comment="Actual command" Name="_LMCPROF_CMDINDEX._LMCPROF_ACTCMD"/>
    _LMCPROF_VORANZ,  //! <Type Comment="Commands that are not executeted now" Name="_LMCPROF_CMDINDEX._LMCPROF_VORANZ"/>
    _LMCPROF_SUMINDEX,  //! <Type Comment="Number of entries in the UserBuffer remaining to be traversed." Name="_LMCPROF_CMDINDEX._LMCPROF_SUMINDEX"/>
    _LMCPROF_LASTLOADED_I,  //! <Type Comment="Last loaded command" Name="_LMCPROF_CMDINDEX._LMCPROF_LASTLOADED_I"/>
    _LMCPROF_ACTCMD_I  //! <Type Comment="Actual command" Name="_LMCPROF_CMDINDEX._LMCPROF_ACTCMD_I"/>
  )$UDINT;
  _LMCPROF_EXECUTE :  //! <Type Comment="Time of command execution" Name="_LMCPROF_EXECUTE"/>
  (
    LMCPROF_BUFFERED,  //! <Type Comment="The command is placed into the internal buffer.&#13;&#10;It is executed when all buffered motion commands before it are finished." Name="_LMCPROF_EXECUTE.LMCPROF_BUFFERED"/>
    LMCPROF_IMMEDIATE  //! <Type Comment="The command is executed immediately." Name="_LMCPROF_EXECUTE.LMCPROF_IMMEDIATE"/>
  )$UDINT;
  _LMCPROFCMDTYPES :  //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES"/>
  (
    CMD_Nothing,  //! <Type Comment="Empty buffer entry / no movement" Name="_LMCPROFCMDTYPES.CMD_Nothing"/>
    CMD_Linear:=2,  //! <Type Comment="Linear movement" Name="_LMCPROFCMDTYPES.CMD_Linear"/>
    CMD_CircleCW:=5,  //! <Type Comment="Circular movement clockwise" Name="_LMCPROFCMDTYPES.CMD_CircleCW"/>
    CMD_CircleCCW:=4,  //! <Type Comment="Circular movement counter clockwise" Name="_LMCPROFCMDTYPES.CMD_CircleCCW"/>
    CMD_MoveCurve:=12,  //! <Type Comment="Evasive movement with MoveCurve()" Name="_LMCPROFCMDTYPES.CMD_MoveCurve"/>
    CMD_Circle3D:=13,  //! <Type Comment="Circular movement in 3 dimensions" Name="_LMCPROFCMDTYPES.CMD_Circle3D"/>
    CMD_SetProfPos:=20  //! <Type Comment="Set profile positions command" Name="_LMCPROFCMDTYPES.CMD_SetProfPos"/>
  )$UDINT;
  _LMCPROFINTCMDCONFIG : BDINT  //! <Type Comment="Move command flags" Name="_LMCPROFINTCMDCONFIG"/>
  [
    1 CmdActive,  //! <Type Comment="1: the movement calculations are finished." Name="_LMCPROFINTCMDCONFIG.CmdActive"/>
    2 RapidTraverse,  //! <Type Comment="1: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFINTCMDCONFIG.RapidTraverse"/>
    3 FeedRateInterpolation,  //! <Type Comment="1: feed rate interpolation selected" Name="_LMCPROFINTCMDCONFIG.FeedRateInterpolation"/>
    4 SecondTransition,  //! <Type Comment="0: this is the first transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected&#13;&#10;1: this is the second transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected" Name="_LMCPROFINTCMDCONFIG.SecondTransition"/>
    5 IsProgrammedExactStop,  //! <Type Comment="this path segment was programmed with TransitionMode:=_LMCPROF_EXACT_STOP" Name="_LMCPROFINTCMDCONFIG.IsProgrammedExactStop"/>
    6 AfterSetPosCmd,  //! <Type Comment="The command before this one is a SetProfilePositions(). This command maybe needs to be recomputed." Name="_LMCPROFINTCMDCONFIG.AfterSetPosCmd"/>
    7 MoveCurveSplineInserted,
    8 MoveCurveSplineExecuting,
    9 MoveCurvePathPerThousand,
    10 CmdActivated,
    12 SpecialLinear_OrientateTangAx,
    13 EndlessMovement,
    17 PathLenReduced,  //! <Type Comment="this bit is only used in internal buffer" Name="_LMCPROFINTCMDCONFIG.PathLenReduced"/>
    25 Activated,
    26 WaitFinish,
    27 CmdStarted,
  ];
  _LMCPROFTRANSMODES :  //! <Type Comment="Transition type between path segments" Name="_LMCPROFTRANSMODES"/>
  (
    _LMCPROF_EXACT_STOP:=0,  //! <Type Comment="There is an exact stop after this movement" Name="_LMCPROFTRANSMODES._LMCPROF_EXACT_STOP"/>
    _LMCPROF_CONT_DIRECT:=2,  //! <Type Comment="The transition between path segments is executed in the smooth rounding mode." Name="_LMCPROFTRANSMODES._LMCPROF_CONT_DIRECT"/>
    _LMCPROF_SMOOTH_PARAB,  //! <Type Comment="The transition between path segments is executed in the rounding mode with tolerance sphere." Name="_LMCPROFTRANSMODES._LMCPROF_SMOOTH_PARAB"/>
    _LMCPROF_SMOOTH_CUBIC,  //! <Type Comment="The transition between path segments is executed with a cubic spline." Name="_LMCPROFTRANSMODES._LMCPROF_SMOOTH_CUBIC"/>
    _LMCPROF_SMOOTH_QUINT
  )$UDINT;
  _LMCPROFCIRCLEDEF : BDINT  //! <Type Comment="Circle axes definition" Name="_LMCPROFCIRCLEDEF"/>
  [
    1 Axis1,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis1"/>
    2 Axis2,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis2"/>
    3 Axis3,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis3"/>
    4 Axis4,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis4"/>
    5 Axis5,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis5"/>
    6 Axis6,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis6"/>
    7 Axis7,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis7"/>
    8 Axis8,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis8"/>
    9 Axis9,  //! <Type Comment="0: axis is a linear axis&#13;&#10;1: axis is a circle axis" Name="_LMCPROFCIRCLEDEF.Axis9"/>
  ];
#pragma pack(push, 1)
  _LMCPROF_POSITIONS : STRUCT  //! <Type Comment="Start and end positions of an axis [Internal units]" Name="_LMCPROF_POSITIONS"/>
    start : DINT;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.start"/>
    end : DINT;  //! <Type Comment="[Internal units]" Name="_LMCPROF_POSITIONS.end"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _LMCPROF_OBSTACLE : STRUCT  //! <Type Public="true" Comment="Data for MoveCurve definition" Name="_LMCPROF_OBSTACLE"/>
    PathPerThousand : BOOL;  //! <Type Comment="FALSE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in application units.&#13;&#10;TRUE: The distances Obstacle.PathStart and Obstacle.PathEnd are given in parts per thousand of the path length." Name="_LMCPROF_OBSTACLE.PathPerThousand"/>
    AxisNr : DINT;  //! <Type Comment="Number of axis, in which direction the evasive movement should be performed [1-9]." Name="_LMCPROF_OBSTACLE.AxisNr"/>
    HeightStart_relativ : DINT;  //! <Type Comment="The evasive movement starts with an &quot;linear up movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_relativ"/>
    HeightEnd_relativ : DINT;  //! <Type Comment="The evasive movement ends with a &quot;linear down movement&quot;. This value defines its height. &#13;&#10;distance in [application units]" Name="_LMCPROF_OBSTACLE.HeightEnd_relativ"/>
    PathStart : DINT;  //! <Type Comment="position, where the HeightStart_absolute should be reached.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement." Name="_LMCPROF_OBSTACLE.PathStart"/>
    HeightStart_absolut : DINT;  //! <Type Comment="position of the evasive axis at PathStart [application units]" Name="_LMCPROF_OBSTACLE.HeightStart_absolut"/>
    PathEnd : DINT;  //! <Type Comment="position, where the HeightEnd_absolute should be reached. The distance is measured from the end of the vertical movement.&#13;&#10;&#13;&#10;Depending on the _LMCPROF_OBSTACLE struct element PathPerThousand the length is given in application units or in parts per thousand of the length of the &quot;vertical&quot; movement.&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.PathEnd"/>
    HeightEnd_absolut : DINT;  //! <Type Comment="position of the evasive axis at PathEnd [application units]&#13;&#10;&#13;&#10;This value is ignored, if PathEnd + PathStart is longer then the vertical distance." Name="_LMCPROF_OBSTACLE.HeightEnd_absolut"/>
    VelStart_relativ_ppT : DINT;  //! <Type Comment="value &gt; 0: maximal velocity of the starting linear up movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the starting linear up movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelStart_relativ_ppT"/>
    VelEnd_relativ_ppT : DINT;  //! <Type Comment="value &gt; 0: maximal velocity of the ending linear down movement in parts per thousand of the programmed Velocity value.&#13;&#10;&#13;&#10;value &lt;= 0: maximal velocity of the ending linear down movement equals the programmed Velocity." Name="_LMCPROF_OBSTACLE.VelEnd_relativ_ppT"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  _LMCPROF_MoveData : STRUCT  //! <Type Comment="Element of the profile buffer " Name="_LMCPROF_MoveData"/>
    pPrevMoveUncommon : ^_LMCPROF_MoveData;  //! <Type Comment="Pointer to the previous movement if it is not commonly determined.&#13;&#10;It is used during reverse drive or if the next movement is saved in different buffer than this one. &#13;&#10;There are three buffer types:&#13;&#10;Profile&#13;&#10;Temporary&#13;&#10;Restart" Name="_LMCPROF_MoveData.pPrevMoveUncommon"/>
    pNextMoveUncommon : ^_LMCPROF_MoveData;  //! <Type Comment="Pointer to the next movement if it is not commonly determined.&#13;&#10;It is used during reverse drive or if the next movement is saved in different buffer than this one. &#13;&#10;There are three buffer types:&#13;&#10;Profile&#13;&#10;Temporary&#13;&#10;Restart" Name="_LMCPROF_MoveData.pNextMoveUncommon"/>
    index : UDINT;  //! <Type Comment="Index in the profile buffer" Name="_LMCPROF_MoveData.index"/>
    enCmdType : _LMCPROFCMDTYPES;  //! <Type Comment="Move command type" Name="_LMCPROF_MoveData.enCmdType"/>
    bsCmdFlags : _LMCPROFINTCMDCONFIG;  //! <Type Comment="Move command flags" Name="_LMCPROF_MoveData.bsCmdFlags"/>
    enTransitionMode : _LMCPROFTRANSMODES;  //! <Type Comment="Type of transition between path segments" Name="_LMCPROF_MoveData.enTransitionMode"/>
    dTransitionRadius : DINT;  //! <Type Comment="Radius of the tolerance sphere. Used for the smooth rounding mode, the rounding mode with tolerance sphere and for the rounding mode with cubic spline." Name="_LMCPROF_MoveData.dTransitionRadius"/>
    bdCirAxis : _LMCPROFCIRCLEDEF;  //! <Type Comment="Defines the circle axes." Name="_LMCPROF_MoveData.bdCirAxis"/>
    stPositions : ARRAY [0.._LMC_MAX_AXIS-1] OF _LMCPROF_POSITIONS;  //! <Type Comment="Start and end positions of all axes [Internal units]" Name="_LMCPROF_MoveData.stPositions"/>
    xMp : DINT;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the first circle axis [Internal units]" Name="_LMCPROF_MoveData.xMp"/>
    yMp : DINT;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the second circle axis [Internal units]" Name="_LMCPROF_MoveData.yMp"/>
    zMP : DINT;  //! <Type Comment="Distance from the start point to the circle center point in the direction of the third circle axis [Internal units]" Name="_LMCPROF_MoveData.zMP"/>
    PathLength : DINT;  //! <Type Comment="Path length [Internal units]" Name="_LMCPROF_MoveData.PathLength"/>
    vMax : DINT;  //! <Type Comment="Max. allowed path speed [Internal units/tick]" Name="_LMCPROF_MoveData.vMax"/>
    aMax : DINT;  //! <Type Comment="Max. allowed path acceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.aMax"/>
    dMax : DINT;  //! <Type Comment="Max. allowed path deceleration [Internal units/tick²]" Name="_LMCPROF_MoveData.dMax"/>
    jMax : DINT;  //! <Type Comment="Max. allowed path jerk [Internal units/tick²/sec]" Name="_LMCPROF_MoveData.jMax"/>
    sCircleIPSpec : _LMCPROF_CIRCLEPOINT;  //! <Type Comment="Interpoint of the circle movement." Name="_LMCPROF_MoveData.sCircleIPSpec"/>
    bIPnil : BOOL;  //! <Type Comment="TRUE .. Interpoint was not specified." Name="_LMCPROF_MoveData.bIPnil"/>
    CircleCCW : BOOL;  //! <Type Comment="Flag is set if this is a counter-clockwise circle movement. It is used for eventual reverse drive." Name="_LMCPROF_MoveData.CircleCCW"/>
    sObstacleSpec : _LMCPROF_OBSTACLE;  //! <Type Comment="Obstacle specification of the curve movement." Name="_LMCPROF_MoveData.sObstacleSpec"/>
    SplineMove : BOOL;  //! <Type Comment="Is this a (Curve)Spline move?" Name="_LMCPROF_MoveData.SplineMove"/>
    SplineCornerOverdrive : DINT;  //! <Type Comment="Corner overdrive property if the move is a spline one." Name="_LMCPROF_MoveData.SplineCornerOverdrive"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROF_OPMODE :  //! <Type Comment="Operating mode" Name="_LMCPROF_OPMODE"/>
  (
    _LMC_AUTOMATIC,  //! <Type Comment="The loaded sequences are started automatically." Name="_LMCPROF_OPMODE._LMC_AUTOMATIC"/>
    _LMC_MANUAL  //! <Type Comment="The loaded sequences are not started automatically. Server &apos;Start&apos; must be set to 1." Name="_LMCPROF_OPMODE._LMC_MANUAL"/>
  )$UDINT;
#pragma pack(push, 1)
  _LMCPROF_POS : STRUCT  //! <Type Comment="Absolute Endpositions / relative distances of all Axes [Application Units]" Name="_LMCPROF_POS"/>
    Pos1 : DINT;  //! <Type Comment="Absolute Endposition of Axis1 [Application Units]" Name="_LMCPROF_POS.Pos1"/>
    Pos2 : DINT;  //! <Type Comment="Absolute Endposition of Axis2 [Application Units]" Name="_LMCPROF_POS.Pos2"/>
    Pos3 : DINT;  //! <Type Comment="Absolute Endposition of Axis3 [Application Units]" Name="_LMCPROF_POS.Pos3"/>
    Pos4 : DINT;  //! <Type Comment="Absolute Endposition of Axis4 [Application Units]" Name="_LMCPROF_POS.Pos4"/>
    Pos5 : DINT;  //! <Type Comment="Absolute Endposition of Axis5 [Application Units]" Name="_LMCPROF_POS.Pos5"/>
    Pos6 : DINT;  //! <Type Comment="Absolute Endposition of Axis6 [Application Units]" Name="_LMCPROF_POS.Pos6"/>
    Pos7 : DINT;  //! <Type Comment="Absolute Endposition of Axis7 [Application Units]" Name="_LMCPROF_POS.Pos7"/>
    Pos8 : DINT;  //! <Type Comment="Absolute Endposition of Axis8 [Application Units]" Name="_LMCPROF_POS.Pos8"/>
    Pos9 : DINT;  //! <Type Comment="Absolute Endposition of Axis9 [Application Units]" Name="_LMCPROF_POS.Pos9"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROF_RECOUPLEMODE :
  (
    _LMCPROF_RECOUPLE_TO_PROFILE:=0,  //! <Type Comment="recouple the axis to the Profile position" Name="_LMCPROF_RECOUPLEMODE._LMCPROF_RECOUPLE_TO_PROFILE"/>
    _LMCPROF_RECOUPLE_TO_ACTPOS:=1  //! <Type Comment="recouple the axis to the actual position" Name="_LMCPROF_RECOUPLEMODE._LMCPROF_RECOUPLE_TO_ACTPOS"/>
  )$UDINT;
  _LMCPROF_RESTIME_CALCMODE :  //! <Type Comment="Modus of calculation of the Residualtime" Name="_LMCPROF_RESTIME_CALCMODE"/>
  (
    LMCPROF_TONEXT_STOPP,  //! <Type Comment="The remaining way and the actual velocity of the acting record-set is employed for calculation of the remaining time" Name="_LMCPROF_RESTIME_CALCMODE.LMCPROF_TONEXT_STOPP"/>
    LMCPROF_TO_NEXT_PATH_SEGMENT,
    LMCPROF_TO_NEXT_PATH_SEGMENT_ORIG,
    LMCPROF_LAST_PATH_SEGMENT,
    LMCPROF_TOLAST_STOPP
  )$UDINT;
  _LMCPROF_SETPOS_MODE :  //! <Type Comment="Mode defines how we get the set positions." Name="_LMCPROF_SETPOS_MODE"/>
  (
    _LMCPROF_SETPOS_TO_AXES_POS,  //! <Type Comment="The profile positions will be set to the master position of the LMCAxis object.&#13;&#10;&#13;&#10;E.g. This mode may be used to set the profile back to the correct position after adding some discrepancy with CoupleAdditivePosDiff" Name="_LMCPROF_SETPOS_MODE._LMCPROF_SETPOS_TO_AXES_POS"/>
    _LMCPROF_SETPOS_TO_USER_POS,  //! <Type Comment="The profile positions will be set to the positions, which are returned from the methode SetProfPosCallback(). Please overwrite this private methode.&#13;&#10;&#13;&#10;The _LMCAxis objects may move to this new position in the fastest possible way." Name="_LMCPROF_SETPOS_MODE._LMCPROF_SETPOS_TO_USER_POS"/>
    _LMCPROF_SETPOS_TO_USER_POS_NO_AX_TRAVEL  //! <Type Comment="The profile positions will be set to the positions, which are returned from the methode SetProfPosCallback(). Please overwrite this private methode.&#13;&#10;&#13;&#10;The _LMCAxis objects will ignore this position jump. They will move relative to the new profile positions, but the position discrepancy may last." Name="_LMCPROF_SETPOS_MODE._LMCPROF_SETPOS_TO_USER_POS_NO_AX_TRAVEL"/>
  )$UDINT;
  _LMCPROFCMDCONFIG : BDINT  //! <Type Comment="Move command flags" Name="_LMCPROFCMDCONFIG"/>
  [
    1 RapidTraverse,  //! <Type Comment="True: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFCMDCONFIG.RapidTraverse"/>
    2 CircleCW,  //! <Type Comment="True: circular movement clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement dromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCW"/>
    3 CircleCCW,  //! <Type Comment="True: circular movement counter clockwise in case of a 2-dimensional movement&#13;&#10;True: circular movement antidromic in case of a 3-dimensional movement" Name="_LMCPROFCMDCONFIG.CircleCCW"/>
    4 FeedRateInterpolation,  //! <Type Comment="True: feed rate interpolation selected. The feedrate changes linearly over the path length." Name="_LMCPROFCMDCONFIG.FeedRateInterpolation"/>
    5 MoveImmediately,  //! <Type Comment="False: Command will be inserted in the movement buffer after the last inserted movement&#13;&#10;True: Command shall be immediately executed. Buffer will be deleted and actual movement interrupted. " Name="_LMCPROFCMDCONFIG.MoveImmediately"/>
  ];
  _LMCPROFCMDTYPES_INTERN :  //! <Type Comment="Move command type" Name="_LMCPROFCMDTYPES_INTERN"/>
  (
    _LMCPROF_CMD_Nothing,  //! <Type Comment="Empty buffer entry" Name="_LMCPROFCMDTYPES_INTERN._LMCPROF_CMD_Nothing"/>
    _LMCMT_NoPosChange,  //! <Type Comment="Move command with zero path length, i.e. a linear movement where the end positions are equal to the start positions." Name="_LMCPROFCMDTYPES_INTERN._LMCMT_NoPosChange"/>
    _LMCMT_Linear,  //! <Type Comment="Linear movement" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Linear"/>
    _LMCMT_SpeedLimit,  //! <Type Comment="This command reduces the path speed so that the speed jump or acceleration jump is not exceeded." Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SpeedLimit"/>
    _LMCMT_CircleCCW,  //! <Type Comment="Circle Movement Counter-Clockwise in case of 2-dimensional Movement&#13;&#10;Circle Movement antidromic in case of 3-dimensional Movement" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_CircleCCW"/>
    _LMCMT_CircleCW,  //! <Type Comment="Circle Movement Clockwise in case of 2-dimensional Movement&#13;&#10;Circle Movement dromic in case of 3-dimensional Movement" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_CircleCW"/>
    _LMCMT_Round_All,  //! <Type Comment="A linear-linear transition when _LMCPROF_SMOOTH_PARAB is selected" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Round_All"/>
    _LMCMT_Lin_Round_Aux,  //! <Type Comment="The linear part of a linear-circular or circular-linear transition when _LMCPROF_SMOOTH_PARAB is selected" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Lin_Round_Aux"/>
    _LMCMT_Circle_Lin_Round_Aux,  //! <Type Comment="The circular part of a linear-circular or circular-linear transition when _LMCPROF_SMOOTH_PARAB is selected" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Circle_Lin_Round_Aux"/>
    _LMCMT_SplineCub,  //! <Type Comment="Transition formed by a cubic spline" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SplineCub"/>
    _LMCMT_SplineQuint,  //! <Type Comment="Transition formed by a 5th order spline" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SplineQuint"/>
    _LMCMT_Fourier,
    _LMCMT_MoveCurve,  //! <Type Comment="Evasive movement with MoveCurve()" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_MoveCurve"/>
    _LMCMT_Circle3D,  //! <Type Comment="circle in 3 dimensions&#13;&#10;ONLY USED FOR INSERTING INTO USERBUFFER." Name="_LMCPROFCMDTYPES_INTERN._LMCMT_Circle3D"/>
    _LMCMT_MoveCurveAuxRound,  //! <Type Comment="start and end piece of an evasive movement with MoveCurve(). Used to accelerate auxiliary axes (like SplineQuint)" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_MoveCurveAuxRound"/>
    _LMCMT_SetProfPos:=20  //! <Type Comment="Set profile positions command" Name="_LMCPROFCMDTYPES_INTERN._LMCMT_SetProfPos"/>
  )$UDINT;
  _LMCPROFERRORTYPES :  //! <Type Comment="Error numbers" Name="_LMCPROFERRORTYPES"/>
  (
    _LMCPROF_NoError,  //! <Type Comment="No error occured" Name="_LMCPROFERRORTYPES._LMCPROF_NoError"/>
    _LMCPROF_INIT_ERROR,  //! <Type Comment="Not enough memory for the profile buffer&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_INIT_ERROR"/>
    _LMCPROF_MOVECMD_ERROR,  //! <Type Comment="Unknown move command" Name="_LMCPROFERRORTYPES._LMCPROF_MOVECMD_ERROR"/>
    _LMCPROF_INT_POINTER_ERROR,  //! <Type Comment="Internal pointer error" Name="_LMCPROFERRORTYPES._LMCPROF_INT_POINTER_ERROR"/>
    _LMCPROF_JUMP_CMD_ERROR,  //! <Type Comment="After a jump active command there is no active entry in the buffer&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_JUMP_CMD_ERROR"/>
    _LMCPROF_POS_OVERRUN_ERROR,  //! <Type Comment="Set position overrun" Name="_LMCPROFERRORTYPES._LMCPROF_POS_OVERRUN_ERROR"/>
    _LMCPROF_AXIS_ERROR,  //! <Type Comment="One of the coupled axes has an error" Name="_LMCPROFERRORTYPES._LMCPROF_AXIS_ERROR"/>
    _LMCPROF_SWE_ERROR,  //! <Type Comment="SW end position violation while loading the command&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_SWE_ERROR"/>
    _LMCPROF_CIRDEF_ERROR,  //! <Type Comment="The circle definition is wrong" Name="_LMCPROFERRORTYPES._LMCPROF_CIRDEF_ERROR"/>
    _LMCPROF_NO_POS_CHANGE,  //! <Type Comment="Move command without any axes travel" Name="_LMCPROFERRORTYPES._LMCPROF_NO_POS_CHANGE"/>
    _LMCPROF_GROUP_ERROR,  //! <Type Comment="Change Command to this Group is not possible because the Set Group has no Distance / SubError: Set GroupNr" Name="_LMCPROFERRORTYPES._LMCPROF_GROUP_ERROR"/>
    _LMCPROF_KOFAC_ERROR,  //! <Type Comment="Division error in the calculation of the coupling factors / Sub error shows the axis number&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_KOFAC_ERROR"/>
    _LMCPROF_VEL_CMD_ERROR,  //! <Type Comment="Movement speed &lt; 1" Name="_LMCPROFERRORTYPES._LMCPROF_VEL_CMD_ERROR"/>
    _LMCPROF_ACC_CMD_ERROR,  //! <Type Comment="Movement acceleration / deceleration &lt; 1&#13;&#10;" Name="_LMCPROFERRORTYPES._LMCPROF_ACC_CMD_ERROR"/>
    _LMCPROF_JERK_CMD_ERROR,  //! <Type Comment="Movement jerk &lt; 1" Name="_LMCPROFERRORTYPES._LMCPROF_JERK_CMD_ERROR"/>
    _LMCPROF_RESOLUTION_ERROR,  //! <Type Comment="Error occured while loading the command,the entries are bigger than 2^31 when multiplied by the resolution factor." Name="_LMCPROFERRORTYPES._LMCPROF_RESOLUTION_ERROR"/>
    _LMCPROF_SAFETY_ZONES_REACHED,  //! <Type Comment="User has reached a safety zone" Name="_LMCPROFERRORTYPES._LMCPROF_SAFETY_ZONES_REACHED"/>
    _LMCPROF_INSERT_ERROR,  //! <Type Comment="The profile buffer is full" Name="_LMCPROFERRORTYPES._LMCPROF_INSERT_ERROR"/>
    _LMCPROF_AXIS_NOT_CONNECTED,  //! <Type Comment="Selected axis was not found or is not connected." Name="_LMCPROFERRORTYPES._LMCPROF_AXIS_NOT_CONNECTED"/>
    _LMCPROF_GROUP_NOT_FOUND,  //! <Type Comment="Selected group is not configured in the system" Name="_LMCPROFERRORTYPES._LMCPROF_GROUP_NOT_FOUND"/>
    _LMCPROF_PARAMETER_NOT_FOUND,  //! <Type Comment="Selected parameter was not found in the settings" Name="_LMCPROFERRORTYPES._LMCPROF_PARAMETER_NOT_FOUND"/>
    _LMCPROF_PARAMETER_ERROR,  //! <Type Comment="Enabling or disabling the selected function is impossible" Name="_LMCPROFERRORTYPES._LMCPROF_PARAMETER_ERROR"/>
    _LMCPROF_ERROR_BUSY,  //! <Type Comment="Changing a parameter is not allowed in the current state" Name="_LMCPROFERRORTYPES._LMCPROF_ERROR_BUSY"/>
    _LMCPROF_OUT_OF_RANGE,  //! <Type Comment="Parameter value is too big or too small" Name="_LMCPROFERRORTYPES._LMCPROF_OUT_OF_RANGE"/>
    _LMCPROF_RADIUS_ERROR,  //! <Type Comment="Circle radius is out of range (radius &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_RADIUS_ERROR"/>
    _LMCPROF_ARCLEN_ERROR,  //! <Type Comment="Circle arc length is out of range (arc length &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_ARCLEN_ERROR"/>
    _LMCPROF_RES_PATHLEN_ERROR:=26,  //! <Type Comment="The residual path length is out of range (residual path length &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_RES_PATHLEN_ERROR"/>
    _LMCPROF_ENDPOS_ERROR,  //! <Type Comment="The end position of a move is out of range (end position &gt; 2^31 - 1 [Internal units]).&#13;&#10;Check SetBasicParameter(.., PosOffseti, ..)" Name="_LMCPROFERRORTYPES._LMCPROF_ENDPOS_ERROR"/>
    _LMCPROF_AXTRAVEL_ERROR,  //! <Type Comment="The axis travel distance is out of range (end position - start position &gt; 2^31 - 1 [Internal units])." Name="_LMCPROFERRORTYPES._LMCPROF_AXTRAVEL_ERROR"/>
    _LMCPROF_AX_COUPLE_ERROR,  //! <Type Comment="Some axis coupling command (CoupleGearAbsolute etc.) returned an error." Name="_LMCPROFERRORTYPES._LMCPROF_AX_COUPLE_ERROR"/>
    _LMCPROF_PLAINEDEF_ERROR,  //! <Type Comment="The Plaine of the Circle is not defined" Name="_LMCPROFERRORTYPES._LMCPROF_PLAINEDEF_ERROR"/>
    _LMCPROF_VEC_ERROR,  //! <Type Comment="Coordinates of vectors used for calcualtion of a circle are out of range" Name="_LMCPROFERRORTYPES._LMCPROF_VEC_ERROR"/>
    _LMCPROF_LOCKGROUP_ERROR,  //! <Type Comment="Slave-Group of an Axis is undefined." Name="_LMCPROFERRORTYPES._LMCPROF_LOCKGROUP_ERROR"/>
    _LMCPROF_LINEDEF_ERROR,  //! <Type Comment="The definition of the endpositions for the linear movement is wrong." Name="_LMCPROFERRORTYPES._LMCPROF_LINEDEF_ERROR"/>
    _LMCPROF_CHORDLEN_ERROR,  //! <Type Comment="The start point or the endpoint of the circle is identical to the center point.&#13;&#10;The circle will be replaced by a line." Name="_LMCPROFERRORTYPES._LMCPROF_CHORDLEN_ERROR"/>
    _LMCPROF_LOCKGROUP_DIFF_RESTART,  //! <Type Comment="Axes group assignment at restart differs from the original axes assignment." Name="_LMCPROFERRORTYPES._LMCPROF_LOCKGROUP_DIFF_RESTART"/>
    _LMCPROF_REFPOINT_DIFF_RESTART,  //! <Type Comment="Axes geometric reference point at restart differs from the original geometric reference point." Name="_LMCPROFERRORTYPES._LMCPROF_REFPOINT_DIFF_RESTART"/>
    _LMCPROF_AXIS_POS_ERROR,  //! <Type Comment="The axis is not at the correct start / restart position." Name="_LMCPROFERRORTYPES._LMCPROF_AXIS_POS_ERROR"/>
    _LMCPROF_INPOSITION_TIMEOUT_ERROR,  //! <Type Comment="After performing an exact stop the actual axis positions have not reached their target position for too long." Name="_LMCPROFERRORTYPES._LMCPROF_INPOSITION_TIMEOUT_ERROR"/>
    _LMCPROF_MATH_ERROR,  //! <Type Comment="Calculation error occured." Name="_LMCPROFERRORTYPES._LMCPROF_MATH_ERROR"/>
    _LMCPROF_CALC_ITERATION_ERROR,
    _LMCPROF_REVERSE_ONGOING,  //! <Type Comment="Command impossible as reverse drive is ongoing." Name="_LMCPROFERRORTYPES._LMCPROF_REVERSE_ONGOING"/>
    _LMCPROF_REVERSE_INSERT_ERROR,  //! <Type Comment="An error occured during reverse movement calculation" Name="_LMCPROFERRORTYPES._LMCPROF_REVERSE_INSERT_ERROR"/>
    _LMCROBOT_REF_ERROR:=1000,
    _LMCROBOT_AX_COUPLING_ERROR,
    _LMCROBOT_BACKUP_POS_ERROR,  //! <Type Comment="The positions stored at the last PowerOff are invalid." Name="_LMCPROFERRORTYPES._LMCROBOT_BACKUP_POS_ERROR"/>
    _LMCROBOT_POWERON_ERROR,  //! <Type Comment="The PowerOn-command failed." Name="_LMCPROFERRORTYPES._LMCROBOT_POWERON_ERROR"/>
    _LMCROBOT_POS_CHECK_ERROR,  //! <Type Comment="There position validation returned an error" Name="_LMCPROFERRORTYPES._LMCROBOT_POS_CHECK_ERROR"/>
    _LMCROBOT_LINEUP_AX_ERROR,  //! <Type Comment="There was an axis error during position lineup" Name="_LMCPROFERRORTYPES._LMCROBOT_LINEUP_AX_ERROR"/>
    _LMCROBOT_COUPLE_TIMEOUT,  //! <Type Comment="The coupling of the motor axes timed out" Name="_LMCPROFERRORTYPES._LMCROBOT_COUPLE_TIMEOUT"/>
    _LMCROBOT_AX_COUPLING_LOST,  //! <Type Comment="The coupling of the motor axes was lost" Name="_LMCPROFERRORTYPES._LMCROBOT_AX_COUPLING_LOST"/>
    _LMCROBOT_AXIS_ERROR,  //! <Type Comment="One of the coupled motor axes has an error" Name="_LMCPROFERRORTYPES._LMCROBOT_AXIS_ERROR"/>
    _LMCROBOT_BELTCOUPLING_ERROR,
    _LMCROBOT_COORDSYSTEM_ERROR,
    _LMCROBOT_AX_CMD_ERROR,
    _LMCROBOT_KINEMATIC_ERROR
  )$UDINT;
#pragma pack(push, 1)
  _LMCPROFERRORDEF : STRUCT  //! <Type Comment="Error information" Name="_LMCPROFERRORDEF"/>
    LineNo : DINT;  //! <Type Comment="Number of the source code line where the error was reported" Name="_LMCPROFERRORDEF.LineNo"/>
    ErrorNo : _LMCPROFERRORTYPES;  //! <Type Comment="Error number" Name="_LMCPROFERRORDEF.ErrorNo"/>
    SubErrorNo : DINT;  //! <Type Comment="Additional error information" Name="_LMCPROFERRORDEF.SubErrorNo"/>
  END_STRUCT;
#pragma pack(pop)
  _LMCPROFERRWARNCONFIG : BDINT  //! <Type Comment="User defined error message configuration" Name="_LMCPROFERRWARNCONFIG"/>
  [
    1 bPosChangeWarning,  //! <Type Comment="FALSE: no warning is issued when a movement with zero path length is encountered &#13;&#10;TRUE : a warning is issued when a movement with zero path length is encountered" Name="_LMCPROFERRWARNCONFIG.bPosChangeWarning"/>
    2 bResolutionError,  //! <Type Comment="FALSE: a warning is issued when a parameter value * resolution does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when a parameter value * resolution does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bResolutionError"/>
    3 bPosLimitError,  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is ouside of the software end position&#13;&#10;TRUE : an error is issued when the endpoint of a movement is ouside of the software end position" Name="_LMCPROFERRWARNCONFIG.bPosLimitError"/>
    4 bCircleError,  //! <Type Comment="FALSE: a warning is issued when the number of circle axes is not equal two.&#13;&#10;TRUE : an error is issued when the number of circle axes is not equal two." Name="_LMCPROFERRWARNCONFIG.bCircleError"/>
    5 bCmdLimitError,  //! <Type Comment="FALSE: a warning is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis&#13;&#10;TRUE : an error is issued when the path speed or path acceleration is less than one due to a limit in an auxiliary axis" Name="_LMCPROFERRWARNCONFIG.bCmdLimitError"/>
    6 bKoFacError,  //! <Type Comment="FALSE: a warning is issued when the coupling factor does not fit into a 32 bit signed integer.&#13;&#10;TRUE : an error is issued when the coupling factor does not fit into a 32 bit signed integer." Name="_LMCPROFERRWARNCONFIG.bKoFacError"/>
    7 bSafetyZonesError,  //! <Type Comment="FALSE: a warning is issued when the endpoint of a movement is inside of a safety zone&#13;&#10;TRUE : an error is issued when the endpoint of a movement is inside of a safety zone" Name="_LMCPROFERRWARNCONFIG.bSafetyZonesError"/>
  ];
  _LMCPROFILESTATES : BDINT  //! <Type Comment="Profile States" Name="_LMCPROFILESTATES"/>
  [
    1 bProfileLocked,  //! <Type Comment="TRUE  .. All required axes are coupled to the profile.&#13;&#10;FALSE .. Axes are not coupled." Name="_LMCPROFILESTATES.bProfileLocked"/>
    2 bProfileStoped,  //! <Type Comment="TRUE ... command StopMove() is active and axes are not moving.&#13;&#10;FALSE .. command StopMove() is not active or at least the profile has not stopped now." Name="_LMCPROFILESTATES.bProfileStoped"/>
    3 bProfileBraking,  //! <Type Comment="TRUE ... The profile is reducing its speed.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bProfileBraking"/>
    4 bNoPreRtWork,  //! <Type Comment="TRUE ... LMCPreRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPreRtWorkTrigger is connected&#13;&#10;" Name="_LMCPROFILESTATES.bNoPreRtWork"/>
    5 bNoPostRtWork,  //! <Type Comment="TRUE ... LMCPostRtWorkTrigger is not connected&#13;&#10;FALSE .. LMCPostRtWorkTrigger is connected" Name="_LMCPROFILESTATES.bNoPostRtWork"/>
    6 bBraketoExactStop,  //! <Type Comment="TRUE ... The profile is reducing its speed due to stoping at an exact stop point.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoExactStop"/>
    7 bDynSWLimit,  //! <Type Comment="TRUE ... maximumum or minimum dynamic software limit has been reached&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimit"/>
    8 bBraketoDynSWLimit,  //! <Type Comment="TRUE ... The profile is reducing its speed due to a dynamic software limit&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bBraketoDynSWLimit"/>
    9 bDynSWLimitViolation,  //! <Type Comment="TRUE ... The dynamic software limit is violated or we probably cannot stop before violating it.&#13;&#10;FALSE .. otherwise" Name="_LMCPROFILESTATES.bDynSWLimitViolation"/>
  ];
  _LMCPROFINPOSTYPES :  //! <Type Comment="Mode" Name="_LMCPROFINPOSTYPES"/>
  (
    _LMCPROF_ProfileInPosition,  //! <Type Comment="Check whether the movement toward an end point has been ended and whether the speed is 0, i.e. read the Profile-In-Position Flag." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileInPosition"/>
    _LMCPROF_ProfileFinished,  //! <Type Comment="Check whether all motion sequences have been completed and that no new move commands are in the internal buffer." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileFinished"/>
    _LMCPROF_ProfileAxisInPos,  //! <Type Comment="Checks whether a movement toward an end point has been ended and whether the path speed is 0 and also whether the actual positions of the coupled axes are within their specified position windows." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAxisInPos"/>
    _LMCPROF_ProfileAxisFinished,  //! <Type Comment="Check whether all motion sequences have been completed and that no new move commands are in the internal buffer and whether the path speed is 0 and also whether the actual positions of the coupled axes are within their specified position windows.&#13;&#10;" Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAxisFinished"/>
    _LMCPROF_ProfileInWindow,  //! <Type Comment="Check whether the movement toward an end point is within the defined window." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileInWindow"/>
    _LMCPROF_ProfileInWindowFinished,  //! <Type Comment="Check whether the movement toward an end point is within the defined window and that no new move commands are in the internal buffer." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileInWindowFinished"/>
    _LMCPROF_ProfileAndAxisInWindow,  //! <Type Comment="Check whether the movement toward an end point is within the defined window and also&#13;&#10;check whether the actual positions of the coupled axes are within their specified position windows." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAndAxisInWindow"/>
    _LMCPROF_ProfileAndAxisInWindowFinished,  //! <Type Comment="Check whether the movement toward an end point is within the defined window and that no new move commands are in the internal buffer and also check whether the actual positions of the coupled axes are within their specified position windows." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileAndAxisInWindowFinished"/>
    _LMCPROF_ProfileStandstill  //! <Type Comment="Check whether the path speed is zero and the coupled axes are not moving." Name="_LMCPROFINPOSTYPES._LMCPROF_ProfileStandstill"/>
  )$UDINT;
#pragma pack(push, 1)
  _LMCPROFINTCMDCONFIG_THREADSAFE : STRUCT  //! <Type Comment="Move command flags" Name="_LMCPROFINTCMDCONFIG_THREADSAFE"/>
    Byte1 : BSINT
    [
      1 CmdActive,  //! <Type Comment="1: the movement calculations are finished." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.CmdActive"/>
      2 RapidTraverse,  //! <Type Comment="1: rapid traverse selected. The axis with the longest travelling distance moves with its maximum speed." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.RapidTraverse"/>
      3 FeedRateInterpolation,  //! <Type Comment="1: feed rate interpolation selected" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.FeedRateInterpolation"/>
      4 SecondTransition,  //! <Type Comment="0: this is the first transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected&#13;&#10;1: this is the second transition element of a LIN-CIR, CIR-LIN or CIR-CIR transition when _LMC_SMOOTH_PARAB is selected" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.SecondTransition"/>
      5 IsProgrammedExactStop,  //! <Type Comment="1: this path segment was programmed with TransitionMode:=_LMCPROF_EXACT_STOP" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.IsProgrammedExactStop"/>
      6 AfterSetPosCmd,  //! <Type Comment="1: The command before this one is a SetProfilePositions(). This command maybe needs to be recomputed." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte1.AfterSetPosCmd"/>
    ];
    Byte2 : BSINT
    [
      1 MoveCurvePathPerThousand,
      2 FreezeTangentialAxis,
      3 BackwardMovement,
      4 SpecialLinear_OrientateTangAx,
      5 EndlessMovement,
      6 MoveCurveStartPosAdaption,
      7 MoveCurveRotAxisCorrection,  //! <Type Comment="If this bit is set, then the position of axis 4 is determined with a 5th order spline to correct the rotatory axis position for decoupling from a rotatory disc." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte2.MoveCurveRotAxisCorrection"/>
      8 Bit8,
    ];
    Byte3 : BSINT
    [
      1 PathLenReduced,  //! <Type Comment="1: The pathlength was reduced when inserting a transition movement (spline etc.).&#13;&#10;The attainable leaving speed must be calculated new." Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte3.PathLenReduced"/>
      2 SmallPath,  //! <Type Comment="If the SmallLines functionality is enabled this bit indcates that the MoveSection is shorter than the maximum length for a SmallLine section.&#13;&#10;This bit may only be set for Moves of type _LMCMT_Linear" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte3.SmallPath"/>
      3 Bit3,
      4 Bit4,
      5 Bit5,
      6 Bit6,
      7 Bit7,
      8 Bit8,
    ];
    Byte4 : BSINT
    [
      1 RESERVED_Activated,  //! <Type Comment="this bit is only used in user buffer" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte4.RESERVED_Activated"/>
      2 RESERVED_WaitFinish,  //! <Type Comment="this bit is only used in user buffer" Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte4.RESERVED_WaitFinish"/>
      3 CmdStarted,  //! <Type Comment="1: " Name="_LMCPROFINTCMDCONFIG_THREADSAFE.Byte4.CmdStarted"/>
      4 Bit4,
      5 Bit5,
      6 Bit6,
      7 Bit7,
      8 Bit8,
    ];
  END_STRUCT;
#pragma pack(pop)
  _LMCPROFMOVEPROFILE :  //! <Type Comment="Type of profile" Name="_LMCPROFMOVEPROFILE"/>
  (
    RAMP_PROFILE,  //! <Type Comment="The movement is generated using ramp profiles, i.e. the path acceleration is rectangular and the path speed is a trapezoid.&#13;&#10;When braking to a lower path speed is needed, the lower speed is attained before the end of the path segment.&#13;&#10;The jerk is unlimited." Name="_LMCPROFMOVEPROFILE.RAMP_PROFILE"/>
    JERK_PROFILE  //! <Type Comment="Movements with jerk limitation are generated, i.e. the path jerk is rectangular and the path acceleration is a trapezoid." Name="_LMCPROFMOVEPROFILE.JERK_PROFILE"/>
  )$UDINT;
  _LMCPROFPARAMETER :  //! <Type Comment="_LMCProfile parameters" Name="_LMCPROFPARAMETER"/>
  (
    _LMCPROF_MaxOverride,  //! <Type Comment="Max. override value. Default value = 1000" Name="_LMCPROFPARAMETER._LMCPROF_MaxOverride"/>
    _LMCPROF_MinOverride,  //! <Type Comment="Min. override value. Default value = 0" Name="_LMCPROFPARAMETER._LMCPROF_MinOverride"/>
    _LMCPROF_SafetyZones,  //! <Type Comment="FALSE: Default value. The safety zones are not monitored.&#13;&#10;TRUE : the safety zone are monitored." Name="_LMCPROFPARAMETER._LMCPROF_SafetyZones"/>
    _LMCPROF_Max_Entries,  //! <Type Comment="Set the max. number of entries in the probile buffer.&#13;&#10;Can only be set before the last Init cycle." Name="_LMCPROFPARAMETER._LMCPROF_Max_Entries"/>
    _LMCPROF_NoOverrideChange,  //! <Type Comment="FALSE: Default value. When calling the LockProfile() method, the override is set to the 100 percent value automatically.&#13;&#10;TRUE : When calling the LockProfile() method, the override is not changed and therefore remains at the last value set." Name="_LMCPROFPARAMETER._LMCPROF_NoOverrideChange"/>
    _LMCPROF_ChkArcLength:=9,  //! <Type Comment="FALSE: Default value. Whether the arc length is the same as the chord length, is not tested.&#13;&#10;TRUE : If the arc length is the same as the chord length + 1, a linear movement is executed instead of a circular movement." Name="_LMCPROFPARAMETER._LMCPROF_ChkArcLength"/>
    _LMCPROF_NoChkAuxAxis:=10,  //! <Type Comment="FALSE: Default value. Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes and the limit values of the auxiliary axes.&#13;&#10;TRUE : Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes only." Name="_LMCPROFPARAMETER._LMCPROF_NoChkAuxAxis"/>
    _LMCPROF_OverrideType:=11,  //! <Type Comment="0: Default value. The override calculation is always based on the actual path speed of the path segment. &#13;&#10;1: The override calculation is based on the specified path speed of the path segment only. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation.&#13;&#10;2: The override calculation is based on the actual path speed. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation.&#13;&#10;" Name="_LMCPROFPARAMETER._LMCPROF_OverrideType"/>
    _LMCPROF_RoundConnectMode:=13,  //! <Type Comment="FALSE: Default value. The single axis movement at the segment transfer with tolerance sphere is always trapezoidal.&#13;&#10;TRUE : The single axis movement at the segment transfer with tolerance sphere is executed with a &quot;softer&quot; movement.&#13;&#10;       As the duration of the movement remains unchanged compared to the trapezoidal movement, temporarily the acceleration is higher than defined but the jerk is minimized." Name="_LMCPROFPARAMETER._LMCPROF_RoundConnectMode"/>
    _LMCPROF_aMinOverride:=14,  //! <Type Comment="The lower limit for the acceleration in [application units/s²]. The lower limit must be greater than null.&#13;&#10;" Name="_LMCPROFPARAMETER._LMCPROF_aMinOverride"/>
    _LMCPROF_ActVel:=15,  //! <Type Comment="Returns the current path speed." Name="_LMCPROFPARAMETER._LMCPROF_ActVel"/>
    _LMCPROF_ActAcc:=16,  //! <Type Comment="Returns the current path acceleration." Name="_LMCPROFPARAMETER._LMCPROF_ActAcc"/>
    _LMCPROF_MoveType:=17,  //! <Type Comment="Set the motion type:&#13;&#10;_RAMP_CURVE -&gt; the motion is defined by a ramp limiting velocity and acceleraation / deceleration&#13;&#10;_JERK_LIMIT -&gt; the motion is defined by a smooth function limiting velocity, acceleraation / deceleration and jerk" Name="_LMCPROFPARAMETER._LMCPROF_MoveType"/>
    _LMCPROF_LockState:=21,  //! <Type Comment="FALSE: Default value. Not all axis are locked.&#13;&#10;TRUE : All axis are locked.&#13;&#10;(just read)" Name="_LMCPROFPARAMETER._LMCPROF_LockState"/>
    _LMCPROF_Window,  //! <Type Comment="Set the window for ProfileInPosition() [application units]" Name="_LMCPROFPARAMETER._LMCPROF_Window"/>
    _LMCPROF_vSTART_F_IPO,  //! <Type Comment="Set the start speed of the feed rate interpolation [Appl.Units/s]." Name="_LMCPROFPARAMETER._LMCPROF_vSTART_F_IPO"/>
    _LMCPROF_NormOverride,  //! <Type Comment="Norm. override value. Default value = 1000" Name="_LMCPROFPARAMETER._LMCPROF_NormOverride"/>
    _LMCPROF_CheckAxisGroup,  //! <Type Comment="to deactivate the LockGroup check" Name="_LMCPROFPARAMETER._LMCPROF_CheckAxisGroup"/>
    _LMCPROF_AxisCount,  //! <Type Comment="defines how many axis are active (must be called when _Firstscan = 0)&#13;&#10;(default 6)" Name="_LMCPROFPARAMETER._LMCPROF_AxisCount"/>
    _LMCPROF_AddOffset,  //! <Type Comment="defines if the offset of the axis is already added to the server for the Position/Destination" Name="_LMCPROFPARAMETER._LMCPROF_AddOffset"/>
    _LMCPROF_Read_Decel,  //! <Type Comment="reads the actual maximal allowed deceleration value of the profile" Name="_LMCPROFPARAMETER._LMCPROF_Read_Decel"/>
    _LMCPROF_Read_Timebase,  //! <Type Comment="Read the RtWork() cycle time [ms]" Name="_LMCPROFPARAMETER._LMCPROF_Read_Timebase"/>
    _LMCPROF_LookAhead,  //! <Type Comment="defines how the profile should work with connected move-commands&#13;&#10;0: Default value. the move-command must calculate a&#13;&#10;   vNext, so it takes a bit more time, but the speed&#13;&#10;   of connected move-commands can be reached exactly at&#13;&#10;   the end of the further command&#13;&#10;1: there is no calculation of vNext, so the velocity&#13;&#10;   reaches the new target-velocity, when it would go&#13;&#10;   down to standstill" Name="_LMCPROFPARAMETER._LMCPROF_LookAhead"/>
    _LMCPROF_HalfCircleTolerance:=31,  //! <Type Comment="Tolerance-Window [application units] of the Endpoint of a Half-Circle. " Name="_LMCPROFPARAMETER._LMCPROF_HalfCircleTolerance"/>
    _LMCPROF_TransRad_ppTh,
    _LMCPROF_Set_LogMode,  //! <Type Comment="Change command logger settings.&#13;&#10;0: logging off&#13;&#10;1: log move commands and write commands&#13;&#10;2: log move commands and write commands plus request commands&#13;&#10;3: log move commands and write commands plus the method parameters (default)&#13;&#10;4: log move commands and write commands plus request commands plus the method parameters" Name="_LMCPROFPARAMETER._LMCPROF_Set_LogMode"/>
    _LMCPROF_ChkEndPosForSwLimit,  //! <Type Comment="1: (default) The Move... methods check its end positions for a violation of the software limits of the axes. In case the command will be rejected with _LMCPROF_SWE_ERROR.&#13;&#10;0: The Move.. methods do not check for software limit violations." Name="_LMCPROFPARAMETER._LMCPROF_ChkEndPosForSwLimit"/>
    _LMCPROF_ProfileInPos,  //! <Type Comment="TRUE ... actual position is used for exact stop&#13;&#10;FALSE ... set position is used for exact stop" Name="_LMCPROFPARAMETER._LMCPROF_ProfileInPos"/>
    _LMCPROF_ProfileInPos_Timeout,  //! <Type Comment="time, how long the _LMCProfile is waiting after an exact stop for the InPosition of the axes. If this time is exceeded a _LMCPROF_INPOSITION_TIMEOUT_ERROR occurs. [milliseconds]&#13;&#10;if Value &lt;= 0: timeout is disabled." Name="_LMCPROFPARAMETER._LMCPROF_ProfileInPos_Timeout"/>
    _LMCPROF_UNUSED,  //! <Type Comment="value 37 currently not in use" Name="_LMCPROFPARAMETER._LMCPROF_UNUSED"/>
    _LMCPROF_IncreaseLimit_SpeedWindow,  //! <Type Comment="for faster override control: maximal speed difference, which may be adjusted with higher limits [application units / sec]&#13;&#10;&#13;&#10;The parameters _LMCPROF_IncreaseLimit_FastAccel and/or _LMCPROF_IncreaseLimit_FastJerk have to be set too." Name="_LMCPROFPARAMETER._LMCPROF_IncreaseLimit_SpeedWindow"/>
    _LMCPROF_IncreaseLimit_FastAccel,  //! <Type Comment="for faster override control: maximal allowed acceleration/deceleration for small velocity changes [application units / sec^2]&#13;&#10;&#13;&#10;The parameter _LMCPROF_IncreaseLimit_SpeedWindow has to be set too." Name="_LMCPROFPARAMETER._LMCPROF_IncreaseLimit_FastAccel"/>
    _LMCPROF_IncreaseLimit_FastJerk,  //! <Type Comment="for faster override control: maximal allowed acceleration/deceleration for small velocity changes [application units / sec^3 * 1000]&#13;&#10;&#13;&#10;The parameter _LMCPROF_IncreaseLimit_SpeedWindow has to be set too." Name="_LMCPROFPARAMETER._LMCPROF_IncreaseLimit_FastJerk"/>
    _LMCPROF_AllowBigTransitionRadius,  //! <Type Comment="0: (default) every programmed transition radius is limited to the half path length of its path segment&#13;&#10;1: The programmed transition radius will only be limited to the whole path length." Name="_LMCPROFPARAMETER._LMCPROF_AllowBigTransitionRadius"/>
    _LMCPROF_SmallLines,  //! <Type Comment="When performing straight line moves with the CONT_DIRECT Transfer Mode, the SmallLines functionality allows the profile to recognize when a sudden change of direction occurs over a few small movements, the change in direction is then summed across these movements and the Profile-path velocity reduction is treated as if the change in direction occurred from one movement to another.&#13;&#10;This functionality is especially used where a Slicer program has produced a profile for the _LMCProfile to travel, such as is the case with 2D Laser- or Waterjetcutters, 3D Printers, etc.&#13;&#10;For further information on how velocity is handled with CONT_DIRECT and a sudden change in direction, see the Parameters and Help on: MaxTangError and VJump.&#13;&#10;&#13;&#10;This parameter defines the maximum length a straight line section can have to be recognized as a SmallLine section, it must be set longer than the small lines that the slicer program builds together to for a curve.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;0: Functionality is disabled.&#13;&#10;&gt;0: The Parameter indicates the path length in Application Units." Name="_LMCPROFPARAMETER._LMCPROF_SmallLines"/>
    _LMCPROF_SmallLines_Dist,  //! <Type Comment="See the Parameter _LMCPROF_SmallLines.&#13;&#10;&#13;&#10;This parameter defines the length that the sum of the SmallLines section can have, this should be set such that the length around a corner in the path is covered but not more.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;0: Functionality is disabled.&#13;&#10;&gt;0: The length to look back over the path in Application Units." Name="_LMCPROFPARAMETER._LMCPROF_SmallLines_Dist"/>
    _LMCPROF_DynamicType,  //! <Type Comment="define the unit of vel, acc and jerk for MoveLinear&#13;&#10;0 ... ApplicationUnits/s&#13;&#10;1 ... permill of the maximal values from SetBasicParameter" Name="_LMCPROFPARAMETER._LMCPROF_DynamicType"/>
    _LMCPROF_MinMoveDistance  //! <Type Comment="Allows the user to set a minimum move distance that is allowed to be travelled by MoveLinear when rounding is enabled. If a linear move with a smaller distance than defined and a smooth transfer mode (&gt; _LMCPROF_CONT_DIRECT) is added to the buffer, the move command is changed into _LMCPROF_NO_POS_CHANGE.&#13;&#10;This is used to avoid braking the profile unnecessarily when the points are very close to each other. E.g. Robot taught by hand.&#13;&#10;&#13;&#10;Value &lt;= 0 - The minimum move distance functionality is disabled.&#13;&#10;Value &gt; 0 - The minimum move distance is active." Name="_LMCPROFPARAMETER._LMCPROF_MinMoveDistance"/>
  )$UDINT;
  _LMCPROFPARAMETERAXIS :  //! <Type Comment="Type of axis parameter" Name="_LMCPROFPARAMETERAXIS"/>
  (
    _LMCPROF_AX_VEL_LIMIT,  //! <Type Comment="Axis velocity limit [Application units/s]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_VEL_LIMIT"/>
    _LMCPROF_AX_ACCEL_LIMIT,  //! <Type Comment="Axis acceleration limit [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_ACCEL_LIMIT"/>
    _LMCPROF_AX_TJERK,  //! <Type Comment="Jerk time [ms]. The time in which the acceleration increases linearly from zero to the maximum." Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_TJERK"/>
    _LMCPROF_AX_UNLOCK_DECEL,  //! <Type Comment="Axis deceleration to be used by UnlockProfile() [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_UNLOCK_DECEL"/>
    _LMCPROF_AX_MAX_VEL_JUMP,  //! <Type Comment="Axis velocity jump limit [Application units/s]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_MAX_VEL_JUMP"/>
    _LMCPROF_AX_INPOS_WINDOW,  //! <Type Comment="Position window [Application units]. Used by ProfileInPosition()." Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_INPOS_WINDOW"/>
    _LMCPROF_AX_LOCK_GRP,  //! <Type Comment="Number of the group to which the axis belongs" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_LOCK_GRP"/>
    _LMCPROF_AX_MAX_ACCEL_JUMP,  //! <Type Comment="Axis acceleration jump limit [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_MAX_ACCEL_JUMP"/>
    _LMCPROF_AX_DEC,  //! <Type Comment="Axis deceleration calculated from path [Application units/s²]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_DEC"/>
    _LMCPROF_AX_NOT_CHECK_SWLIMIT,  //! <Type Comment="handling of _LMCAxis.AxisError.SwMinError/SwMaxError&#13;&#10;0 ... the bits will be checked&#13;&#10;1 ... the bits will be ignored" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_NOT_CHECK_SWLIMIT"/>
    _LMCPROF_AX_SW_MIN_LIMIT,  //! <Type Comment="Reads the minimal software limit. [Application units]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_SW_MIN_LIMIT"/>
    _LMCPROF_AX_SW_MAX_LIMIT,  //! <Type Comment="Reads the maximal software limit. [application units]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_SW_MAX_LIMIT"/>
    _LMCPROF_AX_INPOS_WIN_ADDITIVELYCOUPLED,  //! <Type Comment="Position window used, if the axis is additively coupled with CoupleAdditivePosDiff or belt coupling is active [Application units]. Used by ProfileInPosition()." Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_INPOS_WIN_ADDITIVELYCOUPLED"/>
    _LMCPROF_AX_VEL_LIMIT_RAPID_TRAVERSE,  //! <Type Comment="axis velocity limit for rapid traverse [application units / sec]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_VEL_LIMIT_RAPID_TRAVERSE"/>
    _LMCPROF_AX_ACCEL_LIMIT_RAPID_TRAVERSE,  //! <Type Comment="axis acceleration limit for rapid traverse [application units / sec^2]" Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_ACCEL_LIMIT_RAPID_TRAVERSE"/>
    _LMCPROF_AX_TJERK_RAPID_TRAVERSE  //! <Type Comment="Jerk time [ms] for rapid traverse commands. The time in which the acceleration increases linearly from zero to the maximum." Name="_LMCPROFPARAMETERAXIS._LMCPROF_AX_TJERK_RAPID_TRAVERSE"/>
  )$UDINT;
  _LMCPROFPARAMETERGROUPS :  //! <Type Comment="Type of axes group parameter" Name="_LMCPROFPARAMETERGROUPS"/>
  (
    _LMCPROF_GRP_VEL_LIMIT,  //! <Type Comment="Path speed limit of an axes group [Application units/s]" Name="_LMCPROFPARAMETERGROUPS._LMCPROF_GRP_VEL_LIMIT"/>
    _LMCPROF_GRP_ACCEL_LIMIT,  //! <Type Comment="Path acceleration limit of an axes group [Application units/s²]" Name="_LMCPROFPARAMETERGROUPS._LMCPROF_GRP_ACCEL_LIMIT"/>
    _LMCPROF_GRP_TJERK  //! <Type Comment="During this time [ms], the acceleration&#13;&#10;increases from null to its maximum value" Name="_LMCPROFPARAMETERGROUPS._LMCPROF_GRP_TJERK"/>
  )$UDINT;
  _LMCPROFSETTINGS : BDINT  //! <Type Comment="Currently active profile settings." Name="_LMCPROFSETTINGS"/>
  [
    1 bInitDone,  //! <Type Comment="Set if the Last Init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bInitDone"/>
    2 bFirstInitDone,  //! <Type Comment="Set if the first init run was done&#13;&#10;This var is used for lock some SetPar Functions" Name="_LMCPROFSETTINGS.bFirstInitDone"/>
    3 bOverrideTyp,  //! <Type Comment="0: Default value. The type of Override is always based on the actual speed of the path segment. &#13;&#10;1: The type of Override is based on the specified speed of the path segment only. Limits of the path speed by circle limits, maximum speeds, etc. are not included in the override calculation." Name="_LMCPROFSETTINGS.bOverrideTyp"/>
    4 bNoOverrideChange,  //! <Type Comment="0: Default value. When calling the LockProfile() method, the override is set to the maximum value automatically.&#13;&#10;1: When calling the LockProfile() method, the override is not changed and therefore remains at the last values set." Name="_LMCPROFSETTINGS.bNoOverrideChange"/>
    5 bNoChkSWLimit,
    6 LogReadMethods,  //! <Type Comment="Additionally log request method calls" Name="_LMCPROFSETTINGS.LogReadMethods"/>
    7 LogMethodCallPlusParam,  //! <Type Comment="Additionally log the method parameters" Name="_LMCPROFSETTINGS.LogMethodCallPlusParam"/>
    8 bFatalError,  //! <Type Comment="Is set if the Init was not OK ... We have no Buffer memory" Name="_LMCPROFSETTINGS.bFatalError"/>
    9 bExtTrigger,  //! <Type Comment="0: RtWork() is called by the the operating system (default)&#13;&#10;1: RtWork() has to be called by the application" Name="_LMCPROFSETTINGS.bExtTrigger"/>
    10 bAxCount,  //! <Type Comment="This Bit indicates, if the user already set the number of used axis with the methode SetProfileParameter - _LMCPROF_AxisCount." Name="_LMCPROFSETTINGS.bAxCount"/>
    11 bChkArcLength,  //! <Type Comment="0: Default value. Whether the arc length is the same as the chord length, is not tested.&#13;&#10;1: If the arc length is the same as the chord length + 1, a linear movement is executed instead of a circular movement." Name="_LMCPROFSETTINGS.bChkArcLength"/>
    12 bNoChkAuxAxis,  //! <Type Comment="0: Default value. Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes and the limit values of the auxiliary axes.&#13;&#10;1: Path speed, path acceleration/deceleration and path jerk are limited by the limit values of the path axes only." Name="_LMCPROFSETTINGS.bNoChkAuxAxis"/>
    13 bWaitActPosition,  //! <Type Comment="0: the exact stop functions with the set position (default)&#13;&#10;1: the exact stop functions with the actual position" Name="_LMCPROFSETTINGS.bWaitActPosition"/>
    14 bNoLookAhead,  //! <Type Comment="0: Default value. the move-command must calculate a&#13;&#10;   vNext, so it takes a bit more time, but the speed&#13;&#10;   of connected move-commands can be reached exactly at&#13;&#10;   the end of the further command&#13;&#10;1: there is no calculation of vNext, so the velocity&#13;&#10;   reaches the new target-velocity, when it would go&#13;&#10;   down to standstill" Name="_LMCPROFSETTINGS.bNoLookAhead"/>
    15 bOverrideInitialized,
    16 bRoundConnectMode,  //! <Type Comment="FALSE: Default value. The single axis movement at the segment transfer with tolerance sphere is always trapezoidal.&#13;&#10;TRUE : The single axis movement at the segment transfer with tolerance sphere is executed with a &quot;softer&quot; movement.&#13;&#10;       As the duration of the movement remains unchanged compared to the trapezoidal movement, temporarily the acceleration is higher than defined but the jerk is minimized." Name="_LMCPROFSETTINGS.bRoundConnectMode"/>
    17 bCheckAxisGroup,  //! <Type Comment="False: the AxisGroup where checked&#13;&#10;True : no check of the AxisGroup" Name="_LMCPROFSETTINGS.bCheckAxisGroup"/>
    18 bNoOffsetposition,  //! <Type Comment="false = the Offsetposition is added to the server Position/Destination&#13;&#10;true = the Offsetposition is not added to the server Position/Destination" Name="_LMCPROFSETTINGS.bNoOffsetposition"/>
    21 bOverrideAxLimit,  //! <Type Comment="just has an effect with bOverrideTyp = 1&#13;&#10;FALSE --&gt; Default: The type of Override is based on the specified speed of the path segment only.&#13;&#10;TRUE  --&gt; The type of Override is based on the actual speed of the path segment." Name="_LMCPROFSETTINGS.bOverrideAxLimit"/>
    22 Axis_1_IsConnected,
    23 Axis_2_IsConnected,
    24 Axis_3_IsConnected,
    25 Axis_4_IsConnected,
    26 Axis_5_IsConnected,
    27 Axis_6_IsConnected,
    28 Axis_7_IsConnected,
    29 Axis_8_IsConnected,
    30 Axis_9_IsConnected,
    31 bLMCCNCIprMode,
    32 bAutoActivateCmd,  //! <Type Comment="This bit is used in in _LMCCNCInterpreter mode (bdProfileSettings.bLMCCNCIprMode=1). If set, a move cmd is activated immediately." Name="_LMCPROFSETTINGS.bAutoActivateCmd"/>
  ];
  _POSFLAGS : BDINT
  [
    1 SetSFF,  //! <Type Comment="0 .. the set velocity isn&apos;t written to the drive axis object (SFF)&#13;&#10;1 .. default :the set velocity is written to the drive axis object (SFF)" Name="_POSFLAGS.SetSFF"/>
    2 XWCalcInt,  //! <Type Comment="0 .. default : the contouring error is read directly from the drive axis object&#13;&#10;1 .. the contouring error is calculated in the DrivePosControl object&#13;&#10;" Name="_POSFLAGS.XWCalcInt"/>
    3 WaitPowerOff,  //! <Type Comment="0 ... do not wait for the OperationEnabled-Bit of the controlword&#13;&#10;1 .. default: wait for the OperationEnabled-Bit while poweroff" Name="_POSFLAGS.WaitPowerOff"/>
  ];
  _PVOIDL : ^USINT;
  _SDDAXISSTATE : BDINT
  [
    1 NoHW,
    2 NoParameter,
    3 NotOnline,
    4 NotInitialized,
    5 SFFLimitationActive,
    6 DiagModeActive,
  ];
  _SDDUSERCMD :  //! <Type Comment="Type for user commands to the drive. See Server &apos;SDDCmdIntfc&apos; of the &apos;_DriveAxis&apos; class." Name="_SDDUSERCMD"/>
  (
    _SDDIDLE,  //! <Type Comment="default command" Name="_SDDUSERCMD._SDDIDLE"/>
    _SDDREADALL,  //! <Type Comment="read all parameters of the drive &#13;&#10;  and save the parameters in the SRAM or in the file.&#13;&#10;  If any parameter classes are connected to the class SDDMngBase,&#13;&#10;  the servers of the parameter classes are refreshed." Name="_SDDUSERCMD._SDDREADALL"/>
    _SDDINIT,  //! <Type Comment="Initialize the drive with the saved parameters." Name="_SDDUSERCMD._SDDINIT"/>
    _SDDURINIT,  //! <Type Comment="Initialize the drive with the parameters of the table.&#13;&#10;  (Lasal2 table, User Table or default table)" Name="_SDDUSERCMD._SDDURINIT"/>
    _SDDEXDATA,  //! <Type Comment="Export the actual drive parameter into an excel formatted file." Name="_SDDUSERCMD._SDDEXDATA"/>
    _SDDEXDATAXML:=6,  //! <Type Comment="Export the actual drive parameter into an xml formatted file." Name="_SDDUSERCMD._SDDEXDATAXML"/>
    _SDDIMDATAXML,  //! <Type Comment="Imports the drive parameter from an xml formatted file. User commands &quot;_SDDINIT&quot; must be called to transfer the data to the drive." Name="_SDDUSERCMD._SDDIMDATAXML"/>
    _SDDERROR  //! <Type Comment="This value is shown, when the user commands &quot;_SDDEXDATAXML&quot; or &quot;_SDDIMDATAXML&quot; failed. See Log-File for details. New user commands can be set in this state." Name="_SDDUSERCMD._SDDERROR"/>
  )$UDINT;
  CanDeviceStateTxt :
  (
    cInitialising:=0,
    cDisconnecting:=1,
    cConnecting:=2,
    cPreparing:=3,
    cStopped:=4,
    cOperational:=5,
    cPreOperational:=127,
    cIdle:=255
  )$UDINT;
  CanObjStr : STRUCT  //! <Type Comment="Can object ( ID, Size and Data)" Name="CanObjStr"/>
    ID : HDINT;  //! <Type Comment="CAN ID of the message" Name="CanObjStr.ID"/>
    Size : DINT;  //! <Type Comment="The size of CAN data message" Name="CanObjStr.Size"/>
    Data : ARRAY [1..cMaxCanData] OF HSINT;  //! <Type Comment="The Data in CAN message" Name="CanObjStr.Data"/>
  END_STRUCT;
  cilPos :  //! <Type Comment="JdK 7-10-2019: changed for cilinder with 3 positions&#13;&#10;" Name="cilPos"/>
  (
    cilUnKnown:=0,
    cilIn:=1,
    cilOut:=2,
    cilMovingOut:=3,
    cilMovingOutShort:=4,
    cilOutShort:=5,
    cilMovingInShort:=6,
    cilInShort:=7,
    cilMovingIn:=8,
    cilNotConnected:=10,
    cilMovingMiddle:=11,
    cilMiddle:=12
  )$UDINT;
  CncFlags : BDINT
  [
    1 HwError,  //! <Type Comment="Hardware error Flag" Name="CncFlags.HwError"/>
    2 SwMin,  //! <Type Comment="Software endswitch minimum active" Name="CncFlags.SwMin"/>
    3 SwMax,  //! <Type Comment="Software endswitch maximum active" Name="CncFlags.SwMax"/>
    4 v_error,  //! <Type Comment="velocity setting error" Name="CncFlags.v_error"/>
    5 a_error,  //! <Type Comment="Acceleration / deceleration setting error" Name="CncFlags.a_error"/>
    6 ContrOff,  //! <Type Comment="position controller off" Name="CncFlags.ContrOff"/>
    7 NoRef,  //! <Type Comment="no position reference" Name="CncFlags.NoRef"/>
    8 DragLim,  //! <Type Comment="contouring error" Name="CncFlags.DragLim"/>
    9 ComandErr,  //! <Type Comment="Command is not exepted" Name="CncFlags.ComandErr"/>
    10 ActPosError,  //! <Type Comment="invalid position of the hardware" Name="CncFlags.ActPosError"/>
    11 IsNotControlling,  //! <Type Comment="wake and shake is active" Name="CncFlags.IsNotControlling"/>
    12 Follow,
    13 OverFlowError,
    16 GlobErr,  //! <Type Comment="Any other errors is active" Name="CncFlags.GlobErr"/>
  ];
#pragma pack(push, 1)
  CNCInternalStruct : STRUCT
    ptrExt : ^DINT;
    ptrInt : ^DINT;
    ptrBinOffset : ^DINT;
    NowOverflow : DINT;
    OverflowDelta : DINT;
    SetPos : DINT;
  END_STRUCT;
#pragma pack(pop)
  CntrFlgs : BDINT
  [
    1 InPosition,  //! <Type Comment="Axis is in position" Name="CntrFlgs.InPosition"/>
    2 FiltRdy,  //! <Type Comment="Axis is in position and jerk filter is ready" Name="CntrFlgs.FiltRdy"/>
    3 PosLimActive,  //! <Type Comment="Position limit is active, set position is over the SW end position" Name="CntrFlgs.PosLimActive"/>
    4 Decell,  //! <Type Comment="Deceleration is active" Name="CntrFlgs.Decell"/>
    5 bDynSWLimit,  //! <Type Comment="Set if axis has reached one of its dynamic SW endpositions" Name="CntrFlgs.bDynSWLimit"/>
    7 SetFlg,  //! <Type Comment="Set by calling the SetPositon, CNCRefRun and NCRefRun functions Reset after activating the controller." Name="CntrFlgs.SetFlg"/>
    10 EnLesFlg,  //! <Type Comment="Endless positioning is active" Name="CntrFlgs.EnLesFlg"/>
    11 DirFlg,  //! <Type Comment="Commanded axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.DirFlg"/>
    12 ActDirFlg,  //! <Type Comment="Actual axis direction (0 -&gt; positive, 1 -&gt; negative)" Name="CntrFlgs.ActDirFlg"/>
    13 EmergStop,  //! <Type Comment="Emergency stop is active" Name="CntrFlgs.EmergStop"/>
    14 AutoRun,  //! <Type Comment="Controller output autotuning is running" Name="CntrFlgs.AutoRun"/>
    15 AutoStop,  //! <Type Comment="Controller output autotuning is ready" Name="CntrFlgs.AutoStop"/>
    16 Test,  //! <Type Comment="Is only queried when ControllerOn is set to 0." Name="CntrFlgs.Test"/>
    17 NoActpos,  //! <Type Comment="The Client &quot;iActPosition&quot; is not connected" Name="CntrFlgs.NoActpos"/>
    18 Overflow,  //! <Type Comment="The axis has an internal position overflow." Name="CntrFlgs.Overflow"/>
    19 NoControl,  //! <Type Comment="The axis is not connected to a controller and the CNC therefore operates as a profile generator only." Name="CntrFlgs.NoControl"/>
    20 ModuloFlg,  //! <Type Comment="The axis is defined as a modulo axis." Name="CntrFlgs.ModuloFlg"/>
    21 NoActPosMeth,  //! <Type Comment="The &quot;iActPosition&quot; client is not connected to a server (axis operates without posi-tion feedback)." Name="CntrFlgs.NoActPosMeth"/>
    22 NoRefMeth,  //! <Type Comment="The &quot;iRefChannal&quot; is not connected" Name="CntrFlgs.NoRefMeth"/>
    23 NoControlMeth,  //! <Type Comment="The &quot;oSignalchannal&quot; client is not connected" Name="CntrFlgs.NoControlMeth"/>
    24 NoSpecial,  //! <Type Comment="The &quot;oPrecyclictrigger&quot; client is not connected" Name="CntrFlgs.NoSpecial"/>
    25 NCMotion,  //! <Type Comment="The CNC class is operated in NC mode" Name="CntrFlgs.NCMotion"/>
    26 NoActPosChk,
  ];
  DS402_Control : BDINT
  [
    1 SwitchOn,
    2 EnableVoltage,
    3 QuickStop,
    4 EnableOperation,
    5 OperationModeSpec1,
    6 OperationModeSpec2,
    7 OperationModeSpec3,
    8 ResetFault,
    9 Halt,
    10 Reserved1,
    11 Reserved2,
    12 ManufactureSpec1,
    13 ManufactureSpec2,
    14 ManufactureSpec3,
    15 ManufactureSpec4,
    16 ManufactureSpec5,
  ];
  DS402_State : BDINT
  [
    1 ReadyToSwitchOn,
    2 SwitchedOn,
    3 OperationEnabled,
    4 Fault,
    5 VoltageEnabled,
    6 QuickStop,
    7 SwitchOnDisabled,
    8 Warning,
    9 ManufactureSpec1,
    10 Remote,
    11 TargetReached,
    12 InternalLimitActive,
    13 OperationModeSpec1,
    14 OperationModeSpec2,
    15 ManufactureSpec2,
    16 ManufactureSpec3,
  ];
  eHMI_CmdPML :  //! <Type Comment="Standard command from HMI. Not all commands are&#13;&#10;meant for all kind off modules. But they just are ignored.&#13;&#10;&#13;&#10;Don&apos;t change numbers, they are used to convert the one&#13;&#10;type to the other" Name="eHMI_CmdPML"/>
  (
    nul:=0,
    mdReqAuto:=1,
    mdReqManual:=2,
    mdReqHalfAuto:=3,
    mdReqService:=4,
    mdReqReserve:=5,
    resetAlarms:=6,
    start:=7,
    stop:=8,
    cmd1:=9,
    cmd2:=10,
    cmd3:=11,
    cmd4:=12,
    stReqReset:=101,
    stReqStart:=103,
    stReqHold:=107,
    stReqUnHold:=109,
    stReqSuspend:=114,
    stReqUnSuspend:=116,
    stReqStop:=113,
    stReqAbort:=110,
    stReqClear:=112
  )$UDINT;
  eMillToolComp :
  (
    noComp,
    compPositiveMovement,
    compNegativeMovement
  )$UDINT;
  eMillType :
  (
    line:=0,
    circleCW:=1,
    circleCCW:=2,
    highSpeedLine:=3
  )$UDINT;
  eModePML :
  (
    auto:=0,  //! <Type Comment="In this mode only commands from&#13;&#10;software above are accepted&#13;&#10;" Name="eModePML.auto"/>
    manual:=1,  //! <Type Comment="In this mode only commands from HMI&#13;&#10;are accepted&#13;&#10;" Name="eModePML.manual"/>
    halfAuto:=2,  //! <Type Comment="In this mode only commands from HMI are&#13;&#10;accepted for this unit/em, but underlaying &#13;&#10;software only accepts commands from software&#13;&#10;above." Name="eModePML.halfAuto"/>
    service:=3,  //! <Type Comment="All kind off commands are accepted" Name="eModePML.service"/>
    reserve:=4  //! <Type Comment="Just reserve" Name="eModePML.reserve"/>
  )$UDINT;
  eSimuState :
  (
    noneSimu:=0,
    allSimu:=1,
    noMatSimu:=2,
    noActiveSimu:=4294967295
  )$UDINT;
  eStatePML :
  (
    Stopped:=0,
    Resetting:=1,
    Idle:=2,
    Starting:=3,
    Execute:=4,
    Completing:=5,
    Complete:=6,
    Holding:=7,
    Held:=8,
    UnHolding:=9,
    Aborting:=10,
    Aborted:=11,
    Clearing:=12,
    Stopping:=13,
    Suspending:=14,
    Suspended:=15,
    UnSuspending:=16,
    NotActive:=4294967295
  )$UDINT;
  eTypeMillProg :
  (
    normalProg,
    lineProg,
    squareProg,
    circleProg,
    drillProg:=4
  )$UDINT;
  EventModeTxt :
  (
    Event01Log,
    Event1xLog,
    TraceLog
  )$UDINT;
#pragma pack(push, 1)
  Failure : STRUCT
    One : BDINT
    [
    ];
    Two : BDINT
    [
    ];
  END_STRUCT;
#pragma pack(pop)
  feedPos :
  (
    fdUnKnown:=0,
    fdMovingFastFwd:=1,
    fdMovingFwd:=2,
    fdMovingBack:=4,
    fdWaitStopBack:=5,
    fdStopBack:=6,
    fdCompleteBack:=7
  )$UDINT;
  FeSetup : BDINT
  [
    1 Valid,  //! <Type Comment="must be 1 to Start FileEx work" Name="FeSetup.Valid"/>
    2 FileorRam,  //! <Type Comment="0= work in File 1= Work File" Name="FeSetup.FileorRam"/>
    3 EnableChecksum,  //! <Type Comment="0=no Checksum; 1=Calculate Checksum, increased write access on the CF card" Name="FeSetup.EnableChecksum"/>
    4 Encrypt,  //! <Type Comment="0=no encryption; 1=encrypt file, increased write access on the CF card" Name="FeSetup.Encrypt"/>
  ];
  IO_FLAG : BINT  //! <Type Comment="Status Flag für IO Daten" Name="IO_FLAG"/>
  [
    1 WrongHW,  //! <Type Comment="Falsche Hardware verbunden" Name="IO_FLAG.WrongHW"/>
    2 NoHW,  //! <Type Comment="Keine Hardware verbunden" Name="IO_FLAG.NoHW"/>
    3 NoCalibration,  //! <Type Comment="Keine Kalibrierungsdaten im Modul-EEPROM" Name="IO_FLAG.NoCalibration"/>
    4 ParaChkWrong,  //! <Type Comment="Die Parameter-Checksumme ist falsch" Name="IO_FLAG.ParaChkWrong"/>
    5 PhysicHiLimit,  //! <Type Comment="IO ist am oberen physikalischen Limit" Name="IO_FLAG.PhysicHiLimit"/>
    6 PhysicLoLimit,  //! <Type Comment="IO ist am unteren physikalischen Limit" Name="IO_FLAG.PhysicLoLimit"/>
    7 Invert,  //! <Type Comment="Daten sind invertiert" Name="IO_FLAG.Invert"/>
    14 OnDummyMode,  //! <Type Comment="1 = Objekt ist im Dummymodus (nicht refreshed)" Name="IO_FLAG.OnDummyMode"/>
    15 NotConnected,  //! <Type Comment="1 = Objekt ist nicht verbunden" Name="IO_FLAG.NotConnected"/>
    16 PhysicAccessOff,  //! <Type Comment="1 = kein physikalischer Zugriff erlaubt" Name="IO_FLAG.PhysicAccessOff"/>
  ];
#pragma pack(push, 1)
  IO_State : STRUCT
    uiIO_Flags : IO_FLAG;
    uiChNo : UINT;
  END_STRUCT;
#pragma pack(pop)
  IpAdrStr : ARRAY [0..15] OF CHAR;
#pragma pack(push, 1)
  LogRecStr : STRUCT
    Stepper : DINT;
    tElapsTime : UDINT;
    tOpsTime : UDINT;
  END_STRUCT;
#pragma pack(pop)
  longText : ARRAY [0..80] OF CHAR;
  MasterStruct : STRUCT  //! <Type Comment="Pointers to the master axis data" Name="MasterStruct"/>
    pos : ^DINT;  //! <Type Comment="Pointer to the master axis position [internal units]" Name="MasterStruct.pos"/>
    Speed : ^DINT;  //! <Type Comment="Pointer to the master axis speed [internal units / tick]" Name="MasterStruct.Speed"/>
    ModuloMaster : ^DINT;  //! <Type Comment="Pointer to ModuloInt of master axis [internal units]" Name="MasterStruct.ModuloMaster"/>
    PosLREAL : pVoid;  //! <Type Comment="pointer to a LREAL value cointainig the master position [internal units]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.PosLREAL"/>
    SpeedLREAL : pVoid;  //! <Type Comment="pointer to a LREAL value cointainig the master speed [internal units /tick]&#13;&#10;(this pointer is set and used only by _LMCAxis objects with MoveType=_JERK_PROFILE)" Name="MasterStruct.SpeedLREAL"/>
    pMasterThis : pVoid;  //! <Type Comment="pointer to the _LMCAxis master object" Name="MasterStruct.pMasterThis"/>
  END_STRUCT;
  motorPos :
  (
    moOff:=0,
    moChangeDir:=1,
    moWaitFeedback:=2,
    moStarting:=3,
    moRunning:=4
  )$UDINT;
  pcPlaneType :
  (
    top:=1,
    behind,  //! <Type Comment="&#13;&#10;" Name="pcPlaneType.behind"/>
    bottom,
    front,  //! <Type Comment="behind&#13;&#10;" Name="pcPlaneType.front"/>
    all:=5
  )$UDINT;
  pcUnitTypes :
  (
    sawUnit:=1,
    millUnit:=2,
    punchUnit:=3,
    drillUnit:=4,
    markUnit:=5,
    loaderUnit:=6,
    positionUnit:=7,
    clampUnit:=8,
    measureUnit:=9
  )$UDINT;
#pragma pack(push, 1)
  PDOStr : STRUCT
    Val1 : INT;
    Val2 : INT;
    Val3 : INT;
    Val4 : INT;
  END_STRUCT;
#pragma pack(pop)
  pHwBase : ^HwBase;
  pHwBaseCDIAS : ^HwBaseCDIAS;
  ProfileCommandStatus :
  (
    PassiveProfile,  //! <Type Comment="Axis are unlocked in passive mode" Name="ProfileCommandStatus.PassiveProfile"/>
    IdleProfile,  //! <Type Comment="Axis are locked in idle mode - no motion sequences are available" Name="ProfileCommandStatus.IdleProfile"/>
    RunProfile,  //! <Type Comment="Axes are in motion to generate a profile" Name="ProfileCommandStatus.RunProfile"/>
    EndProfile,  //! <Type Comment="The generated profile is finished now" Name="ProfileCommandStatus.EndProfile"/>
    ErrorProfile,  //! <Type Comment="An error occured" Name="ProfileCommandStatus.ErrorProfile"/>
    IdleProfileRestart,  //! <Type Comment="waiting for end of restart" Name="ProfileCommandStatus.IdleProfileRestart"/>
    WaitProfileRestart,  //! <Type Comment="waiting for end of delay time after calling ContinueNCProg()" Name="ProfileCommandStatus.WaitProfileRestart"/>
    WaitProfileForAxInPos  //! <Type Comment="profile is waiting for the actual axes position to be in position at an exact stop" Name="ProfileCommandStatus.WaitProfileForAxInPos"/>
  )$UDINT;
  rollersState :
  (
    rsUnknown,
    rsEmpty,
    rsFilled,
    rsMatAtTarget:=3
  )$UDINT;
  SafetyConfigStateType :
  (
    _ModuleNotFound,
    _SafetyClassOK,
    _ReinitConfig,
    _UnsafeVarNotFound,
    _ModFromCfgNotFound,
    _MemAllocFailed,
    _ReadFWVerFailed,
    _UnknownCfgError,
    _WaitForSynchronicity,
    _AsyncComError:=9,
    _DOsIncreasedRestartApp:=10,
    _LostPowerSupply:=11,
    _WrongSafetyHW:=12
  )$UDINT;
#pragma pack(push, 1)
  SafetyDiagInfo : STRUCT
    uControllerID : USINT;  //! <Type Comment="ID of µController (0 = µC1, else µC2)" Name="SafetyDiagInfo.uControllerID"/>
    ActErrorCode : USINT;  //! <Type Comment="actual error code" Name="SafetyDiagInfo.ActErrorCode"/>
    FirstErrorCode : USINT;  //! <Type Comment="code of first error that lead to an error state" Name="SafetyDiagInfo.FirstErrorCode"/>
    ReasonCode0 : UDINT;  //! <Type Comment="reason for error (meaning depends on actual error code)" Name="SafetyDiagInfo.ReasonCode0"/>
    ReasonCode1 : UDINT;  //! <Type Comment="reason for error (meaning depends on actual error code)" Name="SafetyDiagInfo.ReasonCode1"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  SafetyDiagState : STRUCT
    RunState : USINT;  //! <Type Comment=" 1..POST&#13;&#10; 2..SERVICE&#13;&#10; 4..ERROR&#13;&#10; 8..IDLE&#13;&#10;16..CHK_CFG&#13;&#10;32..OP_TEMP&#13;&#10;64..OP" Name="SafetyDiagState.RunState"/>
    ConfigState : USINT;  //! <Type Comment=" 1..INVALID&#13;&#10; 2..NOT_CONFIGURED&#13;&#10; 4..CONFIGURED_NOT_DEPLOYED_NOT_VERIFIED&#13;&#10; 8..CONFIGURED_AND_VERIFIED&#13;&#10;16..CONFIGURED_DEPLOYED_NOT_VERIFIED&#13;&#10;36..CONFIGURED_NOT_DEPLOYED_NOT_VERIFIED_DEV&#13;&#10;48..CONFIGURED_DEPLOYED_NOT_VERIFIED_DEV" Name="SafetyDiagState.ConfigState"/>
    LoginLevel : USINT;  //! <Type Comment="0..not logged in&#13;&#10;1..debug&#13;&#10;2..configuration&#13;&#10;3..general" Name="SafetyDiagState.LoginLevel"/>
    ErrorCounterIOState : UINT;  //! <Type Comment="Is increased on change of the error state of any input or output" Name="SafetyDiagState.ErrorCounterIOState"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  SDOStr : STRUCT  //! <Type Comment="SDO communication struct" Name="SDOStr"/>
    SdoId : HINT;  //! <Type Comment="CAN ID number" Name="SDOStr.SdoId"/>
    CmndCode : BSINT  //! <Type Comment="SDO action code" Name="SDOStr.CmndCode"/>
    [
    ];
    Index : UINT;  //! <Type Comment="Paramtere index" Name="SDOStr.Index"/>
    SIndex : USINT;  //! <Type Comment="Parameter sub index" Name="SDOStr.SIndex"/>
    Value : DINT;  //! <Type Comment="Value" Name="SDOStr.Value"/>
  END_STRUCT;
#pragma pack(pop)
  servoPos :
  (
    seStop:=0,
    seWaitReset:=1,
    seIdle:=2,
    seWaitStartMoveRef:=3,
    seStartMoveRef:=4,
    seMoveRef:=5,
    seWaitStartMove:=6,
    seStartMove:=7,
    seMove:=8,
    seMoveLastPiece:=9,
    seWaitInPos:=10,
    seWaitStartJogPos:=11,
    seStartJogPos:=12,
    seJogPos:=13,
    seWaitStartJogNeg:=14,
    seStartJogNeg:=15,
    seJogNeg:=16,
    seStartCoupling:=19,
    seWaitCoupling:=20,
    seWaitUnCoupling:=21,
    seCoupled:=22
  )$UDINT;
  Units : BDINT
  [
    1 BU1,  //! <Type Comment="Bewerkingsunit 1 tot 10&#13;&#10;verwachting is dat dit genoeg is&#13;&#10;dit gaat om boor pons en zaagunits&#13;&#10;" Name="Units.BU1"/>
    2 BU2,
    3 BU3,
    4 BU4,
    5 BU5,
    6 BU6,
    7 BU7,
    8 BU8,
    9 BU9,
    10 BU10,
    11 AV1,  //! <Type Comment="av staat voor ??&#13;&#10;dit gaat om het aanvoer- of afvoermagazijn" Name="Units.AV1"/>
    12 AV2,
    13 PU1,  //! <Type Comment="POSITIONEERUNIT, maximaal 2 beschikbaar&#13;&#10;eentje aan de aanvoer en eentje aan de afvoerkant" Name="Units.PU1"/>
    14 PU2,
    15 CL1,  //! <Type Comment="KLEM, van 1 tot 5 dit lijkt&#13;&#10;voorlopig genoeg.&#13;&#10;Misschien dat er nog meer bewerkings&#13;&#10;units of klemmen nodig zijn.&#13;&#10;Er is op deze manier ruimte tot 30 stuks" Name="Units.CL1"/>
    16 CL2,
    17 CL3,
    18 CL4,
    19 CL5,
    20 MU1,
    21 MU2,
    22 AV4,
    23 BU11,
    24 WaitForOutputList,
    25 AV3,
    26 BU12,
    27 BU13,
    28 CL6,
    29 CL7,
    30 CL8,
    31 CL9,
    32 DoWithOutput,
  ];
  tekst : ARRAY [0..24] OF CHAR;
#pragma pack(push, 1)
  SRegelInfo : STRUCT
    Rnr : DINT;
    Command : DINT;
    Amount : DINT;
    Units : Units;
    Offset : DINT;
    x1Pos : DINT;
    y1Pos : DINT;
    z1Pos : DINT;
    zy1Angle : DINT;
    xz1Angle : DINT;
    xy1Angle : DINT;
    actione : DINT;
    speed : DINT;
    toolID : DINT;
    tekst : tekst;
    level : DINT;
  END_STRUCT;
#pragma pack(pop)
  SRegelInfoArray : ARRAY [0..cMaxRegel] OF SRegelInfo;
#pragma pack(push, 1)
  StepLogStr : STRUCT
    Nr : DINT;  //! <Type Comment="Array offset for the next step.&#13;&#10;So this is the oldest step number in the FIFO." Name="StepLogStr.Nr"/>
    Logger : ARRAY [0..cSCbMaxLogArray] OF LogRecStr;  //! <Type Comment="Step numbers in sequance." Name="StepLogStr.Logger"/>
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  StepperDataStr : STRUCT
    First : DINT;  //! <Type Comment="First time in this step." Name="StepperDataStr.First"/>
    tTime : UDINT;  //! <Type Comment="Time this step is active in mSec." Name="StepperDataStr.tTime"/>
    StepLog : StepLogStr;  //! <Type Comment="Step numbers in sequance of excecution." Name="StepperDataStr.StepLog"/>
    StepperOld : DINT;  //! <Type Comment="Internal, Old stepper value." Name="StepperDataStr.StepperOld"/>
    tMark : UDINT;  //! <Type Comment="Internal, Ops.tAbsolute time when step was enterd for the first time." Name="StepperDataStr.tMark"/>
    OerInit : DINT;  //! <Type Comment="Internal, Detection this function is called for the first time." Name="StepperDataStr.OerInit"/>
    pActLog : ^LogRecStr;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  strMillLine : STRUCT
    millType : eMillType;
    xGoal : DINT;
    yGoal : DINT;
    radius : DINT;
    middleX : DINT;
    middleY : DINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  strMillPlane : STRUCT
    depth : DINT;
    amount : DINT;
    feedRate : DINT;  //! <Type Comment="speed in material in 1/10mm/s" Name="strMillPlane.feedRate"/>
    lowerRate : DINT;  //! <Type Comment="speed going into material in 1/10 mm/sec" Name="strMillPlane.lowerRate"/>
    lines : ARRAY [0..cMaxMillLinesInPlane] OF strMillLine;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  strMillRecipe : STRUCT
    description : ARRAY [0..20] OF CHAR;
    reqRPM : DINT;
    startX : DINT;  //! <Type Comment="for milling X is the way how the material is going through the machine,&#13;&#10;where positive is into the direction the material comes from &#13;&#10;(material is always going negative through the machine)" Name="strMillRecipe.startX"/>
    startY : DINT;  //! <Type Comment="for milling y direction is perpendicular to the x direction&#13;&#10;(of course, z direction is to) but also along the material" Name="strMillRecipe.startY"/>
    startZ : DINT;  //! <Type Comment="z direction for milling is into the material,&#13;&#10;negative movement is into it, so a value of +5mm &#13;&#10;means starting 5mm above the material" Name="strMillRecipe.startZ"/>
    xDimension : DINT;
    yDimension : DINT;
    yToolComp : eMillToolComp;  //! <Type Comment="needed to know if we have to calculate tool diam on positive or negative side&#13;&#10;" Name="strMillRecipe.yToolComp"/>
    offsetForXmovement : DINT;  //! <Type Comment="we try to start at maximum x position, but this doesn&apos;t always fit, because we can only go negative then&#13;&#10;" Name="strMillRecipe.offsetForXmovement"/>
    planes : ARRAY [0..cMaxMillPlanesInRecipe] OF strMillPlane;
    ToolId : DINT;
    typeMillProg : eTypeMillProg;
    Reserve1 : DINT;
    Reserve2 : DINT;
    Reserve3 : DINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 4)
  strStateReqPML : STRUCT
    ID : DINT;
    state : eStatePML;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 4)
  strPmlCom : STRUCT
    Active : DINT;
#pragma pack(push, 1)
    cmd : STRUCT
      interlock : DINT;
      mode : eModePML;
      state : eStatePML;
      simulation : eSimuState;
      reRun : DINT;
      resetAlarms : DINT;
    END_STRUCT;
#pragma pack(pop)
    sts : STRUCT
      stateReq : strStateReqPML;
      inAlarm : DINT;
      isInterlocked : DINT;
      stateCompleted : DINT;
      state : eStatePML;
      mode : eModePML;
      modesNotEqual : DINT;  //! <Type Comment="gives signal that modes of underlaying system are not equal" Name="strPmlCom.sts.modesNotEqual"/>
      moveReady : Units;
      actionReady : Units;
      allReady : DINT;
    END_STRUCT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  strProfileRecipe : STRUCT
    description : ARRAY [0..20] OF CHAR;
    reserveText : ARRAY [0..20] OF CHAR;
    exchangePartInputWagon : DINT;
    vertPosInputWagon : DINT;
    horPosInputWagon : DINT;
    heightBundleMagazin : DINT;
    widthBundleMagazin : DINT;
    exchangePrintPos : DINT;
    exchangePartMillPos1 : DINT;
    exchangePartMillPos2 : DINT;
    exchangePartMillPos3 : DINT;
    exchangePartSaw1 : DINT;
    exchangePartSaw2 : DINT;
    posMillClampsXdirection : DINT;
    posVertMillClamps : DINT;
    posHorMillClamps : DINT;
    posHorSawClamps : DINT;
    posGuidingRolSaw : DINT;
    guidingRolSawUpOrDown : DINT;
    posClampOutputWagon : DINT;
    useLeftBGsaw : DINT;
    useRightBGsaw : DINT;
    workSpeed : DINT;
    useBundleInput : DINT;
    startSawPos : DINT;
    endSawPos : DINT;
    sawSpeed : DINT;
    useDeburHoldCils : DINT;
    useBackGuidingMills : DINT;
    reserve1 : DINT;
    reserve2 : DINT;
    reserve3 : DINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  strTimer : STRUCT
    tmpTime : UDINT;
    done : DINT;
    lastTime : UDINT;
  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
  strToolRecipe : STRUCT
    description : ARRAY [0..20] OF CHAR;
    reserveText : ARRAY [0..20] OF CHAR;
    Id : DINT;
    diameter : DINT;
    length : DINT;
    speedRPM : DINT;
    reserve1 : DINT;
    reserve2 : DINT;
    reserve3 : DINT;
    reserve4 : DINT;
  END_STRUCT;
#pragma pack(pop)
  t_e_VaranErrors :
  (
    _ClassOk,
    _NotInitialized,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._NotInitialized"/>
    _CallBackError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._CallBackError"/>
    _RequiredError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._RequiredError"/>
    _RootError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._RootError"/>
    _NoHardware,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._NoHardware"/>
    _WrongHardware,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._WrongHardware"/>
    _CreateDOFailed,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._CreateDOFailed"/>
    _DirectAccessFailed,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._DirectAccessFailed"/>
    _PllError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._PllError"/>
    _TimeoutInInit,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._TimeoutInInit"/>
    _HardwareRequiredIRQ,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._HardwareRequiredIRQ"/>
    _HardwareNotRequiredIRQ,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._HardwareNotRequiredIRQ"/>
    _HardwareFatalErrorIRQ,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._HardwareFatalErrorIRQ"/>
    _ManagerError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._ManagerError"/>
    _DisableError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._DisableError"/>
    _EnableError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._EnableError"/>
    _MultipleError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._MultipleError"/>
    _SPIError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._SPIError"/>
    _ErrorBootImageFPGA,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._ErrorBootImageFPGA"/>
    _NoCDIASInterface,  //! <Type Comment="for CIV class" Name="t_e_VaranErrors._NoCDIASInterface"/>
    _EEPromError,  //! <Type Comment="for CIV class" Name="t_e_VaranErrors._EEPromError"/>
    _NoVaranInterface,  //! <Type Comment="for VaranMaster" Name="t_e_VaranErrors._NoVaranInterface"/>
    _MemoryFault,  //! <Type Comment="for VaranMaster" Name="t_e_VaranErrors._MemoryFault"/>
    _TimesliceError,  //! <Type Comment="for VaranMaster" Name="t_e_VaranErrors._TimesliceError"/>
    _TimesliceErrorIRQ,  //! <Type Comment="for VaranMaster" Name="t_e_VaranErrors._TimesliceErrorIRQ"/>
    _WatchdogError,  //! <Type Comment="for VaranMaster" Name="t_e_VaranErrors._WatchdogError"/>
    _VaranTimeError,  //! <Type Comment="for HwControl class" Name="t_e_VaranErrors._VaranTimeError"/>
    _DiasTimeError,  //! <Type Comment="for HwControl class" Name="t_e_VaranErrors._DiasTimeError"/>
    _DORamFull,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._DORamFull"/>
    _PortNoLink,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._PortNoLink"/>
    _VaranDriverNotExists,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._VaranDriverNotExists"/>
    _WrongDOLType,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._WrongDOLType"/>
    _WrongRunStatus,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._WrongRunStatus"/>
    _DOHandleInvalid,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._DOHandleInvalid"/>
    _DOCmdInvalid,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._DOCmdInvalid"/>
    _ManagerNotExists,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._ManagerNotExists"/>
    _DOLAddressInvalid,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._DOLAddressInvalid"/>
    _UnknownCommand,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._UnknownCommand"/>
    _ComponentNotExists,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._ComponentNotExists"/>
    _ClientNotExists,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._ClientNotExists"/>
    _CdiasEEPromNotExists,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._CdiasEEPromNotExists"/>
    _CdiasEEPromNoGrant,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._CdiasEEPromNoGrant"/>
    _CdiasEEPromNack,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._CdiasEEPromNack"/>
    _PortNotExists,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._PortNotExists"/>
    _PortIsUplink,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._PortIsUplink"/>
    _NoMutex,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._NoMutex"/>
    _NoTask,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._NoTask"/>
    _IDNotFound,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._IDNotFound"/>
    _IDNotInitialized,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._IDNotInitialized"/>
    _InvalidDeviceAddress,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._InvalidDeviceAddress"/>
    _CallbackNotHandled,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._CallbackNotHandled"/>
    _NoMem,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._NoMem"/>
    _NoLegacyWd,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._NoLegacyWd"/>
    _AdminDOLExecutionError,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._AdminDOLExecutionError"/>
    _DADOLExecutionError,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._DADOLExecutionError"/>
    _SPIFlashNoAccess,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._SPIFlashNoAccess"/>
    _ClientNotready,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._ClientNotready"/>
    _TimeoutVaran,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._TimeoutVaran"/>
    _UnknownFault,  //! <Type Comment="from VaranManager" Name="t_e_VaranErrors._UnknownFault"/>
    _DiasError,  //! <Type Comment="for CIC/DIV with Dias" Name="t_e_VaranErrors._DiasError"/>
    _DeviceError,  //! <Type Comment="for Varan hardwareclasses" Name="t_e_VaranErrors._DeviceError"/>
    _VaranTimeWarning,
    _OnlyASYSupported,
    _InvalidSerialNo,
    _CDIASRequiredError,
    _DIASRequiredError,
    _NoCalibDataFound,
    _ModuleFoundButManagerIsOff:=68,
    _InvalidConfguration,
    _ClientDisabled,
    _ClientCantEnable,
    _CdiasAddressInvalid,
    _SPIFlashInvalid,
    _SPIDOLIDInvalid,
    _SPIDOLInvalid,
    _SPIRequiredListError,
    _SPIChksumError,
    _ParameterInvalid,
    _DOTypeNotSupported,
    _DMAError,
    _PropertyIDInvalid,
    _PropertyValueInvalid,
    _DONumberOverflow,
    _APIUsageNotAllowed,
    _NodeTypeWrong,
    _DataLengthInvalid,
    _DOTypeInvalid,
    _OperationNotAllowed,
    _NodeNumberOverflow,
    _NoHandleFound,
    _TopologyNotAllowed
  )$UDINT;
#pragma pack(push, 1)
  t_s_ModulInfo : STRUCT
    Kennung : HINT;
    p_This : ^void;
  END_STRUCT;
#pragma pack(pop)
  tBewerkingType : BDINT
  [
    1 BU1_saw,
    2 BU2_undersaw,
    3 BU3_sdrill,
    4 BU4_udrill,
    5 BU5_sdrill,
    6 BU6_sdrill,
    7 BU7_udrill,
    8 BU8_sdrill,
    9 BU9_sdrill,
    10 BU10_umill,
    11 BU11_sdrill,
    12 BU12_umill,
    13 BU13_udrill,
    14 frontPiece,
    15 endPiece,
    16 wastePiece,
    17 wasteStop,
    18 transfer,
  ];
  tMyBDint : BDINT
  [
    1 b0,
    2 b1,
    3 b2,
    4 b3,
    5 b4,
    6 b5,
    7 b6,
    8 b7,
    9 b8,
    10 b9,
    11 b10,
    12 b11,
    13 b12,
    14 b13,
    15 b14,
    16 b15,
    17 b16,
    18 b17,
    19 b18,
    20 b19,
    21 b20,
    22 b21,
    23 b22,
    24 b23,
    25 b24,
    26 b25,
    27 b26,
    28 b27,
    29 b28,
    30 b29,
    31 b30,
    32 b31,
  ];
END_TYPE
