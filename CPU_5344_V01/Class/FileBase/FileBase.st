//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "FileBase"
	Revision           = "0.5"
	GUID               = "{FB75AAAA-C7AB-4A2A-BEA8-3AD610ACC4BB}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(450,180)"
	Comment            = "Handeling of file access">
	<Channels>
		<Server Name="ErrorNr" GUID="{F46EDE3A-76F2-4BFF-B9AA-3F7231086861}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Server0" GUID="{E8C0E034-E25B-49A7-A350-88AFE1F58EC7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="FileOs" Required="false" Internal="false" Comment="Interface to Os file"/>
		<Client Name="System" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\FileBase\FileBase.h" Include="false"/>
		</Files>
	</Dependencies>
</Class>
*)
FileBase : CLASS
	TYPE
	  TestStr : STRUCT
	    Letter : CHAR;
	    SourcePtr : HDINT;
	    DestPtr : HDINT;
	    Offset : DINT;
	  END_STRUCT;
	END_TYPE
  //Servers:
	Server0 	: SvrChCmd_DINT;
	ErrorNr 	: SvrCh_DINT;
  //Clients:
	FileOs 	: CltChCmd_File_IO;
	System 	: CltChCmd_System;
  //Variables:
		Handle 	: DINT;
		FileSize 	: DINT;
		SysDate 	: SYSDATE;
		SysTime 	: SYSTIME;
		Test 	: TestStr;
		tmp : ARRAY [0..255] OF CHAR;

		tmpTarget : ARRAY [0..255] OF CHAR;

  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildValue2Ascii"/>
	FUNCTION VIRTUAL GLOBAL BuildValue2Ascii
		VAR_INPUT
			Value 	: DINT;			//! <Variable Comment="Value to be converted to an Ascii string" Name="BuildValue2Ascii.Value"/>
			Dest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine." Name="BuildValue2Ascii.Dest"/>
			Offset 	: DINT;			//! <Variable Comment="Offset in destination string, must be less than cMaxAsciiLine." Name="BuildValue2Ascii.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of string without &apos;nil&apos;." Name="BuildValue2Ascii.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Gets system time and convets it to an Ascii string.&#13;&#10;&#13;&#10;Mode determins the format.&#13;&#10; 0 :  &quot;hh:mm:ss&quot; in 24 hour mode. ( Default)&#13;&#10; 1 :  &quot;hh:mm:ss xm&quot; in 12 hour mode.&#13;&#10; See &quot;BuildTime()&quot; for further information on mode.&#13;&#10;&#13;&#10; 24 hour mode is from 00:01 to 24:00.&#13;&#10; 12 hour mode is with &quot;am&quot; (00:00 to 11:59) and &quot;pm&quot; (12:00 to 23:59).&#13;&#10;    But the time is from 00:00 to 12:59 and than from 01:00 to 23:59.&#13;&#10;&#13;&#10;" Name="BuildSysTime"/>
	FUNCTION VIRTUAL GLOBAL BuildSysTime
		VAR_INPUT
			Mode 	: DINT;			//! <Variable Comment="Date format. If an un implemented mode is selected then mode 0 will be used." Name="BuildSysTime.Mode"/>
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Convert the source date to an Ascii string.&#13;&#10;&#13;&#10;Mode determins the format.&#13;&#10; 0 :  &quot;yyyy-mm-dd&quot; ( Default)&#13;&#10; 1 :  &quot;dd-mm-yyyy&quot;.&#13;&#10; 2 : ?&#13;&#10;&#13;&#10;" Name="BuildSysDate"/>
	FUNCTION VIRTUAL GLOBAL BuildSysDate
		VAR_INPUT
			Mode 	: DINT;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Convert the source time to an Ascii string.&#13;&#10;&#13;&#10;Mode determins the format.&#13;&#10; 0 :  &quot;hh:mm:ss&quot; in 24 hour mode. ( Default)&#13;&#10; 1 :  &quot;hh:mm:ss xm&quot; in 12 hour mode.&#13;&#10; 2 : &quot;[h]h:[m]m:[s]s xm&quot; in 12 hour mode.&#13;&#10; 3 : ?&#13;&#10;&#13;&#10; 24 hour mode is from 00:01 to 24:00.&#13;&#10; 12 hour mode is with &quot;am&quot; (00:00 to 11:59) and &quot;pm&quot; (12:00 to 23:59).&#13;&#10;    But the time is from 00:00 to 12:59 and than from 01:00 to 23:59.&#13;&#10;&#13;&#10;" Name="BuildTime"/>
	FUNCTION VIRTUAL GLOBAL BuildTime
		VAR_INPUT
			Mode 	: DINT;
			Source 	: SYSTIME;			//! <Variable Comment="Pointer to a string where the Ascii string is to be found." Name="BuildTime.Source"/>
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Convert the source date to an Ascii string.&#13;&#10;&#13;&#10;Mode determins the format.&#13;&#10; 0 :  &quot;yyyy-mm-dd&quot; ( Default)&#13;&#10; 1 :  &quot;dd-mm-yyyy&quot;.&#13;&#10; 2 : &quot;[d]d-[m]m-[yyy]y&quot;&#13;&#10; 3 : ?&#13;&#10;&#13;&#10;" Name="BuildDate"/>
	FUNCTION VIRTUAL GLOBAL BuildDate
		VAR_INPUT
			Mode 	: DINT;
			Source 	: SYSDATE;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildSeperator"/>
	FUNCTION VIRTUAL GLOBAL BuildSeperator
		VAR_INPUT
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildEOL"/>
	FUNCTION VIRTUAL GLOBAL BuildEOL
		VAR_INPUT
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="StingCopy"/>
	FUNCTION VIRTUAL GLOBAL StingCopy
		VAR_INPUT
			Source 	: ^CHAR;
			Dest 	: ^CHAR;
			offset 	: DINT;
			Length 	: DINT;			//! <Variable Comment="Length of thestring to be copied to file" Name="StingCopy.Length"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="ConvAscii2Value"/>
	FUNCTION VIRTUAL GLOBAL ConvAscii2Value
		VAR_INPUT
			Source 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;			//! <Variable Comment="The converted Ascii value" Name="ConvAscii2Value.Value"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Copy a string from begin to a Seperator or a &apos;Nil&apos;,&apos;CR&apos;,&apos;LF&apos;.&#13;&#10;" Name="Read2Seperator"/>
	FUNCTION VIRTUAL GLOBAL Read2Seperator
		VAR_INPUT
			Source 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Read2Seperator_or_Space
		VAR_INPUT
			Sourc 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Read2TowPosAfterKomma
		VAR_INPUT
			Sourc 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Read2Comma
		VAR_INPUT
			Sourc 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Copy a string from begin to a CR or a &apos;Nil&apos;.&#13;&#10;" Name="Read2CR"/>
	FUNCTION VIRTUAL GLOBAL Read2CR
		VAR_INPUT
			Source 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Copy a string from begin to a Seperator or a &apos;Nil&apos;.&#13;&#10;" Name="Read2Nil"/>
	FUNCTION VIRTUAL GLOBAL Read2Nil
		VAR_INPUT
			Source 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Clears a Ascii text line.&#13;&#10;A line is cleared by placing a &apos;Nil&apos; Caracter at&#13;&#10; the first position of the string.&#13;&#10;" Name="ClearLine"/>
	FUNCTION VIRTUAL GLOBAL ClearLine
		VAR_INPUT
			Dest 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OpenFile
		VAR_INPUT
			FileName 	: ^CHAR;
			Attribute 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="Help" Name="OpenFile.Result"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="CloseFile"/>
	FUNCTION VIRTUAL GLOBAL CloseFile
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;This method looks for Names in a DataTable to be found by a name type.&#13;&#10; The table has the following formats&#13;&#10;  SizeOf( Table)   // [DINT] The size of the data table is automaticaly generated by LASAL and not visable.&#13;&#10;  &apos;x&apos;,&quot;My First Text&quot;,&#13;&#10;  &apos;x&apos;,&quot;My Second Text&quot;,&#13;&#10;  &apos;x&apos;,&quot;...&quot;,&#13;&#10; &apos;x&apos;    is the name type.&#13;&#10; &quot;...&quot;  is the name to be copied&#13;&#10; Always a &apos;,&apos; at the end. This places a NIL char at the end of the string.&#13;&#10;" Name="FindName"/>
	FUNCTION VIRTUAL GLOBAL FindName
		VAR_INPUT
			NameType 	: CHAR;			//! <Variable Comment="Type of name to be found" Name="FindName.NameType"/>
			Source 	: ^CHAR;
			SOffset 	: DINT;			//! <Variable Comment="Offset in source Table. This is nessesary to find next name of the same &quot;NameType&quot;." Name="FindName.SOffset"/>
		END_VAR
		VAR_OUTPUT
			Offset 	: DINT;			//! <Variable Comment="0..4= Can&apos;t find the name type. For the header of the file is already added." Name="FindName.Offset"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Write a string of length length from source to file.&#13;&#10;" Name="WriteFile"/>
	FUNCTION VIRTUAL GLOBAL WriteFile
		VAR_INPUT
			Source 	: ^CHAR;
			Length 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Read a string from file to a LF or a &apos;Nil&apos;. CR must be followed by a LF.&#13;&#10;" Name="ReadFile"/>
	FUNCTION VIRTUAL GLOBAL ReadFile
		VAR_INPUT
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SkipSpaces
		VAR_INPUT
			ptr 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL FindNumber
		VAR_INPUT
			Src 	: ^CHAR;
			Start 	: DINT;
		END_VAR
		VAR_OUTPUT
			Pos 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL Read2Variable
		VAR_INPUT
			Sourc 	: ^CHAR;
			Dest 	: ^CHAR;
			Offset 	: DINT;
			Variable 	: CHAR;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL CheckGelijk
		VAR_INPUT
			Sourc 	: ^CHAR;
			Sourc2 	: ^CHAR;
			length 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Gelijk 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadValueAfterString
		VAR_INPUT
			Sourc 	: ^CHAR;
			Sourc2 	: ^CHAR;
			lengthSourc2 	: DINT;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadStringAfterString
		VAR_INPUT
			Sourc 	: ^CHAR;
			Sourc2 	: ^CHAR;
			Dest 	: ^CHAR;
			lengthSourc2 	: DINT;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvAscii2ValueStopAtKomma
		VAR_INPUT
			Sourc 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvAscii2BDINT
		VAR_INPUT
			sourc 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			output 	: BDINT;
		END_VAR;
	
	FUNCTION GLOBAL StringTurnAround
		VAR_INPUT
			Sourc 	: ^CHAR;
			Dest 	: ^CHAR;
			Length 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SkipStringZeros
		VAR_INPUT
			Ptr 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL StrReplace
		VAR_INPUT
			Sourc 	: ^CHAR;
			Replace 	: USINT;
			ReplaceWith 	: USINT;
			Offset 	: DINT;
			Length 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadFileAndEnter
		VAR_INPUT
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadFileSkipLineFeeds
		VAR_INPUT
			Dest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd File_IO
#pragma usingLtd System


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB FileBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_FILEBASE
0$UINT, 5$UINT, (SIZEOF(::FileBase))$UINT, 
2$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1689253198), "FileBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::FileBase.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
(::FileBase.ErrorNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3474608145), "ErrorNr", 
//Clients:
(::FileBase.FileOs.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(523274688), "FileOs", TO_UDINT(51451934), "File_IO", 0$UINT, 1$UINT, 
(::FileBase.System.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(968218125), "System", TO_UDINT(968218125), "System", 0$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_FileBase 18

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_FileBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION FileBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_FileBase, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #BuildValue2Ascii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #BuildSysTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #BuildSysDate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #BuildTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #BuildDate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #BuildSeperator();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #BuildEOL();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #StingCopy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ConvAscii2Value();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #Read2Seperator();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #Read2CR();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #Read2Nil();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #ClearLine();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #OpenFile();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #CloseFile();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #FindName();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #WriteFile();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #ReadFile();

#pragma warning (default : 74)
	Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\FileBase\FileBase_00_00.st*********************



 




(*
 *
 *	00:05	30/11/2005	#JE
 * - Prepare for conversion to LASAL2 so ENUM's and STRUCT's must be converted to type's.
 *
 *	00:04	15/04/2005	#JE
 * - In method "FindName" corrected for finding char on the first position.
 * - In method "ReadFile" end test on LF. So CR is ignored so must always be followed by an LF.
 *
 *	00:03	30/06/2004	#JE
 * - The test in the "FileBase" class, if writing to file command has been successfully stored, has been corrected.
 * - Implementing of trace messages.
 *
 *	00:02	24/05/2004	#JE
 * - If "ReadFile" reads a file shorter than I expect then "Size" will be 0 and Dest will start with a "NIL".
 *
 *)

//[#ENGLISH]
(*
 * This class handles 1 file at the time and reads and writes to this file.
 *
 * Server0
 *	0		: Size of the file or no Size available.
 *	-1		: Can't open a second file per 'FileBase' Class.
 *	-2		: Can't open a file.
 *	-3		: Can't write to file beqause there is no handle.
 *	-4		: Can't write the whole word to file.
 *	-5		: Can't write the whole string to file.
 *
 *)
FUNCTION VIRTUAL GLOBAL FileBase::Init

END_FUNCTION //VIRTUAL GLOBAL FileBase::Init
//[#ENGLISH]
//Clears a Ascii text line.
//A line is cleared by placing a 'Nil' Caracter at
//	the first position of the string.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
FUNCTION VIRTUAL GLOBAL FileBase::ClearLine
VAR_INPUT
	Dest		: ^CHAR;
END_VAR

#IfDef TestJE
	Var
		i	: Dint;
	End_Var;
	// Fill with space for test
	For i:= 0 to cMaxAsciiLine Do
		Dest^	:= cTestChar;	// Nil$Char;
		Dest	+= 1;
	End_For;
	// Last is nil
	Dest	-= 1;
	Dest^	:= Nil$Char;
#Else
	Dest^	:= Nil$Char;
#EndIf

END_FUNCTION //VIRTUAL GLOBAL FileBase::Clearline
//[#ENGLISH]
//[>Source]Pointer to the first char of an Ascii value
//[<Value]The converted Ascii value
FUNCTION VIRTUAL GLOBAL FileBase::ConvAscii2Value
VAR_INPUT
	Source		: ^CHAR;
END_VAR
VAR_OUTPUT
	Value		: DINT;
END_VAR
Var
	i			: DINT;
	Sign		: DINT;
End_Var;

Sign := 1;
Value:= 0;
For i:= 0 to 20 Do
	Case Source^ of
	0..US, Separator, 16#2C  : 
		// The end
		i	:= 20;
	'-':
		// It is a negative value
		Sign := -1;
	'0'..'9':
		// convert to DINT
		Value	*= 10;
		Value	+= To_Dint( Source^- '0');
	End_Case;
	Source	+= 1;
End_For;

Value *= Sign;

END_FUNCTION //VIRTUAL GLOBAL FileBase::ConvAscii2Value
//[#ENGLISH]
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
FUNCTION VIRTUAL GLOBAL FileBase::BuildEOL
VAR_INPUT
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

Size	:= 0;
If (Offset + 2) <= cMaxAsciiLine Then
	(Dest + Offset)^	:= CRASC;
	Offset	+= 1;
	(Dest + Offset)^	:= LF;
	Offset	+= 1;
	(Dest + Offset)^	:= Nil$Char;
	Size	:= 2;
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::BuildEOL
//[#ENGLISH]
//Copy a string from begin to a Seperator or a 'Nil'.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::Read2Nil
VAR_INPUT
	Source		: ^CHAR;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
VAR
	i		: DINT;
END_VAR

Size:= 0;
Dest	+= Offset;
Test.SourcePtr	:= Source$UDint;
Test.DestPtr	:= Dest$UDint;
For i:= 0 to cMaxAsciiLine Do
	If Offset < cMaxAsciiLine Then
		Test.Letter	:= Source^;
		Dest^	:= Source^;
		Case Source^ of
		0:
			Dest^	:= Nil$Char;
			i	:= cMaxAsciiLine;
		Else
			Size	+= 1;
			Offset	+= 1;
			Source	+= 1;
			Dest	+= 1;
		End_Case;
	Else
		Dest^	:= Nil$Char;
		Size:= 0;
		i	:= cMaxAsciiLine;
	End_If;
End_For;


END_FUNCTION //VIRTUAL GLOBAL FileBase::Read2Nil
//[#ENGLISH]
//Copy a string from begin to a CR or a 'Nil'.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::Read2CR
VAR_INPUT
	Source		: ^CHAR;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
VAR
	i		: DINT;
END_VAR

Size:= 0;
Dest	+= Offset;
For i:= Offset to cMaxAsciiLine Do
	If Offset < cMaxAsciiLine Then
		Dest^	:= Source^;
		Case Source^ of
		0, CRASC:
			Dest^	:= Nil$Char;
			i	:= cMaxAsciiLine;
		Else
			Size	+= 1;
			Offset	+= 1;
			Source	+= 1;
			Dest	+= 1;
		End_Case;
	Else
		Dest^	:= Nil$Char;
		Size:= 0;
		i	:= cMaxAsciiLine;
	End_If;
End_For;

END_FUNCTION //VIRTUAL GLOBAL FileBase::Read2CR
//[#ENGLISH]
//Copy a string from begin to a Seperator or a 'Nil','CR','LF'.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::Read2Seperator
VAR_INPUT
	Source		: ^CHAR;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
VAR
	i		: DINT;
END_VAR

Size:= 0;
Dest	+= Offset;
For i:= 0 to cMaxAsciiLine Do
	If Offset < cMaxAsciiLine Then
		Dest^	:= Source^;
		Case Source^ of
		0, CRASC, LF, Separator, 16#2C:
			Dest^	:= Nil$Char;
			i	:= cMaxAsciiLine;
		Else
			Size	+= 1;
			Offset	+= 1;
			Source	+= 1;
			Dest	+= 1;
		End_Case;
	Else
		Dest^	:= Nil$Char;
		Size:= 0;
		i	:= cMaxAsciiLine;
	End_If;
End_For;

END_FUNCTION //VIRTUAL GLOBAL FileBase::Read2Seperator
//[#ENGLISH]
//[>Value]Value to be converted to an Ascii string
//[>Dest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
FUNCTION VIRTUAL GLOBAL FileBase::BuildValue2Ascii
VAR_INPUT
	Value		: DINT;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
	i		: Dint;
	ii		: Dint;
	Temp	: Array[0..11] of CHAR;
End_Var

Size	:= -1;
// Test for sign
If Value< 0 then
	If Offset < cMaxAsciiLine Then
		(Dest + Offset)^	:= '-';
		Offset	+= 1;
		Size	+= 1;
		Value	*= -1;
	Else
		offset	:= cMaxAsciiLine;
	End_If;
End_If;
// Convert to Ascii
i	:= 0;
ii	:= 10;
Temp[11]:= Nil$Char;
Repeat
		Temp[ii]	:= To_Usint( Value mod 10)+ '0';
		Value	/= 10;
		i		+= 1;
		ii		-= 1;
Until Value= 0 End_Repeat;

// always 1 char
//If i<= 0 Then i:= 1; End_If;
// Place most left
If Offset+ i<= cMaxAsciiLine Then
	For ii:= 11-i to 11 Do
		(Dest + Offset)^	:= Temp[ii];
		Offset	+= 1;
		Size	+= 1;
	End_For;
Else
	size	:= 0;
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::BuildValue2Ascii
//[#ENGLISH]
//Gets system time and convets it to an Ascii string.
//
//Mode determins the format.
//	0	: 	"hh:mm:ss" in 24 hour mode.	( Default)
//	1	: 	"hh:mm:ss xm" in 12 hour mode.
//	See "BuildTime()" for further information on mode.
//
// 24 hour mode is from 00:01 to 24:00.
// 12 hour mode is with "am" (00:00 to 11:59) and "pm" (12:00 to 23:59).
//				But the time is from 00:00 to 12:59 and than from 01:00 to 23:59.
//
//[>Mode]Time format. If an un implemented mode is selected then mode 0 will be used
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
FUNCTION VIRTUAL GLOBAL FileBase::BuildSysTime
VAR_INPUT
	Mode		: DINT;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

System.GetSysTime( time0	:= #SysTime);
Size	:= BuildTime( Mode		:= Mode
					, Source	:= SysTime
					, Dest		:= Dest
					, Offset	:= Offset);

END_FUNCTION //VIRTUAL GLOBAL FileBase::BuildSysTime
//[#ENGLISH]
//Convert the source time to an Ascii string.
//
//Mode determins the format.
//	0	: 	"hh:mm:ss" in 24 hour mode.	( Default)
//	1	: 	"hh:mm:ss xm" in 12 hour mode.
//	2	:	"[h]h:[m]m:[s]s xm" in 12 hour mode.
//	3	:	?
//
// 24 hour mode is from 00:01 to 24:00.
// 12 hour mode is with "am" (00:00 to 11:59) and "pm" (12:00 to 23:59).
//				But the time is from 00:00 to 12:59 and than from 01:00 to 23:59.
//
//[>Mode]Time format. If an un implemented mode is selected then mode 0 will be used
//[>Source]Time to be converted in a standerd time format.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
FUNCTION VIRTUAL GLOBAL FileBase::BuildTime
VAR_INPUT
	Mode		: DINT;
	Source		: SYSTIME;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
	AmPm	: Dint;
	TSize	: Dint;
	TempPtr	: ^CHAR;
End_Var;

Size	:= 0;
Case Mode Of
1:		// "hh:mm:ss xm" in 12 hour mode.
	If (Offset + 11) <= cMaxAsciiLine Then
		Size	:= 11;
		TempPtr	:= Dest + Offset;
		If Source.wHour < 12 Then
			AmPm	:= 0;
		Else
			AmPm	:= 1;
		End_If;
		If Source.wHour >= 13 Then
			Source.wHour	-= 12;
		End_If;
		// hour
		If Source.wHour < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wHour
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= ':';
		TempPtr	+= 1;
		// Minute
		If Source.wMinute < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wMinute
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= ':';
		TempPtr	+= 1;
		// Seconds
		If Source.wSecond < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wSecond
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= ' ';
		TempPtr	+= 1;
		// am pm
		If AmPm= 0 Then
			TempPtr^:= 'a';
			TempPtr	+= 1;
			TempPtr^:= 'm';
			TempPtr	+= 1;
		Else
			TempPtr^:= 'p';
			TempPtr	+= 1;
			TempPtr^:= 'm';
			TempPtr	+= 1;
		End_If;
		TempPtr^	:= Nil$Char;
	End_If;
2:		// "[h]h:[m]m:[s]s xm" in 12 hour mode.
	If (Offset + 11) <= cMaxAsciiLine Then
		Size	:= 0;
		TempPtr	:= Dest + Offset;
		If Source.wHour < 12 Then
			AmPm	:= 0;
		Else
			AmPm	:= 1;
		End_If;
		If Source.wHour >= 13 Then
			Source.wHour	-= 12;
		End_If;
		// hour
		TSize	:= BuildValue2Ascii(Value	:= Source.wHour
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr	+= TSize;
		Size	+= TSize;
		TempPtr^:= ':';
		TempPtr	+= 1;
		Size	+= 1;
		// Minute
		TSize	:= BuildValue2Ascii(Value	:= Source.wMinute
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr	+= TSize;
		Size	+= TSize;
		TempPtr^:= ':';
		TempPtr	+= 1;
		Size	+= 1;
		// Seconds
		TSize	:= BuildValue2Ascii(Value	:= Source.wSecond
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr	+= TSize;
		Size	+= TSize;
		TempPtr^:= ' ';
		TempPtr	+= 1;
		Size	+= 1;
		// am pm
		If AmPm= 0 Then
			TempPtr^:= 'a';
			TempPtr	+= 1;
			TempPtr^:= 'm';
			TempPtr	+= 1;
			Size	+= 2;
		Else
			TempPtr^:= 'p';
			TempPtr	+= 1;
			TempPtr^:= 'm';
			TempPtr	+= 1;
			Size	+= 2;
		End_If;
		TempPtr^	:= Nil$Char;
	End_If;
 
3:
// "hhmm" in 24 hour format
	If (Offset + 8) <= cMaxAsciiLine Then
		Size	:= 8;
		TempPtr	:= Dest + Offset;
		If Source.wHour < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wHour
									, Dest	:= TempPtr
									, Offset:= 0);
//		TempPtr^:= ':';
//		TempPtr	+= 1;
		If Source.wMinute < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wMinute
									, Dest	:= TempPtr
									, Offset:= 0);
(*                  
		TempPtr^:= ':';
		TempPtr	+= 1;
		If Source.wSecond < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wSecond
									, Dest	:= TempPtr
									, Offset:= 0);
*)                  
		TempPtr^	:= Nil$Char;
	End_If;
  
Else	// "hh:mm:ss" in 24 hour format
	If (Offset + 8) <= cMaxAsciiLine Then
		Size	:= 8;
		TempPtr	:= Dest + Offset;
		If Source.wHour < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wHour
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= ':';
		TempPtr	+= 1;
		If Source.wMinute < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wMinute
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= ':';
		TempPtr	+= 1;
		If Source.wSecond < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wSecond
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^	:= Nil$Char;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL FileBase::BuildTime
//[#ENGLISH]
//Convert the source date to an Ascii string.
//
//Mode determins the format.
//	0	: 	"yyyy-mm-dd"	( Default)
//	1	: 	"dd-mm-yyyy".
//	2	:	?
//
//[>Mode]Date format. If an un implemented mode is selected then mode 0 will be used.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::BuildSysDate
VAR_INPUT
	Mode		: DINT;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

System.GetSysDate( date0	:= #SysDate);
Size	:= BuildDate( Mode	:= Mode
					, Source:= SysDate
					, Dest	:= Dest
					, Offset:= Offset);

END_FUNCTION //VIRTUAL GLOBAL FileBase::BuildSysDate
//[#ENGLISH]
//Convert the source date to an Ascii string.
//
//Mode determins the format.
//	0	: 	"yyyy-mm-dd"	( Default)
//	1	: 	"dd-mm-yyyy".
//	2	:	"[d]d-[m]m-[yyy]y"
//	3	:	?
//
//[>Mode]Date format. If an un implemented mode is selected then mode 0 will be used.
//[>Source]Date to be converted in a standerd date format.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::BuildDate
VAR_INPUT
	Mode		: DINT;
	Source		: SYSDATE;
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
	TSize	: Dint;
	TempPtr	:^CHAR;
End_Var;

Size	:= 0;
Case Mode of
1:		//	"dd-mm-yyyy"
	If (Offset + 10) <= cMaxAsciiLine Then
		Size	:= 10;
		TempPtr	:= Dest + Offset;
		If SysDate.wDay < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wDay
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= '-';
		TempPtr	+= 1;
		If Source.wMonth < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wMonth
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= '-';
		TempPtr	+= 1;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wYear
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^	:= Nil$Char;
	End_If;
2:		//	"[d]d-[m]m-[yyy]y"
	If (Offset + 10) <= cMaxAsciiLine Then
		TempPtr	:= Dest + Offset;
		TSize	:= BuildValue2Ascii(Value	:= Source.wDay
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr	+= TSize;
		Size	+= TSize;
		TempPtr^:= '-';
		TempPtr	+= 1;
		Size	+= 1;
		TSize	:= BuildValue2Ascii(Value	:= Source.wMonth
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr	+= TSize;
		Size	+= TSize;
		TempPtr^:= '-';
		TempPtr	+= 1;
		Size	+= 1;
		TSize	:= BuildValue2Ascii(Value	:= Source.wYear
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr	+= TSize;
		Size	+= TSize;
		TempPtr^	:= Nil$Char;
	End_If;
  
3://	"yyyymmdd"
	If (Offset + 10) <= cMaxAsciiLine Then
		Size	:= 10;
		TempPtr	:= Dest + Offset;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wYear
									, Dest	:= TempPtr
									, Offset:= 0);
//		TempPtr^:= '-';
//		TempPtr	+= 1;
		If Source.wMonth < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wMonth
									, Dest	:= TempPtr
									, Offset:= 0);
//		TempPtr^:= '-';
//		TempPtr	+= 1;
		If SysDate.wDay < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wDay
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^	:= Nil$Char;
	End_If;

Else	//	"yyyy-mm-dd"
	If (Offset + 10) <= cMaxAsciiLine Then
		Size	:= 10;
		TempPtr	:= Dest + Offset;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wYear
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= '-';
		TempPtr	+= 1;
		If Source.wMonth < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wMonth
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^:= '-';
		TempPtr	+= 1;
		If SysDate.wDay < 10 Then
			TempPtr^:= '0';
			TempPtr	+= 1;
		End_If;
		TempPtr	+=BuildValue2Ascii(Value	:= Source.wDay
									, Dest	:= TempPtr
									, Offset:= 0);
		TempPtr^	:= Nil$Char;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL FileBase::BuildDate
//[#ENGLISH]
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'
FUNCTION VIRTUAL GLOBAL FileBase::BuildSeperator
VAR_INPUT
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

Size	:= 0;
If (Offset + 1) <= cMaxAsciiLine Then
	Size	:= 1;
	(Dest + Offset)^	:= Separator;
	Offset += 1;
	(Dest + Offset)^	:= Nil$Char;
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::BuildSeperator
//[#ENGLISH]
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[>Source]String to be copied to an Ascii string.
//[>Dest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Length]Length of the string to be copied.
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::StingCopy
VAR_INPUT
	Source		: ^CHAR;
	Dest		: ^CHAR;
	offset		: DINT;
	Length		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

Size	:= 0;
If Offset+ Length <= cMaxAsciiLine Then 
	_MemCpy(( Dest + Offset), Source, to_Udint( Length));
	Size	:= Length;
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::StingCopy

FUNCTION VIRTUAL GLOBAL FileBase::OpenFile
VAR_INPUT
	FileName		: ^CHAR;
	Attribute		: UDINT;
END_VAR
VAR_OUTPUT
	Result		: DINT;
END_VAR

// Only 1 handle per time in the "FileBase" Class
If Handle <= 0 Then
	// Open the file
	If Attribute= ATT_CREATE_ALWAYS Then
		Handle	:= Result	:= FileOs	:= FileOs.FileOpen( FileName, 1, Attribute);
	Else
		Handle	:= Result	:= FileOs	:= FileOs.FileOpen( FileName, 2, Attribute);
	End_If;	
	If Handle <= 0 Then
		Server0		:= -2;
		Trace("'FileBase::OpenFile' -2: Can't open file.");
		Trace( FileName);	// The file that could not be opend.
	Else
		FileSize	:= 0;
	End_If;
Else
	Server0	:= -1;
	Trace("'FileBase::OpenFile' -1: Can't open a second file per 'FileBase' Class.");
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::OpenFile
//[#ENGLISH]
//[<Result]Help
FUNCTION VIRTUAL GLOBAL FileBase::CloseFile
VAR_OUTPUT
	Result	: DINT;
END_VAR

If Handle> 0 Then
	FileOs.FileClose( Handle	:= Handle);
	Handle	:= 0;
End_If;
Result	:= Handle;

END_FUNCTION //VIRTUAL GLOBAL FileBase::CloseFile
//[#ENGLISH]
//This method looks for Names in a DataTable to be found by a name type.
// The table has the following formats
//		SizeOf( Table)			// [DINT] The size of the data table is automaticaly generated by LASAL and not visable.
//		'x',"My First Text",
//		'x',"My Second Text",
//		'x',"...",
// 'x' 			is the name type.
// "..."		is the name to be copied
// Always a ',' at the end. This places a NIL char at the end of the string.
//[>NameType]Type of name to be found
//[>Source]Pointer to the begin of a DataTable of the discribed format.
//[>SOffset]Offset in source Table. This is nessesary to find next name of the same "NameType".
//[<Offset]0..4= Can't find the name type. For the header of the file is already added.
FUNCTION VIRTUAL GLOBAL FileBase::FindName
VAR_INPUT
	NameType		: CHAR;
	Source		: ^CHAR;
	SOffset		: DINT;
END_VAR
VAR_OUTPUT
	Offset		: DINT;
END_VAR
Var
	TableSize	: Dint;
End_Var;

// Reset for if not found
Offset	:= 0;
// Get Size of data-table
TableSize	:= Source^$Dint;
// Set source pointer
If SOffset < 4 Then
	SOffset	:= 4;
End_If;
Source	+= SOffset;
// Go find
If SOffset= 4 Then	// At the beginning
	If Source^ = NameType Then
		Offset	:= SOffset + 1; // String starts at next position + offset header.
		SOffset := TableSize + 4;
	End_If;
	Source	+= 1;
	SOffset	+= 1;
End_If;
If Offset= 0 Then
	// Notjet found
	While SOffset < (TableSize + 4) Do	// Loop the rest
		// Find NIL ( end of a line
		If Source^ = Nil Then
			Source	+= 1;
			SOffset	+= 1;
			If Source^ = NameType Then
				Offset	:= SOffset + 1; // String starts at next position + offset header.
				SOffset := TableSize + 4;
			End_If;
		End_If;
		Source	+= 1;
		SOffset	+= 1;
	End_While;
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::FindName
//[#ENGLISH]
//Write a string of length length from source to file.
//[>Source]Pointer to a string where the Ascii string is to be found.
//[>Length]Length of thestring to be copied to file
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::WriteFile
VAR_INPUT
	Source		: ^CHAR;
	Length		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

Size	:= 0;
If Handle > 0 Then
	Size	:= FileOs	:= To_Dint( FileOs.FileWrite( Handle, Source, To_UDint( Length)));
	FileSize	+= Size;
	If Size<> Length Then
		Server0	:= -5;
		Trace( "'FileBase::WriteFile' -5 Can't write the whole word to file.");
	End_If;
Else
	Server0	:= -3;
	Trace( "'FileBase::WriteFile' -3 Can't write to file beqause there is no handle.");
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::WriteFile
//[#ENGLISH]
//Read a string from file to a LF or a 'Nil'. CR must be followed by a LF.
//[>Dest]Pointer to the begin of a string where the Ascii string is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of string without 'nil'.
FUNCTION VIRTUAL GLOBAL FileBase::ReadFile
VAR_INPUT
	Dest		: ^CHAR;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
	EndPtr	: ^CHAR;
End_Var;

Size	:= 0;
If Handle > 0 Then
	EndPtr	:= Dest	+ cMaxAsciiLine;
	Dest	+= (Offset- 1);
	Repeat
		Dest	+= 1;
		FileOs	:= To_Dint( FileOs.FileRead(Handle, Dest, 1));
		If FileOs<> 0 Then
			Size	+= FileOs; 
			If Dest^= CRasc Then	// Skip LF
				Dest	-= 1;
				Size	-= 1;
			End_If;
		Else
			Dest^	:= Nil$Char;
			FileOs	:= FileOs;
		End_If;
	Until( Dest^ = Nil$Char
		 | Dest^ = LF
		 | Dest	>= EndPtr )
	End_Repeat;
	Dest^	:= Nil$Char;
	FileSize	+= Size;
	If Size> 1 Then Size	-= 1; End_If;
Else
	Server0	:= -4;	// Can't read.
	Trace( "'FileBase::ReadFile' -4 Can't read from file beqause there is no handle.");
End_If;

END_FUNCTION //VIRTUAL GLOBAL FileBase::ReadFile



FUNCTION GLOBAL FileBase::SkipSpaces
	VAR_INPUT
		ptr 	: ^CHAR;
	END_VAR
  var 
    i : usint;
  end_var

    _strcpy(dest:=#tmp[0], src:=ptr);
    for i := 0 to 255 do 
      if tmp[i] <> 32 & tmp[i] <> 9 then //spaties en tabs verwijderen
        exit;
      end_if;
    end_for;
    _strcpy(dest:=ptr, src:=#tmp[i]);

  END_FUNCTION



FUNCTION GLOBAL FileBase::FindNumber
	VAR_INPUT
		Src 	: ^CHAR;
		Start 	: DINT;
	END_VAR
	VAR_OUTPUT
		Pos 	: DINT;
	END_VAR
VAR
	i : dint;
END_VAR
  
  pos := 0;
  For i:= Start to cMaxAsciiLine Do
    if (src+i)^>= 48 & (src+i)^ <= 57 then  // 0..9
      pos := i;
      exit;
    end_if;
  end_for;
  
END_FUNCTION


FUNCTION GLOBAL FileBase::Read2Comma
	VAR_INPUT
		Sourc 	: ^CHAR;
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
VAR
	i		: DINT;
END_VAR

Size:= 0;
Dest	+= Offset;
For i:= 0 to cMaxAsciiLine Do
	If Offset < cMaxAsciiLine Then
		Dest^	:= Sourc^;
		Case Sourc^ of
		44, '"',';':  //ook stoppen bij ;
			Dest^	:= Nil$Char;
			i	:= cMaxAsciiLine;
		Else
			Size	+= 1;
			Offset	+= 1;
			Sourc	+= 1;
			Dest	+= 1;
		End_Case;
	Else
		Dest^	:= Nil$Char;
		Size:= 0;
		i	:= cMaxAsciiLine;
	End_If;
End_For;

END_FUNCTION //VIRTUAL GLOBAL FileBase::Read2Comma
//[#ENGLISH]
//[>Value]Value to be converted to an Ascii string
//[>Dest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine
//[<Size]0= Can't place value else size of string without 'nil'



FUNCTION GLOBAL FileBase::Read2Seperator_or_Space
	VAR_INPUT
		Sourc 	: ^CHAR;
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
VAR
	i		: DINT;
//  kommaActive : DINT;
//  ii : DINT;
END_VAR

Size:= 0;
Dest	+= Offset;
//kommaActive := 0;
For i:= 0 to cMaxAsciiLine Do
	If Offset < cMaxAsciiLine Then
		Dest^	:= Sourc^;
		Case Sourc^ of
		0, CRasc, LF, Separator, HT, 20, ' ':
			Dest^	:= Nil$Char;
			i	:= cMaxAsciiLine;
      
//   44, 46 : //punt of komma, lees in tot max twee waarden na . of komma
//     ii := 0;
//     kommaActive := 1;
    
      
		Else
			Size	+= 1;
			Offset	+= 1;
			Sourc	+= 1;
			Dest	+= 1;
//      if kommaActive = 1 then
//        ii += 1;
//        if ii >= 2 then
//          i := CMAXASCIILINE;
//        end_if;
//      end_if;
		End_Case;
	Else
		Dest^	:= Nil$Char;
		Size:= 0;
		i	:= cMaxAsciiLine;
	End_If;
End_For;

END_FUNCTION


FUNCTION GLOBAL FileBase::Read2TowPosAfterKomma
	VAR_INPUT
		Sourc 	: ^CHAR;
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  VAR
    i		: DINT;
    kommaActive : DINT;
    ii : DINT;
  END_VAR

  Size:= 0;
  Dest	+= Offset;
  kommaActive := 0;
  For i:= 0 to cMaxAsciiLine Do
    If Offset < cMaxAsciiLine Then
      Dest^	:= Sourc^;
     
      if Sourc^ = 44 | Sourc^ = 46 then //punt of komma, lees in tot max twee waarden na . of komma
        ii := 0;
        kommaActive := 1;
      end_if;

      Size	+= 1;
      Offset	+= 1;
      Sourc	+= 1;
      Dest	+= 1;
      if kommaActive = 1 then
        ii += 1;
        if ii >= 3 then
          i := CMAXASCIILINE;
        end_if;
      end_if;

    Else
      Dest^	:= Nil$Char;
      Size:= 0;
      i	:= cMaxAsciiLine;
    End_If;
  End_For;

END_FUNCTION


FUNCTION GLOBAL FileBase::Read2Variable
	VAR_INPUT
		Sourc 	: ^CHAR;
		Dest 	: ^CHAR;
		Offset 	: DINT;
		Variable 	: CHAR;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  VAR
    i		: DINT;
  END_VAR

  Size:= 0;
  Dest	+= Offset;
  For i:= 0 to cMaxAsciiLine Do
    If Offset < cMaxAsciiLine Then
      Dest^	:= Sourc^;
      if Sourc^ = Variable then
        Dest^	:= Nil$Char;
        i	:= cMaxAsciiLine;
      Else
        Size	+= 1;
        Offset	+= 1;
        Sourc	+= 1;
        Dest	+= 1;
      end_if;
    Else
      Dest^	:= Nil$Char;
      Size:= 0;
      i	:= cMaxAsciiLine;
    End_If;
  End_For;

END_FUNCTION


FUNCTION GLOBAL FileBase::CheckGelijk
	VAR_INPUT
		Sourc 	: ^CHAR;
		Sourc2 	: ^CHAR;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Gelijk 	: DINT;
	END_VAR
  VAR
    i		: UDINT;
  END_VAR
  
  Gelijk := 1; //uitgaan van gelijk, als er een verschil is wordt deze nul gemaakt
  for i:=0 to length do
  
    if Sourc^ <> Sourc2^ then
      Gelijk := 0;
      i := length;
    end_if;
    
    Sourc += 1;
    Sourc2 += 1;
  
  end_for;



END_FUNCTION


FUNCTION GLOBAL FileBase::ReadValueAfterString
	VAR_INPUT
		Sourc 	: ^CHAR;
		Sourc2 	: ^CHAR;
		lengthSourc2 	: DINT;
	END_VAR
	VAR_OUTPUT
		Value 	: DINT;
	END_VAR
  
  VAR
  	tel : DINT;
    tellength : DINT;
  END_VAR
  
  tellength := 0;

  For tel:= 0 to cMaxAsciiLine Do
    If tel < cMaxAsciiLine Then
      if Sourc^ = Sourc2^ then
        Sourc2 += 1;
        tellength += 1;
        if tellength >= lengthSourc2 then
          Sourc += 1;
          if Sourc^ = '=' then
            Value := ConvAscii2ValueStopAtKomma(Sourc:=Sourc); //in andere methode nu waarde uitlezen en teruggeven
            exit;
          else
            //hier had =je moeten staan, nu dus foutwaarde teruggeven en stoppen
            Value := FAULTVALUE;
            tel := CMAXASCIILINE;
            
          end_if;
        end_if;
      else
        Sourc2 -= tellength;
        tellength := 0;
      end_if;
      Sourc += 1;
    Else
      Value := FAULTVALUE;
      tel:= cMaxAsciiLine;
    End_If;
  End_For;


END_FUNCTION


FUNCTION GLOBAL FileBase::ConvAscii2ValueStopAtKomma
	VAR_INPUT
		Sourc 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Value 	: DINT;
	END_VAR
  Var
    i			: DINT;
    Sign		: DINT;
  End_Var;

  Sign := 1;
  Value:= 0;
  For i:= 0 to 20 Do
    Case Sourc^ of
    0..US, Separator, ',' : //Let op! JdK 2-7-2014 aangepast, stopt nu ook met inlezen waarde na een komma
      // The end
      i	:= 20;
    '-':
      // It is a negative value
      Sign := -1;
    '0'..'9':
      // convert to DINT
      Value	*= 10;
      Value	+= To_Dint( Sourc^- '0');
    End_Case;
    Sourc	+= 1;
  End_For;

  Value *= Sign;
  
END_FUNCTION


FUNCTION GLOBAL FileBase::ConvAscii2BDINT
	VAR_INPUT
		sourc 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		output 	: BDINT;
	END_VAR

  VAR
  	tel : DINT;
    telmachie : DINT;
    machie    : DINT;
  END_VAR
  
  output := 0;

  for tel := 0  to cMaxAsciiLine do
    if sourc^ = '1' then //eigenlijk gewoon 2 tot de macht tel, maar dat kan dit ding niet, dus vandaar de volgende regels
      if tel = 0 then
        output := 1;
      else
        machie := 2;  
        for telmachie := 1 to tel-1 do
          machie := machie * 2;
        end_for;
        output += to_udint(machie); 
      end_if;
    elsif sourc^ <> '0' then
      tel := CMAXASCIILINE;
      exit;
    end_if;
    sourc += 1;
  end_for;

END_FUNCTION


FUNCTION GLOBAL FileBase::ReadStringAfterString
	VAR_INPUT
		Sourc 	: ^CHAR;
		Sourc2 	: ^CHAR;
		Dest 	: ^CHAR;
		lengthSourc2 	: DINT;
	END_VAR
	VAR_OUTPUT
		Value 	: DINT;
	END_VAR
  VAR
  	tel : DINT;
    tellength : DINT;
  END_VAR
  
  tellength := 0;

  For tel:= 0 to cMaxAsciiLine Do
    If tel < cMaxAsciiLine Then
      if Sourc^ = Sourc2^ then
        Sourc2 += 1;
        tellength += 1;
        if tellength >= lengthSourc2 then
          Sourc += 1;
          if Sourc^ = '=' then
            Sourc += 1;
            Value  := Read2Comma(Sourc:=Sourc, Dest:=Dest, Offset:=0);  //in andere methode nu waarde uitlezen en teruggeven
            Value += 1; //voor het isje
            Value += lengthSourc2; //voor de vergelijkingsstring
            exit;
          else
            //hier had =je moeten staan, nu dus foutwaarde teruggeven en stoppen
            Value := FAULTVALUE;
            tel := CMAXASCIILINE;
          end_if;
        end_if;
      else
        Sourc2 -= tellength;
        tellength := 0;
      end_if;
      Sourc += 1;
    Else
      Value := FAULTVALUE;
      tel:= cMaxAsciiLine;
    End_If;
  End_For;

END_FUNCTION


FUNCTION GLOBAL FileBase::StringTurnAround
	VAR_INPUT
		Sourc 	: ^CHAR;
		Dest 	: ^CHAR;
		Length 	: DINT;
	END_VAR
  
  VAR
  	i : DINT;
  END_VAR

  if Sourc <> 0 & Dest <> 0 then
    Dest += (Length-1);


    for i := 1 to Length do
      Dest^ := Sourc^;
      Sourc += 1;
      Dest -= 1;
    end_for;
  end_if;
  


END_FUNCTION


FUNCTION GLOBAL FileBase::SkipStringZeros
	VAR_INPUT
		Ptr 	: ^CHAR;
	END_VAR

  VAR 
    iPick : usint;
    iPlace : usint;
    iDiff : usint;
    skip : Dint;
  END_VAR
  
  _memset(dest:=#tmpTarget[0], usByte:=0, cntr:=255);
  _strcpy(dest:=#tmp[0], src:=ptr);
  iPlace := 0;
  for iPick := 0 to 255 do 
    skip := 0;
    if tmp[iPick] = 0 then //spaties en tabs verwijderen
      // dont increase iplace
      skip := 1;
    else
      iplace +=1;
    end_if;
    
    iDiff := iPick - iPlace;
    if (ipick + iDiff >= 255 & iDiff <> 255) then
      iPick := 255;
      exit;
    elsif skip = 0 then
      tmpTarget[iPlace-1] := tmp[iPick];
    end_if;
    
  end_for;
  _strcpy(dest:=ptr, src:=#tmpTarget[0]);



END_FUNCTION


FUNCTION GLOBAL FileBase::StrReplace
	VAR_INPUT
		Sourc 	: ^CHAR;
		Replace 	: USINT;
		ReplaceWith 	: USINT;
		Offset 	: DINT;
		Length 	: DINT;
	END_VAR
  
  VAR
  	index : DINT;
  END_VAR
  
  
  Sourc += offset;
  For index := Offset  to Length do
    if   Sourc^ = Replace then
      Sourc^ := ReplaceWith;
    end_if;
    sourc +=1;
  end_for;


END_FUNCTION


FUNCTION GLOBAL FileBase::ReadFileAndEnter
	VAR_INPUT
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  Var
    EndPtr	: ^CHAR;
  End_Var;

  Size	:= 0;
  If Handle > 0 Then
    EndPtr	:= Dest	+ cMaxAsciiLine;
    Dest	+= (Offset- 1);
    Repeat
      Dest	+= 1;
      FileOs	:= To_Dint( FileOs.FileRead(Handle, Dest, 1));
      If FileOs<> 0 Then
        Size	+= FileOs; 
      Else
        Dest^	:= Nil$Char;
        FileOs	:= FileOs;
      End_If;
    Until( Dest^ = Nil$Char
       | Dest^ = LF
       | Dest	>= EndPtr )
    End_Repeat;
    Dest^	:= Nil$Char;
    FileSize	+= Size;
    If Size> 1 Then Size	-= 1; End_If;
  Else
    Server0	:= -4;	// Can't read.
    Trace( "'FileBase::ReadFile' -4 Can't read from file beqause there is no handle.");
  End_If;

END_FUNCTION


FUNCTION GLOBAL FileBase::ReadFileSkipLineFeeds
	VAR_INPUT
		Dest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  Var
    EndPtr	: ^CHAR;
  End_Var;
  
  //JdK 6-2-2020: for files with assembly's / products etc. there can be linefeeds, but we prefer to use only the carriage return, so we ignore the linefeeds

  Size	:= 0;
  If Handle > 0 Then
    EndPtr	:= Dest	+ cMaxAsciiLine;
    Dest	+= (Offset- 1);
    Repeat
      Dest	+= 1;
      FileOs	:= To_Dint( FileOs.FileRead(Handle, Dest, 1));
      If FileOs<> 0 Then
        Size	+= FileOs; 
        If Dest^= lf Then	// Skip LF
          Dest	-= 1;
          Size	-= 1;
        End_If;        
      Else
        Dest^	:= Nil$Char;
        FileOs	:= FileOs;
      End_If;
    Until( Dest^ = Nil$Char
       | Dest^ = LF
       | Dest	>= EndPtr )
    End_Repeat;
    Dest^	:= Nil$Char;
    FileSize	+= Size;
    If Size> 1 Then Size	-= 1; End_If;
  Else
    Server0	:= -4;	// Can't read.
    Trace( "'FileBase::ReadFile' -4 Can't read from file beqause there is no handle.");
  End_If;


END_FUNCTION
