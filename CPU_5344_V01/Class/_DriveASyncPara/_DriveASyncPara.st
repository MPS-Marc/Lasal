//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_DriveMngBase\SDDDefinitions.h"

(*!
<Class
	Name               = "_DriveASyncPara"
	Revision           = "1.4"
	GUID               = "{5EB9C180-4820-41F7-B174-0B6B8B458E28}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_DriveMngBase\Drive.ico"
	SharedCommandTable = "true"
	Objectsize         = "(330,120)"
	Comment            = "class for asynchron parameter handling">
	<Channels>
		<Server Name="ErrorQuit" GUID="{96F66E41-9679-40F3-8301-3B1DB225A310}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="quit an error if the asnychron parameter handling failed"/>
		<Server Name="ParaNr" GUID="{5ECE6D96-9CB9-4945-81EF-688FF1B783F9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="write the parameter number to read/write the value"/>
		<Server Name="ParaRdWr" GUID="{BB8319FC-2E6D-4269-8326-84FF83386543}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="0 .. read the value of the parameter number&#13;&#10;1 .. write a new value of the parameter number"/>
		<Server Name="ParaValue" GUID="{DC9C6B95-8B83-4E0C-8254-7FC7DC11ABC3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Read Command = actual value of the parameter&#13;&#10;Write Command = the new value which has to written to the parameter"/>
		<Server Name="State" GUID="{F5A853D5-7C1E-4157-A3CD-C1155B74D335}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Actual state of the asynchron handling class&#13;&#10;Following states are possible :&#13;&#10;READY&#13;&#10;BUSY&#13;&#10;ERROR"/>
		<Client Name="DriveAxis" Required="true" Internal="false" Comment="object channel to the class _DriveAxis"/>
		<Client Name="ErrorCode" Required="false" Internal="false" Comment="Following error codes are possible :&#13;&#10;ErrorCode &#13;&#10;   3 =    object change only in disable state&#13;&#10;   4 =    object value greater max value or smaller min value&#13;&#10;   5 =    object write not possible&#13;&#10;   6 =    object cannot be changed in this mode&#13;&#10;   7 =    object not available&#13;&#10;   8 =    object read not possible&#13;&#10;   9 =    initialisation processed successful&#13;&#10;  10 =    communication not initialised&#13;&#10;  11 =    axis is not available&#13;&#10;&#13;&#10;"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_DriveMngBase\SDDDefinitions.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HasHan"/>
		<Dokumentation Revision="1.4" Date="09.01.2020" Author="PieSte" Company="Sigmatek" Description="The variable usEntryType was added so that it can be changed in a derivation (for example to not save the parameter in SRAM)."/>
		<Dokumentation Revision="1.3" Date="26.08.2019" Author="RamAnd" Company="Sigmatek" Description="Trigger error with error code 10 when trying to add a request before the axis is online, which can only be quit if the axis is online.&#13;&#10;Before it was possible to quit the error and successfully add a new request without promting another error."/>
		<Dokumentation Revision="1.2" Date="17.09.2012" Author="RamAnd" Company="Sigmatek" Description="Added method IsOnline to check online state before starting a request."/>
		<Dokumentation Revision="1.1" Date="21.07.2011" Author="RamAnd" Company="Sigmatek" Description="Changed object client DriveAxis from class _DriveAxis to _DriveAxisBase, like in all other drive classes with a connection to the axis object."/>
		<Dokumentation Revision="1.0" Date="05.08.2009" Author="HasHan" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
</Class>
*)
_DriveASyncPara : CLASS
  //Servers:
	State 	: SvrChCmd_iprStates;
	ParaNr 	: SvrCh_DINT;
	ParaRdWr 	: SvrCh_DINT;
	ParaValue 	: SvrCh_DINT;
	ErrorQuit 	: SvrCh_DINT;
  //Clients:
	DriveAxis 	: CltChCmd__DriveAxisBase;
	ErrorCode 	: CltCh_DINT;
  //Variables:
		usEntryType 	: USINT;			//! <Variable Comment="Sets the mode for an update after executing the command&#13;&#10;&#13;&#10;0..Default&#13;&#10;1..all connected parameterclasses for this axis get refreshed after the command&#13;&#10;2..Indicates if the first part of the refresh from the paratmerclasses is finished&#13;&#10;3..only used by Lasal2" Name="usEntryType"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="get the online state (checks if the axis module can be accessed)" Name="IsOnline"/>
	FUNCTION GLOBAL IsOnline
		VAR_OUTPUT
			OnlineState 	: DINT;			//! <Variable Comment="0..offline&#13;&#10;1..online" Name="IsOnline.OnlineState"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL State::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ParaNr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorQuit::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _DriveAxisBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _DriveASyncPara::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__DRIVEASYNCPARA
1$UINT, 4$UINT, (SIZEOF(::_DriveASyncPara))$UINT, 
5$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3294374015), "_DriveASyncPara", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_DriveASyncPara.State.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "State", 
(::_DriveASyncPara.ParaNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(589081120), "ParaNr", 
(::_DriveASyncPara.ParaRdWr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2426770201), "ParaRdWr", 
(::_DriveASyncPara.ParaValue.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(757324645), "ParaValue", 
(::_DriveASyncPara.ErrorQuit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(971218924), "ErrorQuit", 
//Clients:
(::_DriveASyncPara.DriveAxis.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2080180789), "DriveAxis", TO_UDINT(4124502522), "_DriveAxisBase", 1$UINT, 75$UINT, 
(::_DriveASyncPara.ErrorCode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(224164065), "ErrorCode", 
END_FUNCTION


#define USER_CNT__DriveASyncPara 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__DriveASyncPara] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _DriveASyncPara::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__DriveASyncPara, pCmd := #vmt.CmdTable);
	vmt.CmdTable.NewInstr		:= #NewInst();
	vmt.CmdTable.Init		:= #Init();
	State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaNr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ParaNr::Write() );
	IF ParaNr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaRdWr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParaRdWr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaValue.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParaValue.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorQuit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ErrorQuit::Write() );
	IF ErrorQuit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL _DriveASyncPara::Init

  if _firstscan then
    State := READY;
    ErrorCode := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _DriveASyncPara::State::NewInst
  VAR_INPUT
    pPara 	: ^CmdStruct;
    pResult 	: ^results;
  END_VAR
  VAR_OUTPUT
    ret_code 	: iprStates;
  END_VAR

  ret_code:= READY;

  case pPara^.uiCmd of
    SDD_ASYNC_READY :
      // was the command a read or a write command
      if pPara^.aPara[1] = 0 then
        // read command
        ParaValue := pPara^.aPara[2];
      end_if;
      State := READY;
      
    SDD_ASYNC_ERROR :
      ErrorCode := pPara^.aPara[1];
      ErrorCode.write(ErrorCode);
      State := ERROR;

  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _DriveASyncPara::ParaNr::Write
  VAR_INPUT
    input (EAX) 	: DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: DINT;
  END_VAR
  VAR
    IntState    : iprStates;
  END_VAR

  result := ACCESS_DENIED;
  
  if (State = READY) then
    ParaNr := input;
    IntState := DriveAxis.CmdState.Read();
    
    if IntState = ERROR then
      if DriveAxis.AxisState.NoHW = 1 then
        ErrorCode := 11;
        ErrorCode.write(ErrorCode);
      elsif DriveAxis.AxisState.NotInitialized = 1 then
        ErrorCode := 10;
        ErrorCode.write(ErrorCode);
      end_if;
      State := DriveAxis := IntState;
      return;
    end_if;
    
    // Add the entry into the ring buffer
    result := DriveAxis.AddASyncEntry(to_usint(ParaNr), to_usint(ParaRdWr), ParaValue, this, usEntryType);
    if result = 0 then
      State := BUSY;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _DriveASyncPara::ErrorQuit::Write
  VAR_INPUT
    input (EAX) 	: DINT;
  END_VAR
  VAR_OUTPUT
    result (EAX) 	: DINT;
  END_VAR
  VAR
    bError      : BOOL;
    IntState    : iprStates;
  END_VAR
  
  bError := TRUE;
  // quit an error
  if input = 1 then
  
    if State = ERROR then
      case ErrorCode of
      
        10 : //communication not initialized
          if DriveAxis.Online.Read() then
            bError := FALSE;
          end_if;  

        11 : //axis is not available
          IntState := DriveAxis.CmdState.Read();
          if IntState = ERROR then
            if DriveAxis.AxisState.NoHW = 0 then
              bError := FALSE;
            end_if;
          end_if;  
        
      else
        bError := FALSE;
      end_case;
    end_if;
  end_if;
  
  if bError = FALSE then
    State := DriveAxis := READY;
    ErrorCode := 0;
    ErrorCode.write(ErrorCode);
  end_if;
  
  ErrorQuit := 0;
  result := ErrorQuit;

END_FUNCTION


FUNCTION GLOBAL _DriveASyncPara::IsOnline
  VAR_OUTPUT
    OnlineState 	: DINT;
  END_VAR

  OnlineState := DriveAxis.Online.Read();

END_FUNCTION
