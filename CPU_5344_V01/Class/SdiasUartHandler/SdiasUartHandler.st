//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define SDIAS_UART_OFFSET_WR      16#000
#define SDIAS_UART_OFFSET_RD      16#080

#define SDIAS_UART_OFFSET_RD_SDO  16#005 //read offset for option bits

#define SDIAS_UART_TYPE_RS232     0
#define SDIAS_UART_TYPE_RS485     1
#define SDIAS_UART_TYPE_TTY       2

#define SDIAS_UART_BAUD_REFERENCE 115200

#define SDIAS_UART_BAUD_300       0
#define SDIAS_UART_BAUD_600       1
#define SDIAS_UART_BAUD_1200      2
#define SDIAS_UART_BAUD_2400      3
#define SDIAS_UART_BAUD_4800      4
#define SDIAS_UART_BAUD_9600      5
#define SDIAS_UART_BAUD_14400     6
#define SDIAS_UART_BAUD_19200     7
#define SDIAS_UART_BAUD_38400     8
#define SDIAS_UART_BAUD_57600     9
#define SDIAS_UART_BAUD_115200   10

//Frequency defines
#define SDIAS_UART_FREQUENCY_1_8432MHz    1843200
#define SDIAS_UART_FREQUENCY_1MHz         1000000
#define SDIAS_UART_FREQUENCY_7_3728MHz    7372800
#define SDIAS_UART_FREQUENCY_14_7456MHz  14745600

#define SDIAS_UART_TX_LEN_DATA      120 //max length of tx data object length
#define SDIAS_UART_RX_LEN_DATA      120 //max length of rx data object length

#define SDIAS_UART_TX_LEN_NO_DATA   (sizeof(t_WriteData)-SDIAS_UART_TX_LEN_DATA)
#define SDIAS_UART_RX_LEN_NO_DATA   (sizeof(t_ReadData)-SDIAS_UART_RX_LEN_DATA)

#define SDIAS_UART_TX_BUFFER_SIZE 1024
#define SDIAS_UART_RX_BUFFER_SIZE 1024

#define SDIAS_UART_RXTX_BUFFER_SIZE_HW 120  //receive/transmit buffer length of hw modul
#define SDIAS_UART_RXTX_BUFFER_SIZE_HW_EXTENDED 240  //receive/transmit buffer length of hw modul

#define SDIAS_UART_SDO_RESPONSE_TIMEOUT 1000
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\SdiasManager\SdiasManager.h"
#include "..\..\Source\interfaces\lsl_st_mt.h"

(*!
<Class
	Name               = "SdiasUartHandler"
	Revision           = "1.12"
	GUID               = "{AC3AB273-B0A4-4FFB-B501-D6D877E33CA4}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Tool.ico"
	SharedCommandTable = "true"
	Objectsize         = "(426,120)"
	Comment            = "Class to handle UART interfaces on SDIAS modules">
	<Channels>
		<Server Name="HwOptionBits" GUID="{73A6CC9E-2618-40D4-9B47-7C8CF701D254}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the available options of hardware modul.&#13;&#10;Bit1 .. 9 bit word mode&#13;&#10;Bit2 .. flexible baudrate&#13;&#10;Bit3 .. extended rx &amp; tx buffer&#13;&#10;Bit4 .. RTS and CTS as second RS232 IF&#13;&#10;&#13;&#10;Bit32 .. Option Bits are valid"/>
		<Server Name="InvalidDataErrorCnt" GUID="{CE967DDC-C609-494A-9D0F-83E79370A906}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if a framing or parity error occurs."/>
		<Server Name="RecBufOverflowErrorCnt" GUID="{9F8F0B9E-5BE0-4FC6-8A49-3856615EBDF0}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if the receive buffer is overflowed."/>
		<Client Name="AddressOffset" Required="true" Internal="false"/>
		<Client Name="MaxRdLen" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to receive via SDIAS per cycle (the rest of the receive data is stored in the ringbuffer of the module).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="MaxWrLen" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to transmit via SDIAS per cycle (the rest of the send data is stored in the ringbuffer of the class).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="ToSdiasBase" Required="true" Internal="false"/>
		<Client Name="ToStdLib" Required="false" Internal="false"/>
		<Client Name="UartType" Required="true" Internal="false" Comment="Type of UART:&#13;&#10;0..RS232&#13;&#10;1..RS485&#13;&#10;2..TTY"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\SdiasManager\SdiasManager.h" Include="true"/>
			<File Path=".\Source\interfaces\lsl_st_mt.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.12" Date="03.07.2019" Author="PieSte" Company="Sigmatek" Description="Add support for second RS232 interface.&#13;&#10;Numbers have been added to the log messages so that they can be assigned.&#13;&#10;If read and write length is zero there is no access added and the interface is deactivated."/>
		<Dokumentation Revision="1.11" Date="06.03.2018" Author="EisMic" Company="Sigmatek" Description="Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="1.10" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.9" Date="14.12.2017" Author="PieSte" Company="Sigmatek" Description="Save act transmit data length to calculate the correct used transmit buffer length at GetSendState() function (SA37717).&#13;&#10;Added &quot;RecBufOverflowErrorCnt&quot; to indicate that the receive buffer has overflowed.&#13;&#10;Now it is possible to call &quot;SetBaudrate&quot; at Init(). &#13;&#10;Add &quot;HwOptionBits&quot; to show features of hardware.&#13;&#10;If hardware support the extended hw buffer it is used."/>
		<Dokumentation Revision="1.8" Date="29.06.2017" Author="PieSte" Company="Sigmatek" Description="Add transmit buffer used length of module (max 120byte) to return value at GetSendState() function.&#13;&#10;Removed message log for RecvChar() and RecvBlock() if there is no data in receive buffer."/>
		<Dokumentation Revision="1.7" Date="31.08.2016" Author="PieSte" Company="Sigmatek" Description="Add RSMode setting for TTY interface to enable or disable echo."/>
		<Dokumentation Revision="1.6" Date="16.11.2015" Author="PieSte" Company="Sigmatek" Description="Add cyclic task for logging to prevent rt-runtime error."/>
		<Dokumentation Revision="1.5" Date="15.10.2015" Author="PieSte" Company="Sigmatek" Description="Disable EchoOff for RS232 interface to enable receiving during transmit."/>
		<Dokumentation Revision="1.4" Date="20.07.2015" Author="PieSte" Company="Sigmatek" Description="Corrected methode SetRsMode() for tty interface."/>
		<Dokumentation Revision="1.3" Date="30.01.2015" Author="RamAnd" Company="Sigmatek" Description="The parameters for creating DOs were not correctly initialized if SdiasManager class v1.63 or higher has been used."/>
		<Dokumentation Revision="1.2" Date="07.11.2014" Author="EisMic" Company="Sigmatek" Description="Implemented 9Bit Mode and more baudrates"/>
		<Dokumentation Revision="1.1" Date="10.07.2014" Author="ZoePat" Company="Sigmatek" Description="Corrected value of GetInterfaceType()."/>
		<Dokumentation Revision="1.0" Date="28.04.2014" Author="PieSte" Company="Sigmatek" Description="Initial library version."/>
	</RevDoku>
	<Network Name="SdiasUartHandler">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{0FC40410-1AC2-4E59-A1E3-15346F5FBC50}"
				Class      = "_SerLib"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Com"/>
					<Server Name="Command"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Command" Destination="_base.Command" Vertices="(690,210),(518,210),"/>
			<Connection Source="this.Com" Destination="_base.Com" Vertices="(690,270),(518,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _SerLib

SdiasUartHandler : CLASS
: _SerLib
	TYPE
	  t_ModemStatusReg : BSINT
	  [
	    1 DeltaClearToSend,
	    2 DeltaDataSetReady,
	    3 TrailingEdgeRingIndicator,
	    4 DeltaDataCarrierDetect,
	    5 ClearToSend,
	    6 DataSetReady,
	    7 RingIndicator,
	    8 DataCarrierDetect,
	  ];
	  t_LineStatusReg : BSINT
	  [
	    1 TransmHoldRegEmpty,
	    2 ParityError,
	    3 FramingError,
	    4 BreakControlBit,
	    5 Busy,
	    6 ReceiveBufferFull,
	  ];
	  t_ModemControlReg : BSINT
	  [
	    1 DataTerminalReady,
	    2 RequestToSend,
	    3 DataEnableMode,  //! <Type Comment="0..RS232&#13;&#10;1..RS422/RS485" Name="t_ModemControlReg.DataEnableMode"/>
	    4 RSMode,  //! <Type Comment="0..RS422&#13;&#10;1..RS485" Name="t_ModemControlReg.RSMode"/>
	    5 Loop,
	    6 EchoOff,  //! <Type Comment="0..Echo on&#13;&#10;1..Echo off" Name="t_ModemControlReg.EchoOff"/>
	    7 Enable9BitMode,
	  ];
	  t_LineControlReg : BSINT
	  [
	    1 WordLenSelectBit0,
	    2 WordLenSelectBit1,
	    3 NumberOfStopBits,
	    4 ParityEnable,
	    5 EvenParitySelect,
	    6 StickParity,
	    7 SetBreak,
	  ];
#pragma pack(push, 1)
	  t_ReadData : STRUCT
	    ModemStatusReg : t_ModemStatusReg;
	    LineStatusReg : t_LineStatusReg;
	    ModemControlReg : t_ModemControlReg;
	    LineControlReg : t_LineControlReg;
	    ReceiveByteCounter : USINT;
	    TransmitByteCounter : USINT;
	    aReceiveBuffer : ARRAY [0..SDIAS_UART_RX_LEN_DATA-1] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessInfos : STRUCT
	    pStateByte : t_SDIAS_pStateByte;
	    pControlByte : t_SDIAS_pControlByte;
	    AccessHandle : UDINT;
	    ActLength : USINT;  //! <Type Comment="length of DO to set on the end of the actual cycle" Name="t_AccessInfos.ActLength"/>
	    LastDOLen : USINT;  //! <Type Comment="contains the size of the access from the last cycle&#13;&#10;needed to compare it with the size of the actual cycle&#13;&#10;if different =&gt; change access" Name="t_AccessInfos.LastDOLen"/>
	    aLength : ARRAY [0..2] OF USINT;
	    ActLengthIndex : USINT;
	    OldReceiveByteCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_WriteData : STRUCT
	    ModemControlReg : t_ModemControlReg;
	    LineControlReg : t_LineControlReg;
	    DivisorLatchReg : UINT;
	    CoProcessorPortCfg : BSINT
	    [
	    ];
	    Reserved : USINT;
	    aTransmitBuffer : ARRAY [0..SDIAS_UART_TX_LEN_DATA-1] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_AccessData : STRUCT
	    LocalReadData : t_ReadData;
	    pReadData : ^t_ReadData;
	    ReadAccess : t_AccessInfos;
	    LocalWriteData : t_WriteData;
	    pWriteData : ^t_WriteData;
	    WriteAccess : t_AccessInfos;
	    pMutex : ^void;
	  END_STRUCT;
#pragma pack(pop)
	  t_bdOptionBits : BDINT  //! <Type Public="true" Name="t_bdOptionBits"/>
	  [
	    1 _9BitMode,
	    2 FlexibleBaudrate,
	    3 ExtendedTxRxBuffer,
	    4 SecondUARTAvailable,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 OptionBitsValid,
	  ];
	  t_eInitSSW :
	  (
	    _InitIdle,
	    _ReadOptionBits,
	    _InitFinished,
	    _InitError
	  )$UDINT;
	  t_eResponseState :
	  (
	    idle,
	    wait,
	    valid
	  )$UDINT;
#pragma pack(push, 1)
	  t_RingBuffer : STRUCT
	    pMemStart : ^void;
	    pLastEntry : ^void;
	    pActWr : ^void;
	    pActRd : ^void;
	    ud_BufferSize : UDINT;
	    ud_MemUsed : UDINT;
	    b_DefaultBuffer : BOOL;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SendBufferUsed : STRUCT
	    udLastTransmitDiff : UDINT;
	    udActTransmitDiff : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	InvalidDataErrorCnt 	: SvrCh_DINT;
	RecBufOverflowErrorCnt 	: SvrCh_DINT;
	HwOptionBits 	: SvrCh_t_bdOptionBits_PTofCls_SdiasUartHandler;
  //Clients:
	ToSdiasBase 	: CltChCmd_SdiasBase;
	ToStdLib 	: CltChCmd__StdLib;
	AddressOffset 	: CltCh_HDINT;
	UartType 	: CltCh_DINT;
	MaxRdLen 	: CltCh_UDINT;
	MaxWrLen 	: CltCh_UDINT;
  //Variables:
		AccessData 	: t_AccessData;
		usInitCounter 	: USINT;
		b_InitDone 	: BOOL;
		mt_api 	: ^LSL_MT_TYPE;
		ActError 	: DINT;
		RSMode 	: UDINT;
		b_VaranAvailable 	: BOOL;
		RxBuffer 	: t_RingBuffer;
		TxBuffer 	: t_RingBuffer;
		b_Initialized 	: BOOL;
		bExtendedBaudrateSet 	: BOOL;
		WordLen 	: USINT;
		biLogging : BINT
		[
		  1 TxAddBufferOverflow,
		  2 TxAddBufferOverflowLogged,
		  3 RxAddBufferOverflow,
		  4 RxAddBufferOverflowLogged,
		  5 TxGetBufferOverflow,
		  6 TxGetBufferOverflowLogged,
		  7 RxGetBufferOverflow,
		  8 RxGetBufferOverflowLogged,
		  9 AddMutexFailed,
		  10 AddOsInterfaceFailed,
		  11 GetBusInterfaceFailed,
		];

		sTxBufferUsed 	: t_SendBufferUsed;
		eResponseState 	: t_eResponseState;
		eInitSSW 	: t_eInitSSW;
		udSDOTimeout 	: UDINT;
		usHwBufferSize 	: USINT;
		bAdditionaIFActive 	: BOOL;
		bInterfaceActive 	: BOOL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="&#13;&#10; ***************************************************************************&#13;&#10; ****************    _SerLib::StartUser                   ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                     **&#13;&#10; **   Closes an initialized COM if initialized and initializes a new one  **&#13;&#10; ***************************************************************************&#13;&#10;[&gt;Baud]0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200&#13;&#10;[&gt;wordl]&quot;wordlength&quot;  5, 6, 7, 8 or 9 bit. (9Bit since FPGA Version &gt;= 1.2)&#13;&#10;[&gt;Parity]0..SERUSERPARITY_NONE 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK(HIGH Parity) / 4..SERUSERPARITY_SPACE(LOW Parity)&#13;&#10;[&gt;StopB]1=one stop bit, 2=2 stop bits for words of length 6,7 or 8 bits or 1.5 stop bits for word lengths of 5 bits.&#13;&#10;[&gt;FifoOnOff]0=FIFO disable, FIFO enable: 1,4,8,14 = Triggerlevel&#13;&#10;" Name="StartUser"/>
	FUNCTION VIRTUAL GLOBAL StartUser
		VAR_INPUT
			Baud 	: DINT;			//! <Variable Comment="0..SERUSERBAUD_300, 1..600, 2..1200, 3..2400, 4..4800, 5..9600, 6..14400, 7..19200, 8..38400, 9..56000, 10..115200" Name="StartUser.Baud"/>
			wordl 	: DINT;			//! <Variable Comment="wordlength  5, 6, 7 or 8 Bit" Name="StartUser.wordl"/>
			Parity 	: DINT;			//! <Variable Comment="0..SERUSERPARITY_NONE / 1..SERUSERPARITY_ODD / 2..SERUSERPARITY_EVEN / 3..SERUSERPARITY_MARK / 4..SERUSERPARITY_SPACE" Name="StartUser.Parity"/>
			StopB 	: DINT;			//! <Variable Comment="1=one Stop Bit, 2=2 Stop Bits for wordlength 6,7 or 8 Bits or 1.5 stop Bits for a wordlength of 5 Bits." Name="StartUser.StopB"/>
			FifoOnOff 	: DINT := 1;			//! <Variable Comment="0=FIFO disable, FIFO enable: 1,4,8,14 = Triggerlevel" Name="StartUser.FifoOnOff"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1=invalid Com; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)&#13;&#10;-50=FIFO doesn´t exist" Name="StartUser.ErrorCode"/>
		END_VAR;
				//! <Function Comment="&#13;&#10; ***************************************************************************&#13;&#10; ****************    _SerLib::StopUser                   ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                     **&#13;&#10; ** Closes an initialized COM and enables the lasal online-communication  **&#13;&#10; ***************************************************************************&#13;&#10;" Name="StopUser"/>
	FUNCTION VIRTUAL GLOBAL StopUser
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="StopUser.ErrorCode"/>
		END_VAR;
				//! <Function Comment="***************************************&#13;&#10; ****************    _SerLib::SerSend          ***********************&#13;&#10; ***************************************************************************&#13;&#10; ***                                   ******&#13;&#10; *** Sends DATA over the initialized COM                 ******&#13;&#10; *** If there is an Error, wrlen returns how many Bytes were sended   ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;bufferlength]The length of the data buffer to be sent.&#13;&#10;[&gt;wrlen]number of sent bytes&#13;&#10;" Name="SerSend"/>
	FUNCTION VIRTUAL GLOBAL SerSend
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="pointer to receive buffer" Name="SerSend.Buffer"/>
			Bufferlength 	: UDINT;			//! <Variable Comment="number of bytes in the buffer" Name="SerSend.Bufferlength"/>
			WrLen 	: ^UDINT;			//! <Variable Comment="pointer to an variable&#13;&#10;the method writes the number of the written bytes&#13;&#10;" Name="SerSend.WrLen"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SerSend.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ************************************************&#13;&#10; *************  _SerLib::Serclose   *************&#13;&#10; ************************************************&#13;&#10; ***                        ***&#13;&#10; *** This Function clears an initialized COM  ***&#13;&#10; *** receiving buffer also will be cleared    ***&#13;&#10; ***                        ***&#13;&#10; *** --&gt; Not in use               ***&#13;&#10; *** &lt;-- Not in use                           ***&#13;&#10; ***                        ***&#13;&#10; ************************************************&#13;&#10;" Name="SerClose"/>
	FUNCTION VIRTUAL GLOBAL SerClose;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************    _SerLib::SetOnline                   ****************&#13;&#10; ***************************************************************************&#13;&#10; **                                     **&#13;&#10; **   function enables or disables the lasal online communication     ** &#13;&#10; ***************************************************************************&#13;&#10;[&gt;state]0:Lasal online communication disabled; 1=Lasal online communication enabled&#13;&#10;[&lt;ErrorCode]0=OK; -1:Com&lt;&gt;1-4; -2=Error baudtable; -3=baudrate&lt;&gt;0-10; -4=parity&lt;&gt;0-4; - 5=stopbits&lt;&gt;1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetOnline"/>
	FUNCTION VIRTUAL GLOBAL SetOnline
		VAR_INPUT
			state 	: UDINT;			//! <Variable Comment="0=low: shut down lasal online communication&#13;&#10;1=high turn on lasal online communication (standard)" Name="SetOnline.state"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetOnline.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************       _SerLib::RecvBlock        *********************&#13;&#10; ***************************************************************************&#13;&#10; ****                                 ******&#13;&#10; ****   reads a area of character of the receiving buffer       ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;rdlength]Bytes you want to read of the receiving buffer&#13;&#10;[&gt;rdlen]number of correct readed Bytes&#13;&#10;" Name="RecvBlock"/>
	FUNCTION VIRTUAL GLOBAL RecvBlock
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="Pointer to receivbuffer" Name="RecvBlock.Buffer"/>
			rdlength 	: UDINT;			//! <Variable Comment="Number of bytes that should be received" Name="RecvBlock.rdlength"/>
			rdlen 	: ^UDINT;			//! <Variable Comment="number of correct received bytes" Name="RecvBlock.rdlen"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvBlock.ErrorCode"/>
		END_VAR;
				//! <Function Comment="&#13;&#10; ***************************************************************************&#13;&#10; ****************      _SerLib::RecvChar         ***********************&#13;&#10; ***************************************************************************&#13;&#10; ****                                 ******&#13;&#10; ***    the function reads one byte from the serial drivers receive   ******&#13;&#10; ****    buffer                            ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;Buffer]Pointer to receiving buffer&#13;&#10;[&lt;ErrorCode]0=OK; -1:Com&lt;&gt;1-4; -2=Error baudtable; -3=baudrate&lt;&gt;0-10; -4=parity&lt;&gt;0-4; - 5=stopbits&lt;&gt;1-2; -6=ErrorWORDLEN; -10=Com allready in use; -11=Com allready in use of OS; -12=CPU has no COM of this No.;-13=OS Error;-14=NoInitialization; -15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; -17=INPUT was NIL; -19=no DATA in receiving buffer; -20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvChar"/>
	FUNCTION VIRTUAL GLOBAL RecvChar
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="pointer to the buffer" Name="RecvChar.Buffer"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvChar.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************       _SerLib::GetRecvStatus        *****************&#13;&#10; ***************************************************************************&#13;&#10; ***                                     ***&#13;&#10; ***     returns the number of characters in the receive buffer          ***&#13;&#10; ***     if return value &lt; 0 --&gt; return value = Error Code               ***&#13;&#10; ***************************************************************************&#13;&#10;[&lt;length]number of bytes in receiving buffer&#13;&#10;" Name="GetRecvState"/>
	FUNCTION VIRTUAL GLOBAL GetRecvState
		VAR_OUTPUT
			length 	: UDINT;			//! <Variable Comment="Number of bytes in the OS receive buffer" Name="GetRecvState.length"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************        _SerLib::GetSendStatus          *****************&#13;&#10; ***************************************************************************&#13;&#10; ***                                 ******&#13;&#10; ***     returns, how many Bytes are in the &quot;sendbuffer&quot;             ******&#13;&#10; ***     if return value &lt; 0 --&gt; return value = Error Code            ******&#13;&#10; ***************************************************************************&#13;&#10;[&lt;to_send] How many Bytes are too send. If 0 is returned the send buffer of software (1024Byte default) and hardware (120Byte) is empty&#13;&#10;" Name="GetSendState"/>
	FUNCTION VIRTUAL GLOBAL GetSendState
		VAR_OUTPUT
			to_send 	: UDINT;			//! <Variable Comment="If the function succeeds, the return value is the number of characters in the send buffer, otherwise a negative error code value is returned." Name="GetSendState.to_send"/>
		END_VAR;
				//! <Function Comment=" *********************************************************************************************&#13;&#10; ****************************     _SerLib::GetError      *************************************&#13;&#10; *********************************************************************************************&#13;&#10; **  returns actual error state                               ***&#13;&#10; ** ---------------------------------------------------------------------------------------***&#13;&#10; ****                                             ***&#13;&#10; **            !!!!    ERROR CODE TABLE   !!!!                         ***&#13;&#10; **                                              ***&#13;&#10; **   0 .. SERERROR_NONE                                   ***&#13;&#10; ** - 1 .. SERERROR_COMNUM     -&gt; Com &lt;&gt; 1-4                         ***&#13;&#10; ** - 2 .. SERERROR_BAUDTABLE  -&gt; Error baudtable                       ***&#13;&#10; ** - 3 .. SERERROR_BAUDRATE   -&gt; baudrate &lt;&gt; 0-10                      ***&#13;&#10; ** - 4 .. SERERROR_PARITY     -&gt; parity &lt;&gt; 0-4                        ***&#13;&#10; ** - 5 .. SERERROR_STOPBIT    -&gt; Stopbits &lt;&gt; 1-2                       ***&#13;&#10; ** - 6 .. SERERROR_WORDLEN   -&gt; wrong wordlength                      ***&#13;&#10; ** -10 .. SERERROR_INUSE      -&gt; Com allready in use                      ***&#13;&#10; ** -11 .. SERERROR_OSINUSE    -&gt; Com allready in use of OS                   ***&#13;&#10; ** -12 .. SERERROR_NOTAVAIL   -&gt; CPU has no COM of this NR                  ***&#13;&#10; ** -13 .. SERERROR_NOMEM      -&gt; OS Error                          ***&#13;&#10; ** -14 .. SERERROR_NOHANDLE  -&gt; Com not initialized                     ***&#13;&#10; ** -15 .. SERERROR_PARAMETER  -&gt; WRONG INPUT                         ***&#13;&#10; ** -16 .. SERERROR_RECVBUF    -&gt; Receiving Buffer too low, has to bigger then &gt;= 128 Byte&apos;s**&#13;&#10; ** -17 .. SERERROR_SENDBUF    -&gt; INPUT was NIL                        ***&#13;&#10; ** -18 .. SERERROR_TOOLONG                                    ***&#13;&#10; ** -19 .. SERERROR_RECVERROR  -&gt; No DATA in Receiving Buffer                 ***&#13;&#10; ** -20 .. SERERROR_SENDERROR  -&gt; sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)&#13;&#10; *********************************************************************************************&#13;&#10;" Name="GetError"/>
	FUNCTION VIRTUAL GLOBAL GetError
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="GetError.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************&#13;&#10; ******************    _SerLib::IsInitialized   ****************&#13;&#10; ***************************************************************&#13;&#10; **     Checks, if COM is inialized              ***&#13;&#10; **     OUTPUT: 0 = NO Initialization             ****&#13;&#10; **           1 = initialized                ****&#13;&#10; ***************************************************************&#13;&#10;[&lt;Initialization]initialized 0=NO/1=YES&#13;&#10;" Name="IsInitialized"/>
	FUNCTION VIRTUAL GLOBAL IsInitialized
		VAR_OUTPUT
			Initialization 	: UDINT;			//! <Variable Comment="is it initialized &#13;&#10;0 = no&#13;&#10;1 = yes" Name="IsInitialized.Initialization"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************&#13;&#10; ******************      _SerLib::GetInfo      ****************&#13;&#10; ***************************************************************&#13;&#10; ***                              ****&#13;&#10; ***   returns INFO of COM                  ****&#13;&#10; ***   INFO:initialized, ComPortNr, IOPort, IRQNum, ....    ****&#13;&#10; ***** -------------------------------------------------- ******&#13;&#10; ***  --&gt; Info     = Pointer of Strukt LSLAPI_SERIALINFO    ****&#13;&#10; ***  &lt;-- ErrorCode= Error Code                      ****&#13;&#10; ***************************************************************&#13;&#10;[&gt;Info]initialized : USINT; comportnum : USINT; IRQNum : USINT; IOPort : UINT; Baudrate : UINT; Ptr_RecvBuffer : pVoid; Ptr_SendBuffer : pVoid;&#13;&#10;" Name="GetInfo"/>
	FUNCTION VIRTUAL GLOBAL GetInfo
		VAR_INPUT
			Info 	: ^LSLAPI_SERIALINFO;			//! <Variable Comment="initialized : USINT; comportnum : USINT; IRQNum : USINT; IOPort : UINT; Baudrate : UINT; Ptr_RecvBuffer : pVoid; Ptr_SendBuffer : pVoid;" Name="GetInfo.Info"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="GetInfo.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ***************      _SerLib::SetBufferRecv     **************************&#13;&#10; ***************************************************************************&#13;&#10; ***                                   ******&#13;&#10; * function specifies a new receive buffer or a recommended size, in bytes *&#13;&#10; *  of the driver&apos;s internal receive buffer                 *&#13;&#10; **  !!!!   minimumsize 128 Byte    !!!!                ******&#13;&#10; ** If no receivingbuffer is initialized, a DEFAULTbuffer (1024 Byte) ******&#13;&#10; ** will be used                           ******&#13;&#10; ***************************************************************************&#13;&#10;[&gt;RecvBuffer]Pointer of Receiving Buffer&#13;&#10;[&gt;BufferLength]size of buffer (min. 128 byte)&#13;&#10;" Name="SetBufferRecv"/>
	FUNCTION VIRTUAL GLOBAL SetBufferRecv
		VAR_INPUT
			RecvBuffer 	: ^void;			//! <Variable Comment="pointer of new receive buffer" Name="SetBufferRecv.RecvBuffer"/>
			BufferLength 	: UDINT;			//! <Variable Comment="size of new receive buffer (min. 128 byte)" Name="SetBufferRecv.BufferLength"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetBufferRecv.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" ***************************************************************************&#13;&#10; ****************      _SerLib::ClearRecvBuffer          ***************&#13;&#10; ***************************************************************************&#13;&#10; ***                                     ***&#13;&#10; ***      clears the receiving buffer                     ***&#13;&#10; ***      ( puts the reading pointer to the startposition)          ***&#13;&#10; ***************************************************************************&#13;&#10;" Name="ClearRecvBuffer"/>
	FUNCTION VIRTUAL GLOBAL ClearRecvBuffer
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="ClearRecvBuffer.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************            sets/clr&apos;s   RTS            ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin set&apos;s or clear&apos;s RTS on the SERIAL interfaces                         *&#13;&#10; *  RTS = PIN 7  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH (normally)                                                   *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 38/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="RtsOnOff"/>
	FUNCTION VIRTUAL GLOBAL RtsOnOff
		VAR_INPUT
			state 	: BOOL;			//! <Variable Comment="0=low, 1=high (normally)" Name="RtsOnOff.state"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RtsOnOff.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   RTS             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s RTS on the Serial interfaces                                   *&#13;&#10; *  RTS = PIN 7  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH (normally)                                                   *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 38/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdRts"/>
	FUNCTION VIRTUAL GLOBAL rdRts
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0=LOW, 1=HIGH" Name="rdRts.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   CTS             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s CTS on the Serial interfaces                                   *&#13;&#10; *  CTS = PIN 8  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 38/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdCts"/>
	FUNCTION VIRTUAL GLOBAL rdCts
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0=LOW, 1=HIGH" Name="rdCts.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************            sets/clr&apos;s   DTR            ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin set&apos;s or clear&apos;s DTR on the SERIAL interfaces                         *&#13;&#10; *  DTR = PIN 4  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH (normally)                                                   *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="DtrOnOff"/>
	FUNCTION VIRTUAL GLOBAL DtrOnOff
		VAR_INPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="DtrOnOff.state"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="DtrOnOff.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   DTR             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s DTR on the Serial interfaces                                   *&#13;&#10; *  DTR = PIN 4  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdDtr"/>
	FUNCTION VIRTUAL GLOBAL rdDtr
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdDtr.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s  DCD              ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  Data Carrier Detect                                                           *&#13;&#10; *  Functin read&apos;s DCD on the Serial interfaces                                   *&#13;&#10; *  DCD = PIN 1  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdDCD"/>
	FUNCTION VIRTUAL GLOBAL rdDCD
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdDCD.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s   DSR             ***********************&#13;&#10; **********************************************************************************&#13;&#10; *                                                                                *&#13;&#10; *  Functin read&apos;s DSR on the Serial interfaces                                   *&#13;&#10; *  DSR = PIN 6  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdDSR"/>
	FUNCTION VIRTUAL GLOBAL rdDSR
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdDSR.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               read&apos;s  RI               ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  Ring Indicator                                                                *&#13;&#10; *  Functin read&apos;s RI  on the Serial interfaces                                   *&#13;&#10; *  RI  = PIN 9  (9pol. D-SUB)                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  &lt;- state=0: LOW                                                               *&#13;&#10; *     state=1: HIGH                                                              *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;" Name="rdRI"/>
	FUNCTION VIRTUAL GLOBAL rdRI
		VAR_OUTPUT
			state 	: BOOL;			//! <Variable Comment="0 = LOW&#13;&#10;1 = HIGH" Name="rdRI.state"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************            sets/clr&apos;s RSMode           ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  Funktion sets the mode of the interface                                       *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; MODE   : For RS232 = 232 (normally) | RS422 = 422 | RS485 = 485                    *&#13;&#10; *  &lt;- ErrorCode                                                                  *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : BS :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;[&gt;Mode]For RS232 = 232 | RS422 = 422 | CIPC &amp; RS485 = 485&#13;&#10;" Name="SetRSMode"/>
	FUNCTION VIRTUAL GLOBAL SetRSMode
		VAR_INPUT
			Mode 	: UDINT;			//! <Variable Comment="RS232 = 232 &#13;&#10;RS422 = 422; &#13;&#10;RS485 = 485" Name="SetRSMode.Mode"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetRSMode.ErrorCode"/>
		END_VAR;
				//! <Function Comment=" **********************************************************************************&#13;&#10; *******************               get RSMode               ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  Function returns the state of RSMode                                          *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; MODE   : Für RS232 = 232 | RS422 = 422  IF Mode&lt;0 =&gt; Mode=ErrorCode        *&#13;&#10; *  &lt;- ErrorCode                                                                  *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** erstellt   : RM :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10; **********************************************************************************&#13;&#10; *******************            get&apos;s RSMode                ***********************&#13;&#10; **********************************************************************************&#13;&#10; *  function reads the RS Mode                                                    *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; *  -&gt; MODE   : For RS232 = 232 | RS422 = 422 IF Mode&lt;0 =&gt; Mode=ErrorCode         *&#13;&#10; *                                                                                *&#13;&#10; *                                                                                *&#13;&#10; ** ----------------------------------------------------------------------------- *&#13;&#10; ** created    : RM :  KW 48/03                                                   *&#13;&#10; **********************************************************************************&#13;&#10;[&gt;Mode]For RS232 = 232 | RS422 = 422; IF Mode&lt;0 =&gt; Mode=ErrorCode&#13;&#10;" Name="GetRSMode"/>
	FUNCTION VIRTUAL GLOBAL GetRSMode
		VAR_OUTPUT
			Mode 	: DINT;			//! <Variable Comment="232 = RS232&#13;&#10;422 = RS422&#13;&#10;" Name="GetRSMode.Mode"/>
		END_VAR;
				//! <Function Comment="Gets the timestamp from received character&#13;&#10;Buffer is used like normal receive buffer (see RecvChar)" Name="RecvTimingChar"/>
	FUNCTION VIRTUAL GLOBAL RecvTimingChar
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="Buffer where the timestamps are stored" Name="RecvTimingChar.Buffer"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvTimingChar.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Gets the timestamps of an received block&#13;&#10;Buffer is used like normal receive buffer (see RecvBlock)" Name="RecvTimingBlock"/>
	FUNCTION VIRTUAL GLOBAL RecvTimingBlock
		VAR_INPUT
			Buffer 	: ^void;			//! <Variable Comment="Buffer where the timestamps are stored" Name="RecvTimingBlock.Buffer"/>
			rdlength 	: UDINT;			//! <Variable Comment="Number of timestamps that should be read out of the buffer" Name="RecvTimingBlock.rdlength"/>
			rdlen 	: ^UDINT;			//! <Variable Comment="number of correct received timestamps" Name="RecvTimingBlock.rdlen"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="RecvTimingBlock.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Clears the buffer where the timestamps are stored&#13;&#10;This function is used like the function clearBuffer" Name="ClearTimingBuffer"/>
	FUNCTION VIRTUAL GLOBAL ClearTimingBuffer
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="ClearTimingBuffer.ErrorCode"/>
		END_VAR;
				//! <Function Comment="With this function it is possible to set a specific receive buffer&#13;&#10;where the timestamps of the received bytes are stored&#13;&#10;This function is used like the function SetBufferRecv" Name="SetTimingBufferRecv"/>
	FUNCTION VIRTUAL GLOBAL SetTimingBufferRecv
		VAR_INPUT
			RecvBuffer 	: ^void;			//! <Variable Comment="pointer of the new buffer" Name="SetTimingBufferRecv.RecvBuffer"/>
			BufferLength 	: UDINT;			//! <Variable Comment="size of the buffer (min. 128 bytes)" Name="SetTimingBufferRecv.BufferLength"/>
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;			//! <Variable Comment="returns the errorcode&#13;&#10;0=OK; &#13;&#10;-1:Com&lt;&gt;1-4; &#13;&#10;-2=Error baudtable; &#13;&#10;-3=baudrate&lt;&gt;0-10; &#13;&#10;-4=parity&lt;&gt;0-4; &#13;&#10;- 5=stopbits&lt;&gt;1-2; &#13;&#10;-6=ErrorWORDLEN; &#13;&#10;-10=Com allready in use; &#13;&#10;-11=Com allready in use of OS; &#13;&#10;-12=CPU has no COM of this No.;&#13;&#10;-13=OS Error;-14=NoInitialization; &#13;&#10;-15=WRONG INPUT; -16=receiving buffer too low, has to be bigger then &gt;= 128 Byte&apos;s; &#13;&#10;-17=INPUT was NIL; &#13;&#10;-19=no DATA in receiving buffer; &#13;&#10;-20=sending process couldn&apos;t be ended (disturbance., sendbuffer overflow, ...)" Name="SetTimingBufferRecv.ErrorCode"/>
		END_VAR;
				//! <Function Comment="Overwrite this method if you need a user defined interface!" Name="GetInterfaceType"/>
	FUNCTION VIRTUAL GLOBAL GetInterfaceType
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="Contains the interface type.&#13;&#10;0..(default) the interface is the standard &#13;&#10;&lt;&gt;0..user defined" Name="GetInterfaceType.Retcode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL UpdateRt;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL UpdateCy;
				//! <Function Comment="This function adds dynamic accesses." Name="AddAccesses"/>
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL LogError
		VAR_INPUT
			pMsg 	: ^CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL LogValue
		VAR_INPUT
			pString 	: ^CHAR;
			udValue 	: UDINT;
			udValue2 	: UDINT := 16#FFFFFFFF;
			udValue3 	: UDINT := 16#FFFFFFFF;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
	
	FUNCTION ChangeDO
		VAR_INPUT
			AccessHandle 	: UDINT;
			NewOffset 	: HDINT := SDIAS_UNCHANGED_DYNAMIC_PARA;
			NewLength 	: UDINT := SDIAS_UNCHANGED_DYNAMIC_PARA;
		END_VAR;
	
	FUNCTION GetBaudrateValue
		VAR_INPUT
			Baudrate 	: DINT;
		END_VAR
		VAR_OUTPUT
			Divisor 	: UINT;
		END_VAR;
	
	FUNCTION InitRingbuffer
		VAR_INPUT
			pRingBuffer 	: ^t_RingBuffer;
			BufferSize 	: UDINT;
		END_VAR;
	
	FUNCTION GetReadData;
	
	FUNCTION PrepareNextReadData;
	
	FUNCTION PrepareSendData;
	
	FUNCTION AddDataToRingBuffer
		VAR_INPUT
			pRingBuffer 	: ^t_RingBuffer;
			pNewData 	: ^void;
			DataSize 	: UDINT;
			pDataSizeAdded 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION GetDataFromRingBuffer
		VAR_INPUT
			pRingBuffer 	: ^t_RingBuffer;
			pGetBuffer 	: ^void;
			DataSize 	: UDINT;
			pDataSizeFetched 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION InitInternal;
				//! <Function Comment="This method is used to set the baudrate.&#13;&#10;&#13;&#10;Errorcodes:&#13;&#10;-3 ... Baudrate not available" Name="SetBaudRate"/>
	FUNCTION VIRTUAL GLOBAL SetBaudRate
		VAR_INPUT
			BaudRate 	: DINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;
			hOffset 	: HINT;
			usLength 	: USINT;
			eResult 	: iprStates;
			pResponseBuffer 	: ^USINT;
			ResponseLength 	: USINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION GLOBAL SetHwOptionBits
		VAR_INPUT
			bdSetHwOptionBits 	: t_bdOptionBits;
		END_VAR;
	
	FUNCTION GLOBAL SetIFState
		VAR_INPUT
			pbInterfaceActive 	: ^BOOL := NIL;
			pbAdditionalIFActive 	: ^BOOL := NIL;
		END_VAR;
	
	FUNCTION GLOBAL GetIFState
		VAR_INPUT
			pbInterfaceActive 	: ^BOOL := NIL;
			pbAdditionalIFActive 	: ^BOOL := NIL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib
#pragma usingLtd SdiasBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SdiasUartHandler::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDIASUARTHANDLER
1$UINT, 12$UINT, (SIZEOF(::SdiasUartHandler))$UINT, 
3$UINT, 6$UINT, 0$UINT, 
TO_UDINT(1297832995), "SdiasUartHandler", //Class
TO_UDINT(4078275645), "_SerLib", 1$UINT, 34$UINT, //Baseclass
//Servers:
(::SdiasUartHandler.InvalidDataErrorCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2554396159), "InvalidDataErrorCnt", 
(::SdiasUartHandler.RecBufOverflowErrorCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(805978621), "RecBufOverflowErrorCnt", 
(::SdiasUartHandler.HwOptionBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2047737725), "HwOptionBits", 
//Clients:
(::SdiasUartHandler.ToSdiasBase.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2534957682), "ToSdiasBase", TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, 
(::SdiasUartHandler.ToStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2501598121), "ToStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::SdiasUartHandler.AddressOffset.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3269153673), "AddressOffset", 
(::SdiasUartHandler.UartType.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2369976688), "UartType", 
(::SdiasUartHandler.MaxRdLen.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3864267952), "MaxRdLen", 
(::SdiasUartHandler.MaxWrLen.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1539738499), "MaxWrLen", 
END_FUNCTION


#define USER_CNT_SdiasUartHandler 38

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SdiasUartHandler] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SdiasUartHandler::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _SerLib::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _SerLib::Command.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _SerLib::Command.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SdiasUartHandler;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #StartUser();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #StopUser();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #SerSend();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SerClose();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #SetOnline();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #RecvBlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #RecvChar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #GetRecvState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #GetSendState();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #GetError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #IsInitialized();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetInfo();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #SetBufferRecv();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #ClearRecvBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #RtsOnOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #rdRts();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #rdCts();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #DtrOnOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #rdDtr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #rdDCD();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #rdDSR();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #rdRI();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #SetRSMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetRSMode();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #RecvTimingChar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #RecvTimingBlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #ClearTimingBuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #SetTimingBufferRecv();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #GetInterfaceType();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #LogError();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #LogValue();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #SetBaudRate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #InitModule();

#pragma warning (default : 74)
	_SerLib::Command.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _SerLib::Command.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL SdiasUartHandler::StartUser
	VAR_INPUT
		Baud 	: DINT;
		wordl 	: DINT;
		Parity 	: DINT;
		StopB 	: DINT;
		FifoOnOff 	: DINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;

  if (Baud >= SDIAS_UART_BAUD_300) & (Baud <= SDIAS_UART_BAUD_115200) then
    if ((Wordl >= 5) & (Wordl <= 8)) | ((Wordl = 9) & (HwOptionBits._9BitMode | (HwOptionBits.OptionBitsValid = FALSE))) then
      if (Parity >= SERUSERPARITY_NONE) & (Parity <= SERUSERPARITY_SPACE) then
        if (StopB = 1) | (StopB = 2) then
          // on TTY only baudrates up to 19200 bps are allowed
          IF (UartType = SDIAS_UART_TYPE_TTY) & (Baud > SDIAS_UART_BAUD_19200) THEN
            ErrorCode := SERERROR_BAUDRATE;
          ELSE
            // protect via mutex because this memory could be used from different task priorities
            OS_MT_WAIT(AccessData.pMutex);
            
            // get divisor via baud setting
            if bExtendedBaudrateSet = false then
              //only set baudrate if baudrate has not been set via setextendedbaudrate before.
              AccessData.LocalWriteData.DivisorLatchReg := GetBaudrateValue(Baudrate:=Baud);
            end_if;
            
            //Save Wordlen in variable
            WordLen := wordl$USINT;          
            
            if ( WordLen = 9) then
              //Set Registers that 9bit mode is enabled
              AccessData.LocalWriteData.ModemControlReg.Enable9BitMode    := 1;
              AccessData.LocalWriteData.LineControlReg.WordLenSelectBit0  := 1;
              AccessData.LocalWriteData.LineControlReg.WordLenSelectBit1  := 1;
              AccessData.LocalWriteData.LineControlReg.ParityEnable       := 1;
              AccessData.LocalWriteData.LineControlReg.StickParity        := 1;
            else 
              // set word length (0 = 5 bit, 1 = 6 bit, 2 = 7 bit, 3 = 8 bit)
              AccessData.LocalWriteData.LineControlReg := (AccessData.LocalWriteData.LineControlReg AND 2#11111100) OR ((wordl - 5) AND 2#11)$t_LineControlReg;

              // set parity options
              AccessData.LocalWriteData.LineControlReg.ParityEnable := Parity <> SERUSERPARITY_NONE;
              AccessData.LocalWriteData.LineControlReg := (AccessData.LocalWriteData.LineControlReg AND 2#11001111) OR ((Parity SHR 1) SHL 4)$t_LineControlReg;
            end_if;

            // set number of stop bits (at 5 bits wordlength 2 stopbits mean 1.5 stopbits). 1 stopbit is FALSE, 2 stopbits = TRUE
            AccessData.LocalWriteData.LineControlReg.NumberOfStopBits := StopB = 2;

            
            // there is no fifo setting here

            b_Initialized := TRUE;

            OS_MT_SIGNAL(AccessData.pMutex);

            ErrorCode := SERERROR_NONE;
          END_IF;            
        else
          ErrorCode := SERERROR_STOPBIT;
        end_if;
      else
        ErrorCode := SERERROR_PARITY;
      end_if;
    else
      ErrorCode := SERERROR_WORDLEN;
    end_if;
  else
    ErrorCode := SERERROR_BAUDRATE;
  end_if;

  if ErrorCode <> SERERROR_NONE then
    ActError := ErrorCode;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::StopUser
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;

  // protect via mutex because the memory could be used from different task priorities
  OS_MT_WAIT(AccessData.pMutex);

  // stop sending (clear internal transmit buffer)
  InitRingbuffer(pRingBuffer:=#TxBuffer, BufferSize:=TxBuffer.ud_BufferSize);

  b_Initialized := FALSE;

  OS_MT_SIGNAL(AccessData.pMutex);

  ErrorCode := SERERROR_NONE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::SerSend
	VAR_INPUT
		Buffer 	: ^void;
		Bufferlength 	: UDINT;
		WrLen 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;
    
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;
  
  // check parameters
  if Buffer & Bufferlength then
    // protect via mutex because the memory could be used from different task priorities
    OS_MT_WAIT(AccessData.pMutex);

    // copy the data into the ringbuffer
    ErrorCode := AddDataToRingBuffer(pRingBuffer:=#TxBuffer, pNewData:=Buffer, DataSize:=Bufferlength, pDataSizeAdded:=WrLen);

    // protect via mutex because the memory could be used from different task priorities
    OS_MT_SIGNAL(AccessData.pMutex);
  else
    ErrorCode := SERERROR_SENDBUF;
  end_if;

  if ErrorCode <> SERERROR_NONE then
    ActError := ErrorCode;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::SerClose

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    return;
  end_if;
  
  // protect via mutex because the memory could be used from different task priorities
  OS_MT_WAIT(AccessData.pMutex);

  // clear transmit and receive buffer
  InitRingbuffer(pRingBuffer:=#TxBuffer, BufferSize:=TxBuffer.ud_BufferSize);
  InitRingbuffer(pRingBuffer:=#RxBuffer, BufferSize:=RxBuffer.ud_BufferSize);

  OS_MT_SIGNAL(AccessData.pMutex);

END_FUNCTION

#pragma warning(disable: 73)
FUNCTION VIRTUAL GLOBAL SdiasUartHandler::SetOnline
	VAR_INPUT
		state 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // not possible to go online on sdias module (only used for internal serial interfaces)
  ErrorCode := SERERROR_NOTAVAIL;

END_FUNCTION
#pragma warning(default: 73)


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::RecvBlock
	VAR_INPUT
		Buffer 	: ^void;
		rdlength 	: UDINT;
		rdlen 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;

  if Buffer & rdlength then
    // protect via mutex because this memory could be used from different task priorities
    OS_MT_WAIT(AccessData.pMutex);

    // check if enough data in ring buffer
    if rdlength > RxBuffer.ud_MemUsed then
      rdlength := RxBuffer.ud_MemUsed; 
    end_if;
    
    if rdlength > 0 then
      // copy the data from the ringbuffer
      ErrorCode := GetDataFromRingBuffer(pRingBuffer:=#RxBuffer, pGetBuffer:=Buffer, DataSize:=rdlength, pDataSizeFetched:=rdlen);
    else
      // if there is no data in rxbuffer
      ErrorCode := SERERROR_RECVERROR;      
      biLogging.RxGetBufferOverflow := TRUE;
    end_if;
    
    OS_MT_SIGNAL(AccessData.pMutex);
  else
    ErrorCode := SERERROR_PARAMETER;
  end_if;
   
  if ErrorCode <> SERERROR_NONE then
    ActError := ErrorCode;
  end_if;
  
  if ErrorCode <> SERERROR_RECVERROR then
    //if no error occurred allow logging again
    biLogging.RxGetBufferOverflowLogged := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::RecvChar
	VAR_INPUT
		Buffer 	: ^void;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;
  
  if Buffer then
    // protect via mutex because this memory could be used from different task priorities
    OS_MT_WAIT(AccessData.pMutex);

    // copy the data from the ringbuffer
    ErrorCode := GetDataFromRingBuffer(pRingBuffer:=#RxBuffer, pGetBuffer:=Buffer, DataSize:=sizeof(CHAR), pDataSizeFetched:=NIL);

    OS_MT_SIGNAL(AccessData.pMutex);
  else
    ErrorCode := SERERROR_PARAMETER;
  end_if;
  
  if ErrorCode <> SERERROR_NONE then
    ActError := ErrorCode;
  end_if;

  if ErrorCode <> SERERROR_RECVERROR then
    //if no error occurred allow logging again
    biLogging.RxGetBufferOverflowLogged := FALSE;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::GetRecvState
	VAR_OUTPUT
		length 	: UDINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    length := 0;
    return;
  end_if;
  
  length := RxBuffer.ud_MemUsed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::GetSendState
	VAR_OUTPUT
		to_send 	: UDINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    to_send := 0;
    return;
  end_if;  
  
  //add act transmit len because of transmission delay
  to_send := TxBuffer.ud_MemUsed + AccessData.LocalReadData.TransmitByteCounter + sTxBufferUsed.udLastTransmitDiff + sTxBufferUsed.udActTransmitDiff; // check for empty transmit buffer

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::GetError
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  ErrorCode := ActError;
  
  // reset on readout
  ActError := SERERROR_NONE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::IsInitialized
	VAR_OUTPUT
		Initialization 	: UDINT;
	END_VAR

  // state of interface (startuser sets, stopuser resets bit)
  Initialization := b_Initialized;

END_FUNCTION


#pragma warning(disable: 73)
FUNCTION VIRTUAL GLOBAL SdiasUartHandler::GetInfo
	VAR_INPUT
		Info 	: ^LSLAPI_SERIALINFO;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // info structure not available
  ErrorCode := SERERROR_NOTAVAIL;

END_FUNCTION
#pragma warning(default: 73)


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::SetBufferRecv
	VAR_INPUT
		RecvBuffer 	: ^void;
		BufferLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;  

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;

  if RecvBuffer & BufferLength then
    // protect via mutex because this memory could be used from different task priorities
    OS_MT_WAIT(AccessData.pMutex);

    if RxBuffer.pMemStart & RxBuffer.b_DefaultBuffer then
      ToStdLib.Free(mptr:=RxBuffer.pMemStart);
      RxBuffer.b_DefaultBuffer := FALSE;
    end_if;

    RxBuffer.pMemStart := RecvBuffer;
    RxBuffer.pActWr := RxBuffer.pMemStart;
    RxBuffer.pActRd := RxBuffer.pMemStart;
    RxBuffer.ud_BufferSize := BufferLength;
    _memset(dest:=RxBuffer.pMemStart, usByte:=0, cntr:=RxBuffer.ud_BufferSize);
    RxBuffer.pLastEntry := RxBuffer.pMemStart + BufferLength-1;

    RxBuffer.ud_MemUsed := 0;

    OS_MT_SIGNAL(AccessData.pMutex);
    
    ErrorCode := SERERROR_NONE;
  else
    ErrorCode := SERERROR_PARAMETER;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::ClearRecvBuffer
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;

  // protect via mutex because this memory could be used from different task priorities
  OS_MT_WAIT(AccessData.pMutex);

  InitRingbuffer(pRingBuffer:=#RxBuffer, BufferSize:=RxBuffer.ud_BufferSize);

  OS_MT_SIGNAL(AccessData.pMutex);

  ErrorCode := SERERROR_NONE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::RtsOnOff
	VAR_INPUT
		state 	: BOOL;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;
  
  //check if RTS is used for additional interface
  if bAdditionaIFActive = FALSE then  
    // protect via mutex because this memory could be used from different task priorities
    OS_MT_WAIT(AccessData.pMutex);

    // set the state in the write data
    AccessData.LocalWriteData.ModemControlReg.RequestToSend := state;

    OS_MT_SIGNAL(AccessData.pMutex);

    ErrorCode := SERERROR_NONE;
  else
    ErrorCode := SERERROR_NOTAVAIL;  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::rdRts
	VAR_OUTPUT
		state 	: BOOL;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    state := FALSE;
    return;
  end_if;
  
  // protect via mutex because this memory could be used from different task priorities
  OS_MT_WAIT(AccessData.pMutex);

  // if it's set in the read or write data => return it as set
  state := AccessData.LocalReadData.ModemControlReg.RequestToSend OR AccessData.LocalWriteData.ModemControlReg.RequestToSend;

  OS_MT_SIGNAL(AccessData.pMutex);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::rdCts
	VAR_OUTPUT
		state 	: BOOL;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    state := FALSE;
    return;
  end_if;
  
  // protect via mutex because this memory could be used from different task priorities
  OS_MT_WAIT(AccessData.pMutex);

  state := AccessData.LocalReadData.ModemStatusReg.ClearToSend;

  OS_MT_SIGNAL(AccessData.pMutex);

END_FUNCTION

#pragma warning(disable: 73)
FUNCTION VIRTUAL GLOBAL SdiasUartHandler::DtrOnOff
	VAR_INPUT
		state 	: BOOL;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  
  ErrorCode := SERERROR_NOTAVAIL;

END_FUNCTION
#pragma warning(default: 73)

FUNCTION VIRTUAL GLOBAL SdiasUartHandler::rdDtr
	VAR_OUTPUT
		state 	: BOOL;
	END_VAR
  
  //this pin is not used
  state := FALSE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::rdDCD
	VAR_OUTPUT
		state 	: BOOL;
	END_VAR

  //this pin is not used
  state := FALSE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::rdDSR
	VAR_OUTPUT
		state 	: BOOL;
	END_VAR

  //this pin is not used
  state := FALSE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::rdRI
	VAR_OUTPUT
		state 	: BOOL;
	END_VAR

  //this pin is not used
  state := FALSE;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::SetRSMode
	VAR_INPUT
		Mode 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;

  ErrorCode := SERERROR_NONE;

  case UartType of
//********************************************************************************************************************************************************
    SDIAS_UART_TYPE_RS232:
      if Mode <> 232 then
        ErrorCode := SERERROR_NOTAVAIL;
      end_if;

//********************************************************************************************************************************************************
    SDIAS_UART_TYPE_RS485:
    
      // protect via mutex because this memory could be used from different task priorities
      OS_MT_WAIT(AccessData.pMutex);

      case Mode of
  //******************************************************************************************************************************************************
        422:
          RSMode := Mode;
          AccessData.LocalWriteData.ModemControlReg.RSMode          := FALSE;
          AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
          AccessData.LocalWriteData.ModemControlReg.EchoOff         := FALSE;
          
  //******************************************************************************************************************************************************
        485: // with echo
          RSMode := Mode;
          AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
          AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
          AccessData.LocalWriteData.ModemControlReg.EchoOff         := FALSE;
          
  //******************************************************************************************************************************************************
        4850:// without echo
          RSMode := Mode;
          AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
          AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
          AccessData.LocalWriteData.ModemControlReg.EchoOff         := TRUE;
  
  //******************************************************************************************************************************************************
      else
        ErrorCode := SERERROR_PARAMETER;
      end_case;

      OS_MT_SIGNAL(AccessData.pMutex);

  
  //********************************************************************************************************************************************************
    SDIAS_UART_TYPE_TTY:   
    
      // protect via mutex because this memory could be used from different task priorities
      OS_MT_WAIT(AccessData.pMutex);
      

      case Mode of          
  //******************************************************************************************************************************************************
        485: // with echo
          RSMode := Mode;
          AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
          AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
          AccessData.LocalWriteData.ModemControlReg.EchoOff         := FALSE;
          
  //******************************************************************************************************************************************************
        4850:// without echo
          RSMode := Mode;
          AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
          AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
          AccessData.LocalWriteData.ModemControlReg.EchoOff         := TRUE;
  
  //******************************************************************************************************************************************************
      else  // without echo      
        RSMode := Mode;
        AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
        AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
        AccessData.LocalWriteData.ModemControlReg.EchoOff         := TRUE;
      end_case;
      
      OS_MT_SIGNAL(AccessData.pMutex);

//********************************************************************************************************************************************************
  else
    // not supported for the input uart type
    ErrorCode := SERERROR_NOTAVAIL;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::GetRSMode
	VAR_OUTPUT
		Mode 	: DINT;
	END_VAR

  // init has to be done before the user interfaces => call this if it hasn't been done already
  if b_InitDone = FALSE then
    InitInternal();
    b_InitDone := TRUE;
  end_if;

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    Mode := SERERROR_NOTAVAIL;
    return;
  end_if;
  
  // not possible on TTY
  if RSMode then
    Mode := RSMode$DINT;
  else
    Mode := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


#pragma warning(disable: 73)
FUNCTION VIRTUAL GLOBAL SdiasUartHandler::RecvTimingChar
	VAR_INPUT
		Buffer 	: ^void;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  ErrorCode := SERERROR_NOTAVAIL;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::RecvTimingBlock
	VAR_INPUT
		Buffer 	: ^void;
		rdlength 	: UDINT;
		rdlen 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  ErrorCode := SERERROR_NOTAVAIL;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::ClearTimingBuffer
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  ErrorCode := SERERROR_NOTAVAIL;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::SetTimingBufferRecv
	VAR_INPUT
		RecvBuffer 	: ^void;
		BufferLength 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR

  ErrorCode := SERERROR_NOTAVAIL;

END_FUNCTION
#pragma warning(default: 73)


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::GetInterfaceType
	VAR_OUTPUT
		Retcode 	: DINT;
	END_VAR

  // bit 0: 0 = OS; 1 = HW-Class
  // bit 1: 1 = Modbus-RTU
  // bit 2: 0 = echo off possible; 1 = echo can not turned off
  Retcode := 2#001;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::Init

  usInitCounter += 1;  

  if usInitCounter = 1 then
    // init has to be done before the user interfaces => call this if it hasn't been done already
    if b_InitDone = FALSE then
      InitInternal();
      b_InitDone := TRUE;     
     usHwBufferSize := SDIAS_UART_RXTX_BUFFER_SIZE_HW;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::UpdateRt

  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    return;
  end_if;
  
  // protect via mutex because the memory could be used from different task priorities
  OS_MT_WAIT(AccessData.pMutex);
  
  // get the last read data into our local buffer
  GetReadData();
  
  // prepare access for the next read data
  PrepareNextReadData();
  
  OS_MT_SIGNAL(AccessData.pMutex);
  
  // only change the DO if the length of the access has changed
  if AccessData.ReadAccess.ActLength <> AccessData.ReadAccess.LastDOLen then
    ChangeDO(AccessHandle:=AccessData.ReadAccess.AccessHandle, NewLength:=AccessData.ReadAccess.ActLength);
    AccessData.LocalWriteData.Reserved := AccessData.ReadAccess.ActLength - AccessData.ReadAccess.LastDOLen;
    AccessData.ReadAccess.LastDOLen := AccessData.ReadAccess.ActLength;
  else
    AccessData.LocalWriteData.Reserved := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::UpdateRtPostScan
  
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    return;
  end_if;
  
  // protect via mutex because the memory could be used from different task priorities
  OS_MT_WAIT(AccessData.pMutex);

  // prepare the next send data
  PrepareSendData();

  OS_MT_SIGNAL(AccessData.pMutex);

  // only change the DO if the length of the access has changed
  if AccessData.WriteAccess.ActLength <> AccessData.WriteAccess.LastDOLen then
    ChangeDO(AccessHandle:=AccessData.WriteAccess.AccessHandle, NewLength:=AccessData.WriteAccess.ActLength);
    AccessData.WriteAccess.LastDOLen := AccessData.WriteAccess.ActLength;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    eModuleInitState := READY;
    return;
  end_if;
  
  MyPara.uiCmd := SDIAS_CLT_CMD_ADD_DYN_WRITE;
  // the first parameters are filled by the sdias client object
  MyPara.aPara[3] := AddressOffset$DINT + SDIAS_UART_OFFSET_WR;
  MyPara.aPara[4] := sizeof(t_WriteData) - sizeof(t_WriteData.aTransmitBuffer) + MaxWrLen$DINT;
  MyPara.aPara[5] := (#AccessData.pWriteData)$DINT;
  MyPara.aPara[6] := (#AccessData.WriteAccess.pStateByte)$DINT;
  MyPara.aPara[7] := (#AccessData.WriteAccess.pControlByte)$DINT;
  MyPara.aPara[8] := (#AccessData.WriteAccess.AccessHandle)$DINT;
  MyPara.aPara[9] := 0; // wait for access handle;
  MyPara.aPara[10]:= 0; // it's a memory access;

  eModuleInitState := ToSdiasBase.NewInst(#MyPara, #MyResult);

  if eModuleInitState <> READY then
    LogValue("@053A (SdiasUartHandler::AddAccesses) Failed to add dynamic write access for SDIAS module at Place 0x{0}.", MyPara.aPara[2]$UDINT);
    return;
  end_if;

  MyPara.uiCmd := SDIAS_CLT_CMD_ADD_DYN_READ;
  // the first parameters are filled by the sdias client object
  MyPara.aPara[3] := AddressOffset$DINT + SDIAS_UART_OFFSET_RD;
  MyPara.aPara[4] := sizeof(t_ReadData) - sizeof(t_ReadData.aReceiveBuffer) + MaxRdLen$DINT;
  MyPara.aPara[5] := (#AccessData.pReadData)$DINT;
  MyPara.aPara[6] := (#AccessData.ReadAccess.pStateByte)$DINT;
  MyPara.aPara[7] := (#AccessData.ReadAccess.pControlByte)$DINT;
  MyPara.aPara[8] := (#AccessData.ReadAccess.AccessHandle)$DINT;
  MyPara.aPara[9] := 0; // wait for access handle;
  MyPara.aPara[10]:= 0; // it's a memory access;

  eModuleInitState := ToSdiasBase.NewInst(#MyPara, #MyResult);

  if eModuleInitState <> READY then
    LogValue("@053B (SdiasUartHandler::AddAccesses) Failed to add dynamic read access for SDIAS module at Place 0x{0}.", MyPara.aPara[2]$UDINT);
    return;
  end_if;

  eModuleInitState := READY;

END_FUNCTION


FUNCTION VIRTUAL SdiasUartHandler::LogError
	VAR_INPUT
		pMsg 	: ^CHAR;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  MyPara.uiCmd := SDIAS_CLT_CMD_LOG_MESSAGE;
  MyPara.aPara[0] := pMsg$DINT;
  ToSdiasBase.NewInst(#MyPara, #MyResult);

END_FUNCTION


FUNCTION VIRTUAL SdiasUartHandler::LogValue
	VAR_INPUT
		pString 	: ^CHAR;
		udValue 	: UDINT;
		udValue2 	: UDINT;
		udValue3 	: UDINT;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  MyPara.uiCmd := SDIAS_CLT_CMD_LOG_VALUE;
  MyPara.aPara[0] := pString$DINT;
  MyPara.aPara[1] := udValue$DINT;
  MyPara.aPara[2] := udValue2$DINT;
  MyPara.aPara[3] := udValue3$DINT;
  ToSdiasBase.NewInst(#MyPara, #MyResult);
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::ConnectEvent

  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    return;
  end_if;
  
  // at first we only transmit the header
  AccessData.WriteAccess.ActLength := SDIAS_UART_TX_LEN_NO_DATA;
  ChangeDO(AccessHandle:=AccessData.WriteAccess.AccessHandle, NewLength:=AccessData.WriteAccess.ActLength);
  AccessData.ReadAccess.ActLength := SDIAS_UART_RX_LEN_NO_DATA;
  ChangeDO(AccessHandle:=AccessData.ReadAccess.AccessHandle, NewLength:=AccessData.ReadAccess.ActLength);

  if AccessData.WriteAccess.pControlByte then
    AccessData.WriteAccess.pControlByte^.EnableDO := TRUE;
  else
    ToSdiasBase.ClassState := _DOHandleInvalid;
    return;
  end_if;
  
  if AccessData.ReadAccess.pControlByte then
    AccessData.ReadAccess.pControlByte^.EnableDO  := TRUE; 
  else
    ToSdiasBase.ClassState := _DOHandleInvalid;
    return;  
  end_if;

END_FUNCTION


FUNCTION SdiasUartHandler::ChangeDO
	VAR_INPUT
		AccessHandle 	: UDINT;
		NewOffset 	: HDINT;
		NewLength 	: UDINT;
	END_VAR
  VAR
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR

  MyPara.uiCmd := SDIAS_CLT_CMD_CHG_DYN_ACCESS;
  MyPara.aPara[0] := AccessHandle$DINT;
  MyPara.aPara[1] := NewOffset$DINT;
  MyPara.aPara[2] := NewLength$DINT;
  ToSdiasBase.NewInst(#MyPara, #MyResult);

END_FUNCTION


FUNCTION SdiasUartHandler::GetBaudrateValue
	VAR_INPUT
		Baudrate 	: DINT;
	END_VAR
	VAR_OUTPUT
		Divisor 	: UINT;
	END_VAR

  case Baudrate of
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_300:
      Divisor := SDIAS_UART_BAUD_REFERENCE / 300;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_600:     
      Divisor := SDIAS_UART_BAUD_REFERENCE / 600;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_1200:    
      Divisor := SDIAS_UART_BAUD_REFERENCE / 1200;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_2400:    
      Divisor := SDIAS_UART_BAUD_REFERENCE / 2400;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_4800:    
      Divisor := SDIAS_UART_BAUD_REFERENCE / 4800;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_9600:    
      Divisor := SDIAS_UART_BAUD_REFERENCE / 9600;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_14400:   
      Divisor := SDIAS_UART_BAUD_REFERENCE / 14400;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_19200:   
      Divisor := SDIAS_UART_BAUD_REFERENCE / 19200;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_38400:   
      Divisor := SDIAS_UART_BAUD_REFERENCE / 38400;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_57600:   
      Divisor := SDIAS_UART_BAUD_REFERENCE / 57600;
      
//**********************************************************************************************************************************************************
    SDIAS_UART_BAUD_115200:  
      Divisor := SDIAS_UART_BAUD_REFERENCE / 115200;
      
//**********************************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION SdiasUartHandler::InitRingbuffer
	VAR_INPUT
		pRingBuffer 	: ^t_RingBuffer;
		BufferSize 	: UDINT;
	END_VAR

  if pRingBuffer & BufferSize then
    if pRingBuffer^.pMemStart = NIL then
    
      // allocate memory and set the content to 0
      pRingBuffer^.pMemStart$pVoid := ToStdLib.Malloc(size:=BufferSize * sizeof(USINT));
      if pRingBuffer^.pMemStart then
        pRingBuffer^.b_DefaultBuffer := TRUE;
        pRingBuffer^.pActWr := pRingBuffer^.pMemStart;
        pRingBuffer^.pActRd := pRingBuffer^.pMemStart;
        pRingBuffer^.ud_BufferSize := BufferSize * sizeof(USINT);
        _memset(dest:=pRingBuffer^.pMemStart, usByte:=0, cntr:=pRingBuffer^.ud_BufferSize);
        pRingBuffer^.pLastEntry := pRingBuffer^.pMemStart + (BufferSize-1) * sizeof(USINT);
      end_if;
    else
      // only clear the entries
      pRingBuffer^.pActWr     := pRingBuffer^.pMemStart;
      pRingBuffer^.pActRd     := pRingBuffer^.pMemStart;
      pRingBuffer^.ud_MemUsed := 0;
    end_if;
  end_if;

END_FUNCTION


FUNCTION SdiasUartHandler::GetReadData
  VAR
  	ActReadLength   : USINT;
    ErrorCode       : DINT;
  END_VAR

  // copy header always
  _memcpy(ptr1:=#AccessData.LocalReadData, ptr2:=AccessData.pReadData, cntr:=SDIAS_UART_RX_LEN_NO_DATA);

  // remember errors on variable and dismiss data (= leave method)

  if AccessData.LocalReadData.LineStatusReg.ParityError & WordLen <> 9 then
    ActError := SERERROR_PARITY_E;
    InvalidDataErrorCnt += 1;
    return;
    
  // variable can keep only one error => check the second bit only if the first was FALSE
  elsif AccessData.LocalReadData.LineStatusReg.FramingError then
    ActError := SERERROR_FRAMING_E;
    InvalidDataErrorCnt += 1;
    return;
  end_if;
  
  if AccessData.LocalReadData.LineStatusReg.ReceiveBufferFull then
    ActError := SERERROR_RECVBUF;
    RecBufOverflowErrorCnt += 1;
  end_if;  
    
  // on VARAN we need to use the penultimate length
  if b_VaranAvailable then
    if AccessData.ReadAccess.ActLengthIndex = 2 then
      ActReadLength := AccessData.ReadAccess.aLength[0];
    else
      ActReadLength := AccessData.ReadAccess.aLength[AccessData.ReadAccess.ActLengthIndex + 1];
    end_if;
  else
    ActReadLength := AccessData.ReadAccess.aLength[AccessData.ReadAccess.ActLengthIndex XOR 1];
  end_if;
  // limit the size to the access size
  if ActReadLength > MaxRdLen then
    ActReadLength := MaxRdLen$USINT;
  end_if;

   // if there are read data => save them into the ring buffer
  if ActReadLength then    
    // add it to the ring buffer (withouth header)
    ErrorCode := AddDataToRingBuffer(pRingBuffer:=#RxBuffer, pNewData:=#AccessData.pReadData^.aReceiveBuffer[0], DataSize:=ActReadLength, pDataSizeAdded:=NIL);
        
    if ErrorCode <> SERERROR_RECVERROR then
      //if no error occurred allow logging again
      biLogging.RxAddBufferOverflowLogged := FALSE; 
    end_if;
  end_if;
  
  if ErrorCode <> SERERROR_NONE then
    ActError := ErrorCode;
  end_if;

END_FUNCTION


FUNCTION SdiasUartHandler::PrepareNextReadData
  VAR
  	ActLength : USINT;
    i : USINT;
  END_VAR

  if b_VaranAvailable then
    ActLength := AccessData.LocalReadData.ReceiveByteCounter;
    if WordLen = 9 then
      ActLength *= 2;
    end_if;

    for i := 0 to 2 do
      if i <> AccessData.ReadAccess.ActLengthIndex then
        ActLength -= AccessData.ReadAccess.aLength[i];
      end_if;
    end_for;

    // limit the size to the access size
    if ActLength > MaxRdLen then
      ActLength := MaxRdLen$USINT;
    end_if;  

    // remember the size we fetch and increase ringbuffer counter
    AccessData.ReadAccess.aLength[AccessData.ReadAccess.ActLengthIndex] := ActLength;
    if AccessData.ReadAccess.ActLengthIndex < 2 then
      AccessData.ReadAccess.ActLengthIndex += 1;
    else
      AccessData.ReadAccess.ActLengthIndex := 0;
    end_if;
  else

    if WordLen = 9 then
      ActLength := AccessData.LocalReadData.ReceiveByteCounter * 2 - AccessData.ReadAccess.aLength[AccessData.ReadAccess.ActLengthIndex XOR 1];
    else
      ActLength := AccessData.LocalReadData.ReceiveByteCounter - AccessData.ReadAccess.aLength[AccessData.ReadAccess.ActLengthIndex XOR 1];
    end_if;

    // limit the size to the access size
    if ActLength > MaxRdLen then
      ActLength := MaxRdLen$USINT;
    end_if;
    
    // remember the size we fetch and toggle ringbuffer bit
    AccessData.ReadAccess.aLength[AccessData.ReadAccess.ActLengthIndex] := ActLength;
    AccessData.ReadAccess.ActLengthIndex := AccessData.ReadAccess.ActLengthIndex XOR 1;
  end_if;
  
  // calculate size of access
  AccessData.ReadAccess.ActLength := SDIAS_UART_RX_LEN_NO_DATA + ActLength;
  
END_FUNCTION


FUNCTION SdiasUartHandler::AddDataToRingBuffer
	VAR_INPUT
		pRingBuffer 	: ^t_RingBuffer;
		pNewData 	: ^void;
		DataSize 	: UDINT;
		pDataSizeAdded 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  VAR
    FirstPartLength : UINT;  	
  END_VAR

  ErrorCode := SERERROR_NONE;
  
  // check if there is enough space in the ringbuffer => if not print message and save only as much as there is space left
  if pRingBuffer^.ud_MemUsed + DataSize > pRingBuffer^.ud_BufferSize then
    // limit the size to copy to the rest of the buffersize
    DataSize := pRingBuffer^.ud_BufferSize - pRingBuffer^.ud_MemUsed;
    if pRingBuffer = #RxBuffer then
      if biLogging.RxAddBufferOverflowLogged = FALSE then
        biLogging.RxAddBufferOverflow := TRUE;      
      end_if;     
      RecBufOverflowErrorCnt += 1;
      ErrorCode := SERERROR_RECVERROR;
    else
      // only set error if buffer is full
      if DataSize = 0 then
        if biLogging.TxAddBufferOverflowLogged = FALSE then
          biLogging.TxAddBufferOverflow := TRUE;      
        end_if;
        ErrorCode := SERERROR_SENDERROR;      
      end_if;
    end_if;

    // buffer already completely full => leave method, because there are no data to copy in the rest memory if it is 0 byte sized
    if DataSize = 0 then
      return;
    end_if;
  end_if;    

  // return the number of bytes added
  if pDataSizeAdded then
    pDataSizeAdded^ := DataSize;
  end_if;
  
  // copy the data  
  // check if the target memory is completely successive
  if (pRingBuffer^.pActWr + (DataSize-1)) <= pRingBuffer^.pLastEntry then
    // copy at once
    _memcpy(ptr1:=pRingBuffer^.pActWr, ptr2:=pNewData, cntr:=DataSize);
    pRingBuffer^.pActWr     += DataSize;
  else
    // split it up: first part at the end of the ring buffer memory, second part at the start of the ring buffer memory
    FirstPartLength := (pRingBuffer^.pLastEntry$UDINT - pRingBuffer^.pActWr$UDINT)$UINT + 1;
    
    _memcpy(ptr1:=pRingBuffer^.pActWr   , ptr2:=pNewData                  , cntr:=FirstPartLength           );
    _memcpy(ptr1:=pRingBuffer^.pMemStart, ptr2:=pNewData + FirstPartLength, cntr:=DataSize - FirstPartLength);

    pRingBuffer^.pActWr := pRingBuffer^.pMemStart + DataSize - FirstPartLength;
  end_if;
  
  // increase buffer usage
  pRingBuffer^.ud_MemUsed += DataSize;
  
END_FUNCTION


FUNCTION SdiasUartHandler::GetDataFromRingBuffer
	VAR_INPUT
		pRingBuffer 	: ^t_RingBuffer;
		pGetBuffer 	: ^void;
		DataSize 	: UDINT;
		pDataSizeFetched 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  VAR
    FirstPartLength : UINT;  	
  END_VAR

  ErrorCode := SERERROR_NONE;

  // check if there are enough data ringbuffer => if not print message and save only as much as there is
  if DataSize > pRingBuffer^.ud_MemUsed then
    // limit the size to copy to the used size
    DataSize := pRingBuffer^.ud_MemUsed;
    if pRingBuffer = #RxBuffer then
      if biLogging.RxGetBufferOverflowLogged = FALSE then
        biLogging.RxGetBufferOverflow := TRUE;      
      end_if;
      ErrorCode := SERERROR_RECVERROR;
    else
      if biLogging.TxGetBufferOverflowLogged = FALSE then
        biLogging.TxGetBufferOverflow := TRUE;      
      end_if;
      ErrorCode := SERERROR_SENDERROR;
    end_if;    
  end_if;    

  // return the number of bytes added
  if pDataSizeFetched then
    pDataSizeFetched^ := DataSize;
  end_if;
  
  // if there is no data to copy => leave method, because there are no data to copy if it is 0 byte sized
  if DataSize = 0 then
    return;
  end_if;
  
  // copy the data  
  // check if the source memory is completely successive
  if (pRingBuffer^.pActRd + (DataSize-1)) <= pRingBuffer^.pLastEntry then
    // copy at once
    _memcpy(ptr1:=pGetBuffer, ptr2:=pRingBuffer^.pActRd, cntr:=DataSize);
    pRingBuffer^.pActRd     += DataSize;
  else
    // split it up: first part at the end of the ring buffer memory, second part at the start of the ring buffer memory
    FirstPartLength := (pRingBuffer^.pLastEntry$UDINT - pRingBuffer^.pActRd$UDINT)$UINT + 1;
    
    _memcpy(ptr1:=pGetBuffer                  , ptr2:=pRingBuffer^.pActRd   , cntr:=FirstPartLength           );
    _memcpy(ptr1:=pGetBuffer + FirstPartLength, ptr2:=pRingBuffer^.pMemStart, cntr:=DataSize - FirstPartLength);

    pRingBuffer^.pActRd := pRingBuffer^.pMemStart + DataSize - FirstPartLength;
  end_if;
  
  // decrease buffer usage
  pRingBuffer^.ud_MemUsed -= DataSize;
  
END_FUNCTION


FUNCTION SdiasUartHandler::PrepareSendData
  VAR
  	DataSendSize : USINT;
    MaxSize      : USINT;
    udActDataSendSize : UDINT;
  END_VAR

  // copy header always
  _memcpy(ptr1:=AccessData.pWriteData, ptr2:=#AccessData.LocalWriteData, cntr:=SDIAS_UART_TX_LEN_NO_DATA); 
  //initialize act send data length
  udActDataSendSize := 0;
  
  // if there are data to send
  if TxBuffer.ud_MemUsed then
    // check how many and if it's possible with 1 cycle
    if TxBuffer.ud_MemUsed >= MaxWrLen then
      DataSendSize := MaxWrLen$USINT;
    else
      DataSendSize := TxBuffer.ud_MemUsed$USINT;
    end_if;
        
    // we can't send if transmission buffer is already full
    if b_VaranAvailable then
      // maximum size = buffer size - (what we send last + what was in the transmission buffer the last time)
      if WordLen = 9 then
        MaxSize := usHwBufferSize - ((AccessData.WriteAccess.ActLength - SDIAS_UART_TX_LEN_NO_DATA) + AccessData.LocalReadData.TransmitByteCounter*2);            
      else
        MaxSize := usHwBufferSize - ((AccessData.WriteAccess.ActLength - SDIAS_UART_TX_LEN_NO_DATA) + AccessData.LocalReadData.TransmitByteCounter);
      end_if;
      
    else
      // maximum size = buffer size - what was in the transmission buffer the last time;
      if WordLen = 9 then
        MaxSize := usHwBufferSize - AccessData.LocalReadData.TransmitByteCounter*2;
      else
        MaxSize := usHwBufferSize - AccessData.LocalReadData.TransmitByteCounter;
      end_if;
    end_if;
    
    // if it's bigger than the maximum size, it may not fit into the transmission buffer
    if DataSendSize > MaxSize then
      DataSendSize := MaxSize;
    end_if;
      
    // if there is something to send => send it!
    if DataSendSize then
      GetDataFromRingBuffer(pRingBuffer:=#TxBuffer, pGetBuffer:=#AccessData.pWriteData^.aTransmitBuffer[0], DataSize:=DataSendSize, pDataSizeFetched:=#udActDataSendSize);
    end_if;    
  end_if;  
  
  AccessData.WriteAccess.ActLength := SDIAS_UART_TX_LEN_NO_DATA + udActDataSendSize$USINT;
  
  //safe last transmit data length for used transmit buffer length calculation over varan
  if b_VaranAvailable then    
   sTxBufferUsed.udLastTransmitDiff := sTxBufferUsed.udActTransmitDiff;
  end_if;  
  //safe act transmit data length for used transmit buffer length calculation
  sTxBufferUsed.udActTransmitDiff := udActDataSendSize;
  
END_FUNCTION


FUNCTION SdiasUartHandler::InitInternal
  VAR
  	MyPara    : CmdStruct;
    MyResult  : results;
    TempStr   : ARRAY [0..31] OF CHAR;
  END_VAR

  AddressOffset := AddressOffset.Read();
  UartType := UartType.Read();
  MaxRdLen := MaxRdLen.Read();
  MaxWrLen := MaxWrLen.Read();
  
  //if one length is greater than zero the interface is active
  if MaxRdLen > 0 | MaxWrLen > 0 then
    bInterfaceActive := TRUE;
  else 
    //if interface is deactivated we don't need to call this function
    bInterfaceActive := FALSE;
    //return here because read and write length is zero
    return;
  end_if;
  
  // limit to maximum
  if MaxRdLen > sizeof(t_ReadData.aReceiveBuffer) then
    MaxRdLen := sizeof(t_ReadData.aReceiveBuffer);
  end_if;

  // limit to maximum
  if MaxWrLen > sizeof(t_WriteData.aTransmitBuffer) then
    MaxWrLen := sizeof(t_WriteData.aTransmitBuffer);
  end_if;
      
  // get os interface for mutex usage
  if (OS_CILGet("LSL_MULTITASK", #mt_api$void)) THEN
    biLogging.AddOsInterfaceFailed := TRUE;
  end_if;

  // install mutex for accessing the memory (may be done from cyclic but is refreshed in realtime)
  _strcpy(dest:=#TempStr[0], src:="SdiasUart");
  MyPara.uiCmd := SDIAS_CLT_CMD_CREATE_MUTEX;
  MyPara.aPara[0] := (#TempStr)$DINT;
  MyPara.aPara[1] := this$DINT;
  ToSdiasBase.NewInst(pPara:=#MyPara, pResult:=#MyResult);
  
  // check retcode
  if MyResult.aData[0] then
    biLogging.AddMutexFailed := TRUE;
  else
    AccessData.pMutex := MyResult.aData[4]$^void;
  end_if;
  
  // check if we're connected via VARAN
  MyPara.uiCmd     := SDIAS_CLT_CMD_IS_VARAN_AVAILABLE;
  
  ToSdiasBase.NewInst(pPara:=#MyPara, pResult:=#MyResult);
  if MyResult.aData[0] = 0 then
    b_VaranAvailable := MyResult.aData[4]$BOOL;
  else
    biLogging.GetBusInterfaceFailed := TRUE;
  end_if;
  
  // initialize rx and tx buffer
  InitRingbuffer(pRingBuffer:=#TxBuffer, BufferSize:=SDIAS_UART_TX_BUFFER_SIZE);
  InitRingbuffer(pRingBuffer:=#RxBuffer, BufferSize:=SDIAS_UART_RX_BUFFER_SIZE);

  case UartType of
//**********************************************************************************************************************************************************
    SDIAS_UART_TYPE_RS232:
      RSMode := 232;

      AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
      AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := FALSE;
      AccessData.LocalWriteData.ModemControlReg.EchoOff         := FALSE;

//**********************************************************************************************************************************************************
    SDIAS_UART_TYPE_RS485:
      RSMode := 485;

      AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
      AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
      AccessData.LocalWriteData.ModemControlReg.EchoOff         := FALSE;

//**********************************************************************************************************************************************************
    SDIAS_UART_TYPE_TTY:
      RSMode := 4850; // without echo

      AccessData.LocalWriteData.ModemControlReg.RSMode          := TRUE;
      AccessData.LocalWriteData.ModemControlReg.DataEnableMode  := TRUE;
      AccessData.LocalWriteData.ModemControlReg.EchoOff         := TRUE;

//**********************************************************************************************************************************************************
  end_case;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL SdiasUartHandler::SetBaudRate
	VAR_INPUT
		BaudRate 	: DINT;
	END_VAR
	VAR_OUTPUT
		ErrorCode 	: DINT;
	END_VAR
  VAR
  	Divisor     : DINT;
  	Divisorrest : DINT;
    i           : USINT;
    aTempFreqArray : Array [0..3] of DINT;
  END_VAR
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    ErrorCode := SERERROR_NOTAVAIL;
    return;
  end_if;
  
  //Init Errorcode
  ErrorCode := SERERROR_BAUDRATE;
  
  //check if baudrate is within the limits
  if BaudRate = 0 | (BaudRate > (0xFFFFFFFF/16)) then
    return;
  end_if;
  
  aTempFreqArray[0] := SDIAS_UART_FREQUENCY_1_8432MHZ;
  aTempFreqArray[1] := SDIAS_UART_FREQUENCY_1MHZ;
  aTempFreqArray[2] := SDIAS_UART_FREQUENCY_7_3728MHZ;
  aTempFreqArray[3] := SDIAS_UART_FREQUENCY_14_7456MHZ;
  
  //Check all 4 frequencies
  for i:= 0 to 3 do
  
    //Calculate Divisor
    Divisorrest := aTempFreqArray[i] mod (BaudRate * 16);
    
    //Check for rest and if divisor fits in 14 Bit
    if (Divisorrest = 0) then
    
      //Calc divisor value to set register in fpga
      Divisor := (aTempFreqArray[i] / ( BaudRate * 16));
      
      //Check if divisor fits in 14 Bit.
      if Divisor >= 16#4000 then
        exit;
      end_if;
      
      // protect via mutex because this memory could be used from different task priorities
      OS_MT_WAIT(AccessData.pMutex); 
     
      AccessData.LocalWriteData.DivisorLatchReg := Divisor$UINT;
      
      //Write the correct bits for choosen frequency (00 = 1_8432MHZ default, 01 = 1MHZ, 10 = 7_3728MHZ, 11 = 14_7456MHZ)
      AccessData.LocalWriteData.DivisorLatchReg := AccessData.LocalWriteData.DivisorLatchReg or (i shl 14);
      
      OS_MT_SIGNAL(AccessData.pMutex);
      
      //Set Errorcode ok and flag that baudrate has been set via this method
      ErrorCode := SERERROR_NONE;
      bExtendedBaudrateSet := TRUE;
      exit;
      
    else
      //Check if more frequencies are available 
      if (HwOptionBits.FlexibleBaudrate = FALSE & (HwOptionBits.OptionBitsValid = TRUE)) then
        exit;
      end_if;    
    end_if;  
  end_for;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::UpdateCy
  
  //if interface is deactivated we don't need to call this function
  if bInterfaceActive = FALSE then
    return;
  end_if;
  
  if biLogging.RxAddBufferOverflow = TRUE & biLogging.RxAddBufferOverflowLogged = FALSE then  
    LogError("@053D (SdiasUartHandler::AddDataToRingBuffer) [SL] Overflow of internal ring buffer for read data. Fetch receive data in shorter intervals!");
    biLogging.RxAddBufferOverflowLogged := TRUE;
    biLogging.RxAddBufferOverflow       := FALSE;
  end_if;
  
  if biLogging.TxAddBufferOverflow = TRUE & biLogging.TxAddBufferOverflowLogged = FALSE then  
    LogError("@053E (SdiasUartHandler::AddDataToRingBuffer) Overflow of internal ring buffer for write data. Send data is bigger than buffer size!");
    //Log error always
    //biLogging.TxAddBufferOverflowLogged := TRUE;
    biLogging.TxAddBufferOverflow       := FALSE;
  end_if;
  
  if biLogging.RxGetBufferOverflow = TRUE & biLogging.RxGetBufferOverflowLogged = FALSE then
    //Don't log this error because of information overflow
    //LogError("@ZZZZ (SdiasUartHandler::GetDataFromRingBuffer) Not enough data in the internal ring buffer for read data. Check length with GetRecvState!");
    biLogging.RxGetBufferOverflowLogged := TRUE;
    biLogging.RxGetBufferOverflow       := FALSE;
  end_if;
  
  if biLogging.TxGetBufferOverflow = TRUE & biLogging.TxGetBufferOverflowLogged = FALSE then
    LogError("@053F (SdiasUartHandler::GetDataFromRingBuffer) Not enough data in the internal ring buffer for write data. Internal error!");
    //Log error always
    //biLogging.TxGetBufferOverflowLogged := TRUE;
    biLogging.TxGetBufferOverflow       := FALSE;
  end_if;
  
  if biLogging.AddOsInterfaceFailed = TRUE then    
    LogError("@0540 (SdiasUartHandler::InitInternal) Failed to get MULTITASK OS-Interface for Mutex usage.");
    biLogging.AddOsInterfaceFailed := FALSE;
  end_if;  
  
  if biLogging.AddMutexFailed = TRUE then 
    LogError("@0541 (SdiasUartHandler::InitInternal) Failed to create Mutex for accessing the memory.");
    biLogging.AddMutexFailed := FALSE;
  end_if;  
  
  if biLogging.GetBusInterfaceFailed = TRUE then 
    LogError("@0542 (SdiasUartHandler::InitInternal) Failed to get connection state via BusInterface.");
    biLogging.GetBusInterfaceFailed := FALSE;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SdiasUartHandler::InitModule
 VAR_OUTPUT
    eModuleInitState 	: iprStates;
  END_VAR
  VAR
    TmpRetcode   : iprStates;
  	MyPara   : CmdStruct;
    MyResult : results;
  END_VAR
  
  eModuleInitState := BUSY;
  
  case eInitSSW of
    //****************************************************************************************************************************************
    t_eInitSSW::_InitIdle:
      eInitSSW := _ReadOptionBits;
      
    //****************************************************************************************************************************************
  	t_eInitSSW::_ReadOptionBits:
      case eResponseState of
        //*****************************************************
        idle: 
          MyPara.uiCmd := SDIAS_CLT_SDO_CMD_MEM_READ;
          MyPara.aPara[0] := AddressOffset$DINT + SDIAS_UART_OFFSET_RD_SDO;  //address offset
          MyPara.aPara[1] := sizeof(BSINT);  // length for read sdo data
          MyPara.aPara[2] := SDIAS_SDO_CMD_MEM_READ; //command
          
          TmpRetcode := ToSdiasBase.NewInst(#MyPara, #MyResult);
          
          if TmpRetcode = READY then
            udSDOTimeout   := ops.tAbsolute;
            eResponseState := wait; 
          elsif TmpRetcode = ERROR then
            LogError("@0536 (SdiasUartHandler::InitModule) Failed to add read SDO for option bits.");
            eInitSSW   := _InitError;
          end_if; 
          
        //*****************************************************
        wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > SDIAS_UART_SDO_RESPONSE_TIMEOUT) then
            LogError("@0118 (SdiasUartHandler::InitModule) SDO Response timeout read option bits.");
            eInitSSW := _InitError;
          end_if;
          
        //*****************************************************
        valid:    
          eResponseState := idle;
          eInitSSW       := _InitFinished;
            
      end_case;
       
    //****************************************************************************************************************************************
  	t_eInitSSW::_InitFinished:
    
      if HwOptionBits.OptionBitsValid & HwOptionBits.ExtendedTxRxBuffer then
        usHwBufferSize := SDIAS_UART_RXTX_BUFFER_SIZE_HW_EXTENDED;
      end_if;

      eModuleInitState := READY;
  	   
    //****************************************************************************************************************************************
  	t_eInitSSW::_InitError:     
      eModuleInitState := ERROR;    
    
  end_case;      

END_FUNCTION


FUNCTION GLOBAL SdiasUartHandler::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code := BUSY;
  
  case eCommand of
    SDIAS_SDO_CMD_MEM_READ:
      if hOffset = AddressOffset+SDIAS_UART_OFFSET_RD_SDO  then
        if eResponseState = wait then
          eResponseState := valid;
          ret_code       := READY;  
          HwOptionBits   := HwOptionBits or pResponseBuffer^$BSINT;
          //mark option bits as valid
          HwOptionBits.OptionBitsValid := TRUE;
        end_if;
      end_if; 
      
  end_case;
  
END_FUNCTION


FUNCTION GLOBAL SdiasUartHandler::SetHwOptionBits
	VAR_INPUT
		bdSetHwOptionBits 	: t_bdOptionBits;
	END_VAR
  
  HwOptionBits := HwOptionBits or bdSetHwOptionBits;

END_FUNCTION


FUNCTION GLOBAL SdiasUartHandler::SetIFState
	VAR_INPUT
		pbInterfaceActive 	: ^BOOL;(* := NIL *)
		pbAdditionalIFActive 	: ^BOOL;(* := NIL *)
	END_VAR
  
  if pbInterfaceActive <> NIL then
    bInterfaceActive := pbInterfaceActive^;
  end_if;
  
  if pbAdditionalIFActive <> NIL then
    bAdditionaIFActive := pbAdditionalIFActive^;
  end_if; 

END_FUNCTION


FUNCTION GLOBAL SdiasUartHandler::GetIFState
	VAR_INPUT
		pbInterfaceActive 	: ^BOOL;(* := NIL *)
		pbAdditionalIFActive 	: ^BOOL;(* := NIL *)
	END_VAR
  
  if pbInterfaceActive <> NIL then
     pbInterfaceActive^ := bInterfaceActive;
  end_if;
  
  if pbAdditionalIFActive <> NIL then
    pbAdditionalIFActive^ := bAdditionaIFActive;
  end_if; 

END_FUNCTION