//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "cmServo"
	Revision           = "1.0"
	GUID               = "{8614CA2F-D4E0-4A90-B348-3564365A64F6}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "500 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(570,2640)">
	<Channels>
		<Server Name="calcReqSpeed" GUID="{55C57D70-6733-4EBE-BFE2-2BA9633390DA}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="csPowerOffServo" GUID="{960D1164-7228-403F-8842-50D215B42A8D}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="firstPos" GUID="{D2360CA2-F826-4603-B02C-2435B2C61407}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="parExtraIFactor" GUID="{1AF0DAAE-395E-46B6-890A-22C0CFB968AC}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="File"/>
		<Server Name="parHomeAgain" GUID="{571E12B4-CA88-4668-8754-7943A2628E1F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="parIFactor" GUID="{7FFDCC96-5818-4430-A075-17FF8DD8F272}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="File"/>
		<Server Name="parInPosBand" GUID="{262F639A-C0B9-40FA-BCAC-0B6665418630}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="File" Comment="max difference between act real pos and req pos  (*100)&#13;&#10;in thousands of mm for sts.InPos"/>
		<Server Name="parJogTime" GUID="{D07A0742-75BC-496B-876D-EA377F24D3B3}" Visualized="true" Initialize="true" DefValue="500" WriteProtected="false" Retentive="File"/>
		<Server Name="parKeepControllerOn" GUID="{A3F0DE19-7D9F-48B1-8807-42C96F0610D9}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File"/>
		<Server Name="parLastPieceBand" GUID="{6845C1E3-9067-400A-A252-B47F333BD617}" Visualized="true" Initialize="true" DefValue="1000" WriteProtected="false" Retentive="File"/>
		<Server Name="parManualSpeed" GUID="{8FA071CB-B6FA-46E9-A852-8D5595AC0E20}" Visualized="true" Initialize="true" DefValue="500" WriteProtected="false" Retentive="File"/>
		<Server Name="parMaxAcc" GUID="{D05F2D13-358A-4906-9021-5F24545A1744}" Visualized="true" Initialize="true" DefValue="10000" WriteProtected="false" Retentive="File"/>
		<Server Name="parMaxDec" GUID="{8213D05C-6AA9-4337-8F5B-DD191AD0748E}" Visualized="true" Initialize="true" DefValue="10000" WriteProtected="false" Retentive="File"/>
		<Server Name="parMaxPos" GUID="{A8C94A7C-A9C6-438E-BAE2-4696A8A0566C}" Visualized="true" Initialize="true" DefValue="1500000" WriteProtected="false" Retentive="File"/>
		<Server Name="parMaxSpeed" GUID="{49F069FC-B2EA-4617-A63B-1B24FCBA6460}" Visualized="true" Initialize="true" DefValue="10000" WriteProtected="false" Retentive="File"/>
		<Server Name="parMinPos" GUID="{4E200780-66E4-49CC-9BD8-8F42C1403357}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="File"/>
		<Server Name="parNoRefSwitch" GUID="{68150034-39A4-4FB0-A820-B9743145ECB7}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File"/>
		<Server Name="parOverrideSimulateServo" GUID="{BC19CE55-F00B-45B7-8FAF-B1AC4A56E82B}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parRefDirPositive" GUID="{70181237-448C-4019-A54B-2117C197C3DA}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="File"/>
		<Server Name="parRefPos" GUID="{90157B00-89D5-41C3-810A-BFFCABF56262}" Visualized="true" Initialize="true" DefValue="1500000" WriteProtected="false" Retentive="File"/>
		<Server Name="parRefSpeed" GUID="{8BBFBCB3-1661-4796-832B-DEA4B422D381}" Visualized="true" Initialize="true" DefValue="1000" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeBrakeOff" GUID="{30F93178-5F0B-498A-9D61-0D3F416BF61F}" Visualized="true" Initialize="true" DefValue="200" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeBrakeOn" GUID="{4AF9E218-4D6B-4E00-8195-E2534C56D6D6}" Visualized="true" Initialize="true" DefValue="200" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeControllerOn" GUID="{6537EAB4-3C71-4A7F-A3F5-62433ACD28AA}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeOutTime" GUID="{A3A3A9CF-EADF-45C7-B9E1-6BEEAA05B1BE}" Visualized="true" Initialize="true" DefValue="120000" WriteProtected="false" Retentive="File"/>
		<Server Name="parWaitInPosTime" GUID="{3E51AE40-FA65-4CE4-9E64-EC8E66799661}" Visualized="true" Initialize="true" DefValue="100" WriteProtected="false" Retentive="File"/>
		<Server Name="PendelOn" GUID="{E81747D9-E6E7-45D4-AD24-5A8C6BC89C96}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reqAcc" GUID="{15507A18-A71A-446A-AEBE-7B4F256B134F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reqDec" GUID="{8242CE8F-FBAA-4296-AC97-ED2FCC8DE7FA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reqPos" GUID="{9EEEE4A1-EB8E-4C81-A835-925F6582F892}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reqSpeed" GUID="{4FCCEE56-8810-4BA8-84C2-3DA17899F154}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="secondPos" GUID="{6687B77C-C3D5-4243-AA6B-1D8240DC7DFA}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsActRealPos" GUID="{8440CDED-DBE3-47F8-AE63-8C2C99A64FE3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsAllSimuActive" GUID="{B35B366C-C6A2-41FD-97BA-3869C8BAE071}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsControllerIsOn" GUID="{D869DEF4-99B4-4D58-91F9-5B5516FEE990}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsInPos" GUID="{59E0B45C-2801-40A6-8FDD-C4BC8AD6B57A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsIsHomed" GUID="{05C6D768-A820-45E5-8EA0-E7B315FBAC5B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsPos" GUID="{A796AFE9-8E25-4924-92EB-E53C947130AF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsSimRef" GUID="{D0EC6E3C-BEF2-40CE-BE24-747BACC86A17}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsSpeed" GUID="{9E04E196-85F5-4299-AD48-770E9F03CF9A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsState" GUID="{EE0F8FCB-473A-4737-8F97-27632B0328F6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="cntrDistance1" Required="true" Internal="true"/>
		<Client Name="ctrlLiftingCil" Required="false" Internal="false"/>
		<Client Name="iEmergencyStop" Required="false" Internal="false"/>
		<Client Name="iHWReady" Required="true" Internal="false"/>
		<Client Name="iPmSpeed" Required="true" Internal="false" DefValue="1000"/>
		<Client Name="iReleaseMovement" Required="true" Internal="false"/>
		<Client Name="lmcCtrl" Required="true" Internal="false"/>
		<Client Name="oBrake" Required="false" Internal="false"/>
		<Client Name="oIFactor" Required="false" Internal="false"/>
		<Client Name="oResetHW" Required="false" Internal="false"/>
		<Client Name="oSimRefSwitch" Required="false" Internal="false"/>
		<Client Name="sExtraForMinMaxPos" Required="false" Internal="false"/>
		<Client Name="sNoHoming" Required="false" Internal="false" DefValue="0"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="10"/>
			<SepChn Position="34"/>
			<SepChn Position="40"/>
		</Servers>
	</Separators>
	<RevDoku>
		<Owner Author="JdK"/>
		<Dokumentation Revision="0.3" Date="2020-04-01" Author="TP" Description="add variable speed with ipmSpeed"/>
		<Dokumentation Revision="0.1" Date="2019-10-03" Author="JdK" Description="added control for start homing and merker to home again"/>
		<Dokumentation Revision="0.2" Date="2019-09-24" Author="JdK" Description="added coupling possibillity"/>
	</RevDoku>
	<Network Name="cmServo">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{5D4ABB4E-B3F1-403E-B5EC-10C93C28D2F7}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name           = "cntrDistance1"
				GUID           = "{2F17FAC9-9218-47E5-8DC6-9940AF69DAD2}"
				Class          = "cntrDistance"
				Position       = "(300,1110)"
				Visualized     = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="actPos"/>
					<Server Name="ClassSvr"/>
					<Server Name="resetSoftCounter"/>
					<Server Name="softCounter"/>
					<Server Name="totalCounter"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
			<Connection Source="this.cntrDistance1" Destination="cntrDistance1.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

cmServo : CLASS
: cmBase
  //Servers:
	stsState 	: SvrCh_servoPos;
	stsIsHomed 	: SvrCh_DINT;
	stsInPos 	: SvrCh_DINT;
	stsControllerIsOn 	: SvrCh_DINT;
	stsPos 	: SvrCh_DINT;
	stsActRealPos 	: SvrCh_DINT;
	stsSpeed 	: SvrCh_DINT;
	stsSimRef 	: SvrCh_DINT;
	stsAllSimuActive 	: SvrCh_DINT;
	csPowerOffServo 	: SvrCh_DINT;
	parMinPos 	: SvrCh_DINT;
	parMaxPos 	: SvrCh_DINT;
	parMaxSpeed 	: SvrCh_DINT;
	parMaxAcc 	: SvrCh_DINT;
	parMaxDec 	: SvrCh_DINT;
	parRefSpeed 	: SvrCh_DINT;
	parRefPos 	: SvrCh_DINT;
	parRefDirPositive 	: SvrCh_DINT;
	parNoRefSwitch 	: SvrCh_DINT;
	parIFactor 	: SvrCh_DINT;
	parExtraIFactor 	: SvrCh_DINT;
	parInPosBand 	: SvrCh_DINT;
	parLastPieceBand 	: SvrCh_DINT;
	parTimeControllerOn 	: SvrCh_UDINT;
	parTimeOutTime 	: SvrCh_UDINT;
	parWaitInPosTime 	: SvrCh_UDINT;
	parTimeBrakeOn 	: SvrCh_UDINT;
	parTimeBrakeOff 	: SvrCh_UDINT;
	parJogTime 	: SvrCh_UDINT;
	parKeepControllerOn 	: SvrCh_DINT;
	parManualSpeed 	: SvrCh_DINT;
	parHomeAgain 	: SvrCh_DINT;
	parOverrideSimulateServo 	: SvrCh_DINT;
	reqPos 	: SvrCh_DINT;
	reqSpeed 	: SvrCh_DINT;
	reqAcc 	: SvrCh_DINT;
	reqDec 	: SvrCh_DINT;
	calcReqSpeed 	: SvrCh_DINT;
	PendelOn 	: SvrCh_DINT;
	firstPos 	: SvrCh_DINT;
	secondPos 	: SvrCh_DINT;
  //Clients:
	lmcCtrl 	: CltChCmd__LMCAxis;
	ctrlLiftingCil 	: CltChCmd_cmCil;
	oIFactor 	: CltCh_DINT;
	oBrake 	: CltCh_DINT;
	oSimRefSwitch 	: CltCh_DINT;
	oResetHW 	: CltCh_DINT;
	iHWReady 	: CltCh_DINT;
	iEmergencyStop 	: CltCh_DINT;
	iReleaseMovement 	: CltCh_DINT;
	iPmSpeed 	: CltCh_DINT;
	sNoHoming 	: CltCh_DINT;
	sExtraForMinMaxPos 	: CltCh_DINT;
	cntrDistance1 	: CltChCmd_cntrDistance;
  //Variables:
		timerTimeOut 	: strTimer;
		timerJog 	: strTimer;
		timerControllerOn 	: strTimer;
		timerWaitInPos 	: strTimer;
		timerBrakeOn 	: strTimer;
		timerBrakeOff 	: strTimer;
		timerSimRef 	: strTimer;
		jogSet 	: DINT;
		tmpRefMode 	: _LMCAXIS_REFMODE;
		tmpAcc 	: DINT;
		tmpDec 	: DINT;
		tmpSpeed 	: DINT;
		tmpOldReqSpeed 	: DINT;
		tmpHomingDone 	: DINT;
		tmpCouplingSpeed 	: DINT;
		tmpCouplingAcc 	: DINT;
		tmpCouplingMaster 	: ^MasterStruct;
		esWasAlreadyActive 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL execHmiCmd1;
	
	FUNCTION VIRTUAL execHmiCmd2;
	
	FUNCTION VIRTUAL execHmiCmd3;
	
	FUNCTION VIRTUAL resetAlarm;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL execStart;
	
	FUNCTION VIRTUAL execStop;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION GLOBAL csStartMoveAbs
		VAR_INPUT
			iReqPos 	: DINT;
			iReqSpeed 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL checkInPos
		VAR_INPUT
			checkPos 	: DINT;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL giveActualSpeed
		VAR_OUTPUT
			speed 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL csStartHoming;
	
	FUNCTION GLOBAL csStop;
	
	FUNCTION startMoveAbs
		VAR_INPUT
			iReqPos 	: DINT;
		END_VAR;
	
	FUNCTION startHoming;
	
	FUNCTION Pendel;
	
	FUNCTION GLOBAL csPowerOn;
	
	FUNCTION GLOBAL csCheckPosFits
		VAR_INPUT
			pos 	: DINT;
		END_VAR
		VAR_OUTPUT
			fits 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL csCouple
		VAR_INPUT
			start1Stop0 	: DINT;
			couplingMaxSpeed 	: DINT;
			couplingMaxAcc 	: DINT;
			master 	: ^MasterStruct;
		END_VAR
		VAR_OUTPUT
			done 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL csGiveMaster
		VAR_OUTPUT
			master 	: ^MasterStruct;
		END_VAR;
	
	FUNCTION GLOBAL csPowerOff;
	
	FUNCTION VIRTUAL GLOBAL parMinPos::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL parMaxPos::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL parMaxSpeed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL parMaxAcc::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reqPos::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using cntrDistance
#pragma usingLtd _LMCAxis
#pragma usingLtd cmCil


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB cmServo::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CMSERVO
1$UINT, 0$UINT, (SIZEOF(::cmServo))$UINT, 
41$UINT, 13$UINT, 0$UINT, 
TO_UDINT(3985303601), "cmServo", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::cmServo.stsState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1911454695), "stsState", 
(::cmServo.stsIsHomed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(826179624), "stsIsHomed", 
(::cmServo.stsInPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(605877427), "stsInPos", 
(::cmServo.stsControllerIsOn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3616075167), "stsControllerIsOn", 
(::cmServo.stsPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3335286665), "stsPos", 
(::cmServo.stsActRealPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2494554370), "stsActRealPos", 
(::cmServo.stsSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3713751018), "stsSpeed", 
(::cmServo.stsSimRef.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2777219761), "stsSimRef", 
(::cmServo.stsAllSimuActive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(851862207), "stsAllSimuActive", 
(::cmServo.csPowerOffServo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3511989900), "csPowerOffServo", 
(::cmServo.parMinPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2985762437), "parMinPos", 
(::cmServo.parMaxPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4109720839), "parMaxPos", 
(::cmServo.parMaxSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2961998230), "parMaxSpeed", 
(::cmServo.parMaxAcc.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1477692200), "parMaxAcc", 
(::cmServo.parMaxDec.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(142782021), "parMaxDec", 
(::cmServo.parRefSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3632588265), "parRefSpeed", 
(::cmServo.parRefPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1127443237), "parRefPos", 
(::cmServo.parRefDirPositive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(756938963), "parRefDirPositive", 
(::cmServo.parNoRefSwitch.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2578815012), "parNoRefSwitch", 
(::cmServo.parIFactor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4192581454), "parIFactor", 
(::cmServo.parExtraIFactor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4067080407), "parExtraIFactor", 
(::cmServo.parInPosBand.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1590238700), "parInPosBand", 
(::cmServo.parLastPieceBand.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1488428954), "parLastPieceBand", 
(::cmServo.parTimeControllerOn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1905833433), "parTimeControllerOn", 
(::cmServo.parTimeOutTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4183149504), "parTimeOutTime", 
(::cmServo.parWaitInPosTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3343502337), "parWaitInPosTime", 
(::cmServo.parTimeBrakeOn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2298709997), "parTimeBrakeOn", 
(::cmServo.parTimeBrakeOff.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1532370018), "parTimeBrakeOff", 
(::cmServo.parJogTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(144159227), "parJogTime", 
(::cmServo.parKeepControllerOn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3335605862), "parKeepControllerOn", 
(::cmServo.parManualSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2238667815), "parManualSpeed", 
(::cmServo.parHomeAgain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2699074640), "parHomeAgain", 
(::cmServo.parOverrideSimulateServo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1915918282), "parOverrideSimulateServo", 
(::cmServo.reqPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4195994261), "reqPos", 
(::cmServo.reqSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2643484933), "reqSpeed", 
(::cmServo.reqAcc.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1459575994), "reqAcc", 
(::cmServo.reqDec.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(107887063), "reqDec", 
(::cmServo.calcReqSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2965701568), "calcReqSpeed", 
(::cmServo.PendelOn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2379808786), "PendelOn", 
(::cmServo.firstPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3370573199), "firstPos", 
(::cmServo.secondPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1573660351), "secondPos", 
//Clients:
(::cmServo.lmcCtrl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2812393610), "lmcCtrl", TO_UDINT(1422175863), "_LMCAxis", 1$UINT, 98$UINT, 
(::cmServo.ctrlLiftingCil.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(46660203), "ctrlLiftingCil", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::cmServo.oIFactor.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3893278119), "oIFactor", 
(::cmServo.oBrake.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1754796348), "oBrake", 
(::cmServo.oSimRefSwitch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(754772381), "oSimRefSwitch", 
(::cmServo.oResetHW.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(186906187), "oResetHW", 
(::cmServo.iHWReady.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(746370556), "iHWReady", 
(::cmServo.iEmergencyStop.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4147534605), "iEmergencyStop", 
(::cmServo.iReleaseMovement.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4116773888), "iReleaseMovement", 
(::cmServo.iPmSpeed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4256382449), "iPmSpeed", 
(::cmServo.sNoHoming.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2321382364), "sNoHoming", 
(::cmServo.sExtraForMinMaxPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2993524359), "sExtraForMinMaxPos", 
(::cmServo.cntrDistance1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(591250376), "cntrDistance1", TO_UDINT(3956148192), "cntrDistance", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_cmServo 20

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_cmServo] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION cmServo::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_cmServo;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #execHmiCmd1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #execHmiCmd2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #execHmiCmd3();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #resetAlarm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #execStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #execStop();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #checkInPos();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsState.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stsState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsIsHomed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stsIsHomed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	csPowerOffServo.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF csPowerOffServo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMinPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #parMinPos::Write() );
	IF parMinPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMaxPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #parMaxPos::Write() );
	IF parMaxPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMaxSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #parMaxSpeed::Write() );
	IF parMaxSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMaxAcc.pMeth			:= StoreMethod( #M_RD_DIRECT(), #parMaxAcc::Write() );
	IF parMaxAcc.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMaxDec.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parMaxDec.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parRefSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parRefSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parRefPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parRefPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parRefDirPositive.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parRefDirPositive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parNoRefSwitch.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parNoRefSwitch.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parIFactor.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parIFactor.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parExtraIFactor.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parExtraIFactor.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parInPosBand.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parInPosBand.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parLastPieceBand.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parLastPieceBand.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeControllerOn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeControllerOn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeOutTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeOutTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parWaitInPosTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parWaitInPosTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeBrakeOn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeBrakeOn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeBrakeOff.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeBrakeOff.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parJogTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parJogTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parKeepControllerOn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parKeepControllerOn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parManualSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parManualSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parHomeAgain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parHomeAgain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parOverrideSimulateServo.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parOverrideSimulateServo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reqPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reqPos::Write() );
	IF reqPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reqSpeed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF reqSpeed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reqAcc.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF reqAcc.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reqDec.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF reqDec.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PendelOn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF PendelOn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	firstPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF firstPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	secondPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF secondPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 3-10-2019: added control sNoHoming = 0 before start homing, also added parHomeAgain, merker for em's to home again if required
// JdK 24-9-2019: added possibility to couple two normally independent servo's
// cmServo created by JdK at 17-5-2019 for library MPS/project 4284
// goal is to control a servo movement icm a LMC object

// HMI start means start movement, HMI stop means stop movement, HMI cmd1: start homing, cmd2: jog positive, cmd3: jog negative

FUNCTION VIRTUAL cmServo::work

  //stsState control
  IF stsState<>seStop & stsState<>seWaitReset & stsState<>seIdle & (pmlCom.sts.isInterlocked=1 | pmlCom.sts.inAlarm=1 | iEmergencyStop=1 | iReleaseMovement=0) THEN
    stsState:=seStop; //if interlock or alarm, stop movement
  END_IF;
  
  CASE stsState OF
  
    seStop: //stop movement
      IF lmcCtrl.ActVelocity < 50 & lmcCtrl.ActVelocity > -50 THEN //wait until moving stopped
        stsState:=seWaitReset;
      ELSE
        lmcCtrl.StopMove(Decel:=3*parMaxDec); //sStop movement as fast as possible
      END_IF;
    
    seWaitReset: //wait until problem is solved
      IF pmlCom.sts.inAlarm=0 & pmlCom.sts.isInterlocked=0 THEN //no problem active, make starting again possible
        stsState:=seIdle;
      END_IF;
    
    seIdle: //ready for new action
      
    
    seWaitStartMoveRef: //wait until controller on/brake released
      IF stsControllerIsOn=1 & timerBrakeOff.done=1 THEN
        stsState:=seStartMoveRef;
      END_IF;
    
    seStartMoveRef: //give ref command
      tmpRefMode:= _LMCAXIS_REFMODE.NoZImpulse; //we don't use the Z pulse of the encoder
      IF parRefDirPositive THEN //IF DIRECTION IS POSITIVE, TELL IT TO THE CONTROLLER
        tmpRefMode += _LMCAXIS_REFMODE.RefDirection;
      END_IF;
      IF parNoRefSwitch THEN
        tmpRefMode += _LMCAXIS_REFMODE.ESEqualRef; //no refswitch means use endswitch for homing
      END_IF;
      
      lmcCtrl.Override.Write(input:=1000);//override at max
      lmcCtrl.MoveReference(Mode:=tmpRefMode, 
                   Position:=ParRefPos, 
                      VRef1:=ParRefSpeed, 
                      VRef2:=(ParRefSpeed/5), //reverse direction of homing with 1/5 of normal homing speed
                      Accel:=ParMaxAcc, //use normal acc
             PositionWindow:=ParInPosBand);      
      stsState:=seMoveRef;
    
    seMoveRef: //wait until ref is done
      IF lmcCtrl.AxisStatus.IsReferenced=1 THEN 
        tmpHomingDone:= 1;
        parHomeAgain:= 0;
        stsState:=seIdle;
      END_IF;
    
    seWaitStartMove: //wait until controller on/brake released
      IF stsControllerIsOn=1 & timerBrakeOff.done=1 THEN
        stsState:=seStartMove;
        oIFactor:=parIFactor;
      END_IF;
    
    
    seStartMove: //give move command
      IF reqAcc = 0 THEN
        tmpAcc:=ParMaxAcc;//no Acc given, use the max
      ELSE
        tmpAcc:= (reqAcc * parMaxAcc)/1000; //ReqAcc is a percentage of the maximum
      END_IF;
      IF reqDec = 0 THEN
        tmpDec:=parMaxDec;//no Acc given, use the max
      ELSE
        tmpDec:= (reqDec * parMaxDec)/1000; //ReqAcc is a percentage of the maximum
      END_IF;    
      
      IF pmlCom.sts.mode=manual THEN
        tmpSpeed:= parManualSpeed*iPmSpeed/1000; //in manual move with half the speed
      ELSE

        if ReqSpeed = 0 & calcReqSpeed <> 0 then // tp and calcReqSpeed = not null
          reqSpeed:= 1000;
          tmpSpeed:=(1000*iPmSpeed)/1000;
        else
          tmpSpeed := calcReqSpeed;//JdK 5-11-2019: just use given speed, sometimes we want a wagon to hold for some time, so we need speed 0
        end_if;
      END_IF;

      
      lmcCtrl.Override.Write(input:=tmpSpeed); //required speed is in 1/10%, even as the override, in this way we control the speed
      lmcCtrl.MoveAbsolute(Position:=ReqPos, 
                         Speed:=parMaxSpeed, 
                         Accel:=tmpAcc, 
                         Decel:=tmpDec); 
      tmpOldReqSpeed:=calcReqSpeed; 
      stsState:=seMove;
    
    seMove: //wait until movement is nearly done
      IF (lmcCtrl.Destination <> reqPos | tmpOldReqSpeed <> calcReqSpeed ) THEN //start again if req pos or speed changed
        stsState:= seStartMove;
      ELSIF stsInPos=1 then
        stsState := seWaitInPos;
      ELSIF lmcCtrl.InPosition(Mode:=LMCAXIS_POSITIONWINDOW_INT_UNITS, PositionWindow:=parLastPieceBand) =1 THEN
        stsState:= seMoveLastPiece;
      END_IF;
    
    seMoveLastPiece: //wait until movement is done
      oIFactor:=parExtraIFactor;
      IF ((lmcCtrl.Destination <> reqPos) | tmpOldReqSpeed <> calcReqSpeed  ) THEN //start again if req pos or speed changed
        stsState:= seStartMove;
      ELSIF stsInPos =1 THEN
        stsState:= seWaitInPos;
      END_IF;      
    
    seWaitInPos:
      IF (lmcCtrl.Destination <> reqPos | tmpOldReqSpeed <> calcReqSpeed) THEN //start again if req pos or speed changed
        stsState:= seWaitStartMove;
      ELSIF timerWaitInPos.done=1 THEN
        If stsInPos=1 THEN //action done
          stsState:=seIdle;
        ELSE //start action again
          stsState:=seWaitStartMove;
        END_IF;
      END_IF;
      
    seWaitStartJogPos:
      IF stsControllerIsOn=1 & timerBrakeOff.done=1 THEN
        stsState:=seStartJogPos;
      END_IF;
    
    seStartJogPos:
      lmcCtrl.Override.Write(input:=100); //jog at 10% of speed
      lmcCtrl.MoveEndless(Speed:=parMaxSpeed, Accel:=parMaxAcc);  
      stsState:=seJogPos;
    
    seJogPos:
      IF timerJog.done=1 THEN
        stsState:=seStop;
      END_IF;
    
    seWaitStartJogNeg:
      IF stsControllerIsOn=1 & timerBrakeOff.done=1 THEN
        stsState:=seStartJogNeg;
      END_IF;
      
    seStartJogNeg:
      lmcCtrl.Override.Write(input:=100); //jog at 10% of speed
      lmcCtrl.MoveEndless(Speed:=parMaxSpeed*-1, Accel:=parMaxAcc);  
      stsState:=seJogNeg;    
    
    seJogNeg:
      IF timerJog.done=1 THEN
        stsState:=seStop;
      END_IF;  
    
    seStartCoupling:
      IF stsControllerIsOn=1 & timerBrakeOff.done=1 THEN
        lmcCtrl.CoupleGearRelative(     MaxVel:=parMaxSpeed, 
                                        MaxAcc:=parMaxAcc, 
                                       pMaster:=tmpCouplingMaster, 
                                       GearMul:=1, 
                                       GearDiv:=1);//, 
                                       //MaxJerk:=);
                                       
        stsState:=seWaitCoupling; 
      END_IF;
    
    seWaitCoupling:
      IF lmcCtrl.Control = LOCKED_LMCAXIS THEN
        stsState:=seCoupled;
      END_IF;
      
    seCoupled:
    
    seWaitUnCoupling:
      IF lmcCtrl.Control <> LOCKED_LMCAXIS THEN
        stsState:=seIdle;
      ELSE
        lmcCtrl.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
      END_IF;
  
  END_CASE;
  

  //depending on state, power lmc axis
  IF stsState=seWaitStartMoveRef | stsState=seWaitStartMove | stsState=seWaitStartJogNeg | stsState=seWaitStartJogPos | stsState=seStartCoupling THEN
    lmcCtrl.PowerOn(Mode:=LMCAXIS_MOVE_ANY_WAY);
  END_IF;
  
  //depending on state and some mor, power off lmc axis
  IF stsControllerIsOn=1 & (stsState=seWaitReset | ((stsState=seIdle | stsState=seWaitInPos) & timerBrakeOn.done=1 & (parKeepControllerOn=0 | csPowerOffServo=1))) THEN //JdK 23-4-2022 make it possible to poweroff servo, in this case (5010) for moving into a toolmagazine, and need one servo to go free
    lmcCtrl.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
  END_IF;

END_FUNCTION


FUNCTION GLOBAL cmServo::csStartMoveAbs
	VAR_INPUT
		iReqPos 	: DINT;
		iReqSpeed 	: DINT;
	END_VAR

  IF pmlCom.sts.mode=auto | pmlCom.sts.mode=service THEN
    reqSpeed:=iReqSpeed;
    startMoveAbs(iReqPos:=iReqPos);
  END_IF;
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmServo::checkInPos
	VAR_INPUT
		checkPos 	: DINT;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  //real positions should be in 1/1000 of mm, means resolution in LMC is 100
  ok := stsActRealPos<= ((checkPos *lmcCtrl.Resolution)+parInPosBand) & stsActRealPos>= ((checkPos *lmcCtrl.Resolution)-parInPosBand) ;

END_FUNCTION


FUNCTION GLOBAL cmServo::csStartHoming

  //only accept cs commands if in auto/service 
  IF (pmlCom.sts.mode=auto | pmlCom.sts.mode=service) & sNoHoming= 0 THEN
    startHoming();
  END_IF;

END_FUNCTION


FUNCTION cmServo::startMoveAbs
	VAR_INPUT
		iReqPos 	: DINT;
	END_VAR

  IF stsState<> seStop & stsState<> seWaitReset THEN //only if not in stop or wait reset
    IF iReqPos <= parMaxPos & iReqPos >= parMinPos THEN
      reqPos:=iReqPos;
      IF stsState<> seWaitStartMove & stsState<> seStartMove & stsState<> seMove & stsState<> seMoveLastPiece & stsState<> seWaitReset THEN
        stsState:=seWaitStartMove;
      END_IF;
    ELSE
      giveAlarm(errorNr:=2);
    END_IF;
  END_IF;


END_FUNCTION


FUNCTION cmServo::startHoming
  //start homing, only if in idle
  IF stsState= seIdle THEN
    stsState:=seWaitStartMoveRef;
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL cmServo::execStart
  //start move from HMI
  startMoveAbs(iReqPos:=reqPos);


END_FUNCTION


FUNCTION VIRTUAL cmServo::execStop
  //execute stop command
  IF stsState<> seStop & stsState<> seWaitReset & (stsState<> seIdle | stsControllerIsOn) THEN //only if not already stopped
    stsState:=seStop;
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL cmServo::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  lmcCtrl.SWMinPos.Write(input:=parMinPos-sExtraForMinMaxPos); //keep some distance because we don't want alarms if there is some overshoot
  lmcCtrl.SWMaxPos.Write(input:=parMaxPos+sExtraForMinMaxPos);
  sNoHoming:= sNoHoming.Read();

  state:=1;

END_FUNCTION


FUNCTION GLOBAL cmServo::csStop

  IF pmlCom.sts.mode=auto | pmlCom.sts.mode=service THEN
    execStop();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmServo::resetAlarm
  
  _Alarm.AlarmActief.Write(input:=0);
  _Alarm.ErrorNr.Write(input:=0);
  IF (stsState= seWaitReset | stsState=seIdle) & lmcCtrl.AxisError<>0 THEN
    oResetHW.Write(input:=1);
    lmcCtrl.QuitError();
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmServo::reqPos::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  IF pmlCom.sts.mode= manual | pmlCom.sts.mode= service THEN //only take write of new pos if in manual
	  reqPos := input;
  END_IF;
  
	result := reqPos;

END_FUNCTION


FUNCTION VIRTUAL cmServo::execHmiCmd1
//hmi start home
  startHoming();

END_FUNCTION


FUNCTION VIRTUAL cmServo::execHmiCmd2
//hmi start jog pos
  IF stsState<> seStop & stsState<> seWaitReset & stsState<> seWaitStartJogPos & stsState<> seStartJogPos & stsState<> seJogPos THEN
    stsState:=seWaitStartJogPos;
  END_IF;
  jogSet:=1; //to set timer again

END_FUNCTION


FUNCTION VIRTUAL cmServo::execHmiCmd3
//hmi start jog pos
  IF stsState<> seStop & stsState<> seWaitReset & stsState<> seWaitStartJogNeg & stsState<> seStartJogNeg & stsState<> seJogNeg THEN
    stsState:=seWaitStartJogNeg;
  END_IF;
  jogSet:=1; //to set timer again
  
END_FUNCTION


FUNCTION cmServo::Pendel
  //method is only called if pendel is active, is meant to see how movement goes and to tune PID params
  IF stsState= seIdle THEN //in idle so go to next pos
    IF reqPos=firstPos THEN
      startMoveAbs(iReqPos:=secondPos);
    ELSE
      startMoveAbs(iReqPos:=firstPos);
    END_IF;
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL cmServo::Init1
  
  IF initDone=0 THEN
    //write minpos, maxpos, speed and acc
    sExtraForMinMaxPos:=sExtraForMinMaxPos.Read(); //make extra space for min/max pos optional changeble
    IF sExtraForMinMaxPos=0 THEN
      sExtraForMinMaxPos:=20;
    END_IF;
    
    lmcCtrl.SWMinPos.Write(input:=parMinPos-sExtraForMinMaxPos); //keep some distance because we don't want alarms if there is some overshoot
    lmcCtrl.SWMaxPos.Write(input:=parMaxPos+sExtraForMinMaxPos);
    lmcCtrl.VMax.Write(input:=parMaxSpeed);
    lmcCtrl.AMax.Write(input:=parMaxAcc);
    //lmcCtrl.Resolution.Write(input:=1000);
    IF parManualSpeed=0 THEN
      parManualSpeed:=100; //set speed at 10%
    END_IF;
    initDone:=1;

    
  END_IF;
  
  tmpHomingDone:= 0;
  
END_FUNCTION


FUNCTION GLOBAL cmServo::giveActualSpeed
	VAR_OUTPUT
		speed 	: DINT;
	END_VAR
  //method to give actual speed in % of maximum
  IF parMaxSpeed <> 0 THEN
    speed:=(lmcCtrl.ActVelocity*1000)/parMaxSpeed;
  ELSE
    speed:=0;
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmServo::parMinPos::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	parMinPos := input;
  lmcCtrl.SWMinPos.Write(input:=parMinPos-sExtraForMinMaxPos); //keep some distance because we don't want alarms if there is some overshoot
	result := parMinPos;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmServo::parMaxPos::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	parMaxPos := input;
  lmcCtrl.SWMaxPos.Write(input:=parMaxPos+sExtraForMinMaxPos);
	result := parMaxPos;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmServo::parMaxSpeed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	parMaxSpeed := input;
  lmcCtrl.VMax.Write(input:=parMaxSpeed);
	result := parMaxSpeed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmServo::parMaxAcc::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	parMaxAcc := input;
  lmcCtrl.AMax.Write(input:=parMaxAcc);    
	result := parMaxAcc;

END_FUNCTION


FUNCTION VIRTUAL cmServo::preScanOverride

  //if servo hardware is frequency controller or something, we may have a ready signal
  iHWReady:=iHWReady.Read();
  iEmergencyStop:=iEmergencyStop.Read();
  IF stsState<> seIdle & stsState<> seWaitReset & stsState<> seStop THEN
    iReleaseMovement:=iReleaseMovement.Read(); //if there is no release, alarm is given in release class
  END_IF;
  
  //get position in calculation value of lmc, normally this is in 1/1000mm
  stsActRealPos:=lmcCtrl.ReadPosition(Mode:=LMCAXIS_ACTPOS_INTUNIT);
  
  //calculate in pos state, reqpos is in 1/10 mm, act real pos in 1/1000
  stsInPos:= ABS(stsActRealPos-(reqPos*lmcCtrl.Resolution))< parInPosBand;
  
  IF stsIsHomed=0 THEN //don't give real value if we are not homed yet
    stsPos:=NOREFVALUE;
  ELSIF stsInPos=1 THEN
    stsPos:=reqPos;
  ELSE
    stsPos:=(stsActRealPos)/lmcCtrl.Resolution; //JdK 23-3-2022 get real resolution  100; //go from 1/1000ste to 1/10
  END_IF;
  stsSpeed:=lmcCtrl.ActVelocity.Read();
  

  //call timers
  timerTimeOut:=runTimer(Active:=stsState=seMove, iMem:=timerTimeOut, TimerTime:=parTimeOutTime, Pause:=tmpSpeed = 0);//tp 25-09-2020 pause timer when speed is nul
  timerJog:=runTimer(Active:=(stsState=seJogNeg|stsState=seJogPos)&jogSet=0, iMem:=timerJog, TimerTime:=parJogTime, Pause:=0);
  jogSet:=0; //set it to zero every cycle, if button is pressed, it is ma de 1
  timerControllerOn:=runTimer(Active:=lmcCtrl.AxisStatus.PowerOn, iMem:=timerControllerOn, TimerTime:=parTimeControllerOn, Pause:=0);
  timerWaitInPos:=runTimer(Active:=stsState=seWaitInPos, iMem:=timerWaitInPos, TimerTime:=parWaitInPosTime, Pause:=0);
  timerBrakeOn:=runTimer(Active:=oBrake=1, iMem:=timerBrakeOn, TimerTime:=parTimeBrakeOn, Pause:=0);
  timerBrakeOff:=runTimer(Active:=oBrake=0, iMem:=timerBrakeOff, TimerTime:=parTimeBrakeOff, Pause:=0);
  timerSimRef:=runTimer(Active:=stsState=seMoveRef, iMem:=timerSimRef, TimerTime:=10, Pause:=0);
  
  //homed status
  stsIsHomed:=(lmcCtrl.AxisStatus.IsReferenced);//test JdK 19-7-2019 & (tmpHomingDone=1 | pmlCom.cmd.simulation= allSimu)); //only if homing is started at least once, or no homing required
  
  //controller on status
  stsControllerIsOn:=timerControllerOn.done;
  
  //calculate calc req speed
  iPmSpeed:=iPmSpeed.Read();
  calcReqSpeed:= (reqSpeed * iPmSpeed)/1000;



  IF stsControllerIsOn=0 & (lmcCtrl.AxisError.HwMinError=1 | lmcCtrl.AxisError.HwMaxError= 1) THEN //JdK 22-09-2021, don't give alarm after startup, because servo can go down on endswitch
    esWasAlreadyActive:=1;
  ELSIF lmcCtrl.AxisError.HwMinError=0 & lmcCtrl.AxisError.HwMaxError= 0 THEN
    esWasAlreadyActive:= 0;
  END_IF;

  //set alarms
  IF timerTimeOut.done THEN
    giveAlarm(errorNr:=1);
  END_IF;
  //nr 2 is given if reqpos is out of reach
  IF iHWReady= 0 & stsState<>seWaitReset & stsState<>seIdle & stsState<>seStop & pmlCom.cmd.simulation<>allSimu THEN
    giveAlarm(errorNr:=3);
  END_IF;
  IF lmcCtrl.AxisError<>0 & stsState<>seWaitReset & stsState<>seIdle & stsState<>seStop & (esWasAlreadyActive=0 | (lmcCtrl.AxisError.HwMinError=0 & lmcCtrl.AxisError.HwMaxError= 0)) THEN //error in drive, and not stopped
    IF lmcCtrl.AxisError.HwError THEN
      giveAlarm(errorNr:=4);
    ELSIF lmcCtrl.AxisError.SwMinError THEN
      IF stsState=seMove & reqPos < stsPos THEN //only if moving negative
        giveAlarm(errorNr:=5);
      END_IF;
    ELSIF lmcCtrl.AxisError.SwMaxError THEN
      IF stsState=seMove & reqPos > stsPos THEN //only if moving positive
        giveAlarm(errorNr:=6);
      END_IF;
    ELSIF lmcCtrl.AxisError.HwMinError THEN
      IF stsState=seMove & reqPos < stsPos THEN //only if moving negative
        giveAlarm(errorNr:=7);
      END_IF;
    ELSIF lmcCtrl.AxisError.HwMaxError THEN
      IF stsState=seMove & reqPos > stsPos THEN //only if moving positive
        giveAlarm(errorNr:=8);
      END_IF;
    ELSIF lmcCtrl.AxisError.ReferenceError THEN
      giveAlarm(errorNr:=9);
    ELSIF lmcCtrl.AxisError.ContouringError THEN
      giveAlarm(errorNr:=10);
    ELSE
      giveAlarm(errorNr:=11); //general alarm, one of the other alarms is active in the controller
    END_IF;
  END_IF;
  IF iEmergencyStop=1 & stsState<>seWaitReset & stsState<>seIdle & stsState<>seStop THEN
    giveAlarm(errorNr:=12);
  END_IF;
    
  IF PendelOn=1 & stsIsHomed=1 THEN
    Pendel();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmServo::postScanOverride

  oBrake:= stsState=seWaitReset | ((stsState=seIdle | stsState=seWaitInPos) & ((parKeepControllerOn=0 | csPowerOffServo=1) | stsControllerIsOn=0)); //brake on if reset, or if in idle/wait and not keep controller on, or controller is of
  oBrake.Write(input:=oBrake);

  oIFactor.Write(input:=oIFactor);
  stsSimRef:=(pmlCom.cmd.simulation=allSimu | parOverrideSimulateServo) & stsState=seMoveRef & timerSimRef.done=0;
  stsAllSimuActive:= pmlCom.cmd.simulation= allSimu | parOverrideSimulateServo;

  
  IF (pmlCom.cmd.simulation=allSimu | parOverrideSimulateServo) & lmcCtrl.SimulateMode<>1 THEN //JdK 7-4-2022: make it possible to test with one or more servo's in simulate mode
    lmcCtrl.SimulateMode.Write(input:=1);
  ELSIF (pmlCom.cmd.simulation<>allSimu & parOverrideSimulateServo=0) & lmcCtrl.SimulateMode<>0 THEN
    lmcCtrl.SimulateMode.Write(input:=0);
  END_IF;

  cntrDistance1.actPos:= stsActRealPos/100; //for counting distance

END_FUNCTION


FUNCTION GLOBAL cmServo::csPowerOn

  //only accept cs commands if in auto/service 
  IF (pmlCom.sts.mode=auto | pmlCom.sts.mode=service) & stsControllerIsOn=0 THEN
    lmcCtrl.PowerOn(Mode:=LMCAXIS_MOVE_ANY_WAY);
  END_IF;
  

END_FUNCTION


FUNCTION GLOBAL cmServo::csCheckPosFits
	VAR_INPUT
		pos 	: DINT;
	END_VAR
	VAR_OUTPUT
		fits 	: DINT;
	END_VAR

  IF pos <= parMaxPos & pos >= parMinPos THEN
    fits:=1;
  ELSE
    fits:=0;
  END_IF;

END_FUNCTION


FUNCTION GLOBAL cmServo::csCouple
	VAR_INPUT
		start1Stop0 	: DINT;
		couplingMaxSpeed 	: DINT;
		couplingMaxAcc 	: DINT;
		master 	: ^MasterStruct;
	END_VAR
	VAR_OUTPUT
		done 	: DINT;
	END_VAR

  done:=0;
  //only accept cs commands if in auto/service 
  IF (pmlCom.sts.mode=auto | pmlCom.sts.mode=service) THEN
    IF start1Stop0= 1 THEN //means start coupling
      IF stsState= seIdle THEN
        tmpCouplingSpeed:=couplingMaxSpeed;
        tmpCouplingAcc:=couplingMaxAcc;
        tmpCouplingMaster:=master;
        stsState:= seStartCoupling;
      ELSIF stsState= seCoupled THEN
        done:= 1;
      END_IF;
    ELSE
      IF stsState= seCoupled THEN
        stsState:= seWaitUnCoupling;
      ELSIF stsState= seIdle THEN
        done:= 1;
      END_IF;
    END_IF;
  ELSE
    done:= -1; //failure
  END_IF;
        

END_FUNCTION


FUNCTION GLOBAL cmServo::csGiveMaster
	VAR_OUTPUT
		master 	: ^MasterStruct;
	END_VAR

  master:=lmcCtrl.ReadMasterInfo(usDelay:=0);

END_FUNCTION


FUNCTION GLOBAL cmServo::csPowerOff

  lmcCtrl.PowerOff(Mode:=LMCAXIS_IMMEDIATE_STOPP);
  
END_FUNCTION
