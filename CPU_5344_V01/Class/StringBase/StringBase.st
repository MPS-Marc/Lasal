//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "StringBase"
	Revision           = "1.9"
	GUID               = "{261DA0D7-7803-406D-8F57-0EC0B7F187C5}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="Command" GUID="{FA1B9652-3521-4E91-ACDE-606F1E87933A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="ToOsKernal" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\StringBase\AsciiChar.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SigmaControl" Author="Johan"/>
		<Dokumentation Revision="1.9" Date="15/10/2010" Author="JE" Company="SigmaControl" Description="Made 2 classes for CRC from Table and with a Poly.&#13;&#10;&quot;BuildCrc16Check&quot; and &quot;BuildCrc16CheckTable&quot;.&#13;&#10;&quot;DecodeCrc16Check&quot; and &quot;DecodeCrc16CheckTable&quot;"/>
		<Dokumentation Revision="1.8" Date="06/04/2010" Author="JE" Company="SigmaControl" Description="In function &quot;IpValidChk&quot; the for next loop was one byte to long.&#13;&#10;In function &quot;StringCopy&quot; a char to long can be copied.&#13;&#10;In function &quot;Read2Nul&quot; not limited should no nul be found."/>
		<Dokumentation Revision="1.7" Date="02/11/2009" Author="JE" Company="SigmaControl" Description="System replaced by OS Kernal."/>
		<Dokumentation Revision="1.6" Date="14/08/2009" Author="JE" Company="SigmaControl" Description="Swap 2 and 4 byte."/>
		<Dokumentation Revision="1.5" Date="27/07/2009" Author="JE" Company="SigmaControl" Description="Added &quot;IpValidChk&quot;"/>
		<Dokumentation Revision="1.3" Date="21/10/2009" Author="JE" Company="SigmaControl" Description="BuildValue2Ascii The Value -2147483648 is handeld correctly."/>
		<Dokumentation Revision="1.2" Date="17/10/2008" Author="JE" Company="SigmaControl" Description="BuildValue2Ascii also handels negative values."/>
	</RevDoku>
</Class>
*)
StringBase : CLASS
  //Servers:
	Command 	: SvrChCmd_DINT;
  //Clients:
	ToOsKernal 	: CltChCmd__OSKernel;
  //Variables:
		DummyString : ARRAY [0..cMaxAsciiLine] OF CHAR;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildValue2Ascii"/>
	FUNCTION VIRTUAL GLOBAL BuildValue2Ascii
		VAR_INPUT
			Value 	: DINT;			//! <Variable Comment="Decimal value to be converted to an Ascii string." Name="BuildValue2Ascii.Value"/>
			Digit 	: DINT;			//! <Variable Comment="Number of ASCII digits to be converted, 0= read till a none number char." Name="BuildValue2Ascii.Digit"/>
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildValue2Ascii.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Offset in destination string, must be less than cMaxAsciiLine." Name="BuildValue2Ascii.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildValue2Ascii.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildBCD2Ascii"/>
	FUNCTION VIRTUAL GLOBAL BuildBCD2Ascii
		VAR_INPUT
			Value 	: HDINT;			//! <Variable Comment="BCD value to be converted to an Ascii string." Name="BuildBCD2Ascii.Value"/>
			Digit 	: DINT;
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildBCD2Ascii.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildBCD2Ascii.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildBCD2Ascii.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildValue2Hex"/>
	FUNCTION VIRTUAL GLOBAL BuildValue2Hex
		VAR_INPUT
			Value 	: DINT;			//! <Variable Comment="Hexa decimal value to be converted to an Ascii string." Name="BuildValue2Hex.Value"/>
			Digit 	: DINT;
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildValue2Hex.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildValue2Hex.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildValue2Hex.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildTime"/>
	FUNCTION VIRTUAL GLOBAL BuildTime
		VAR_INPUT
			TimeValue 	: SYSTIME;			//! <Variable Comment="Time in system format." Name="BuildTime.TimeValue"/>
			Mode 	: DINT;			//! <Variable Comment="0= HHMMSS, 10= HH:MM:SS, 11= HH:MM:SS PM/AM, 20= [H]H:[M]M:[S]S, 21= [H]H:[M]M:[S]S PM/AM." Name="BuildTime.Mode"/>
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildTime.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildTime.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildTime.Size"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BuildSysTime
		VAR_INPUT
			Mode 	: DINT;
			pBaDest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildDate"/>
	FUNCTION VIRTUAL GLOBAL BuildDate
		VAR_INPUT
			DateValue 	: SYSDATE;			//! <Variable Comment="date in system format." Name="BuildDate.DateValue"/>
			Mode 	: DINT;
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildDate.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildDate.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildDate.Size"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BuildSysDate
		VAR_INPUT
			Mode 	: DINT;
			pBaDest 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Copies a sting starting at pSource and written to pBaDest+ Offset.&#13;&#10;" Name="BuildString"/>
	FUNCTION VIRTUAL GLOBAL BuildString
		VAR_INPUT
			pSource 	: ^CHAR;			//! <Variable Comment="Pointer to a string to be converted." Name="BuildString.pSource"/>
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildString.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildString.Offset"/>
			Length 	: DINT;			//! <Variable Comment="If Length is bigger than 0 then that is the number of characters to be copied else the length is till the &apos;cNul&apos;." Name="BuildString.Length"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildString.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Places one Seperator character and leaves the line as a nullimited string.&#13;&#10;" Name="BuildChar"/>
	FUNCTION VIRTUAL GLOBAL BuildChar
		VAR_INPUT
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildChar.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildChar.Offset"/>
			Character 	: CHAR;			//! <Variable Comment="Charakter to be added to the destination string" Name="BuildChar.Character"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildChar.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Places one Seperator character and leaves the line as a nullimited string.&#13;&#10;" Name="BuildSeperator"/>
	FUNCTION VIRTUAL GLOBAL BuildSeperator
		VAR_INPUT
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildSeperator.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildSeperator.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildSeperator.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Places one &apos;CR&apos; and one &apos;LF&apos; character and leaves the line as a nullimited string.&#13;&#10;" Name="BuildEOL"/>
	FUNCTION VIRTUAL GLOBAL BuildEOL
		VAR_INPUT
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildEOL.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="BuildEOL.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildEOL.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Copy a string from begin to a seperator or a &apos;cNul&apos;.&#13;&#10;When pBaDest is 0 than only the size of the string is measured ( without the &apos;cNul&apos;) and not copied.&#13;&#10;" Name="StringCopy"/>
	FUNCTION VIRTUAL GLOBAL StringCopy
		VAR_INPUT
			pSource 	: ^CHAR;			//! <Variable Comment="Pointer to a string to be copied." Name="StringCopy.pSource"/>
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="StringCopy.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="StringCopy.Offset"/>
			Length 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="StringCopy.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Copy a string from begin to a seperator or a &apos;cNul&apos;.&#13;&#10;When pBaDest is 0 than only the size of the string is measured ( without the &apos;cNul&apos;) and not copied.&#13;&#10;" Name="Read2Nul"/>
	FUNCTION VIRTUAL GLOBAL Read2Nul
		VAR_INPUT
			pSource 	: ^CHAR;			//! <Variable Comment="Pointer to a string to be read." Name="Read2Nul.pSource"/>
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="Read2Nul.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="Read2Nul.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="Read2Nul.Size"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;Copy a string from begin to a &apos;CR&apos; or a &apos;cNul&apos;.&#13;&#10;When pBaDest is 0 than only the size of the string is measured ( without the &apos;cNul&apos;) and not copied.&#13;&#10;" Name="Read2CR"/>
	FUNCTION VIRTUAL GLOBAL Read2CR
		VAR_INPUT
			pSource 	: ^CHAR;			//! <Variable Comment="Pointer to a string to be read." Name="Read2CR.pSource"/>
			pBaDest 	: ^CHAR;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="Read2CR.pBaDest"/>
			Offset 	: DINT;			//! <Variable Comment="Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine." Name="Read2CR.Offset"/>
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="Read2CR.Size"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Read2Char
		VAR_INPUT
			pSource 	: ^CHAR;
			pBaDest 	: ^CHAR;
			Offset 	: DINT;
			Character 	: CHAR;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ConvAscii2Value
		VAR_INPUT
			pSource 	: ^CHAR;			//! <Variable Comment="Pointer to a string to be converted." Name="ConvAscii2Value.pSource"/>
			Digit 	: DINT;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;			//! <Variable Comment="ASCII HEX value in a DINT format" Name="ConvAscii2Value.Value"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ConvAscii2Bcd
		VAR_INPUT
			PSource 	: ^CHAR;
			Digit 	: DINT;
		END_VAR
		VAR_OUTPUT
			Value 	: HDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ConvHex2Value
		VAR_INPUT
			pSource 	: ^CHAR;			//! <Variable Comment="Pointer to a string to be converted." Name="ConvHex2Value.pSource"/>
			Digit 	: DINT;
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL IpValidChk
		VAR_INPUT
			pIpAddress 	: ^IpAdrStr;
		END_VAR
		VAR_OUTPUT
			Status 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DleStuffing
		VAR_INPUT
			pBaSource 	: ^CHAR;
			Length 	: DINT;
			Skip 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DleWipig
		VAR_INPUT
			pBaSource 	: ^CHAR;
			Length 	: DINT;
			Skip 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CalcLrc8
		VAR_INPUT
			pBaSource 	: ^CHAR;
			Length 	: DINT;
			Mask 	: CHAR;
		END_VAR
		VAR_OUTPUT
			Checksum 	: CHAR;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BuildLrc8Check
		VAR_INPUT
			pBaSource 	: ^CHAR;
			Offset 	: DINT;
			Mask 	: CHAR;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildLrc8Check.Size"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DecodeLrc8Check
		VAR_INPUT
			pBaSource 	: ^CHAR;
			Length 	: DINT;
			Mask 	: CHAR;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="DecodeLrc8Check.State"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BuildCrc8Check
		VAR_INPUT
			pBaSource 	: ^CHAR;
			Offset 	: DINT;
		END_VAR
		VAR_OUTPUT
			Size 	: DINT;			//! <Variable Comment="0= Can&apos;t place value else size of added string without &apos;cNul&apos;." Name="BuildCrc8Check.Size"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DecodeCrc8Check
		VAR_INPUT
			pBaSource 	: ^CHAR;
			Length 	: DINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION TAB Crc8Table;
	
	FUNCTION TAB Crc16Table;
	
	FUNCTION TAB Crc32Table;
	
	FUNCTION TAB CrcDnpTable;
	
	FUNCTION TAB CrcCcittTable;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _OSKernel


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB StringBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_STRINGBASE
1$UINT, 9$UINT, (SIZEOF(::StringBase))$UINT, 
1$UINT, 1$UINT, 0$UINT, 
TO_UDINT(1348707034), "StringBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::StringBase.Command.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2978944206), "Command", 
//Clients:
(::StringBase.ToOsKernal.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3361380467), "ToOsKernal", TO_UDINT(3045737964), "_OSKernel", 0$UINT, 5$UINT, 
END_FUNCTION


#define USER_CNT_StringBase 27

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_StringBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION StringBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_StringBase, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #BuildValue2Ascii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #BuildBCD2Ascii();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #BuildValue2Hex();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #BuildTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #BuildSysTime();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #BuildDate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #BuildSysDate();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #BuildString();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #BuildChar();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #BuildSeperator();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #BuildEOL();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #StringCopy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #Read2Nul();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #Read2CR();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #Read2Char();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #ConvAscii2Value();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #ConvAscii2Bcd();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #ConvHex2Value();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #IpValidChk();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #DleStuffing();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #DleWipig();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #CalcLrc8();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #BuildLrc8Check();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #DecodeLrc8Check();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #BuildCrc8Check();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #DecodeCrc8Check();

#pragma warning (default : 74)
	Command.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Command.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


//[#ENGLISH]
// ****************************************************************************************
// BASIC Ascii string  handler
// ****************************************************************************************
//
// Server	Command		: ID			= .
//		   	Status		: 0				= ok.
// Client	System  	: Dont connect. 
//
// ****************************************************************************************
// Created : JE  : Wk 19/05 | Lasal V01.01.005 | Lars V1.70
// Tested  : JE  : Wk 37/06 | Lasal V02.20.015 | Lars V01.01.127
// Tested  : JE  : Wk 42/06 | Lasal V02.20.015 | Lars V01.01.127
//
// REV 01.01
// In the DecodeCrc16Check there was a problem with the check that is corected.
//
// ****************************************************************************************
//[#DEUTSCH]
// ****************************************************************************************
// BASIC RS handler
// ****************************************************************************************
//
//
// ****************************************************************************************

FUNCTION VIRTUAL GLOBAL StringBase::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

	state := READY;

END_FUNCTION

//[#ENGLISH]
//[>Value]Value to be converted to an Ascii string.
//[>Digit]Number of digits 0 is autolengt n is number of digits (with leading zero's).
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::BuildValue2Ascii
VAR_INPUT
	Value		: DINT;
	Digit		: DINT;
	pBaDest		: ^Char;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
  i			: Dint;
  TempPtr		: ^Char;
  TempValue	: Dint;
  TempNegFl : Dint;
End_Var;

// Deterin if positive
If Value< 0 Then
  TempNegFl := 1;
  If Value= -2147483648 Then
    // -2147483648 has no ABS pos value!
    Value := 0;
  Else
    Value := Abs( Value);
  End_If;
Else
  TempNegFl := 0;
End_If;

// Deterin the size
If Digit<> 0 then
  If Digit<= 11 Then
    Size	:= Digit;
  Else
    Size	:= 11;
  End_If;
Else
  Size:= TempNegFl; // If signed then 1 larger.
  TempValue	:= Value;
  Repeat
    Size	+= 1;
    TempValue	:= TempValue / 10;
  Until TempValue= 0 End_Repeat;
End_If;

// Does it fit in to the string
If Offset+ Size<= cMaxAsciiLine Then
  TempPtr	:= pBaDest+ Offset;
  If TempNegFl= 1 Then
    If Value= 0 Then
      Size := 11;
      If Offset+ Size<= cMaxAsciiLine Then
        _MemCpy( TempPtr, "-2147483648", To_Udint( Size));
        ( TempPtr+ Size)^	:= cNul;
      Else
        Size := 0;
      End_If;
      return;
    Else
      TempPtr^  := '-';
    End_If;
  End_If;
  ( TempPtr+ Size)^	:= cNul;
  For i:= Size- 1 to TempNegFl By -1 Do
    TempValue	:= Value mod 10;
    Value	/= 10;
    ( TempPtr+ i)^	:= To_USint( TempValue)+ '0';
  End_For;
Else
	Size	:= 0;
End_If;

END_FUNCTION //GLOBAL StringBase::BuildValue2Ascii


//[#ENGLISH]
//[>Value]BCD Value to be converted to an Ascii string.
//[>Digit]Number of digits. Autolengt is not posible
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildBCD2Ascii
VAR_INPUT
	Value		: HDINT;
	Digit		: DINT;
	pBaDest		: ^Char;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
	i			: Dint;
	TempPtr		: ^Char;
	TempValue	: HDint;
End_Var;

Size	:= 0;
If Digit= 0 then
  Size	:= 8;
ElsIf Digit<= 8 Then
  Size	:= Digit;
Else
  Size	:= 8;
End_If;

// Does it fit in to the string
If Offset+ Size<= cMaxAsciiLine Then
  TempPtr	:= pBaDest+ Offset;
  ( TempPtr+ Size)^	:= cNul;
  For i:= Size- 1 to 0 By -1 Do
    TempValue	:= Value And 16#0F;
    Value	:= Value shr 4;
    // BCD value can't exceed 9.
    if TempValue>9 then TempValue := 0; end_if;
    ( TempPtr+ i)^	:= To_USint( TempValue)+ '0';
  End_For;
Else
	Size	:= 0;
End_If;

END_FUNCTION //VIRTUAL GLOBAL StringBase::BuildBCD2Ascii


//[#ENGLISH]
//[>Value]Value to be converted to an Ascii string.
//[>Digit]Number of digits 0 is autolengt n is number of digits (with leading zero's).
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::BuildValue2Hex
VAR_INPUT
	Value		: DINT;
	Digit		: DINT;
	pBaDest		: ^Char;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
	i			: Dint;
	TempPtr		: ^Char;
	TempValue	: Dint;
End_Var;

// Negative Value
If Value< 0 Then
  Value := Abs( Value);
  Trace("'StringBase::BuildValue2Hex' UNDER CONSTRUCTION Not tested");
End_If;

// Determin the size
If Digit<> 0 then
	If Digit<= 8 Then
		Size	:= Digit;
	Else
		Size	:= 8;
	End_If;
Else
	Size:= 0;
	TempValue	:= Value;
	Repeat
		Size	+= 1;
		TempValue	:= TempValue shr 4;
	Until TempValue= 0 End_Repeat;
End_If;

// Does it fit in to the string
If Offset+ Size<= cMaxAsciiLine Then
	TempPtr	:= pBaDest+ Offset;
	( TempPtr+ Size)^	:= cNul;
	For i:= Size- 1 to 0 By -1 Do
		TempValue	:= Value mod 16;
		Value	/= 16;
		If TempValue< 10 Then
			( TempPtr+ i)^	:= To_USint( TempValue)+ '0';
		Else
			( TempPtr+ i)^	:= ( To_USint( TempValue)- 10)+ 'A';
		End_If;
	End_For;
Else
	Size	:= 0;
End_If;

END_FUNCTION //GLOBAL StringBase::BuildValue2Hex


//[#ENGLISH]
//[>DateValue]date in system format.
//[>Mode]0= YYYYMMDD, 1= YYMMDD, 10= DD/MM/YYYY, 11= DD/MM/YY, 20= [D]D/[M]M/[YYY]Y, 21= [D]D/[M]M/[Y]Y.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildDate
	VAR_INPUT
		DateValue 	: SYSDATE;
		Mode 	: DINT;
		pBaDest 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR

Size	:= 0;
Case Mode of
00:	//	YYYYMMDD
	Size	+= BuildValue2Ascii( Value	:= DateValue.wYear	, Digit	:= 4, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildValue2Ascii( Value	:= DateValue.wMonth	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildValue2Ascii( Value	:= DateValue.wDay	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
01:	//	YYMMDD
	Size	+= BuildValue2Ascii( Value	:= DateValue.wYear	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildValue2Ascii( Value	:= DateValue.wMonth	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildValue2Ascii( Value	:= DateValue.wDay	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
10:	// DD/MM/YYYY
	Size	+= BuildValue2Ascii( Value	:= DateValue.wDay	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= DateValue.wMonth	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= DateValue.wYear	, Digit	:= 4, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ' ');
11:	// DD/MM/YY
	Size	+= BuildValue2Ascii( Value	:= DateValue.wDay	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= DateValue.wMonth	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= DateValue.wYear	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ' ');
20:	// [D]D/[M]M/[YYY]Y
	Size	+= BuildValue2Ascii( Value	:= DateValue.wDay	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= DateValue.wMonth	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= DateValue.wYear	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ' ');
21:	// [D]D/[M]M/[Y]Y
	Size	+= BuildValue2Ascii( Value	:= DateValue.wDay	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= DateValue.wMonth	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= '/');
	Size	+= BuildValue2Ascii( Value	:= ( DateValue.wYear mod 100)	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ' ');
Else // No valid date mode
	Trace("'StringBase::BuildDate' Not a valid date mode");
	Size	+= BuildString( pSource	:= "DATE ", pBaDest	:= pBaDest, Offset	:= Offset, Length	:= 0);
End_Case;

END_FUNCTION //VIRTUAL GLOBAL StringBase::BuildDate


//[#ENGLISH]
//[>DateValue]date in system format.
//[>Mode]0= YYYYMMDD, 1= YYMMDD, 10= DD/MM/YYYY, 11= DD/MM/YY, 20= [D]D/[M]M/[YYY]Y, 21= [D]D/[M]M/[Y]Y.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildSysDate
  VAR_INPUT
    Mode		: DINT;
    pBaDest		: ^Char;
    Offset		: DINT;
  END_VAR
  VAR_OUTPUT
    Size		: DINT;
  END_VAR
  VAR
  	IntDate : SYSDATE;
  END_VAR

  ToOsKernal.GetSystemDate( #IntDate);
  Size	:= BuildDate( DateValue := IntDate
                    , Mode , pBaDest , Offset);

END_FUNCTION


//[#ENGLISH]
//[>TimeValue]Time in system format.
//[>Mode]0= HHMMSS, 10= HH:MM:SS, 11= HH:MM:SS PM/AM, 20= [H]H:[M]M:[S]S, 21= [H]H:[M]M:[S]S PM/AM.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildTime
VAR_INPUT
	TimeValue	: SysTime;
	Mode		  : DINT;
	pBaDest		: ^Char;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
Var
	TempHour	: DINT;
	Pm_Am		: BOOL;
End_Var;

Size	:= 0;
Case Mode of
00:	//	HHMMSS
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wHour		, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wMinute	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wSecond	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
10:	//	HH:MM:SS
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wHour		, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wMinute	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wSecond	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ' ');
11:	// HH:MM:SS PM/AM
	If TimeValue.wHour< 12 Then
		Pm_Am	:= 0;
		TempHour	:= TimeValue.wHour;
	Else
		Pm_Am	:= 1;
		If TimeValue.wHour< 13 Then
			TempHour	:= TimeValue.wHour;
		Else
			TempHour	:= TimeValue.wHour- 12;
		End_If;
	End_If;
	Size	+= BuildValue2Ascii( Value	:= TempHour		, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wMinute	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wSecond	, Digit	:= 2, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	If Pm_Am= 0 Then
		Size	+= BuildString( pSource	:= " AM ", pBaDest	:= pBaDest, Offset	:= Size+ Offset, Length	:= 0);
	Else
		Size	+= BuildString( pSource	:= " PM ", pBaDest	:= pBaDest, Offset	:= Size+ Offset, Length	:= 0);
	End_If;
20:	//	[H]H:[M]M:[S]S
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wHour		, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wMinute	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wSecond	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ' ');
21: // [H]H:[M]M:[S]S PM/AM
	If TimeValue.wHour< 12 Then
		Pm_Am	:= 0;
		TempHour	:= TimeValue.wHour;
	Else
		Pm_Am	:= 1;
		If TimeValue.wHour< 13 Then
			TempHour	:= TimeValue.wHour;
		Else
			TempHour	:= TimeValue.wHour- 12;
		End_If;
	End_If;
	Size	+= BuildValue2Ascii( Value	:= TempHour		, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wMinute	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	Size	+= BuildChar( pBaDest, Size+ Offset, Character:= ':');
	Size	+= BuildValue2Ascii( Value	:= TimeValue.wSecond	, Digit	:= 0, pBaDest	:= pBaDest, Offset	:= Size+ Offset);
	If Pm_Am= 0 Then
		Size	+= BuildString( pSource	:= " AM ", pBaDest	:= pBaDest, Offset	:= Size+ Offset, Length	:= 0);
	Else
		Size	+= BuildString( pSource	:= " PM ", pBaDest	:= pBaDest, Offset	:= Size+ Offset, Length	:= 0);
	End_If;
Else	// No valid time mode
	Trace("'StringBase::BuildDate' Not a valid time mode");
	Size	+= BuildString( pSource	:= "TIME ", pBaDest	:= pBaDest, Offset	:= Offset, Length	:= 0);
End_Case;

END_FUNCTION //VIRTUAL GLOBAL StringBase::BuildTime


//[#ENGLISH]
//[>Mode]0= HHMMSS, 10= HH:MM:SS, 11= HH:MM:SS PM/AM, 20= [H]H:[M]M:[S]S, 21= [H]H:[M]M:[S]S PM/AM.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildSysTime
  VAR_INPUT
    Mode		: DINT;
    pBaDest		: ^Char;
    Offset		: DINT;
  END_VAR
  VAR_OUTPUT
    Size		: DINT;
  END_VAR
  VAR
  	IntTime : SYSTIME;
  END_VAR

  ToOsKernal.GetSystemTime( #IntTime);
  Size	:= BuildTime( TimeValue := IntTime
                    , Mode , pBaDest , Offset);

END_FUNCTION


//[#ENGLISH]
//Copies a sting starting at pSource and written to pBaDest+ Offset.
//[>pSource]Pointer to a string to be copied.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[>Length]If Length is bigger than 0 then that is the number of characters to be copied else the length is till the 'cNul'.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::BuildString
VAR_INPUT
	pSource		: ^Char;
	pBaDest		: ^Char;
	Offset		: DINT;
	Length		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

// Determin the size
If Length<= 0 Then
	Length	:= Read2Nul( pSource	:= pSource, pBaDest	:= 0$^USINT, Offset	:= 0);
End_If;
// Copy the String
Size	:= 0;
If Offset+ Length<= cMaxAsciiLine Then 
	_MemCpy(( pBaDest + Offset), pSource, to_Udint( Length));
	Size	:= Length;
	// Leave as a NulLimited string
	If pBaDest+ Offset+ Length- 1= cNul Then
		Size	-= 1;
	Else
		If Offset+ Length<= cMaxAsciiLine Then
			( pBaDest+ Offset+ Length)^ := cNul;
		Else
      Size  := 0;
		End_If;
	End_If; 
Else
  Size  := 0;
End_If;

END_FUNCTION //GLOBAL StringBase::BuildString


//[#ENGLISH]
//Places one Seperator character and leaves the line as a nullimited string.
//[>pBaDest]Pointer to the begin of a string where the Seperator is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[>Character]Charakter to be added to the destination string
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildChar
VAR_INPUT
	pBaDest		: ^Char;
	Offset		: DINT;
	Character		: Char;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

Size	:= 0;
If (Offset + 1) <= cMaxAsciiLine Then
	(pBaDest + Offset)^	:= Character;
	Offset += 1;
	(pBaDest + Offset)^	:= cNul;
	Size	:= 1;
Else
  Size  := 0;
End_If;

END_FUNCTION //VIRTUAL GLOBAL StringBase::BuildChar


//[#ENGLISH]
//Places one Seperator character and leaves the line as a nullimited string.
//[>pBaDest]Pointer to the begin of a string where the Seperator is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::BuildSeperator
VAR_INPUT
	pBaDest		: ^Char;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

Size	:= 0;
If (Offset + 1) <= cMaxAsciiLine Then
	(pBaDest + Offset)^	:= ';';
	Offset += 1;
	(pBaDest + Offset)^	:= cNul;
	Size	:= 1;
Else
  Size  := 0;
End_If;

END_FUNCTION //GLOBAL StringBase::BuildSeperator


//[#ENGLISH]
//Places one 'CR' and one 'LF' character and leaves the line as a nullimited string.
//[>pBaDest]Pointer to the begin of a string where the Seperator is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::BuildEOL
VAR_INPUT
	pBaDest		: ^Char;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR

Size	:= 0;
If (Offset + 2) <= cMaxAsciiLine Then
	(pBaDest + Offset)^	:= cCR;
	Offset	+= 1;
	(pBaDest + Offset)^	:= cLF;
	Offset	+= 1;
	(pBaDest + Offset)^	:= cNul;
	Size	:= 2;
Else
  Size  := 0;
End_If;

END_FUNCTION //GLOBAL StringBase::BuildEOL


//[#ENGLISH]
//Copy a string from begin to a seperator or a 'cNul'.
//When pBaDest is 0 than only the size of the string is measured ( without the 'cNul') and not copied.
//[>pSource]Pointer to a string to be copied.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::StringCopy
VAR_INPUT
	pSource		: ^Char;
	pBaDest		: ^Char;
	Offset		: DINT;
	Length		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
VAR
	tempPtr : ^Char;
END_VAR


Size	:= 0;
// Determin the size
If Length= 0 then
  TempPtr := pSource;
  while TempPtr^<> 0 do
    Length	+= 1;
    if Offset+ Length <= cMaxAsciiLine then
      TempPtr += 1;
    else
      return;
    end_if;
  end_while;
End_If;

If Offset+ Length <= cMaxAsciiLine Then
  _MemCpy(( pBaDest + Offset), pSource, to_Udint( Length));
  Size	:= Length;
End_If;

// Leave as a NulLimited string
If pBaDest+ Offset+ Length- 1= cNul Then
	Size	-= 1;
Else
	If Offset+ Length<= cMaxAsciiLine Then
		( pBaDest+ Offset+ Length)^ := cNul;
	Else
    Size  := 0;
	End_If;
End_If;

END_FUNCTION //GLOBAL StringBase::StringCopy


//[#ENGLISH]
//Copy a string from begin to a seperator or a 'cNul'.
//When pBaDest is 0 than only the size of the string is measured ( without the 'cNul') and not copied.
//[>pSource]Pointer to a string to be copied.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::Read2Nul
VAR_INPUT
	pSource		: ^Char;
	pBaDest		: ^Char;
	Offset		: DINT;
END_VAR
VAR_OUTPUT
	Size		: DINT;
END_VAR
VAR
	TempPtr		: ^Char;
	TempChar	: Char;
	i		: DINT;
END_VAR

Size:= 0;
TempPtr	:= pBaDest+ Offset;
For i:= 0 to cMaxAsciiLine Do
	If Offset< cMaxAsciiLine Then
		TempChar	:= pSource^;
		If pBaDest<> nil Then
			TempPtr^	:= TempChar;
		End_If;
		Case TempChar of
		0:
      If pBaDest<> nil Then
        TempPtr^	:= cNul;
      End_If;
			i	:= cMaxAsciiLine;
		Else
			Size	+= 1;
			Offset	+= 1;
			pSource	+= 1;
			TempPtr	+= 1;
		End_Case;
	Else
    If pBaDest<> nil Then
      ( pBaDest+ cMaxAsciiLine)^ := cNul;
    End_If;
		i	:= cMaxAsciiLine;
	End_If;
End_For;

END_FUNCTION //GLOBAL StringBase::Read2Nul


//[#ENGLISH]
//Copy a string from begin to a 'CR' or a 'cNul'.
//When pBaDest is 0 than only the size of the string is measured ( without the 'cNul') and not copied.
//[>pSource]Pointer to a string to be copied.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION GLOBAL StringBase::Read2CR
  VAR_INPUT
    pSource		: ^Char;
    pBaDest		: ^Char;
    Offset		: DINT;
  END_VAR
  VAR_OUTPUT
    Size		: DINT;
  END_VAR
  VAR
    TempPtr		: ^Char;
    TempChar	: Char;
    i		: DINT;
  END_VAR

Size:= 0;
TempPtr	:= pBaDest+ Offset;
For i:= 0 to cMaxAsciiLine Do
	If Offset < cMaxAsciiLine Then
		TempChar	:= pSource^;
		If pBaDest<> nil Then
			TempPtr^	:= TempChar;
		End_If;
		Case TempChar of
		0, cCR:
      If pBaDest<> nil Then
        TempPtr^	:= cNul;
      End_If;
			i	:= cMaxAsciiLine;
		Else
			Size	+= 1;
			Offset	+= 1;
			pSource	+= 1;
			TempPtr	+= 1;
		End_Case;
	Else
    If pBaDest<> nil Then
      ( pBaDest+ cMaxAsciiLine)^ := cNul;
    End_If;
		i	:= cMaxAsciiLine;
	End_If;
End_For;

END_FUNCTION //GLOBAL StringBase::Read2CR


//[#ENGLISH]
//Copy a string from begin to a 'character or a 'cNul'.
//When pBaDest is 0 than only the size of the string is measured ( without the 'cNul') and not copied.
//[>pSource]Pointer to a string to be copied.
//[>pBaDest]Pointer to the begin of a string where the Ascii value is to be placed. This must be of the size cMaxAsciiLine.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[>Character]The character to stop reading.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::Read2Char
	VAR_INPUT
		pSource 	: ^CHAR;
		pBaDest 	: ^CHAR;
		Offset 	: DINT;
		Character 	: CHAR;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  VAR
    TempPtr		: ^Char;
    TempChar	: Char;
    i		: DINT;
  END_VAR

Size:= 0;
TempPtr	:= pBaDest+ Offset;
For i:= 0 to cMaxAsciiLine Do
	If Offset < cMaxAsciiLine Then
		TempChar	:= pSource^;
		If pBaDest<> nil Then
			TempPtr^	:= TempChar;
		End_If;
    If TempChar= cNul | TempChar= Character Then
      If pBaDest<> nil Then
        TempPtr^	:= cNul;
      End_If;
			i	:= cMaxAsciiLine;
		Else
			Size	+= 1;
			Offset	+= 1;
			pSource	+= 1;
			TempPtr	+= 1;
		End_If;
	Else
    If pBaDest<> nil Then
      ( pBaDest+ cMaxAsciiLine)^ := cNul;
    End_If;
		i	:= cMaxAsciiLine;
	End_If;
End_For;

END_FUNCTION


//[#ENGLISH]
//[>pSource]Pointer to a string to be converted.
//[>Digit]Number of ASCII digits to be converted, 0= read till a none number char. '.' and ',' are skiped and number conversion is continued.
//[<Value]ASCII value in a DINT format
FUNCTION GLOBAL StringBase::ConvAscii2Value
VAR_INPUT
	pSource		: ^Char;
	Digit		: DINT;
END_VAR
VAR_OUTPUT
	Value		: DINT;
END_VAR
Var
	i	: Dint;
	Sign	: Dint;
	TempVal	: Dint;
End_Var;

// Auto size
If Digit= 0 Then
	Digit	:= 11;
End_If;
// Negative charakter
If pSource^= '-' & pSource <> 0 Then
	pSource	+= 1;
	Digit	-= 1;
	Sign	:= 1;
Else
	Sign	:= 0;
End_If;
// Start conversion
TempVal	:= 0;
For i:= 1 to Digit Do
	Case pSource^ of 
	'0'..'9':
		// Clac values
		TempVal	*= 10;
		TempVal	+= pSource^- '0';
		pSource	+= 1;
	'.', ',':
		// Skip chars
		pSource	+= 1;
	Else
		// No number
		i	:= Digit;
	End_Case;
End_For;
// Add sign
If Sign= 1 Then
	Value	:= 0- TempVal;
Else
	Value	:= TempVal;
End_If;

END_FUNCTION //GLOBAL StringBase::ConvAscii2Value


//[#ENGLISH]
//[>pSource]Pointer to a string to be converted.
//[>Digit]Number of ASCII digits to be converted, 0= read till a none number char. '.' and ',' are skiped and number conversion is continued.
//[<Value]ASCII value in a HDINT format
FUNCTION VIRTUAL GLOBAL StringBase::ConvAscii2Bcd
	VAR_INPUT
		PSource 	: ^CHAR;
		Digit 	: DINT;
	END_VAR
	VAR_OUTPUT
		Value 	: HDINT;
	END_VAR
#Pragma Warning (disable:72);
Var
  i	: Dint;
  TempSource  : Char;
  TempVal	: HDint;
End_Var;
#Pragma Warning (default:72);

// Auto size
If Digit= 0 Then
  Digit	:= 8;
ElsIf Digit> 8 Then
  Digit	:= 8;
End_If;
// Start conversion
TempVal	:= 0;
For i:= 1 to Digit Do
	Case pSource^ of 
	'0'..'9':
		// Clac values
		TempVal	:= TempVal Shl 4;
		TempVal	:= TempVal OR (pSource^- '0');
		pSource	+= 1;
	Else
		// No number
		i	:= Digit;
	End_Case;
End_For;
Value := TempVal;

END_FUNCTION


//[>pSource]Pointer to a string to be converted.
//[>Digit]Number of ASCII digits to be converted, 0= read till a none number char.
//[<Value]ASCII HEX value in a DINT format
FUNCTION GLOBAL StringBase::ConvHex2Value
VAR_INPUT
	pSource		: ^Char;
	Digit		: DINT;
END_VAR
VAR_OUTPUT
	Value		: DINT;
END_VAR
Var
	i	: Dint;
	Upper	: Dint;
	Lower	: Dint;
	TempVal	: Dint;
End_Var;

Value	:= 0;
For i:= 0 to (( Digit/ 2)- 1) Do
	Value	*= 256;
	Upper	:= To_Dint( pSource^);
	Lower	:= To_Dint((pSource+ 1)^);
	pSource	+= 2;
	If Upper< 'A' Then
		TempVal	:= ( Upper- '0');
	Else
		TempVal	:= ( Upper- 'A')+ 10;
	End_If;
	Value	+= TempVal* 16;
	If Lower< 'A' Then
		TempVal	:= ( Lower- '0');
	Else
		TempVal	:= ( Lower- 'A')+ 10;
	End_If;
	Value	+= TempVal;
End_For;

END_FUNCTION //GLOBAL StringBase::ConvHex2Value


//[#ENGLISH]
//Check if Ip address is xxx.xxx.xxx.xxx0 format.
//[>pIpAddress]Pointer to the begin of a string witch contains a IP address.
//[<Status]0= Ack, -1= value>255, -2=, 
FUNCTION VIRTUAL GLOBAL StringBase::IpValidChk
#Pragma Warning (disable:73);
	VAR_INPUT
		pIpAddress 	: ^IpAdrStr;
	END_VAR
#Pragma Warning (default:73);
	VAR_OUTPUT
		Status 	: DINT;
	END_VAR
  
Trace("'StringBase::IpValidChk' UNDER CONSTRUCTION Not tested");
Status  := -1;
  
(*
	VAR
		i 	      : DINT;
    Done      : DINT;
		Cntr 	    : DINT;
		Offset 	  : DINT;
		TempAdr 	: IpAdrStr;
	END_VAR

  Status  := 0;   // Lets start positive.
  Offset  := 0;
  Cntr    := 0;
  // Clear TempAdr
  for  i:= 0 to Sizeof( IpAdrStr)- 1 do
    TempAdr[ i] := cNul;
  end_for;
  // Copy ip Address
  TempAdr := pIpAddress^;
  for  i:= 0 to Sizeof( IpAdrStr)- 1 do
    if TempAdr[ i]= cNul then
      Done  := 1;
    end_if;
    if TempAdr[ i]= '.'
     | TempAdr[ i]= cNul then
      TempAdr[ i] := cNul;
      cntr  += 1;
      if ConvAscii2Value( pSource := #TempAdr[ Offset], Digit  := 0)> 255 then
        Status  := -1;
        Trace("'StringBase::IpValidChk' an IP value over 255");
        i := Sizeof( IpAdrStr);  // End loop
      else
        Offset  := i+ 1;
      end_if;
    end_if;
    if done= 1 then
      i := Sizeof( IpAdrStr);
    end_if;
  end_for;
  if cntr<> 4 then
    Status  := -2;
    Trace("'StringBase::IpValidChk' A valid IP address exsists of 4 value's no more no less");
  end_if;
*)

END_FUNCTION


//[#ENGLISH]
//If data contains control commands as Stx then a cDle is placed in front of the charakter.
//So that the communication protocol can determin if a Stx is data or a control charakter.
//DleWiping must be used to remove cDle charakters from the data. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's of the hole string to be tested.
//[>Skip]Number of byte's at the begin of the string to be skiped.
//[<Size]Number of cDle's added.
FUNCTION VIRTUAL GLOBAL StringBase::DleStuffing
	VAR_INPUT
		pBaSource 	: ^CHAR;
		Length 	: DINT;
		Skip 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  Var
    pString   : ^Hsint;
    Append    : Dint;
    i     : Dint;
  End_Var;
  
  Size  := 0;
  // Determin how many cDle must be placed
  Append  := 0;
  If Length+ Append <= cMaxAsciiLine Then
    pString := pBaSource+ Skip;
    For i:= 0 to (Length- Skip) Do
      Case pString^ Of
      cStx, cEtx, cDle:
        Append  += 1;
      End_Case;
      DummyString[i] := pString^;
      pString += 1;
    End_For;
  
    // If we place these cDle does it still fit in the buffer.
    If Length+ Append <= cMaxAsciiLine Then
      // 
      pString := pBaSource+ Skip;
      For i:= 0 to (Length- Skip) Do
        Case DummyString[i] Of
        cStx, cEtx, cDle:
          pString^  := cDle;
          pString += 1;
          pString^  := DummyString[i];
          pString += 1;
        Else
          pString^  := DummyString[i];
          pString += 1;
        End_Case;
      End_For;
      Size  := Append;
    End_If;
  End_If;

END_FUNCTION


//[#ENGLISH]
//Removes the cDle's that DleStuffing has placed in the
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's of the hole string to be tested.
//[>Skip]Number of byte's at the begin of the string to be skiped.
//[<Size]Number of cDle's added. LOOK OUT! this is a negative number for cDle's will be removed.
FUNCTION VIRTUAL GLOBAL StringBase::DleWipig
	VAR_INPUT
		pBaSource 	: ^CHAR;
		Length 	: DINT;
		Skip 	: DINT;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  Var
    i     : Dint;
    pDest : ^Char;
  End_Var;
  
  Size  := 0;
  pBaSource += Skip;
  pDest := pBaSource;
  For i:= 0 to (Length- Skip) Do
    If pBaSource^= cDle Then
      Size  -= 1;
      pBaSource += 1;
    End_If;
    pDest^  := pBaSource^;
    pBaSource += 1;
    pDest += 1;
  End_For;
  pBaSource^  := cNul;

END_FUNCTION


//[#ENGLISH]
//Calculate the LRC checksum of a string and place it as 2 ASCII characters at the end. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's that must be calculated.
//[>Mask]Start value of the checksum ( mostly 16#00 or 16#FF).
//[<Checksum]The calculated checksum.
FUNCTION VIRTUAL GLOBAL StringBase::CalcLrc8
	VAR_INPUT
		pBaSource 	: ^CHAR;
		Length 	: DINT;
		Mask 	: CHAR;
	END_VAR
	VAR_OUTPUT
		Checksum 	: CHAR;
	END_VAR
  Var
    i   : Dint;
  End_Var

Trace("'StringBase::CalcLrc8' UNDER CONSTRUCTION Not tested");

Checksum := Mask;
For i:= 0 to Length- 1 Do
  Checksum := Checksum Xor pBaSource^;
  pBaSource += 1;
End_For;

END_FUNCTION


//[#ENGLISH]
//Calculate the LRC checksum of a string and place it as 2 ASCII characters at the end. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Offset]Offset in destination string, must be less than cMaxAsciiLine.
//[>Mask]Start value of the checksum ( mostly 16#00 or 16#FF).
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildLrc8Check
	VAR_INPUT
		pBaSource 	: ^CHAR;
		Offset 	: DINT;
		Mask 	: CHAR;
	END_VAR
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR
  Var
    Checksum   : Char;
  End_Var;

Trace("'StringBase::BuildLrc8Check' UNDER CONSTRUCTION Not tested");

If (Offset + 2) <= cMaxAsciiLine Then
  Checksum  := CalcLrc8( pBaSource, Length := Offset, Mask);
  Size  := BuildValue2Hex( Value := Checksum, Digit  := 2, pBaDest := pBaSource, Offset);
Else
  Size  := 0;
End_If;

END_FUNCTION


//[#ENGLISH]
//Test if the LRC checksum of a string is correct. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's that must be calculated.
//[>Mask]Start value of the checksum ( mostly 16#00 or 16#FF).
//[<State]0<= Nok, 1= Ok. The Checksum is correct data valid.
FUNCTION VIRTUAL GLOBAL StringBase::DecodeLrc8Check
	VAR_INPUT
		pBaSource 	: ^CHAR;
		Length 	: DINT;
		Mask 	: CHAR;
	END_VAR
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  Var
    Checksum  : Char;
  End_Var;

Trace("'StringBase::DecodeLrc8Check' UNDER CONSTRUCTION Not tested");

  Checksum  := CalcLrc8( pBaSource, (Length- 2), Mask);
  If Checksum= To_USint( ConvHex2Value( pSource := (pBaSource+ (Length- 2)), Digit := 2)) Then
    State := 1;
  Else
    State := 0;
  End_if;

END_FUNCTION


//[#ENGLISH]
//Calculate the CRC 8 checksum of a string. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's that must be calculated.
//[<Size]0= Can't place value else size of added string without 'cNul'.
FUNCTION VIRTUAL GLOBAL StringBase::BuildCrc8Check
#Pragma Warning (disable:73);
	VAR_INPUT
		pBaSource 	: ^CHAR;
		Offset 	: DINT;
	END_VAR
#Pragma Warning (default:73);
	VAR_OUTPUT
		Size 	: DINT;
	END_VAR

Trace("'StringBase::BuildCrc8Check' UNDER CONSTRUCTION Not tested");
Size  := 0;

END_FUNCTION


//[#ENGLISH]
//Test if the CRC 8 checksum of a string is correct. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's that must be calculated.
//[<State]0<= Nok, 1= Ok. The Checksum is correct data valid.
FUNCTION VIRTUAL GLOBAL StringBase::DecodeCrc8Check
#Pragma Warning (disable:73);
	VAR_INPUT
		pBaSource 	: ^CHAR;
		Length 	: DINT;
	END_VAR
#Pragma Warning (default:73);
	VAR_OUTPUT
		State 	: DINT;
	END_VAR

Trace("'StringBase::DecodeCrc8Check' UNDER CONSTRUCTION Not tested");
State := 0;

END_FUNCTION


//[#ENGLISH]
//Calculate the CRC 16 checksum of a string. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>offset]Place where the CRC must be placed
//[>Skip]Number of byte's at the begin of the string to be skiped.
//[>Mask]The start value for the CRC calculation.
//[>Poly]The polynoom used.
//[<Size]0= Can't place value else size of added string without 'cNul'.

//[#ENGLISH]
//Test if the CRC 16 checksum of a string is correct. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's that must be calculated.
//[>Skip]Number of byte's at the begin of the string to be skiped.
//[>Mask]The start value for the CRC calculation.
//[>Poly]The polynoom used.
//[<State]0<= Nok, 1= Ok. The Checksum is correct data valid.

//[#ENGLISH]
//Calculate the CRC 16 checksum of a string. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>offset]Place where the CRC must be placed
//[>Skip]Number of byte's at the begin of the string to be skiped.
//[>Mask]The start value for the CRC calculation.
//[>CrcTable]A table calculated with the polynoom used.
//[<Size]0= Can't place value else size of added string without 'cNul'.

//[#ENGLISH]
//Test if the CRC 16 checksum of a string is correct. 
//[>pBaSource]Pointer to the begin of a string of witch a checksum must be calculated.
//[>Legth]Number of byte's that must be calculated.
//[>Skip]Number of byte's at the begin of the string to be skiped.
//[>Mask]The start value for the CRC calculation.
//[>CrcTable]A table calculated with the polynoom used.
//[<State]0<= Nok, 1= Ok. The Checksum is correct data valid.

//[#ENGLISH]
// CRC 8 checksum table with Polynoom ????? = 16#?????
FUNCTION TAB StringBase::Crc8Table

END_FUNCTION


//[#ENGLISH]
// CRC 16 checksum table with Polynoom x15+x13+1 = 16#A001
FUNCTION TAB StringBase::Crc16Table

16#0000$UINT,16#C0C1,16#C181,16#0140,16#C301,16#03C0,16#0280,16#C241
16#C601$UINT,16#06C0,16#0780,16#C741,16#0500,16#C5C1,16#C481,16#0440
16#CC01$UINT,16#0CC0,16#0D80,16#CD41,16#0F00,16#CFC1,16#CE81,16#0E40
16#0A00$UINT,16#CAC1,16#CB81,16#0B40,16#C901,16#09C0,16#0880,16#C841
16#D801$UINT,16#18C0,16#1980,16#D941,16#1B00,16#DBC1,16#DA81,16#1A40
16#1E00$UINT,16#DEC1,16#DF81,16#1F40,16#DD01,16#1DC0,16#1C80,16#DC41
16#1400$UINT,16#D4C1,16#D581,16#1540,16#D701,16#17C0,16#1680,16#D641
16#D201$UINT,16#12C0,16#1380,16#D341,16#1100,16#D1C1,16#D081,16#1040

16#F001$UINT,16#30C0,16#3180,16#F141,16#3300,16#F3C1,16#F281,16#3240
16#3600$UINT,16#F6C1,16#F781,16#3740,16#F501,16#35C0,16#3480,16#F441
16#3C00$UINT,16#FCC1,16#FD81,16#3D40,16#FF01,16#3FC0,16#3E80,16#FE41
16#FA01$UINT,16#3AC0,16#3B80,16#FB41,16#3900,16#F9C1,16#F881,16#3840
16#2800$UINT,16#E8C1,16#E981,16#2940,16#EB01,16#2BC0,16#2A80,16#EA41
16#EE01$UINT,16#2EC0,16#2F80,16#EF41,16#2D00,16#EDC1,16#EC81,16#2C40
16#E401$UINT,16#24C0,16#2580,16#E541,16#2700,16#E7C1,16#E681,16#2640
16#2200$UINT,16#E2C1,16#E381,16#2340,16#E101,16#21C0,16#2080,16#E041

16#A001$UINT,16#60C0,16#6180,16#A141,16#6300,16#A3C1,16#A281,16#6240
16#6600$UINT,16#A6C1,16#A781,16#6740,16#A501,16#65C0,16#6480,16#A441
16#6C00$UINT,16#ACC1,16#AD81,16#6D40,16#AF01,16#6FC0,16#6E80,16#AE41
16#AA01$UINT,16#6AC0,16#6B80,16#AB41,16#6900,16#A9C1,16#A881,16#6840
16#7800$UINT,16#B8C1,16#B981,16#7940,16#BB01,16#7BC0,16#7A80,16#BA41
16#BE01$UINT,16#7EC0,16#7F80,16#BF41,16#7D00,16#BDC1,16#BC81,16#7C40
16#B401$UINT,16#74C0,16#7580,16#B541,16#7700,16#B7C1,16#B681,16#7640
16#7200$UINT,16#B2C1,16#B381,16#7340,16#B101,16#71C0,16#7080,16#B041

16#5000$UINT,16#90C1,16#9181,16#5140,16#9301,16#53C0,16#5280,16#9241
16#9601$UINT,16#56C0,16#5780,16#9741,16#5500,16#95C1,16#9481,16#5440
16#9C01$UINT,16#5CC0,16#5D80,16#9D41,16#5F00,16#9FC1,16#9E81,16#5E40
16#5A00$UINT,16#9AC1,16#9B81,16#5B40,16#9901,16#59C0,16#5880,16#9841
16#8801$UINT,16#48C0,16#4980,16#8941,16#4B00,16#8BC1,16#8A81,16#4A40
16#4E00$UINT,16#8EC1,16#8F81,16#4F40,16#8D01,16#4DC0,16#4C80,16#8C41
16#4400$UINT,16#84C1,16#8581,16#4540,16#8701,16#47C0,16#4680,16#8641
16#8201$UINT,16#42C0,16#4380,16#8341,16#4100,16#81C1,16#8081,16#4040

END_FUNCTION


//[#ENGLISH]
// CRC DNP checksum table with Polynoom ????? = 16#A6BC
FUNCTION TAB StringBase::CrcDnpTable

END_FUNCTION


//[#ENGLISH]
// CRC CCITT checksum table with Polynoom ????? = 16#1021
FUNCTION TAB StringBase::CrcCcittTable

END_FUNCTION


//[#ENGLISH]
// CRC 32 checksum table with Polynoom ????? = 16#EBD88320
FUNCTION TAB StringBase::Crc32Table

END_FUNCTION
