//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Logic_And_Base"
	Revision           = "1.11"
	GUID               = "{B14BCCC0-3259-11D4-AB39-02A024AEA053}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "true"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Logic_And_Base\Tools.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)"
	Comment            = "Baseclass Logic AND class">
	<Channels>
		<Server Name="result" GUID="{B14BCCC1-3259-11D4-AB39-00A024AEA053}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="result of the calculation"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\code\Global_Functions\H_Get_ptr_on_Obj.h" Include="false"/>
			<File Path=".\Source\code\Global_Functions\Get_ptr_on_Obj.st"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.11" Date="2017-02-01" Author="FucHer" Company="Sigmatek" Description="And_stx(): clients were not updated  in case of target architecture ARM. Use RD_CHNL() instead of RD().&#13;&#10;To update all clients do not exit the loop when a client is zero."/>
		<Dokumentation Revision="1.10" Date="2013-12-12" Author="spimar" Company="Sigmatek" Description="The Read() method of connected clients wasn&apos;t called in case of target architecture ARM"/>
		<Dokumentation Revision="1.4" Date="30.04.09" Author="hötant" Company="Sigmatek" Description="Changed LSL_TARGETARCH_ARM to _LSL_TARGETARCH_ARM"/>
		<Dokumentation Revision="1.3" Date="04.02.09" Author="hötant" Company="Sigmatek" Description="AWL to ST (to guarantee compatibility for other processors) "/>
	</RevDoku>
</Class>
*)
Logic_And_Base : CLASS
  //Servers:
	result 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
		pCls 	: ^ClsHdr;
  //Functions:
	
	FUNCTION Logic_And_Base
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION AWL And_stx
		VAR_INPUT
			ptr_C 	: ^CltCh;
			numbers 	: UINT;
		END_VAR
		VAR_OUTPUT
			result 	: DINT;
		END_VAR;
				//! <Function Comment=" ******************************************************************&#13;&#10;        UND Funktion mit variablen Kanälen&#13;&#10; ******************************************************************&#13;&#10;   CLIENT: Op1, Op2,...&#13;&#10;   SERVER: result&#13;&#10;   Wenn Op1&lt;&gt;0 und Op2 &lt;&gt;0 ,... Dann result := 1 Sonst 0&#13;&#10;          Diese Basisklasse darf keine Clients haben !&#13;&#10; ******************************************************************&#13;&#10;                          READ Funktion&#13;&#10; ******************************************************************&#13;&#10;   erstellt  :   BS   :   47/01&#13;&#10; ******************************************************************&#13;&#10;   getested: BS | 29.11.2001 | Lasal V00.53 | OPS V4.00&#13;&#10; ******************************************************************&#13;&#10; ******************************************************************&#13;&#10;        AND Operation with variable channels&#13;&#10; ******************************************************************&#13;&#10;   CLIENT: Op1, Op2,...&#13;&#10;   SERVER: result&#13;&#10;   If Op1&lt;&gt;0 and Op2 &lt;&gt;0 ,... then result := 1 Else 0&#13;&#10;          This baseclass is not allowed to have clients !&#13;&#10; ******************************************************************&#13;&#10;                    operation of READ function&#13;&#10; ******************************************************************&#13;&#10;   created  :   BS   :   47/01&#13;&#10; ******************************************************************&#13;&#10;   tested: BS | 29.11.2001 | Lasal V00.53 | OPS V4.00&#13;&#10; ******************************************************************&#13;&#10;" Name="result.Read"/>
	FUNCTION VIRTUAL GLOBAL result::Read
		VAR_OUTPUT
			EAX 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Logic_And_Base::@CT_
0$UINT,
2#0110000000000000$UINT, //TY_LOGIC_AND_BASE
1$UINT, 11$UINT, (SIZEOF(::Logic_And_Base))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(427688042), "Logic_And_Base", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Logic_And_Base.result.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3817997973), "result", 
//Clients:
END_FUNCTION


#define USER_CNT_Logic_And_Base 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Logic_And_Base] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Logic_And_Base::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_Logic_And_Base, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Read		:= #Read();
	vmt.CmdTable.Write		:= #M_WR_DIRECT();
	result.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF result.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= Logic_And_Base();

END_FUNCTION

//{{LSL_IMPLEMENTATION


//*********************Inserted from .\code\C_And.st*********************



 



//[#DEUTSCH]
// ******************************************************************
// 	   			UND Funktion mit variablen Kanälen
// ******************************************************************
//			CLIENT:	Op1, Op2,...
//			SERVER:	result
//
//			Wenn Op1<>0 und Op2 <>0 ,... Dann result := 1 Sonst 0
//
//          Diese Basisklasse darf keine Clients haben !
// ******************************************************************
//                          READ Funktion
// ******************************************************************
//			erstellt		:		 BS 		:		 47/01
// ******************************************************************
//   getested: BS | 29.11.2001 | Lasal V00.53 | OPS V4.00
// ******************************************************************
//[#ENGLISH]
// ******************************************************************
// 	   			AND Operation with variable channels
// ******************************************************************
//			CLIENT:	Op1, Op2,...
//			SERVER:	result
//
//			If Op1<>0 and Op2 <>0 ,... then result := 1 Else 0
//
//          This baseclass is not allowed to have clients !
// ******************************************************************
//                    operation of READ function
// ******************************************************************
//			created		:		 BS 		:		 47/01
// ******************************************************************
//   tested: BS | 29.11.2001 | Lasal V00.53 | OPS V4.00
// ******************************************************************
FUNCTION Logic_And_Base::result::Read
VAR_OUTPUT
	 EAX	: DINT; 	
END_VAR
VAR	
	Ptr		: ^CltCh;
END_VAR

// Pointer auf 1.Client
	Ptr := THIS$^CltCh;
//-----------------------------------------------------------------
// vor Änderung
//  Ptr := (ptr$UDINT + SIZEOF(Logic_And_Base) + SIZEOF(SvrCh)*TO_UDINT(pCls^.nSvrChs))$^CltCh;
// Daten einlesen
// Datan verknuepfen
//	result.dData := And_stx(Ptr,pCls^.nCltChs);

// nach Änderung
  Ptr := (ptr$UDINT + SIZEOF(Logic_And_Base) + SIZEOF(SvrCh)*TO_UDINT(pCls^.pDsc^.nSvrChs))$^CltCh;
// Daten einlesen
// Datan verknuepfen
	result.dData := And_stx(Ptr,pCls^.pDsc^.nCltChs);

//HaaPet 15.01.05
//-----------------------------------------------------------------

// Datan schreiben
	EAX := result.dData$UDINT;
END_FUNCTION //CAnd::Read
//[#ENGLISH]
// ******************************************************************
// 	   			AND Operation with variable channels
// ******************************************************************
//			CLIENT:	Op1, Op2,...
//			SERVER:	result
//
//			If Op1<>0 and Op2 <>0 ,... then result := 1 Else 0
//
//          This baseclass is not allowed to have clients !
// ******************************************************************
//                          CONSTRUCTION
// ******************************************************************
//			created		:		 BS 		:		 47/01
// ******************************************************************
//   tested: BS | 29.11.2001 | Lasal V00.53 | OPS V4.00
// ******************************************************************
//[#DEUTSCH]
// ******************************************************************
// 	   			UND Funktion mit variablen Kanälen
// ******************************************************************
//			CLIENT:	Op1, Op2,...
//			SERVER:	result
//
//			Wenn Op1<>0 und Op2 <>0 ,... Dann result := 1 Sonst 0
//
//          Diese Basisklasse darf keine Clients haben !
// ******************************************************************
//                          CONSTRUCTION
// ******************************************************************
//			erstellt		:		 BS 		:		 47/01
// ******************************************************************
//   getested: BS | 29.11.2001 | Lasal V00.53 | OPS V4.00
// ******************************************************************
 //VIRTUAL GLOBAL Logic_And::Init
FUNCTION Logic_And_Base::Logic_And_Base
  VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  pCls 	:= Get_ptr_on_Obj(THIS);

	ret_code := C_OK;

END_FUNCTION

#ifdef _LSL_TARGETARCH_ARM

FUNCTION Logic_And_Base::And_stx
	VAR_INPUT
		ptr_C 	: ^CltCh;
		numbers 	: UINT;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR
VAR
	i:DINT;
END_VAR

  result:=1;
  i:=0;
  while i < numbers do 
    if RD_CHNL(this, to_uint((ptr_C$UDINT - this$UDINT))) = 0 then
      result:=0;
    end_if;
    ptr_c += SIZEOF(CLTCH);
    i+=1;
  end_while;
  
END_FUNCTION //GLOBAL Logic_And::And_st

#else

FUNCTION AWL LOGIC_AND_BASE::And_stx
VAR_INPUT
	ptr_C		: ^CLTCH;
	numbers		: UINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

 	L.D			result, 1
	L.EBX		Ptr_C
	SUB.EBX		ESI
	CLR			ECX			// LOOP with ECX
	L.CX	numbers
	O.CX		CX
	JZ			END_AND_ST
LOOP_READ_AND
	PUSH		EBX
	PUSH		ECX
	FC			ASM_RD_CHNL // CALL = FC
	POP			ECX
	POP			EBX
	O.EAX		EAX
	JNZ			AND_NO_ZERO
	L.D			result, 0 
AND_NO_ZERO
	ADD.EBX		SIZEOF(CLTCH)
	LOOP		LOOP_READ_AND
	JMP			END_AND_ST1	
END_AND_ST
	L.D			result, 0 

END_AND_ST1	

END_FUNCTION //GLOBAL Logic_And::And_stx

#endif


(*
FUNCTION AWL LOGIC_AND_BASE::And_stx
VAR_INPUT
	ptr_C		: ^CLTCH;
	numbers		: UINT;
END_VAR
VAR_OUTPUT
	result		: DINT;
END_VAR

	L.D			result, 0
	L.EBX		Ptr_C
	SUB.EBX		ESI
	CLR			ECX			// LOOP with ECX
	L.CX		numbers
	O.CX		CX
	JZ			END_AND_ST
LOOP_READ_AND
	PUSH		EBX
	PUSH		ECX
	FC			ASM_RD_CHNL
	POP			ECX
	POP			EBX
	O.EAX		EAX
	JZ			END_AND_ST
	ADD.EBX		SIZEOF(CLTCH)
	LOOP		LOOP_READ_AND
	L.D			result, 1
	JMP			END_AND_ST	
END_AND_ST	

END_FUNCTION //GLOBAL Logic_And::And_st
*)









