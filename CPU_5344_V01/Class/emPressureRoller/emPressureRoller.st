//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emPressureRoller"
	Revision           = "1.0"
	GUID               = "{92849841-93F1-41E8-8080-D9745178940D}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "500 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(642,120)">
	<Channels>
		<Server Name="oStopWagon" GUID="{A5444446-0B59-45CF-8E4C-30A0D77EDB84}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="parPosFC" GUID="{2607A5EC-6412-486C-BD0F-598A16931095}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parPosRol" GUID="{EAE4DA92-1AF0-4D38-B195-34D463C3A608}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parRolActive" GUID="{1EEFA0AC-C971-4FA5-A1D0-570C409AEE9E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parSafeZone" GUID="{1FD48A17-9A58-4547-A87D-625184CD9236}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parSendBackAfterFirstOperation" GUID="{744E8367-C21E-4F6F-A732-DEDD723630A5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parSlowSpeedAfterSendedBack" GUID="{C1277842-1FF4-45E7-9C19-A9DF1C9EE9A9}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="true" Retentive="false"/>
		<Server Name="parStopZone" GUID="{1B1DBCA3-A0FB-4988-9C3F-0F923FD5F4E0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parUseSlowSpeed" GUID="{612498C0-22FC-4DC6-8D34-7F55694FA385}" Visualized="false" Initialize="true" DefValue="1" WriteProtected="true" Retentive="false"/>
		<Server Name="stsAlreadySendedOut" GUID="{CE8E75D4-0097-4DD9-AF0E-47E596B38744}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsMaxSpeedWagonNegative" GUID="{587BD2C9-3C85-43B3-B15E-16A651DC4037}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="ctrlCil" Required="true" Internal="false"/>
		<Client Name="iActPosWagon" Required="true" Internal="false"/>
		<Client Name="iFcMatDetected" Required="true" Internal="false"/>
		<Client Name="iSlowSpeedWagon" Required="true" Internal="false"/>
		<Client Name="iStprFirstOperation" Required="true" Internal="false"/>
	</Channels>
	<Network Name="emPressureRoller">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{CEA56774-C71D-4B31-9B5A-491FD19E13E8}"
				Class      = "emBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1156,210),(984,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1156,270),(984,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1156,330),(984,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1156,390),(984,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1156,450),(984,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1156,510),(984,510),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1156,570),(984,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1156,630),(984,630),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1156,690),(984,750),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1156,750),(984,810),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1156,810),(984,870),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1156,870),(984,930),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1156,930),(984,1170),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1156,990),(984,1230),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emBase

emPressureRoller : CLASS
: emBase
  //Servers:
	stsMaxSpeedWagonNegative 	: SvrCh_DINT;
	stsAlreadySendedOut 	: SvrCh_DINT;
	oStopWagon 	: SvrCh_DINT;
	parSafeZone 	: SvrCh_DINT;
	parStopZone 	: SvrCh_DINT;
	parPosFC 	: SvrCh_DINT;
	parPosRol 	: SvrCh_DINT;
	parSendBackAfterFirstOperation 	: SvrCh_DINT;
	parRolActive 	: SvrCh_DINT;
	parSlowSpeedAfterSendedBack 	: SvrCh_DINT;
	parUseSlowSpeed 	: SvrCh_DINT;
  //Clients:
	ctrlCil 	: CltChCmd_cmCil;
	iFcMatDetected 	: CltCh_DINT;
	iActPosWagon 	: CltCh_DINT;
	iStprFirstOperation 	: CltCh_DINT;
	iSlowSpeedWagon 	: CltCh_DINT;
  //Variables:
		MatDetPosWagon 	: DINT;
		UpdateSpeed 	: DINT;
		StartposWagon 	: DINT;
		tmpRunActionDuringHolding 	: DINT;
		cilShouldBeOut 	: DINT;
		oldStprFirstOperation 	: DINT;
		wagonGotValue 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION VIRTUAL execResetting;
	
	FUNCTION VIRTUAL execStarting;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION VIRTUAL execHolding;
	
	FUNCTION VIRTUAL execUnHolding;
	
	FUNCTION VIRTUAL execSuspending;
	
	FUNCTION VIRTUAL execUnSuspending;
	
	FUNCTION VIRTUAL runAction;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd cmCil


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emPressureRoller::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMPRESSUREROLLER
1$UINT, 0$UINT, (SIZEOF(::emPressureRoller))$UINT, 
11$UINT, 5$UINT, 0$UINT, 
TO_UDINT(3643978336), "emPressureRoller", //Class
TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emPressureRoller.stsMaxSpeedWagonNegative.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3016554406), "stsMaxSpeedWagonNegative", 
(::emPressureRoller.stsAlreadySendedOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3198187947), "stsAlreadySendedOut", 
(::emPressureRoller.oStopWagon.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2458792232), "oStopWagon", 
(::emPressureRoller.parSafeZone.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4179111849), "parSafeZone", 
(::emPressureRoller.parStopZone.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1139922426), "parStopZone", 
(::emPressureRoller.parPosFC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1331041406), "parPosFC", 
(::emPressureRoller.parPosRol.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2902502585), "parPosRol", 
(::emPressureRoller.parSendBackAfterFirstOperation.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2623187934), "parSendBackAfterFirstOperation", 
(::emPressureRoller.parRolActive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3357487266), "parRolActive", 
(::emPressureRoller.parSlowSpeedAfterSendedBack.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(308086396), "parSlowSpeedAfterSendedBack", 
(::emPressureRoller.parUseSlowSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2034791712), "parUseSlowSpeed", 
//Clients:
(::emPressureRoller.ctrlCil.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3230419771), "ctrlCil", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::emPressureRoller.iFcMatDetected.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2241345131), "iFcMatDetected", 
(::emPressureRoller.iActPosWagon.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3428722028), "iActPosWagon", 
(::emPressureRoller.iStprFirstOperation.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1501093293), "iStprFirstOperation", 
(::emPressureRoller.iSlowSpeedWagon.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4249379662), "iSlowSpeedWagon", 
END_FUNCTION


#define USER_CNT_emPressureRoller 41

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emPressureRoller] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emPressureRoller::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emPressureRoller;
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #execResetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #execStarting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #execHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #execUnHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #execSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #execUnSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #runAction();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parSafeZone.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parSafeZone.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parStopZone.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parStopZone.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parPosFC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parPosFC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parPosRol.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parPosRol.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parSendBackAfterFirstOperation.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parSendBackAfterFirstOperation.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parRolActive.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parRolActive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 12-2-2020: pressureRoller created for 4484/standard lib
// This class controls a cilinder (with rol), this cil is sended to the material after a command. 
// It's sended back after first operation is done or after a command, or after input wagon is to close

// errornr 1 = Command not recognized
// errornr 2 = wagon in stopzone before Cil fully up
// errornr 3 = fc not active when expected

FUNCTION VIRTUAL emPressureRoller::preScanOverride
  
  //read in all inputs
  IF pmlCom.cmd.simulation= noneSimu THEN
    iFcMatDetected  := iFcMatDetected.Read();
  ELSE //all simu or no mat simu
    iFcMatDetected:= stprAction= 31;
  END_IF;
  iActPosWagon    := iActPosWagon.Read();
  iSlowSpeedWagon := iSlowSpeedWagon.Read();
  iStprFirstOperation := iStprFirstOperation.Read();
  
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::work

  //set max speed status, full speed if cil is out, or 
  IF ctrlCil.stsPos = cilOut | (stsAlreadySendedOut>= 1 & parSlowSpeedAfterSendedBack= 0) | parUseSlowSpeed= 0 THEN
    stsMaxSpeedWagonNegative:= 1000; //full speed allowed when cil is out
  ELSE
    stsMaxSpeedWagonNegative:= iSlowSpeedWagon;
  END_IF;
  
  IF wagonGotValue = 0 & iActPosWagon<>0 THEN // JDK 17-08-2022: direct after start plc wagon pos still is zero, dont give the alarm for that
    wagonGotValue:=1;
  END_IF;

  //check if wagon isn't to close
  IF iActPosWagon < (parPosRol+parSafeZone) | iActPosWagon= NOREFVALUE THEN // pull cil back up if wagon is near. stop wagon if cil is to late
    IF stsAlreadySendedOut= 1 THEN
      stsAlreadySendedOut:= 2; //means wagon further then rol
    END_IF;
    IF ctrlCil.stsPos <> cilIn THEN
      ctrlcil.csMoveIn();
      cilShouldBeOut:= 0;
      IF iActPosWagon < (ParStopZone + parPosRol) & iActPosWagon <> NOREFVALUE & wagonGotValue=1 THEN
        oStopWagon:=1;
        giveAlarm(errorNr:=2);        
      END_IF;
    ELSE
      oStopWagon:=0;
    END_IF;
  ELSIF stsAlreadySendedOut = 2 THEN
    stsAlreadySendedOut:= 0; //reset already sended out if wagon was further then rol and now is going back
  END_IF;
  
  //handle should be out par, for unholding
  IF cilShouldBeOut = 1 & ctrlCil.stsPos <> cilOut & pmlCom.cmd.mode= manual THEN  // Jdk 22-09-2022: addded to be reset only when in manual, because if during production we press the emergency stop, it goes up (in) and if we continue with production, it doesnt go back out
    cilShouldBeOut:= 0;
  END_IF;

  //send cil back after first operation
  IF (pmlCom.cmd.mode = auto | pmlCom.cmd.mode = halfAuto | pmlCom.cmd.mode = service) & //only if in one of the auto states
      parSendBackAfterFirstOperation & ctrlCil.stsPos <> cilIn & iStprFirstOperation<> 0 & oldStprFirstOperation= 0 THEN //and if rol isn't back, and should go back after first operation, then on pos. trigger, send it back
    ctrlCil.csMoveIn();
    cilShouldBeOut:= 0;
  END_IF;
  
 
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::execResetting

 CASE stprState OF
  
  0: //reset steppers and vars
    IF pmlCom.cmd.reRun= 0 THEN
      stprAction:=0;
      oStopWagon:=0;
      MatDetPosWagon:=0;
      StartposWagon:=0;    
      stsAlreadySendedOut:= 0;
      cilShouldBeOut:= 0; // Jdk 22-09-2022: reset this variable as well
      stprState+=1;
    ELSE
      stprState+=2; 
    END_IF;
    
  1: //open clamp
    IF ctrlCil.stsPos= cilIn THEN
      stprState+=1;
    ELSE
      ctrlCil.csMoveIn();
    END_IF;
     
  2: //done
    stprState:=1000;
    
  1000: //ready   
  
 END_CASE;
 
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::execStarting

  IF pmlCom.cmd.reRun= 0 THEN
    execResetting();
  ELSE
    execUnHolding();
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::execExecute
 
  runAction();

  IF stprAction=0  THEN // also give statecomplete if roll is waiting to close at proper time, necessary to get trough
     stprState:=1000; //only state completed if action is done 
  ELSE
     stprState:=1;
  END_IF;
    
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::execHolding

  CASE stprState OF
  
  0: //check if waiting for wagon to go in position, then go on, else just wait until done
    IF stprAction=0 THEN
      tmpRunActionDuringHolding:= 0;
      stprState:=1000;
    ELSIF stprAction < 30 THEN 
      runAction();
    ELSE //means waiting for wagon to go to position, maybe wagon is in alarm, then it will never reach position, so already go to ready, but keep running action
      tmpRunActionDuringHolding:= 1;
      stprState:= 1000;
    END_IF;

    
  1000: //ready
    IF tmpRunActionDuringHolding = 1 THEN
      IF stprAction <> 0 THEN
        runAction();
      ELSE
        tmpRunActionDuringHolding:= 0;
      END_IF;
    END_IF;
  
  END_CASE;
  
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::execUnHolding

  //during unholding, always send back to old position
  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //check if cil should be in or out
    IF cilShouldBeOut=1 THEN
      stprState+=1;
    ELSE
      stprState+=2;
    END_IF;
    
  2: //send cil out
    IF ctrlCil.stsPos= cilOut THEN
      stprState:= 1000;
    ELSE
      ctrlCil.csMoveOut();
    END_IF;

  3: //send cil IN
    IF ctrlCil.stsPos= cilIn THEN
      stprState:= 1000;
    ELSE
      ctrlCil.csMoveIn();
    END_IF;
    
  1000: //done
  
  END_CASE;
 
  
  
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::execSuspending

  execHolding();
  
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::execUnSuspending

  execUnHolding();
  
END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::runAction

 CASE stprAction OF
 
 1: //take action from command and go to step to manage it
    
    stsAlreadySendedOut:= 0; //after each new command, reset this signal
    CASE actionLine.actione OF

    CILDICHT: 
      stprAction:=10;
      
    CILOPEN:
      stprAction:=20;
      
    3:
      stprAction:=30;
      
    ELSE
      giveAlarm(errorNr:=1);

    END_CASE;
   
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

  10: //send cil down
    IF ctrlCil.stsPos=cilOut THEN
      stprAction +=1;
    ELSE
      ctrlCil.csMoveOut();
    END_IF;
 
    
  11: //done
      stprAction:=0;
      
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

  20: // send cil up
    IF ctrlCil.stsPos=cilIn THEN
      stprAction +=1;
    ELSE
      ctrlCil.csMoveIn();
    END_IF;
 
    
  21: //done
      stprAction:=0;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
 
  30: //Wait for active FC before sending cil down
    IF parRolActive THEN
      StartposWagon:=iActPosWagon;
      stprAction+=1;
    ELSE
      stprAction:= 0;
    END_IF;
    
  31: //wait until material is detected, if wagon is to close, just go on  
//    IF (ActPosWagon < StartposWagon - parPosFC) then //JdK 6-12-2019, don't give alarm if fc doesn't detect material, because sometimes it's just to small to use pressure rol
//      giveAlarm(errorNr:=3);
//    end_if;
  
    IF iActPosWagon <= (parPosRol + parSafeZone) THEN
      stprAction+=3;
    ELSIF iFcMatDetected THEN 
      MatDetPosWagon:= iActPosWagon;
      stprAction+=1;
    END_IF;

  32: //wait until movement is far enough
    IF (MatDetPosWagon - iActPosWagon) > (parPosFC - parPosRol )   THEN //JdK 21-6-2022 distract pos rol from pos fc
      stprAction+= 1;
    END_IF;

  33: //send out cilinder
    IF ctrlCil.stsPos=cilOut THEN
      stsAlreadySendedOut:= 1;
      cilShouldBeOut:= 1;
      stprAction +=1;
    ELSE
      ctrlCil.csMoveOut();
    END_IF;  
    
  34:  //Done, Work method will manage sending Cil back at right time
    stprAction:=0;
    MatDetPosWagon:=0;
    StartposWagon:=0;

 END_CASE;



END_FUNCTION


FUNCTION VIRTUAL emPressureRoller::postScanOverride

  oldStprFirstOperation:= iStprFirstOperation;

END_FUNCTION
