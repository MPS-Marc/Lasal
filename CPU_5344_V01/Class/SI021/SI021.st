//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define SI021_SDIAS_DEVICEID         1041

#define SI021_ADDR_PLL_OFFSET        16#140
#define SI021_ADDR_PLL_CONTROL       SI021_ADDR_PLL_OFFSET + 16#08

#define SI021_ADDR_WRITE_DATA        0
#define SI021_WRITE_SIZE             sizeof(t_WriteData)

#define SI021_SDO_RESPONSE_TIMEOUT   1000


//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SI021"
	Revision           = "1.18"
	GUID               = "{CDCCE889-1FF6-420F-8904-FE233C3C9C74}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(640,120)"
	Comment            = "Class for SI021 hardwaremodule">
	<Channels>
		<Server Name="Ch1_Data" GUID="{66F2DDE0-3AC3-46F8-8CED-577DC4FD02AC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual value from SSI. (scaled to 32Bit)"/>
		<Server Name="Ch1_Error" GUID="{C0BD4613-6806-4F6E-B203-C8CDE7498AC9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Data is valid&#13;&#10;1 = Error with SSI communication"/>
		<Server Name="Ch2_Data" GUID="{26D7EF36-6570-480E-BA13-8BAF7BEB73F2}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="actual value from SSI. (scaled to 32Bit)"/>
		<Server Name="Ch2_Error" GUID="{519735DF-C6B7-4B21-80FC-85EC5D160922}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="0 = Data is valid&#13;&#10;1 = Error with SSI communication"/>
		<Client Name="Ch1_Frequency" Required="false" Internal="false" DefValue="3" Comment="This client must be set with an Initial value!&#13;&#10;Frequenzy of SSI&#13;&#10;0 = 125 kHz&#13;&#10;1 = 250 kHz&#13;&#10;2 = 500 kHz&#13;&#10;3 = 1   MHz"/>
		<Client Name="Ch1_RawValue" Required="false" Internal="false" DefValue="0" Comment="This client must be set with an Initial value!&#13;&#10;0 = calculated position set on Ch_Data&#13;&#10;1 = rawvalue set on Ch_Data"/>
		<Client Name="Ch1_SSIBitSize" Required="true" Internal="false" DefValue="25" Comment="This client must be set with an Initial value!&#13;&#10;Length of SSI shift register (1..32 Bit)"/>
		<Client Name="Ch1_SSIDoubleRead" Required="false" Internal="false" DefValue="0" Comment="This client must be set with an Initial value!&#13;&#10;0 = disable double read&#13;&#10;1 = enable double read&#13;&#10;"/>
		<Client Name="Ch1_UseGraycode" Required="false" Internal="false" DefValue="1" Comment="This client must be set with an Initial value!&#13;&#10;0 = binary data&#13;&#10;1 = gray code"/>
		<Client Name="Ch2_Frequency" Required="false" Internal="false" DefValue="3" Comment="This client must be set with an Initial value!&#13;&#10;Frequenzy of SSI&#13;&#10;0 = 125 kHz&#13;&#10;1 = 250 kHz&#13;&#10;2 = 500 kHz&#13;&#10;3 = 1   MHz"/>
		<Client Name="Ch2_RawValue" Required="false" Internal="false" DefValue="0" Comment="This client must be set with an Initial value!&#13;&#10;0 = calculated position set on Ch_Data&#13;&#10;1 = rawvalue set on Ch_Data"/>
		<Client Name="Ch2_SSIBitSize" Required="true" Internal="false" DefValue="25" Comment="This client must be set with an Initial value!&#13;&#10;Length of SSI shift register (1..32 Bit)"/>
		<Client Name="Ch2_SSIDoubleRead" Required="false" Internal="false" DefValue="0" Comment="This client must be set with an Initial value!&#13;&#10;0 = disable double read&#13;&#10;1 = enable double read&#13;&#10;"/>
		<Client Name="Ch2_UseGraycode" Required="false" Internal="false" DefValue="1" Comment="This client must be set with an Initial value!&#13;&#10;0 = binary data&#13;&#10;1 = gray code"/>
		<Client Name="SampleMultiplier" Required="false" Internal="false" DefValue="1" Comment="This client must be set with an Initial value!&#13;&#10;Multiplier for sampling the SSI data in relation to the bus time (default = 1).&#13;&#10;If a SSI encoder needs more time to get a new value than the bus time,&#13;&#10;this client has to be set."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="EisMic"/>
		<Dokumentation Revision="1.18" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms.&#13;&#10;Changed DisplayGroup in SI021.lhd file from Analog to Special."/>
		<Dokumentation Revision="1.17" Date="15.01.2019" Author="RamAnd" Company="Sigmatek" Description="Corrected the Chx_Error-Server behavior. The Server has not been resetted when the error was gone in raw-value mode."/>
		<Dokumentation Revision="1.16" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.15" Date="23.10.2018" Author="PieSte" Company="Sigmatek" Description="Changed behavior of &quot;Chx_Data&quot; to show as first value the absolute position of ssi-encoder instead of 0.&#13;&#10;Overwrite the UpdateRtPreOp() methode to wait for data ready. &#13;&#10;Add numbers for the assignment of the log messages."/>
		<Dokumentation Revision="1.14" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.13" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.12" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.11" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.10" Date="14.06.2016" Author="EisMic" Company="Sigmatek" Description="Corrected hardware description file (deleted wrong property which is only used for safety modules)"/>
		<Dokumentation Revision="1.9" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.8" Date="15.07.2015" Author="PieSte" Company="Sigmatek" Description="Add client for rawvalue of ssi-encoder."/>
		<Dokumentation Revision="1.7" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.6" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.5" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.4" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.3" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.2" Date="03.09.2014" Author="RamAnd" Company="Sigmatek" Description="Added SampleMultiplier to use SSI Encoders with monoflop time slower than the bustime."/>
		<Dokumentation Revision="1.1" Date="09.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.0" Date="22.05.2014" Author="EisMic" Company="Sigmatek" Description="First Library Version"/>
	</RevDoku>
	<Network Name="SI021">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{721EB8B3-CC92-42D1-9CE5-F3892068E408}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

SI021 : CLASS
: SdiasBase
	TYPE
	  t_ConfigRegister : BSINT
	  [
	    1 Size1,
	    2 Size2,
	    3 Size3,
	    4 Size4,
	    5 Size5,
	    6 Size6,
	    7 EnblDoubleRead,
	    8 HWConfig,  //! <Type Comment="Bit is set by HW. (read only)&#13;&#10;0 = Incremental encoder mode&#13;&#10;1 = SSI encode mode" Name="t_ConfigRegister.HWConfig"/>
	  ];
	  t_ControlandStateRegister : BSINT
	  [
	    1 Frequency1,  //! <Type Comment="Select Frequency (Bit1-2):&#13;&#10;2#00 = 0 = 125kHz&#13;&#10;2#01 = 1 = 250kHz&#13;&#10;2#10 = 2 = 500kHz&#13;&#10;2#11 = 3 = 1MHz" Name="t_ControlandStateRegister.Frequency1"/>
	    2 Frequency2,  //! <Type Comment="Select Frequency (Bit1-2):&#13;&#10;2#00 = 0 = 125kHz&#13;&#10;2#01 = 1 = 250kHz&#13;&#10;2#10 = 2 = 500kHz&#13;&#10;2#11 = 3 = 1MHz" Name="t_ControlandStateRegister.Frequency2"/>
	    3 EnblGrayDecoding,
	    4 SSIBusy,
	    5 ZInputActVal,  //! <Type Comment="actual input value of Z-impulse" Name="t_ControlandStateRegister.ZInputActVal"/>
	    6 ZPositionValid,  //! <Type Comment="1 = Position at Z-impulse was latched&#13;&#10;(write 1 to reset)" Name="t_ControlandStateRegister.ZPositionValid"/>
	    7 StartWithSync,  //! <Type Comment="0 = start encoding with next pulse&#13;&#10;1 = start encoding at sync&#13;&#10;" Name="t_ControlandStateRegister.StartWithSync"/>
	    8 ContinuousRead,  //! <Type Comment="0 = read if SingleStartRegister is set&#13;&#10;1 = read continuous" Name="t_ControlandStateRegister.ContinuousRead"/>
	  ];
	  t_e_InitSSW :
	  (
	    Init_DisablePll,
	    Init_ReadPll,
	    Init_SetPll,
	    Init_WriteConfig,
	    Init_Finish,
	    Init_Error
	  )$UDINT;
	  t_e_ResponseState :
	  (
	    SDO_Idle,
	    SDO_Wait,
	    SDO_Valid
	  )$UDINT;
	  t_ExternalPowerState : BSINT
	  [
	    1 DCInputOK,
	    2 res1,
	    3 res2,
	    4 res3,
	    5 res4,
	    6 res5,
	    7 res6,
	    8 res7,
	  ];
	  t_InputState : BSINT
	  [
	    1 Ch1StartPending,
	    2 Ch1Busy,
	    3 Ch1Toggle,
	    4 Ch1SSIError,  //! <Type Comment="if this bit is set the input data is not valid" Name="t_InputState.Ch1SSIError"/>
	    5 Ch2StartPending,
	    6 Ch2Busy,
	    7 Ch2Toggle,
	    8 Ch2SSIError,  //! <Type Comment="if this bit is set the input data is not valid" Name="t_InputState.Ch2SSIError"/>
	  ];
#pragma pack(push, 1)
	  t_SyncConfig : STRUCT
	    Offset : UINT;
	    PeriodMultiplier : USINT;
	    SyncStartDelay : USINT;
	    SyncOutID : USINT;
	    ControlStatusRegister : BSINT
	    [
	      1 SyncOutEnable,
	      2 StartDelayEnable,
	      3 SyncSelector,
	    ];
	    Reserved : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PllRegister : STRUCT
	    SystemPeriodTime : UDINT;
	    SystemPeriodMeasured : UDINT;
	    StatusControl : BSINT
	    [
	      1 Locked,
	      2 Unlocked,
	      3 SyncEnable,
	    ];
	    PeriodDivider : BSINT
	    [
	    ];
	    CompensationDelay : USINT;
	    Reserved : USINT;
	    SyncOut0 : t_SyncConfig;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ReadData : STRUCT
	    ExternalPowerState : t_ExternalPowerState;
	    InputState : t_InputState;
	    InputDataCh1 : DINT;
	    InputDataCh2 : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_SingleStartRegister : BSINT
	  [
	    1 StartChannel1,
	    2 StartChannel2,
	    3 res1,
	    4 res2,
	    5 res3,
	    6 res4,
	    7 res5,
	    8 res6,
	  ];
#pragma pack(push, 1)
	  t_WriteData : STRUCT
	    ConfigCh1 : t_ConfigRegister;
	    ControlCh1 : t_ControlandStateRegister;
	    ConfigCh2 : t_ConfigRegister;
	    ControlCh2 : t_ControlandStateRegister;
	    SingleStartRegister : t_SingleStartRegister;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Ch1_Data 	: SvrCh_DINT;
	Ch1_Error 	: SvrCh_DINT;
	Ch2_Data 	: SvrCh_DINT;
	Ch2_Error 	: SvrCh_DINT;
  //Clients:
	Ch1_SSIBitSize 	: CltCh_DINT;
	Ch1_SSIDoubleRead 	: CltCh_DINT;
	Ch1_Frequency 	: CltCh_DINT;
	Ch1_UseGraycode 	: CltCh_DINT;
	Ch1_RawValue 	: CltCh_DINT;
	Ch2_SSIBitSize 	: CltCh_DINT;
	Ch2_SSIDoubleRead 	: CltCh_DINT;
	Ch2_Frequency 	: CltCh_DINT;
	Ch2_UseGraycode 	: CltCh_DINT;
	Ch2_RawValue 	: CltCh_DINT;
	SampleMultiplier 	: CltCh_UDINT;
  //Variables:
		eInitSSW 	: t_e_InitSSW;
		eResponseState 	: t_e_ResponseState;
		pReadData 	: ^t_ReadData;
		udSDOTimeout 	: UDINT;
		InitSSWErrorStep 	: t_e_InitSSW;
		LastPositionCh1 	: DINT;
		LastPositionCh2 	: DINT;
		bCh1DataReady 	: BOOL;
		bCh2DataReady 	: BOOL;
		bsSSIRawValue : BSINT
		[
		  1 Channel1,
		  2 Channel2,
		];

		BitMaskCh1 	: DINT;
		BitMaskCh2 	: DINT;
		ShiftLengthCh1 	: DINT;
		ShiftLengthCh2 	: DINT;
		sPllRegister 	: t_PllRegister;
		us_InitCount 	: DINT;
		bsOldInputState 	: t_InputState;
		bFirstReadData 	: BOOL;
  //Functions:
				//! <Function Comment="Init-Methode of Class.&#13;&#10;&#13;&#10;This Methode needs to get called. In case the Methode gets overwritten, a call needs to bet installed." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
	
	FUNCTION VIRTUAL GLOBAL UpdateRtPreOp
		VAR_INPUT
			callinfo 	: t_SDIAS_UpdateRTPreOp;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SI021::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SI021
1$UINT, 18$UINT, (SIZEOF(::SI021))$UINT, 
4$UINT, 11$UINT, 0$UINT, 
TO_UDINT(3343443050), "SI021", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::SI021.Ch1_Data.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2056481952), "Ch1_Data", 
(::SI021.Ch1_Error.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1678339884), "Ch1_Error", 
(::SI021.Ch2_Data.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4228324878), "Ch2_Data", 
(::SI021.Ch2_Error.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1440839089), "Ch2_Error", 
//Clients:
(::SI021.Ch1_SSIBitSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2521326497), "Ch1_SSIBitSize", 
(::SI021.Ch1_SSIDoubleRead.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4078619420), "Ch1_SSIDoubleRead", 
(::SI021.Ch1_Frequency.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(471040418), "Ch1_Frequency", 
(::SI021.Ch1_UseGraycode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(598427071), "Ch1_UseGraycode", 
(::SI021.Ch1_RawValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2995577796), "Ch1_RawValue", 
(::SI021.Ch2_SSIBitSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3788943697), "Ch2_SSIBitSize", 
(::SI021.Ch2_SSIDoubleRead.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3798442341), "Ch2_SSIDoubleRead", 
(::SI021.Ch2_Frequency.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2247223203), "Ch2_Frequency", 
(::SI021.Ch2_UseGraycode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2657167729), "Ch2_UseGraycode", 
(::SI021.Ch2_RawValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1505450183), "Ch2_RawValue", 
(::SI021.SampleMultiplier.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1595585603), "SampleMultiplier", 
END_FUNCTION


#define USER_CNT_SI021 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SI021] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SI021::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SI021;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPreOp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL SI021::UpdateRt
  VAR
    ActReadData : t_ReadData;
    TmpData     : DINT;
    TmpDiff     : DINT;
  END_VAR
   
  //copy from DPRam to local
  ActReadData := pReadData^;
  
  //get value of channel 1
  if ActReadData.InputState.Ch1SSIError = 0 then
    if bsSSIRawValue.Channel1 = FALSE then  
    
      // make 32bit signed value
      TmpData := ActReadData.InputDataCh1 SHL ShiftLengthCh1;
      
      //get difference
      TmpDiff := (TmpData - LastPositionCh1) SHR ShiftLengthCh1;
      LastPositionCh1 := TmpData;
      
      // get new position
      Ch1_Data += TmpDiff;     
    else
      //set value from ssi encoder directly to channel data
      Ch1_Data := ActReadData.InputDataCh1;
    end_if;    

    //reset error
    Ch1_Error := 0;
  else
    // set error
    Ch1_Error := 1;
  end_if;

  //get value of channel 2
  if ActReadData.InputState.Ch2SSIError = 0 then
    
    if bsSSIRawValue.Channel2 = FALSE then
      // make 32bit signd value
      TmpData := ActReadData.InputDataCh2 SHL ShiftLengthCh2;
      
      //get difference
      TmpDiff := (TmpData - LastPositionCh2) SHR ShiftLengthCh2;
      LastPositionCh2 := TmpData;
      
      // get new position
      Ch2_Data += TmpDiff;      
    else
      //set value from ssi encoder directly to channel data
      Ch2_Data := ActReadData.InputDataCh2;
    end_if;    

    //reset error
    Ch2_Error := 0;
  else
    // set error
    Ch2_Error := 1;
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SI021::ConnectEvent

  //Read Access
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_ReadData;

    //Start Read-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := true;
  else
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  //reset data valid variables
  bFirstReadData := FALSE;
  bCh1DataReady  := FALSE;
  bCh2DataReady  := FALSE;
  
  //Reset Statemachines
  eInitSSW       := Init_DisablePll;
  eResponseState := SDO_Idle;
  eInitState     := _NotInitialized;  
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SI021::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
    tmpRetcode    : iprStates;
    ConfigData    : t_WriteData;
    udBusTime_us  : UDINT;
    Bit_Per_ms    : DINT;
    tmpBitSize    : DINT;
    tmpFrequency  : DINT;
    tmpDoubleRead : DINT;
    tmpSSITime    : UDINT;
  END_VAR

  eModuleInitState := BUSY;
  
  case eInitSSW of
  
    //**********************************************************************************************************************************************************
    Init_DisablePll:    
      case eResponseState of
        //*****************************************************
        SDO_Idle:
          sPllRegister.StatusControl := 0;
          TmpRetcode  := StartWriteSDO(hOffset:= SI021_ADDR_PLL_CONTROL, usLength:= sizeof(sPllRegister.StatusControl), pWriteBuffer:=#sPllRegister.StatusControl$USINT, eCommand:= SDIAS_SDO_CMD_CTRL_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= SDO_Wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@013F (SI021::InitModule) Failed to add write SDO for channel configuration, step DisablePll");
            eInitState := _ClientNotready;
          end_if; 
       //*****************************************************
        SDO_Wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > SI021_SDO_RESPONSE_TIMEOUT) then
            LogError("@0140 (SI021::InitModule) SDO Response timeout, step DisablePll");
            InitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
          end_if;
        //*****************************************************
        SDO_Valid:
          eInitSSW        := Init_ReadPll;
          eResponseState  := SDO_Idle;
        //*****************************************************
      end_case;
      
    //**********************************************************************************************************************************************************
    Init_ReadPll:    
      case eResponseState of
        //*****************************************************
        SDO_Idle:
          TmpRetcode  := StartReadSDO(hOffset:=SI021_ADDR_PLL_OFFSET, usLength:= sizeof(sPllRegister), eCommand:= SDIAS_SDO_CMD_CTRL_READ);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= SDO_Wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0141 (SI021::InitModule) Failed to add read SDO to read pll.");
            eInitState := _ClientNotready;
          end_if;
        //*****************************************************
        SDO_Wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > SI021_SDO_RESPONSE_TIMEOUT) then
            LogError("@0142 (SI021::InitModule) SDO Response timeout read pll.");
           InitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
          end_if;
        //*****************************************************
        SDO_Valid:
         eInitSSW        := Init_SetPll;
         eResponseState  := SDO_Idle;
         //*****************************************************
      end_case;
      
    //**********************************************************************************************************************************************************
    Init_SetPll:    
      case eResponseState of
        //*****************************************************
        
        SDO_Idle:        
          //*******************************************************************************************
          // read configuration of clients for channel 1
          Ch1_SSIBitSize := Ch1_SSIBitSize.Read();
          if (Ch1_SSIBitSize < 1) | (Ch1_SSIBitSize > 32) then
            Ch1_SSIBitSize := 32;
          end_if;
          
          BitMaskCh1 := (16#FFFFFFFF)$DINT SHL Ch1_SSIBitSize;
          ShiftLengthCh1 := 32 - Ch1_SSIBitSize;
          Ch1_SSIDoubleRead := Ch1_SSIDoubleRead.Read() <> 0;
          
          Ch1_Frequency := Ch1_Frequency.Read();
          if (Ch1_Frequency < 0) | (Ch1_Frequency > 3) then
            Ch1_Frequency := 0;
          end_if;
          Ch1_UseGraycode := Ch1_UseGraycode.Read() <> 0;
          
          Ch1_RawValue := Ch1_RawValue.Read(); 
          if Ch1_RawValue > 0 then
            Ch1_RawValue := 1;
            bsSSIRawValue.Channel1 := TRUE;
          else
            Ch1_RawValue := 0;
            bsSSIRawValue.Channel1 := FALSE;
          end_if;       
       
          //*******************************************************************************************
          // read configuration of clients for channel 2
          Ch2_SSIBitSize := Ch2_SSIBitSize.Read();
          if (Ch2_SSIBitSize < 1) | (Ch2_SSIBitSize > 32) then
            Ch2_SSIBitSize := 32;
          end_if;
          
          BitMaskCh2 := (16#FFFFFFFF)$DINT SHL Ch2_SSIBitSize;
          ShiftLengthCh2 := 32 - Ch2_SSIBitSize;          
          Ch2_SSIDoubleRead := Ch2_SSIDoubleRead.Read() <> 0;
          
          Ch2_Frequency := Ch2_Frequency.Read();          
          if (Ch2_Frequency < 0) | (Ch2_Frequency > 3) then
            Ch2_Frequency := 0;
          end_if;
          
          Ch2_UseGraycode := Ch2_UseGraycode.Read() <> 0;

          Ch2_RawValue := Ch2_RawValue.Read(); 
          if Ch2_RawValue > 0 then
            Ch2_RawValue := 1;
            bsSSIRawValue.Channel2 := TRUE;
          else
            Ch2_RawValue := 0;
            bsSSIRawValue.Channel2 := FALSE;
          end_if;             
        
          //*******************************************************************************************
          // calculate settings for pll          
          udBusTime_us := udBusTime / 1000;
          // get maximum transfer length
          tmpBitSize := Ch1_SSIBitSize;
          if Ch2_SSIBitSize > tmpBitSize then
            tmpBitSize := Ch2_SSIBitSize; 
          end_if;
          tmpFrequency := Ch1_Frequency;
          if Ch2_Frequency < tmpFrequency then
            tmpFrequency := Ch2_Frequency;
          end_if;
          tmpDoubleRead := Ch1_SSIDoubleRead;
          if Ch2_SSIDoubleRead > tmpDoubleRead then
            tmpDoubleRead := Ch2_SSIDoubleRead;
          end_if;

          Bit_Per_ms := 125 SHL tmpFrequency;
          tmpSSITime := (tmpBitSize * (tmpDoubleRead+1) * 1000 / Bit_Per_ms)$UDINT; // *1000 to get µs

          sPllRegister.SystemPeriodTime  := udBusTime / 10;            // convert to 10*ns
          sPllRegister.StatusControl     := 0;
          sPllRegister.StatusControl.SyncEnable  := 1;
          sPllRegister.PeriodDivider     := 1;
          //sPllRegister.CompensationDelay // Keep value
          sPllRegister.SyncOut0.Offset           := to_uint(udBusTime_us - 100 - tmpSSITime); // -100 to have reserve befor next sync
          sPllRegister.SyncOut0.PeriodMultiplier := SampleMultiplier$USINT;
          sPllRegister.SyncOut0.SyncStartDelay   := 0;
          sPllRegister.SyncOut0.ControlStatusRegister.SyncOutEnable      := 1;
          sPllRegister.SyncOut0.ControlStatusRegister.StartDelayEnable   := 0;
          sPllRegister.SyncOut0.ControlStatusRegister.SyncSelector       := 1;
          
          TmpRetcode  := StartWriteSDO(hOffset:= SI021_ADDR_PLL_OFFSET, usLength:=sizeof(sPllRegister), pWriteBuffer:=#sPllRegister$USINT, eCommand:= SDIAS_SDO_CMD_CTRL_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= SDO_Wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0143 (SSI021::InitModule) Failed to add write SDO in step SetPll.");
            eInitState := _ClientNotready;
          end_if; 
          
       //*****************************************************
        SDO_Wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > SI021_SDO_RESPONSE_TIMEOUT) then
            LogError("@0144 (SI021::InitModule) SDO Response timeout SetPll.");
            InitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
          end_if;
        //*****************************************************
        SDO_Valid:
          eInitSSW        := Init_WriteConfig;
          eResponseState  := SDO_Idle;
        //*****************************************************
      end_case;
      
  
    //Write Configuration to Module
    //*****************************************************************************
    Init_WriteConfig:
    
      case eResponseState of
      
        //**************************************************
        //start write configuration
        //**************************************************
        SDO_Idle: 
        
          //init config
          ConfigData.ConfigCh1                    := Ch1_SSIBitSize$USINT;
          ConfigData.ConfigCh1.EnblDoubleRead     := Ch1_SSIDoubleRead$BOOL;
          ConfigData.ControlCh1                   := Ch1_Frequency$USINT;
          ConfigData.ControlCh1.EnblGrayDecoding  := Ch1_UseGraycode$BOOL;
          ConfigData.ControlCh1.ZPositionValid    := TRUE;
          ConfigData.ControlCh1.StartWithSync     := TRUE;
          ConfigData.ControlCh1.ContinuousRead    := TRUE;

          ConfigData.ConfigCh2                    := Ch2_SSIBitSize$USINT;
          ConfigData.ConfigCh2.EnblDoubleRead     := Ch2_SSIDoubleRead$BOOL;
          ConfigData.ControlCh2                   := Ch2_Frequency$USINT;
          ConfigData.ControlCh2.EnblGrayDecoding  := Ch2_UseGraycode$BOOL;
          ConfigData.ControlCh2.ZPositionValid    := TRUE;
          ConfigData.ControlCh2.StartWithSync     := TRUE;
          ConfigData.ControlCh2.ContinuousRead    := TRUE;

          ConfigData.SingleStartRegister          := 0;
          
          
          //Start SDO-Command
          tmpRetcode := StartWriteSDO(hOffset       := SI021_ADDR_WRITE_DATA, 
                                      usLength      := SI021_WRITE_SIZE, 
                                      pWriteBuffer  := (#ConfigData)$^USINT, 
                                      eCommand      := SDIAS_SDO_CMD_MEM_WRITE);
          
          //Evaluate Returncode
          if tmpRetcode = READY then
            
            //Timestamp for TimeoutCheck
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := SDO_Wait; 
          
          //Error occured  
          elsif tmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@0145 (SI021::InitModule) Failed to add write SDO for hardware configuration.");
            eInitState := _ClientNotready;
          end_if;
        
        //**************************************************
        //Wait for Response
        //**************************************************
        SDO_Wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > SI021_SDO_RESPONSE_TIMEOUT) then
            LogError("@0146 (SI021::InitModule) SDO Response timeout for write hardware configuration.");
            InitSSWErrorStep  := eInitSSW;
            eInitSSW          := Init_Error;
          end_if;
        
        
        //**************************************************
        //Response received
        //**************************************************
        SDO_Valid:
        
          eInitSSW := Init_Finish;
          
      end_case;
   
    //Initialization of Module finished
    //*****************************************************************************
    Init_Finish:
    
      eInitSSW          := Init_WriteConfig;
      eInitState        := _ClassOk;
      eModuleInitState  := READY;
     
   //Error during Initialization
    //*****************************************************************************
    Init_Error:
      
      eInitState        := _ClientNotready;
      eModuleInitState  := ERROR; 
    
  end_case;

END_FUNCTION


FUNCTION VIRTUAL SI021::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

  
  //Call Response of Base-Class
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand        := eCommand, 
                                            hOffset         := hOffset, 
                                            usLength        := usLength, 
                                            eResult         := eResult, 
                                            pResponseBuffer := pResponseBuffer, 
                                            ResponseLength  := ResponseLength);
  
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;
  
  //Evaluate Result of SDO
  //----------------------------------------------------------------------------
  if eResult = READY then
    
    //Check Type of SDO-Command
    case eCommand of
    
      //Memory Write
      SDIAS_SDO_CMD_MEM_WRITE,
      SDIAS_SDO_CMD_MEM_READ,
      SDIAS_SDO_CMD_CTRL_WRITE,
      SDIAS_SDO_CMD_CTRL_READ:

        if eResponseState = SDO_Wait then
          eResponseState := SDO_Valid;
        else
          LogError("@04A1 (SI021::ReceiveSDOResponse) Class in wrong State during Response of SDO");
          eInitSSW := Init_Error;      
        end_if; 
        
      else
        //error: command was not requested
          LogError("@04A2 (SI021::ReceiveSDOResponse) Wrong command at Response of SDO");
          eInitSSW := Init_Error;      
        
    end_case;
    
  //Problem with Response
  //----------------------------------------------------------------------------
  else
  
    //Check Type of SDO-Command to set correct Log-Message
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@00E8 (SI021::ReceiveSDOResponse) Error while writing the Firmware Configuration");
      else
        LogError("@04A3 (SI021::ReceiveSDOResponse) Wrong command at Response of SDO (request failed)");
        
    end_case;
    
    eInitSSW := Init_Error;
    
  end_if;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SI021::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR

  if udID2Check = SI021_SDIAS_DEVICEID then
    bIsOK := TRUE;
  else
    bIsOK := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL SI021::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR
  
  TaskCfg := SDIAS_TASK_MASK_RT_PRE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SI021::Init

  us_InitCount += 1;
  
  if (us_InitCount = 1) then
    Required := Required.Read();
  end_if;

  SdiasBase::Init();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SI021::DisconnectEvent

  //server are not reset at disconnect due to hwk convention
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION VIRTUAL SI021::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := SI021_SDIAS_DEVICEID;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SI021::UpdateRtPreOp
	VAR_INPUT
		callinfo 	: t_SDIAS_UpdateRTPreOp;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  VAR  	
    ActReadData : t_ReadData;
  END_VAR
  
  //initialze the return value
  ret_code := READY;
  
  case callinfo of
  	SDIAS_RTPREOP_CHECKDATAVALID:  
            
      //copy from DPRam to local
      ActReadData := pReadData^;
      
      if bFirstReadData = FALSE then
        bFirstReadData := TRUE;
        bsOldInputState := ActReadData.InputState;
      end_if;      
      
      //check for toggle or error of channel
      if ActReadData.InputState.Ch1Toggle <> bsOldInputState.Ch1Toggle | ActReadData.InputState.Ch1SSIError then
        bCh1DataReady := TRUE;
      end_if;
      
      //check for toggle or error of channel
      if ActReadData.InputState.Ch2Toggle <> bsOldInputState.Ch2Toggle | ActReadData.InputState.Ch2SSIError then
        bCh2DataReady := TRUE;
      end_if;
      
      // if one of the two channels has not yet set data ready, busy is returned.
      if bCh1DataReady = FALSE | bCh2DataReady = FALSE then
        ret_code := BUSY;
      end_if;
      
      //save act inputstate for next cycle    
      bsOldInputState := ActReadData.InputState;
        
  end_case;

END_FUNCTION