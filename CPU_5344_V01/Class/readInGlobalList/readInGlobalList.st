//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "readInGlobalList"
	Revision           = "0.0"
	GUID               = "{95B15F10-4336-4232-9DA3-9C76B4ABACED}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="BU2used" GUID="{E400BE7B-754D-4CF3-8231-DE111D0B4FFC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="BU3used" GUID="{D60B885C-D5A8-4F5A-BDC2-E53607130358}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stprReadIn" GUID="{E5AFF5CC-B333-4A96-A871-C969A24E5D98}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsActInputHeigth" GUID="{92790332-FD14-4DAA-B122-BE84DF592D51}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsActInputLength" GUID="{C3ED041A-262C-47F0-8C6C-43C4CA0AC7A4}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsActInputWidth" GUID="{5CDBF593-F96F-4DCA-8A97-FA1D5EAEEF5A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsReadInDoneUntilEnd" GUID="{4725D38B-76DC-4F91-BA05-7654B2490397}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="testUnits" GUID="{4C558FB3-7E24-4156-8A51-6E43269CDFE8}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="fileBase" Required="true" Internal="false"/>
		<Client Name="fileName" Required="true" Internal="false"/>
		<Client Name="fileSys" Required="false" Internal="false"/>
		<Client Name="folderName" Required="true" Internal="false"/>
		<Client Name="globalList" Required="true" Internal="false"/>
	</Channels>
	<Network Name="readInGlobalList">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{CCDB630D-D2E4-4FF5-BAA8-04D9BC4760B8}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

readInGlobalList : CLASS
: cmBase
  //Servers:
	stprReadIn 	: SvrCh_DINT;
	stsReadInDoneUntilEnd 	: SvrCh_DINT;
	stsActInputLength 	: SvrCh_DINT;
	stsActInputWidth 	: SvrCh_DINT;
	stsActInputHeigth 	: SvrCh_DINT;
	testUnits 	: SvrCh_Units;
	BU2used 	: SvrCh_DINT;
	BU3used 	: SvrCh_DINT;
  //Clients:
	fileSys 	: CltChCmd__FileSys;
	fileBase 	: CltChCmd_FileBase;
	folderName 	: CltChCmd_StringRAM;
	fileName 	: CltChCmd_StringRAM;
	globalList 	: CltChCmd_GlobalList;
  //Variables:
		fileLoc : ARRAY [0..50] OF CHAR;

		length 	: UDINT;
		length2 	: UDINT;
		fileHandle 	: DINT;
		timerReadIn 	: UDINT;
		timeLastReadIn 	: UDINT;
		readNr 	: DINT;
		tmpLine 	: SRegelInfo;
		charCntr 	: DINT;
		charLine : ARRAY [0..cMaxNrCharsInFileLine] OF CHAR;

		tmp : ARRAY [0..cMaxNrCharsInFileLine] OF CHAR;

		tmp2 : ARRAY [0..cMaxNrCharsInFileLine] OF CHAR;

		startLength 	: DINT;
		readLength 	: DINT;
		tmpChar 	: DINT;
		tmpNr 	: DINT;
		cntr 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION openFile
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION closeFile;
	
	FUNCTION readLine
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION giveCommand
		VAR_OUTPUT
			command 	: DINT;
		END_VAR;
	
	FUNCTION giveUnit
		VAR_OUTPUT
			oUnits 	: Units;
		END_VAR;
	
	FUNCTION convBitNrToValue
		VAR_INPUT
			bitNr 	: DINT;
		END_VAR
		VAR_OUTPUT
			value 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL startNextProfile;
	
	FUNCTION VIRTUAL GLOBAL testUnits::Write
		VAR_INPUT
			input (EAX) 	: Units;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: Units;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd FileBase
#pragma usingLtd GlobalList
#pragma usingLtd StringRAM


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB readInGlobalList::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_READINGLOBALLIST
0$UINT, 0$UINT, (SIZEOF(::readInGlobalList))$UINT, 
8$UINT, 5$UINT, 0$UINT, 
TO_UDINT(3217018748), "readInGlobalList", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::readInGlobalList.stprReadIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1254797893), "stprReadIn", 
(::readInGlobalList.stsReadInDoneUntilEnd.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2728548294), "stsReadInDoneUntilEnd", 
(::readInGlobalList.stsActInputLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1700613911), "stsActInputLength", 
(::readInGlobalList.stsActInputWidth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3345162262), "stsActInputWidth", 
(::readInGlobalList.stsActInputHeigth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1662727608), "stsActInputHeigth", 
(::readInGlobalList.testUnits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4113444978), "testUnits", 
(::readInGlobalList.BU2used.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2815203388), "BU2used", 
(::readInGlobalList.BU3used.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2595008908), "BU3used", 
//Clients:
(::readInGlobalList.fileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "fileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::readInGlobalList.fileBase.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1689253198), "fileBase", TO_UDINT(1689253198), "FileBase", 0$UINT, 5$UINT, 
(::readInGlobalList.folderName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3955695189), "folderName", TO_UDINT(2408581120), "StringRAM", 1$UINT, 10$UINT, 
(::readInGlobalList.fileName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4198004009), "fileName", TO_UDINT(2408581120), "StringRAM", 1$UINT, 10$UINT, 
(::readInGlobalList.globalList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2390595228), "globalList", TO_UDINT(2390595228), "GlobalList", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_readInGlobalList 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_readInGlobalList] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION readInGlobalList::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_readInGlobalList;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprReadIn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprReadIn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	testUnits.pMeth			:= StoreMethod( #M_RD_DIRECT(), #testUnits::Write() );
	IF testUnits.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// readInGlobalList JdK 27-5-2020: goal is to put all commands from a file into the global list
// this is done from start to stop, after stop we stop reading in, and we go on after production is done so far

//reading in is done at the background because else it may stop the complete plc

/////////////////////////////////////////////////////////////////
// errornr = 1 --> file niet gevonden
// errornr = 2 --> geen commando in lijn gevonden
// errornr = 3 --> geen enter gevonden in lijn
// errornr = 4 --> betreffende commandotext niet gevonden bij vergelijken
// errornr = 5 --> betreffende unittext niet gevonden bij vergelijken
// errornr = 6 --> geen unitbits of tekst gevonden
// errornr = 7 --> geen unit in lijn gevonden


FUNCTION VIRTUAL GLOBAL readInGlobalList::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  IF stprReadIn= 3 & pmlCom.sts.state= Resetting & pmlCom.cmd.reRun= 0 THEN
    stprReadIn:= 10; //close file
  END_IF;

  CASE stprReadIn OF
  
  0: //just wait
  
  1: //open file
    BU2used:= 0;
    BU3used:= 0;
    globalList.clearAll(); //first empty old list
    stsReadInDoneUntilEnd:= 0;
    IF openFile()= 1 THEN
      stprReadIn+= 1;
    ELSE
      stprReadIn:= 0;
    END_IF;
  
  2: //read in until stop command
    timerReadIn:= ops.tAbsolute;
    FOR readNr:= 0 TO CMAXREGEL*10 DO
      IF readLine() = 1 THEN
        //IF tmpLine.Command= WAITOPERATIONCOM & tmpLine.Units=(Units.BU4 + Units.PU1) THEN
          //JdK 16-6-2022 doesn't work this easytmpLine.Units.PU1:= 0; //JdK 16-6-2022, if only waiting for printer and wagon, delete waiting for wagon, because not neaded for print
        //END_IF;
        globalList.writeLine(Nr:=readNr, Regel:=tmpLine);
        IF tmpLine.Command= STOPCOM & tmpLine.Units.DoWithOutput= 0 THEN //stop reading in until production is done
          stprReadIn+= 1;
          EXIT;
        END_IF;
      ELSIF stsReadInDoneUntilEnd= 1 THEN
        stprReadIn:= 4;
      ELSE
        readNr:= CMAXREGEL*10+1;
        stprReadIn:= 10; //mistake with reading in line, stop immediately
      END_IF;
    END_FOR;

  
  
  3: //wait until next start
  
  4: //done with file
  
  10: //close file
    closeFile();
    stprReadIn:= 0;
  
  END_CASE;


END_FUNCTION


FUNCTION readInGlobalList::openFile
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR


  //first empty file location
  _memset(dest:=#fileLoc[0], usByte:=0, cntr:=sizeof(fileLoc));

  //total name should be here, like c:\control\list.txt, JdK 11-4-2022, changed because g-code files are in same folder, so add both folder and filename together
  
  length:= folderName.GetLength();
  folderName.GetDataAt(pData:=#fileLoc[0], udSize:=length, udAt:=0);
  length2:= _strlen(src:=#fileLoc[0]);
  length:= fileName.GetLength();
  fileName.GetDataAt(pData:=#fileLoc[length2], udSize:=length, udAt:=0);

  
  fileHandle:= fileSys.FileOpen(filename:=#fileLoc[0], attributes:=0);                                       

  IF fileHandle>= 0 THEN //means file can be opened
    OK:= 1;
  ELSE
    ok:= 0;
    giveAlarm(errorNr:=1);
  END_IF;

END_FUNCTION


FUNCTION readInGlobalList::closeFile

  fileSys.CloseAllOpenFiles();

END_FUNCTION


FUNCTION readInGlobalList::readLine
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  ok:= 0; //always give zero back unless everything was ok
  charCntr:= 0;
  
  _memset(dest:=#charLine[0], usByte:=0, cntr:=sizeof(charLine));
  _memset(dest:=#tmpLine, usByte:=0, cntr:=sizeof(tmpLine));
  
  WHILE charCntr < CMAXNRCHARSINFILELINE DO
    IF fileSys.FileRead(handle:=fileHandle, buffer:=#charLine[charCntr], length:=1)> 0 THEN
      IF charLine[charCntr]= 10 THEN //until line feed (=value 10)
        ok:= 1;
        charCntr:= CMAXNRCHARSINFILELINE; //stop reading in
      END_IF;
      charCntr+= 1;
    ELSE
      stsReadInDoneUntilEnd:= 1;
      charCntr:= CMAXNRCHARSINFILELINE;
    END_IF;
  END_WHILE;

  //now get info from line
  IF ok= 1 THEN
    //start with nr., so MPS control can monitor progress
    _memset(dest:=#tmp[0], usByte:=0, cntr:=sizeof(tmp));
    fileBase.Read2Comma(Sourc:=#charLine[0], Dest:=#tmp[0], Offset:=0);
    tmpLine.Rnr:= fileBase.ConvAscii2Value(Source:=#tmp[0]);
  
    length:= _strlen(src:=#tmp[0])+1;
    _memset(dest:=#tmp[0], usByte:=0, cntr:=sizeof(tmp));
    fileBase.Read2Variable(Sourc:=#charLine[length], Dest:=#tmp[0], Offset:=0, Variable:=':');
    tmpLine.Command:= giveCommand(); //uses tmp to check command
    
    length += _strlen(src:=#Tmp[0])+1;
    
    CASE tmpLine.Command OF
    
    0: //not ok
      ok:= 0;

    STARTCOM: //get general information
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="amount"); 
      tmpLine.Amount := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=6); 
      IF tmpLine.Amount = 0 | tmpLine.Amount= FAULTVALUE THEN //JdK 31-12-2021: also give amount if amount is zero or not written
        tmpLine.Amount:= 1;
      END_IF;

      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="length"); 
      stsActInputLength := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=6); 
      
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="width"); 
      stsActInputWidth := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=5); 

      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="height"); 
      stsActInputHeigth := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=6); 
      
      
      IF stsActInputWidth= 260 & stsActInputHeigth= 470 THEN
        stsActInputWidth:= stsActInputWidth-74;
      END_IF;      

    WAITOPERATIONCOM: 
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _memset(dest:=#Tmp, usByte:=0, cntr:=sizeof(Tmp));
      _strcpy(dest:=#Tmp2[0], src:="units");
      length += to_udint(FileBase.ReadStringAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], Dest:=#Tmp[0], lengthSourc2:=5)) +1;//lengte van units= en dan bits voor units wordt doorgegeven, +1 voor ;
      if length >= FAULTVALUE then
        giveAlarm(errorNr:=6);
        OK := 0;
      end_if;
      tmpLine.Units :=giveUnit();//gets units from Tmp  // FileBase.ConvAscii2BDINT(sourc:=#Tmp[0]);

    STARTOUTPUT: 
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _memset(dest:=#Tmp, usByte:=0, cntr:=sizeof(Tmp));
      _strcpy(dest:=#Tmp2[0], src:="units");
      length += to_udint(FileBase.ReadStringAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], Dest:=#Tmp[0], lengthSourc2:=5)) +1;//lengte van units= en dan bits voor units wordt doorgegeven, +1 voor ;
      if length >= FAULTVALUE then
        giveAlarm(errorNr:=6);
        OK := 0;
      end_if;
      tmpLine.Units :=giveUnit();//gets units from Tmp  // FileBase.ConvAscii2BDINT(sourc:=#Tmp[0]);    
  
    LOADINGCOM, UNITMOVECOM, UNITSTARTCOM: //unit achterhalen, offset doorgeven
      _memset(dest:=#Tmp, usByte:=0, cntr:=sizeof(Tmp));
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="units"); 
      length2 := _strlen(src:=#Tmp2[0]);
      length += to_udint(FileBase.ReadStringAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], Dest:=#Tmp[0], lengthSourc2:=5)) +1;  //lengte van unit= en unittekst wordt doorgegeven, +1 voor ,    
      if length >= FAULTVALUE then
        giveAlarm(errorNr:=6);
        OK := 0;
      end_if;
      
      tmpLine.Units := GiveUnit(); //gets units from Tmp
      
      _memset(dest:=#tmpLine.tekst, usByte:=0, cntr:=sizeof(tekst));
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="text"); //let op! was gCode, omdat ook printtekst hier staat wordt het tekst
      length2 := _strlen(src:=#Tmp2[0]);        
      FileBase.ReadStringAfterString(Sourc:=#charLine[0], Sourc2:=#Tmp2[0], Dest:=#tmpLine.tekst[0], lengthSourc2:=4);
      
      tmpLine.Offset :=to_dint(length);
      
      
    STOPCOM: //?????
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _memset(dest:=#Tmp, usByte:=0, cntr:=sizeof(Tmp));
      _strcpy(dest:=#Tmp2[0], src:="units");
      length += to_udint(FileBase.ReadStringAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], Dest:=#Tmp[0], lengthSourc2:=5)) +1;//lengte van units= en dan bits voor units wordt doorgegeven, +1 voor ;
//      if length >= FAULTVALUE then
//        giveAlarm(errorNr:=6);
//        OK := 0;
//      end_if;
      tmpLine.Units :=giveUnit();//gets units from Tmp  // FileBase.ConvAscii2BDINT(sourc:=#Tmp[0]);

    
    WAITTIMECOM: //tijd achterhalen en meegeven ipv unitnr
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="time"); 
      length2 := _strlen(src:=#Tmp2[0]);
      tmpLine.Amount:= FileBase.ReadValueAfterString(Sourc:=#charLine[0], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));     
    
    
    MEASUREMATCOM: //nog verder uitdenken    
    
    END_CASE;

    if length >= FAULTVALUE then
      length:= 0;
    end_if;
  
    //just try to find this information, no problem if it isn't in a line, then we just get the fault value for it
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="x1Pos"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.x1Pos := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));  
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="y1Pos"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.y1Pos := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));   
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="z1Pos"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.z1Pos := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));          
    
    if tmpLine.Command <> STARTCOM then
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="zY1Angle"); 
      length2 := _strlen(src:=#Tmp2[0]);
      tmpLine.zy1Angle := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));  
    end_if;
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="xZ1Angle"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.xz1Angle := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));   
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="xY1Angle"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.xy1Angle := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));          
       
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="speed"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.speed := FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2)); 
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="toolID"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.toolID:= FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));     
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="action"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.actione:= FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));     
    
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="level"); 
    length2 := _strlen(src:=#Tmp2[0]);
    tmpLine.level:= FileBase.ReadValueAfterString(Sourc:=#charLine[length], Sourc2:=#Tmp2[0], lengthSourc2:=to_dint(length2));      
  
  
  
  END_IF;


END_FUNCTION


FUNCTION readInGlobalList::giveCommand
	VAR_OUTPUT
		command 	: DINT;
	END_VAR

  length2 := _strlen(src:=#Tmp[0]); //lengte van commando opgeven
  if length2 > 0 then
    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
    _strcpy(dest:=#Tmp2[0], src:="start"); 
    if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then
      Command := STARTCOM;
    else
      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
      _strcpy(dest:=#Tmp2[0], src:="stop"); 
      if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
        Command := STOPCOM;
      else  
        _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
        _strcpy(dest:=#Tmp2[0], src:="waitOperation"); 
        if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
          Command := WAITOPERATIONCOM;
        else  
          _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
          _strcpy(dest:=#Tmp2[0], src:="loading"); 
          if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
            Command := LOADINGCOM;
          else  
            _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
            _strcpy(dest:=#Tmp2[0], src:="unitMove"); 
            if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
              Command := UNITMOVECOM;
            else  
              _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
              _strcpy(dest:=#Tmp2[0], src:="unitStart"); 
              if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
                Command := UNITSTARTCOM;
              else  
                _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
                _strcpy(dest:=#Tmp2[0], src:="waitTime"); 
                if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
                  Command := WAITTIMECOM;
                else  
                  _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
                  _strcpy(dest:=#Tmp2[0], src:="measureMat"); 
                  if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
                    Command := MEASUREMATCOM;
                  else  
                    _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
                    _strcpy(dest:=#Tmp2[0], src:="waitForOutput"); 
                    if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
                      Command := WAITFOROUTPUT;
                    else  
                      _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
                      _strcpy(dest:=#Tmp2[0], src:="startOutput"); 
                      if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
                        Command := STARTOUTPUT;
                      else     
                         _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
                        _strcpy(dest:=#Tmp2[0], src:="startMultipleOperations"); 
                        if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
                          Command := STARTBLOCK;
                        else                         
                           _memset(dest:=#Tmp2, usByte:=0, cntr:=sizeof(Tmp2));
                          _strcpy(dest:=#Tmp2[0], src:="stopMultipleOperations"); 
                          if FileBase.CheckGelijk(Sourc:=#Tmp[0], Sourc2:=#Tmp2[0], length:=length2) = 1 then   
                            Command := ENDBLOCK;
                          else                         
                            Command := 0;
                            giveAlarm(errorNr:=4);
                          end_if;
                        end_if;
                      end_if;
                    end_if;
                  end_if;                 
                end_if;              
              end_if;            
            end_if;          
          end_if;
        end_if;
      end_if;
    end_if;
  end_if;


END_FUNCTION


FUNCTION readInGlobalList::giveUnit
	VAR_OUTPUT
		oUnits 	: Units;
	END_VAR

  //tmp contains a string with at least one unit (like BU1 or CL1), it can be more units seperated by a white space
  
  
  startLength:= to_dint(_strlen(src:=#tmp[0]));
  readLength:= 0;
  oUnits:= 0;
  
  WHILE  startLength > readLength DO
    _memset(dest:=#tmp2[0], usByte:=0, cntr:=sizeof(tmp2));
    readLength+= fileBase.Read2Seperator_or_Space(Sourc:=#tmp[readLength], Dest:=#tmp2[0], Offset:=0); //read from last position to space
    readLength+= 1; //next time also ignore space
    
    tmpChar:= to_dint(tmp2[0]); //now first character of unit is in tmp char
    tmpNr:= fileBase.ConvAscii2Value(Source:=#tmp2[2]); //now nr after bu chars is in tmpNr
    
    CASE tmpChar  OF //this way of converting only works as long as all units are numbered together, thats why there is a max amount number check in it 

    65: //=A
      IF tmpNr<= 2 THEN
        oUnits+=convBitNrToValue(bitNr:=(9+tmpNr))$::units;
        //exit;
      END_IF;
      
    66: //=B
      IF tmpNr<= 10 THEN
        oUnits+=convBitNrToValue(bitNr:=(-1+tmpNr))$::units;
        IF oUnits.BU2 THEN //set used units to start motors already
          BU2used:= 1;
        END_IF;
        IF oUnits.BU3 THEN
          BU3used:= 1;
        END_IF;

        //exit;
      END_IF;
    
    67: //=C
      IF tmpNr<= 5 THEN
        oUnits+=convBitNrToValue(bitNr:=(13+tmpNr))$::units;
        //exit;
      ELSIF tmpNr <= 9 THEN //also read in cl's from 6 to 9
        oUnits+=convBitNrToValue(bitNr:=(21+tmpNr))$::units;
      END_IF;
    
    68: //=D
      IF tmpNr<= 5 THEN
        oUnits+=units.DoWithOutput;
        //exit;
      END_IF;
      
    77: //=M
      IF tmpNr<= 2 THEN
        oUnits+=convBitNrToValue(bitNr:=(18+tmpNr))$::units;
        //exit;
      END_IF;
      
    80: //=P
      IF tmpNr<= 2 THEN
        oUnits+=convBitNrToValue(bitNr:=(11+tmpNr))$::units;
        //exit;
      END_IF;    
    
    
    END_CASE;

    
  
  END_WHILE;


END_FUNCTION


FUNCTION readInGlobalList::convBitNrToValue
	VAR_INPUT
		bitNr 	: DINT;
	END_VAR
	VAR_OUTPUT
		value 	: DINT;
	END_VAR

  value:= 1;
  IF bitNr < 0 THEN
    value:= 0;
  ELSIF bitNr= 0 THEN
    value:= 1;
  ELSE
    FOR cntr:=1 TO bitNr DO
      value:= value*2;
    END_FOR;
 
  END_IF;

END_FUNCTION


FUNCTION GLOBAL readInGlobalList::startNextProfile
// start with reading in until next stop, first empty global list

  globalList.clearAll(); //first empty old list
  stprReadIn:= 2;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL readInGlobalList::testUnits::Write
	VAR_INPUT
		input (EAX) 	: Units;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: Units;
	END_VAR

  
	testUnits := giveUnit();
	result := testUnits;

END_FUNCTION
