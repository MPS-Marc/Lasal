//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "unitBase"
	Revision           = "1.0"
	GUID               = "{0701713E-1A3A-4801-98AA-2FD82FD9115A}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="abortButton" GUID="{86432C05-CE88-454E-A397-A6DD3B3B253C}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="cmdCompleted" GUID="{DF533320-7A89-49CB-94A0-5042FAA495E6}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="holdButton" GUID="{6DE0318D-75D7-4D98-9FE8-0F02FFD66BFA}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reqMode" GUID="{B465F003-D500-4526-AE6B-64AF8E7F6C02}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="resetButton" GUID="{6F84C60D-16F0-49BF-B1F9-31B3F5F65DBB}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="simulation" GUID="{1B851FEB-CC4D-43BD-8A4F-DCF7C1B9DCED}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="startButton" GUID="{76A14F7F-3752-46D8-A8CC-DD15E40CAA99}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stopButton" GUID="{3C972B61-F209-401C-AB8A-88E6C8C2971D}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsProgChangesAllowed" GUID="{89CD08F8-0F24-4BFF-B5EC-ED7D70310FDB}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="suspendButton" GUID="{48EDBAB5-CD9A-44D7-B09B-4EC037B87EB8}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="testSline" GUID="{E7C799D4-FCED-4E41-A3B8-D18981077CBA}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="unHoldButton" GUID="{08A87B92-6ED5-4797-8049-928053C07E28}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="unsuspendButton" GUID="{590EFE3F-7E88-432A-A4F7-52AFE3FB9C37}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="iBlinkFast" Required="false" Internal="false"/>
		<Client Name="iBlinkSlow" Required="false" Internal="false"/>
		<Client Name="iSafe" Required="true" Internal="false"/>
		<Client Name="oCycleLight" Required="false" Internal="false"/>
		<Client Name="oResetAlarm" Required="false" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
			<SepChn Position="11"/>
		</Servers>
	</Separators>
	<Network Name="unitBase">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{4C589833-D166-472E-8BF3-71E2F3F5D701}"
				Class      = "emBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1156,210),(984,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1156,270),(984,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1156,330),(984,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1156,390),(984,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1156,450),(984,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1156,510),(984,510),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1156,690),(984,750),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1156,750),(984,810),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1156,810),(984,870),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1156,990),(984,1170),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1156,1050),(984,1230),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1156,870),(984,930),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1156,570),(984,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1156,630),(984,630),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,210),"/>
			<Connection Source="this.cmdWaitReset" Destination="_base.cmdWaitReset" Vertices="(1156,930),(984,1050),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emBase

unitBase : CLASS
: emBase
  //Servers:
	simulation 	: SvrCh_eSimuState;
	reqMode 	: SvrCh_eModePML;
	resetButton 	: SvrCh_DINT;
	startButton 	: SvrCh_DINT;
	stopButton 	: SvrCh_DINT;
	suspendButton 	: SvrCh_DINT;
	holdButton 	: SvrCh_DINT;
	unsuspendButton 	: SvrCh_DINT;
	unHoldButton 	: SvrCh_DINT;
	abortButton 	: SvrCh_DINT;
	cmdCompleted 	: SvrCh_DINT;
	testSline 	: SvrCh_Units;
	stsProgChangesAllowed 	: SvrCh_DINT;
  //Clients:
	iSafe 	: CltCh_DINT;
	oResetAlarm 	: CltCh_DINT;
	oCycleLight 	: CltCh_DINT;
	iBlinkSlow 	: CltCh_DINT;
	iBlinkFast 	: CltCh_DINT;
  //Variables:
		stateChangedByReq 	: DINT;
		tmrSuspending 	: strTimer;
  //Functions:
	
	FUNCTION VIRTUAL resetAlarm;
	
	FUNCTION VIRTUAL interlock;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL stateControl;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION GLOBAL resetRerun;
	
	FUNCTION VIRTUAL GLOBAL simulation::Write
		VAR_INPUT
			input (EAX) 	: eSimuState;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: eSimuState;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reqMode::Write
		VAR_INPUT
			input (EAX) 	: eModePML;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: eModePML;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL resetButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL startButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stopButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL suspendButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL holdButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL unsuspendButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL unHoldButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL abortButton::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL testSline::Write
		VAR_INPUT
			input (EAX) 	: Units;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: Units;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB unitBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_UNITBASE
1$UINT, 0$UINT, (SIZEOF(::unitBase))$UINT, 
13$UINT, 5$UINT, 0$UINT, 
TO_UDINT(1584517769), "unitBase", //Class
TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::unitBase.simulation.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3225770820), "simulation", 
(::unitBase.reqMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4091227975), "reqMode", 
(::unitBase.resetButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3049434987), "resetButton", 
(::unitBase.startButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1214826680), "startButton", 
(::unitBase.stopButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(910407337), "stopButton", 
(::unitBase.suspendButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(617480361), "suspendButton", 
(::unitBase.holdButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3666259748), "holdButton", 
(::unitBase.unsuspendButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3411393796), "unsuspendButton", 
(::unitBase.unHoldButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1648303816), "unHoldButton", 
(::unitBase.abortButton.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1551933327), "abortButton", 
(::unitBase.cmdCompleted.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(781583986), "cmdCompleted", 
(::unitBase.testSline.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2493399763), "testSline", 
(::unitBase.stsProgChangesAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2399253550), "stsProgChangesAllowed", 
//Clients:
(::unitBase.iSafe.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2612320002), "iSafe", 
(::unitBase.oResetAlarm.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(415226770), "oResetAlarm", 
(::unitBase.oCycleLight.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2752200653), "oCycleLight", 
(::unitBase.iBlinkSlow.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3863464356), "iBlinkSlow", 
(::unitBase.iBlinkFast.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4129747389), "iBlinkFast", 
END_FUNCTION


#define USER_CNT_unitBase 40

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_unitBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION unitBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_unitBase;
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #resetAlarm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #interlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #stateControl();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	simulation.pMeth			:= StoreMethod( #M_RD_DIRECT(), #simulation::Write() );
	IF simulation.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reqMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reqMode::Write() );
	IF reqMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	resetButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #resetButton::Write() );
	IF resetButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startButton::Write() );
	IF startButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stopButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #stopButton::Write() );
	IF stopButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	suspendButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #suspendButton::Write() );
	IF suspendButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	holdButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #holdButton::Write() );
	IF holdButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	unsuspendButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #unsuspendButton::Write() );
	IF unsuspendButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	unHoldButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #unHoldButton::Write() );
	IF unHoldButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	abortButton.pMeth			:= StoreMethod( #M_RD_DIRECT(), #abortButton::Write() );
	IF abortButton.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	cmdCompleted.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF cmdCompleted.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	testSline.pMeth			:= StoreMethod( #M_RD_DIRECT(), #testSline::Write() );
	IF testSline.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//JdK 29-5-2019: class unitBase created for MPS library and project Traffiroad 4284
// goal is to handle all basethings of a unit, unit is machine part with own safety level, and own possibility to start/stop
// unit is based on PackML principle, gets pointers from em's and cm's
// cs communication is given to em's and cm's downwards, sts communication is assembled 
// choosen base is emBase, because this one has everything we need, only difference is the state control
// controlling the unit is done by the machine manager

// errornr 1: start required while not in auto

FUNCTION VIRTUAL unitBase::stateControl

//state control just handles that the right method is done in the right place
//every wait state gives state complete = 0 (wait method is only possible to come out if there is a command)
//every acting state give state complete = 1 als stepper = 1000 (are states that are done if task is done)

//beside just doing the states job, also make state chance possible


  tmpStateComplete:=0;//on start just make this one 0, if necessary, it will be changed
  stateChangedByReq:=0;//var to remember if there was a state-change, to write all changes with id to file
  
  //check isafe, if isafe isn't ok, abort operation
  iSafe:=iSafe.Read();
  IF iSafe=0 & pmlCom.cmd.state<>Aborting & pmlCom.cmd.state<>Aborted THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Aborting;
  END_IF;
  
  IF pmlCom.sts.stateReq.state=Stopped & tmpReqState<> Stopped THEN //means state is manually changed
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=tmpReqState;
  END_IF;
  
  IF pmlCom.sts.stateReq.state=Stopping | pmlCom.sts.stateReq.state=Aborting THEN //only thing we always can do is a direct stop, or an abort
    pmlCom.cmd.state:=pmlCom.sts.stateReq.state;
    stateChangedByReq:=1;
    IF pmlCom.sts.stateReq.state=Stopping THEN
      pmlCom.cmd.reRun:= 0; //stopping makes rerun impossible
    END_IF;
  END_IF;
  
  
  //run timer for suspending/holding time-out, after 5 seconds, always just go to suspedended/held
  tmrSuspending:= runTimer(Active:=(pmlCom.sts.state=Suspending | pmlCom.sts.state=Holding), iMem:=tmrSuspending, TimerTime:=5000, Pause:=0);
 
  CASE pmlCom.cmd.state OF
  
    Stopped:
      execStopped();
      IF pmlCom.sts.stateReq.state=Resetting THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Resetting;
        stateChangedByReq:=1;
      END_IF;
    
    Resetting:
      execResetting();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Idle;
        stateChangedByReq:=1;
      END_IF;
      
    Idle:
      execIdle();
      IF pmlCom.sts.stateReq.state=Starting THEN 
        IF (pmlCom.sts.mode=auto | pmlCom.sts.mode=halfAuto) & pmlCom.sts.modesNotEqual=0 THEN //only start if complete in auto or in half auto
          tmpStateComplete:=0; //before state change reset state complete
          pmlCom.cmd.state:=Starting;
          stateChangedByReq:=1;
        ELSE
          giveAlarm(errorNr:=1);
        END_IF;
      END_IF;

    Starting:
      execStarting();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.reRun:= 1; //makes it possible to restart
        pmlCom.cmd.state:=Execute;
      END_IF;
      
    Execute:
      execExecute();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateReq.state= Holding THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Holding;
        stateChangedByReq:=1;
      ELSIF pmlCom.sts.stateReq.state= Suspending THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Suspending;
        stateChangedByReq:=1;
      ELSIF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Completing;
      END_IF;
      
    Completing:
      execCompleting();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN //just wait until completing is done
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.reRun:= 0; //makes it impossible to restart
        pmlCom.cmd.state:=Complete;
      END_IF;
      
    Complete:
      execComplete();
      IF pmlCom.sts.stateReq.state= Resetting THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Resetting;
        stateChangedByReq:=1;
      END_IF;
    
    Holding:
      execHolding();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted | tmrSuspending.done THEN //JdK 11-1-2022: after enough time also just go to held
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Held;
      END_IF;      
      
    Held:
      execHeld();
      IF pmlCom.sts.stateReq.state=UnHolding THEN
        tmpStateComplete:=0; //before state change reset state complete
        stateChangedByReq:=1;
        pmlCom.cmd.state:=UnHolding;
      END_IF;
    
    UnHolding:
      execUnHolding();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Execute;
      END_IF;           
      
    Aborting:
      execAborting();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Aborted;
      END_IF;
      
    Aborted:
      execAborted();
      IF pmlCom.sts.stateReq.state=Clearing | iSafe=1 THEN //clear can also be done by resetting isafe
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Clearing;
        stateChangedByReq:=1;
      END_IF;
    
    Clearing:
      execClearing();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Stopped;
      END_IF;
    
    Stopping:
      execStopping();
      resetRerun(); //stopping makes rerun impossible
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Stopped;
      END_IF;      
      
    Suspending:
      execSuspending();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted | tmrSuspending.done THEN //JdK 11-1-2022: after enough time also just go to held
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Suspended;
      END_IF;           
      
    Suspended:
      execSuspended();
      IF pmlCom.sts.stateReq.state=UnSuspending THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=UnSuspending;
        stateChangedByReq:=1;
      END_IF;
    
    UnSuspending:
      execUnSuspending();
      tmpStateComplete:=stprState=1000;
      IF pmlCom.sts.stateCompleted THEN
        tmpStateComplete:=0; //before state change reset state complete
        pmlCom.cmd.state:=Execute;
      END_IF;     
  
  END_CASE;
  
 
  //control state light
  IF pmlCom.cmd.state= Execute | pmlCom.cmd.state= Completing THEN
    oCycleLight:= 1;
  ELSIF pmlCom.cmd.state= Holding | pmlCom.cmd.state= Aborting THEN
    iBlinkFast:=iBlinkFast.Read();
    oCycleLight:= iBlinkFast;
  ELSIF pmlCom.cmd.state= Held | pmlCom.cmd.state= Suspended THEN
    iBlinkSlow:= iBlinkSlow.Read();
    oCycleLight:= iBlinkSlow;
  ELSE
    oCycleLight:= 0;
  END_IF;
  oCycleLight.Write(input:=oCycleLight);


  stsProgChangesAllowed:=pmlCom.cmd.reRun=0;

END_FUNCTION


FUNCTION VIRTUAL unitBase::interlock
  
  //an unit sets interlock if iSafe = 0
  //see if interlock required, standard only take over interlock from above, else derive this method
  pmlCom.sts.isInterlocked:=pmlCom.cmd.interlock | iSafe=0;
END_FUNCTION


FUNCTION VIRTUAL unitBase::Init1

  IF initDone=0 THEN
    pmlCom.cmd.simulation:=simulation;
    initDone:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::simulation::Write
	VAR_INPUT
		input (EAX) 	: eSimuState;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: eSimuState;
	END_VAR

	simulation := input;
  pmlCom.cmd.simulation:=simulation;
	result := simulation;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::startButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	startButton := input;
  IF pmlCom.cmd.state = Idle THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Starting;
  END_IF;
  startButton:= 0;
	result := startButton;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::stopButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	stopButton := input;
  pmlCom.sts.stateReq.ID:=id;
  pmlCom.sts.stateReq.state:=Stopping;
  stopButton:= 0;
	result := stopButton;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::suspendButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	suspendButton := input;
  IF pmlCom.cmd.state= Execute THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Suspending;  
  END_IF;
  suspendButton:= 0;
	result := suspendButton;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::holdButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	holdButton := input;
  IF pmlCom.cmd.state= Execute THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Holding;  
  END_IF;
  holdButton:= 0;
	result := holdButton;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::unsuspendButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	unsuspendButton := input;
  IF pmlCom.cmd.state= Suspended THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=UnSuspending; 
  END_IF;
  unsuspendButton:= 0;
	result := unsuspendButton;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::unHoldButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	unHoldButton := input;
  IF pmlCom.cmd.state= Held THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=UnHolding;  
  END_IF;
  unHoldButton:= 0;
	result := unHoldButton;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::abortButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	abortButton := input;
  pmlCom.sts.stateReq.ID:=id;
  pmlCom.sts.stateReq.state:=Aborting;  
  abortButton:= 0;
	result := abortButton;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::reqMode::Write
	VAR_INPUT
		input (EAX) 	: eModePML;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: eModePML;
	END_VAR

	reqMode := input;
  IF pmlCom.cmd.state= Held | pmlCom.cmd.state= Suspended | pmlCom.cmd.state= Stopped | pmlCom.cmd.state= Idle | pmlCom.sts.mode= manual THEN //only if it's safe to change state
    pmlCom.cmd.mode:=reqMode;
  END_IF;
	result := reqMode;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::resetButton::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	resetButton := input;
  IF pmlCom.cmd.state= Stopped | pmlCom.cmd.state= Complete THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Resetting;  
  END_IF;
  resetButton:= 0;
	result := resetButton;

END_FUNCTION


FUNCTION GLOBAL unitBase::resetRerun

  pmlCom.cmd.reRun:=0;  

END_FUNCTION


FUNCTION VIRTUAL unitBase::execExecute

  IF cmdCompleted=1 THEN //if machine manager is ready, standard the unit is also ready, but of course we can override this
    stprState:=1000;
  ELSE
    stprState:=0;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL unitBase::resetAlarm

  _Alarm.AlarmActief.Write(input:=0);
  _Alarm.ErrorNr.Write(input:=0);
  oResetAlarm.Write(input:=1);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL unitBase::testSline::Write
	VAR_INPUT
		input (EAX) 	: Units;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: Units;
	END_VAR

	testSline := input;
  
  testSline:=Start(sLine:=actionLine);
  
	result := testSline;

END_FUNCTION
