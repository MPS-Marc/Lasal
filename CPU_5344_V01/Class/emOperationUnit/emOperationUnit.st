//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emOperationUnit"
	Revision           = "1.0"
	GUID               = "{768EF40A-8C86-49DD-8F5D-C6D806836F07}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,1080)">
	<Channels>
		<Server Name="oEnableLubrication" GUID="{A080302B-D92D-412F-B570-B8C3179B70BA}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="parExtraTimeOut" GUID="{92F83C9C-C8D3-4F0F-8C84-B0E7E4AAF4A2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeBeforeMotorOff" GUID="{5F694F97-B6DB-4F13-AE8D-D632ABFC4FE6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeOutTime" GUID="{FB040B20-2644-48CE-85DD-386DE19AAFF6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Client Name="ctrlBlower" Required="false" Internal="false"/>
		<Client Name="ctrlClamp" Required="false" Internal="false"/>
		<Client Name="ctrlfeed" Required="true" Internal="false"/>
		<Client Name="ctrlMotor" Required="false" Internal="false"/>
		<Client Name="iOperationAllowed" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
		</Servers>
	</Separators>
	<Network Name="emOperationUnit">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{0BC13C1E-34C5-4899-B169-579FA52D4CF7}"
				Class      = "emBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit" Value="0"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1156,210),(984,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1156,270),(984,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1156,330),(984,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1156,390),(984,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1156,450),(984,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1156,510),(984,510),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1156,570),(984,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1156,630),(984,630),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1156,690),(984,750),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1156,750),(984,810),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1156,810),(984,870),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1156,870),(984,930),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1156,930),(984,1170),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1156,990),(984,1230),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emBase

emOperationUnit : CLASS
: emBase
  //Servers:
	parTimeBeforeMotorOff 	: SvrCh_UDINT;
	parTimeOutTime 	: SvrCh_UDINT;
	parExtraTimeOut 	: SvrCh_UDINT;
	oEnableLubrication 	: SvrCh_DINT;
  //Clients:
	ctrlMotor 	: CltChCmd_cmMotor;
	ctrlfeed 	: CltChCmd_cmCil;
	ctrlClamp 	: CltChCmd_cmMultipleCil;
	ctrlBlower 	: CltChCmd_cmBlower;
	iOperationAllowed 	: CltCh_DINT;
  //Variables:
		motorConnected 	: DINT;
		clampsConnected 	: DINT;
		blowerConnected 	: DINT;
		stsPosClamps 	: cilPos;
		stsPosfeed 	: cilPos;
		stsStateMotor 	: motorPos;
		tmpMotorNotRunningDuringAction 	: DINT;
		oldMode 	: eModePML;
		oldAutoStprAction 	: DINT;
		timerLastRun 	: strTimer;
		timeOutTimer 	: strTimer;
		timerPulse 	: strTimer;
		timerExtraOut 	: strTimer;
		oldStprAction 	: DINT;
		oldManualClamp 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL execHmiCmd4;
	
	FUNCTION VIRTUAL interlock;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL execStart;
	
	FUNCTION VIRTUAL execStop;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL execResetting;
	
	FUNCTION VIRTUAL execStarting;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION VIRTUAL execCompleting;
	
	FUNCTION VIRTUAL execHolding;
	
	FUNCTION VIRTUAL execUnHolding;
	
	FUNCTION VIRTUAL execStopping;
	
	FUNCTION VIRTUAL execSuspending;
	
	FUNCTION VIRTUAL execUnSuspending;
	
	FUNCTION Prescan1;
	
	FUNCTION Postscan1;
	
	FUNCTION runAction;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd cmBlower
#pragma usingLtd cmCil
#pragma usingLtd cmMotor
#pragma usingLtd cmMultipleCil


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emOperationUnit::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMOPERATIONUNIT
1$UINT, 0$UINT, (SIZEOF(::emOperationUnit))$UINT, 
4$UINT, 5$UINT, 0$UINT, 
TO_UDINT(2133132873), "emOperationUnit", //Class
TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emOperationUnit.parTimeBeforeMotorOff.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(605557712), "parTimeBeforeMotorOff", 
(::emOperationUnit.parTimeOutTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4183149504), "parTimeOutTime", 
(::emOperationUnit.parExtraTimeOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2895337134), "parExtraTimeOut", 
(::emOperationUnit.oEnableLubrication.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1421400189), "oEnableLubrication", 
//Clients:
(::emOperationUnit.ctrlMotor.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3868185908), "ctrlMotor", TO_UDINT(2708248773), "cmMotor", 1$UINT, 0$UINT, 
(::emOperationUnit.ctrlfeed.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4252941684), "ctrlfeed", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::emOperationUnit.ctrlClamp.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2380244622), "ctrlClamp", TO_UDINT(3389912646), "cmMultipleCil", 0$UINT, 0$UINT, 
(::emOperationUnit.ctrlBlower.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1349372656), "ctrlBlower", TO_UDINT(2593188663), "cmBlower", 0$UINT, 0$UINT, 
(::emOperationUnit.iOperationAllowed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(439506079), "iOperationAllowed", 
END_FUNCTION


#define USER_CNT_emOperationUnit 40

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emOperationUnit] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emOperationUnit::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emOperationUnit;
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #execHmiCmd4();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #interlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #execStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #execStop();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #execResetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #execStarting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #execCompleting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #execHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #execUnHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #execStopping();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #execSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #execUnSuspending();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeBeforeMotorOff.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeBeforeMotorOff.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeOutTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeOutTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parExtraTimeOut.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parExtraTimeOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 11-12-2019 wait some time after feed is out, before going back
// tp 4-12-2019 add to give speed to motor in halfauto 
//RVDL 31-7-2019 emOperationUnit, copied from emSawingInterface, created for 4284 TraffiRoad/ standard MPS library and modified for 4468 Nijburg products 
// this em controls an Simple operation unit e.g. saw, drill
// RVDL 8-8-2019 added lubrication to runaction


// errors: 1: motor stopped during movement
//         2: cycil not under during starting
//         3: operation not allowed

//         5: time out

//RVDL 8-8-2019 // HMI command available
//HMI command also apply for external button inputs
//  run any manual stuff but only if in half-auto
// hmi start = start 1 operation cycle
// hmi stop = stop operation cycle
// hmi cmd4  = toggle clamp position


FUNCTION VIRTUAL emOperationUnit::Init1

  IF initDone=0 THEN
    motorConnected:=IsClientConnected(#ctrlMotor); 
    clampsConnected:=IsClientConnected(#ctrlClamp);
    blowerConnected:=IsClientConnected(#ctrlBlower);
    
    initDone:=1;
  END_IF;

END_FUNCTION


FUNCTION emOperationUnit::Prescan1

  //get states/positions from connected stuff
  IF motorConnected THEN
    stsStateMotor:=ctrlMotor.stsStateRun;
  ELSE
    stsStateMotor:= moRunning; //if motor not connected, always say motor is running
  END_IF;
  
  stsPosfeed := ctrlfeed.stsPos;  
  
  IF clampsConnected THEN
    stsPosClamps:=ctrlClamp.stsPos;
  ELSE
    stsPosClamps:=cilNotConnected;
  END_IF;
   
  //read in if operation is allowed, and other inputs
  iOperationAllowed:=iOperationAllowed.Read();
  //check if motor isn't switched off during sawing
  tmpMotorNotRunningDuringAction:=stprAction>= 3 & stprAction<= 8 & stsStateMotor<>moRunning;
  IF tmpMotorNotRunningDuringAction= 1 THEN
    giveAlarm(errorNr:=1);
  END_IF;
  
  //run timer to switch off motor, if not used for a while, and run time out timer
  timerLastRun:= runTimer(Active:=stprAction=0 & stprState<>3, iMem:=timerLastRun, TimerTime:=parTimeBeforeMotorOff, Pause:=FALSE);
  timeOutTimer:= runTimer(Active:=stprAction>0 & stprAction=oldStprAction, iMem:=timeOutTimer, TimerTime:=parTimeOutTime, Pause:=pmlCom.cmd.state<>Holding & pmlCom.cmd.state<>Suspending & pmlCom.cmd.state<>Execute);
  timerExtraOut:= runTimer(Active:=stprAction=7, iMem:=timerExtraOut, TimerTime:=parExtraTimeOut, Pause:=pmlCom.cmd.interlock=1);
  
  oEnableLubrication:=0; //RVDL 8-8-2019 //reset lubrication
  
END_FUNCTION


FUNCTION emOperationUnit::Postscan1

  //if in manual mode, stop action if there is a problem
  IF (stsInAlarm= 1 | stsIsInterlocked= 1) & (pmlCom.sts.mode= manual | pmlCom.sts.mode= halfAuto) & stprAction<> 0 | 
  (pmlCom.sts.mode= auto & (pmlCom.sts.state = idle| pmlCom.sts.state = Stopping) & stprAction<> 0 ) THEN //tp if state is idle and in auto then also stprAction 0, else alarm stays active
    stprAction:=0;
  END_IF;
  
  //if in auto mode and there is an alarm, go to holding
  IF pmlCom.sts.inAlarm= 1 & pmlCom.sts.mode= auto THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Holding;
  END_IF;
  
  //check if we should switch of the motor
  IF motorConnected= 1 & stsStateMotor<> moOff & parTimeBeforeMotorOff> 0 & timerLastRun.done= 1 THEN
    ctrlMotor.csStop();
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::work

  Prescan1();
  
  IF stsHMI_RunsAllowed & stprAction<> 0 & (pmlCom.sts.mode=manual | pmlCom.sts.mode= halfAuto | pmlCom.sts.mode= service) THEN //if hmi run is allowed, run action (if one was started)
    runAction();
  END_IF;
  IF ((pmlCom.sts.mode = auto & (oldMode = manual | oldMode = halfAuto)) | //stop movement if mode changes, but keep old auto stepper
    ((pmlCom.sts.mode = manual | pmlCom.sts.mode = halfAuto) & oldMode = auto)) & stprAction<> 0 THEN
    IF oldMode = auto | oldMode = service THEN
      oldAutoStprAction:=stprAction;
    END_IF;
    stprAction:=0;
  END_IF;
  oldMode:=pmlCom.sts.mode;  
  
  //tp 4-12-2019 add this because to give speed to the motor when in half auto
  if pmlCom.sts.mode = halfAuto & (actionLine.speed = 0 | actionLine.speed <> ctrlMotor.parSpeed) then
    actionLine.speed:= ctrlMotor.parSpeed;
  end_if;
  
 
  Postscan1();

END_FUNCTION


FUNCTION emOperationUnit::runAction

  IF stprAction >= 5 & stprAction <= 8 THEN
    oEnableLubrication:=1;
  END_IF;

  CASE stprAction OF
  
  0: //wait for start
  
  1: //check if Sawmovement is up
    IF stsPosfeed = cilIn  THEN 
      stprAction+=1;
    ELSIF stsPosfeed <> cilin THEN
      giveAlarm(errorNr:=2);
    END_IF;
    
  2: //start motor, wait for it later
    IF stsStateMotor=moRunning THEN
      stprAction+=1;
    ELSIF motorConnected= 1 THEN
      ctrlMotor.csStartFwd(speed:=actionLine.speed);
    END_IF;
    
  3: //check if movement is allowed
    IF iOperationAllowed= 1 THEN
      stprAction+=1;
    ELSE
      giveAlarm(errorNr:=3);
    END_IF;
    
  4: //close clamps
    IF stsPosClamps=cilNotConnected | stsPosClamps=cilOut THEN
      stprAction+=1;
    ELSIF clampsConnected=1 THEN
      ctrlClamp.csMoveOut();
    END_IF;
    
  5: // start lubrication
    stprAction+=1;
    
  6: //start movement
    IF stsPosfeed=cilOut THEN
      stprAction+=1;
    ELSE
      ctrlfeed.csMoveOut();
    END_IF;
    
  7: //wait some extra time
    IF timerExtraOut.done = 1 THEN
      stprAction+=1;
    END_IF;

  8: //Stop action but keep lubrication on untill feed is fully back
    IF stsPosfeed=cilIn THEN
      stprAction+=1;
    ELSE
      ctrlfeed.csMoveIn();
    END_IF;
         
  9: //open clamps
    IF stsPosClamps=cilNotConnected | stsPosClamps=cilin THEN
      stprAction+=1;
    ELSIF clampsConnected=1 THEN
      ctrlClamp.csMovein();
    END_IF;
    
  10: //if in manual or half auto, switch off motor
    IF motorConnected=0 | (pmlCom.sts.mode=auto | pmlCom.sts.mode=service) | stsStateMotor=moOff THEN
      stprAction+=1;
    ELSE
      ctrlMotor.csStop();
    END_IF;
    
  11: //start blowing
    IF blowerConnected= 1 & ctrlBlower.stprBlow = 0 THEN //tp if blower is busy than not blow
      ctrlBlower.cmdBlow.Write(input:=1);
    END_IF;
    stprAction+=1;
      
  12: //done
    stprAction:=0;
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::interlock

  
  pmlCom.sts.isInterlocked:=pmlCom.cmd.interlock| tmpMotorNotRunningDuringAction  ;  //also interlock if motor not running during movement

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execResetting

  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //reset saw
    IF stsPosfeed = cilIn THEN
      stprState+= 1;
    ELSE
      ctrlfeed.csMoveIn();
    END_IF;
    
  2: //open clamps, but only if rerun isn't active
    IF pmlCom.cmd.reRun= 1 | clampsConnected= 0 THEN
      stprState+= 1;
    ELSE
      IF stsPosClamps= cilIn THEN
        stprState+= 1;
      ELSE
        ctrlClamp.csMoveIn();
      END_IF;
    END_IF;
    
  3: //start motor
    IF motorConnected= 0 | pmlCom.sts.state= Resetting | ctrlMotor.stsStateRun<> moOff THEN
      stprState:=1000;
    ELSE
      ctrlMotor.csStartFwd(speed:=1000);
    END_IF;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execStarting

  IF pmlCom.cmd.reRun= 0 THEN
    execResetting(); //just run reset
  ELSE
    execUnHolding();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execExecute

  runAction();
  IF stprAction=0 THEN
    stprState:=1000; //only state completed if action is done
  ELSE
    stprState:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execSuspending

  CASE stprState OF
  
  0: //wait until action and movement are done, also go on if there is an problem in this em
    IF stprAction=0 | stsInAlarm=1 THEN
      stprState:=1000;
    ELSE
      runAction();
    END_IF;
    
  1000: //ready
  
  END_CASE;
  

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execHolding

  execSuspending();

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execUnSuspending

  execUnHolding();

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execUnHolding

  CASE stprState OF
  
  0: //just go on
    stprState+=1;

  1: //reset saw
    IF stsPosfeed = cilIn THEN
      stprState+= 1;
    ELSE
      ctrlfeed.csMoveIn();
    END_IF;
    
  2: //check if old action nr. during was active, or action nr. still is active
    IF oldAutoStprAction> 0 THEN
      IF oldAutoStprAction <= 6 THEN //sawing not yet done, start it again
        stprAction:= 1;
      ELSE
        stprAction:=oldAutoStprAction; //sawing already done, just do the things to make it complete
      END_IF;
      oldAutoStprAction:=0;
    ELSIF stprAction> 0 THEN
      IF stprAction<= 6 THEN //sawing not yet done, start it again
        stprAction:= 1;
      END_IF;
    END_IF;
    stprState+= 1;
    
  3: //all we have to do during unholding (and unsuspending and restarting) is to set the right nr. to de stprAction
    //start motor
    IF motorConnected= 0 | ctrlMotor.stsStateRun<> moOff THEN
      stprState:=1000;
    ELSE
      ctrlMotor.csStartFwd(speed:=1000);
    END_IF;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execCompleting

  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //stop saw
    IF stsPosfeed = cilIn THEN
      stprState+= 1;
    ELSE
      ctrlfeed.csMoveIn();
    END_IF;
    
  2: //Open Clamps
    IF stsPosClamps = cilIn | clampsConnected =0 THEN
      stprState+= 1;
    ELSE
      ctrlClamp.csMoveIn();
    END_IF; 
    
  3: //switch off motor
    IF motorConnected=0 | stsStateMotor=moOff THEN
      stprState+=1;
    ELSE
      ctrlMotor.csStop();
    END_IF;
    
  4: //that's it
    stprState:=1000;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execStopping
  
  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //stop Feed
    IF stsPosfeed = cilIn THEN
      stprState+= 1;
    ELSE
      ctrlfeed.csMoveIn();
    END_IF;
    
  2: //Open Clamps
    IF stsPosClamps = cilIn | clampsConnected =0  THEN
      stprState+= 1;
    ELSE
      ctrlClamp.csMoveIn();
    END_IF; 
     
  3: //switch off motor
    IF motorConnected=0 | stsStateMotor=moOff THEN
      stprState+=1;
    ELSE
      ctrlMotor.csStop();
    END_IF;
    
  4: //that's it
    stprState:=1000;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execStart

  IF pmlCom.sts.mode = halfAuto THEN //cycle works only in half auto
    IF stprAction= 0 THEN
      stprAction:=1;
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execStop

  stprAction:=0;
  IF stsPosfeed <> cilIn THEN
    ctrlfeed.csMoveIn();
  ELSIF motorConnected= 1 & stsStateMotor <> moOff THEN
    ctrlMotor.csStop();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emOperationUnit::execHmiCmd4

  IF pmlCom.sts.mode = halfAuto & clampsConnected=1 THEN //RVDL 8-8-2019 action works only in half auto and has clamps connected
    IF stprAction = 0 THEN //RVDL 8-8-2019 // toggle between action depending on pos cil
      IF stsPosClamps = cilIn THEN
        ctrlClamp.csMoveOut();
      ELSE
        ctrlClamp.csMoveIn();
      END_IF;
    END_IF;
  END_IF;
 
END_FUNCTION
