//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "AssemblyDbV2"
	Revision           = "1.0"
	GUID               = "{76BB53A7-CF89-402B-9DD7-A718DF941BFF}"
	RealtimeTask       = "false"
	DefRealtime        = "5 ms"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(600,1500)">
	<Channels>
		<Server Name="AmountDone" GUID="{08335974-D308-4AA7-A834-8204A0146E68}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="AmountToDo" GUID="{7408A4AB-0D34-4AFF-831D-D98D412B9457}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="csDeleting" GUID="{105C2B03-057C-4C9A-93E1-22FE3A9059D6}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="firstIDX" GUID="{0E45E2B0-B54A-4CAE-B2D4-C114205FFC9D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiDeleteRecipe" GUID="{53CEC124-58EF-41FE-8FE2-5A15A4FA0557}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiReloadRecipe" GUID="{5C39D31E-6EEB-4CA7-B685-E766FD7D8543}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiSaveRecipe" GUID="{A455598C-39FF-467D-898D-1B7B01346F76}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="inputLength" GUID="{C10CBEF2-45F0-4FE1-85A9-2990A41BE2C3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="InputPackId" GUID="{FBC186D1-C0B5-4657-8D47-527BFC5ADC94}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MeasureInputProfiles" GUID="{18ED7ECD-4AED-4FF9-A2BA-8EF4C7073B2C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="parAutoSave" GUID="{F43817F1-3164-4C15-89E1-2FE6A67783D0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="ProfileId" GUID="{9ECAB2B0-1B1C-4782-948E-4192A6AC6E2F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="RecipeId" GUID="{F37C2124-24C9-4D7D-B096-8CB370AAE3D4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="reserve2" GUID="{9DA10C84-7692-4035-9518-BDC911C1CAD3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="strDescription" GUID="{4AB18F82-3627-47A5-AE82-7FEF42C557BD}" Class="EditString" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="strProductCode" GUID="{6093BA72-6A3A-495E-BBAA-8D2E86493104}" Class="EditString" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="stsUnsafeChanges" GUID="{3E0D00FA-A3AF-4867-81C4-43D9C20A1408}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="AssemRule_1" Required="true" Internal="true"/>
		<Client Name="AssemRule_2" Required="true" Internal="true"/>
		<Client Name="AssemRule_3" Required="true" Internal="true"/>
		<Client Name="AssemRule_4" Required="true" Internal="true"/>
		<Client Name="AssemRule_5" Required="true" Internal="true"/>
		<Client Name="FB" Required="true" Internal="false"/>
		<Client Name="FileSys" Required="false" Internal="false"/>
		<Client Name="iStartDelete" Required="true" Internal="false"/>
		<Client Name="ProductDb" Required="true" Internal="false"/>
		<Client Name="RamEx" Required="true" Internal="false"/>
		<Client Name="str_Description" Required="true" Internal="true"/>
		<Client Name="str_ProductCode" Required="true" Internal="true"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="10"/>
			<SepChn Position="12"/>
		</Servers>
		<Clients>
			<SepChn Position="1"/>
		</Clients>
	</Separators>
	<Network Name="AssemblyDbV2">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{6ACE3937-3338-4E75-862C-7A88469D1502}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name           = "AssemRule_1"
				GUID           = "{5D99868A-D69C-4F10-91D7-59EE86EC4328}"
				Class          = "AssemblyOneProdRuleV2"
				Position       = "(300,1410)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "1000 ms">
				<Channels>
					<Server Name="Amount"/>
					<Server Name="ClassSvr"/>
					<Server Name="Length"/>
					<Server Name="ProductId"/>
					<Server Name="rnr"/>
					<Server Name="strDescription"/>
				</Channels>
			</Object>
			<Object
				Name           = "AssemRule_2"
				GUID           = "{23274C36-0E66-4DF9-991C-0BD98ED70887}"
				Class          = "AssemblyOneProdRuleV2"
				Position       = "(300,1860)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "1000 ms">
				<Channels>
					<Server Name="Amount"/>
					<Server Name="ClassSvr"/>
					<Server Name="Length"/>
					<Server Name="ProductId"/>
					<Server Name="rnr"/>
					<Server Name="strDescription"/>
				</Channels>
			</Object>
			<Object
				Name           = "AssemRule_3"
				GUID           = "{31BE7015-7FAE-4C23-A1D6-3365378CD800}"
				Class          = "AssemblyOneProdRuleV2"
				Position       = "(300,2310)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "1000 ms">
				<Channels>
					<Server Name="Amount"/>
					<Server Name="ClassSvr"/>
					<Server Name="Length"/>
					<Server Name="ProductId"/>
					<Server Name="rnr"/>
					<Server Name="strDescription"/>
				</Channels>
			</Object>
			<Object
				Name           = "AssemRule_4"
				GUID           = "{2D43CEE7-2C88-4A12-AC45-3E56674B3497}"
				Class          = "AssemblyOneProdRuleV2"
				Position       = "(300,2760)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "1000 ms">
				<Channels>
					<Server Name="Amount"/>
					<Server Name="ClassSvr"/>
					<Server Name="Length"/>
					<Server Name="ProductId"/>
					<Server Name="rnr"/>
					<Server Name="strDescription"/>
				</Channels>
			</Object>
			<Object
				Name           = "AssemRule_5"
				GUID           = "{8D7244B4-38C1-42AD-9B28-8D0F7AE385B6}"
				Class          = "AssemblyOneProdRuleV2"
				Position       = "(300,3210)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "1000 ms">
				<Channels>
					<Server Name="Amount"/>
					<Server Name="ClassSvr"/>
					<Server Name="Length"/>
					<Server Name="ProductId"/>
					<Server Name="rnr"/>
					<Server Name="strDescription"/>
				</Channels>
			</Object>
			<Object
				Name       = "str_Description"
				GUID       = "{167C7E90-3A4F-46DA-A0E0-F80D3ADFA61C}"
				Class      = "EditString"
				Position   = "(660,810)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="Handle"/>
					<Server Name="NewData"/>
				</Channels>
			</Object>
			<Object
				Name       = "str_ProductCode"
				GUID       = "{66B0B602-6AE4-40B9-BE09-4EA37BAE2109}"
				Class      = "EditString"
				Position   = "(660,1080)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="Handle"/>
					<Server Name="NewData"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1148,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1148,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1148,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1148,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1148,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1148,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1148,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1148,630),(864,690),"/>
			<Connection Source="this.str_ProductCode" Destination="str_ProductCode.Data"/>
			<Connection Source="this.str_Description" Destination="str_Description.Data"/>
			<Connection Source="this.AssemRule_5" Destination="AssemRule_5.ClassSvr"/>
			<Connection Source="this.strProductCode" Destination="str_ProductCode.Data" Vertices="(1148,810),(976,1170),"/>
			<Connection Source="this.strDescription" Destination="str_Description.Data" Vertices="(1148,750),(976,900),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.AssemRule_3" Destination="AssemRule_3.ClassSvr"/>
			<Connection Source="this.AssemRule_4" Destination="AssemRule_4.ClassSvr"/>
			<Connection Source="this.AssemRule_1" Destination="AssemRule_1.ClassSvr"/>
			<Connection Source="this.AssemRule_2" Destination="AssemRule_2.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

AssemblyDbV2 : CLASS
: cmBase
	TYPE
	  str_100 : ARRAY [0..225] OF CHAR;
	  str_3000 : ARRAY [0..3000] OF CHAR;
#pragma pack(push, 1)
	  tBewerkingsRegel : STRUCT  //! <Type Public="true" Name="tBewerkingsRegel"/>
	    Bewerking : Units;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  tRecipeLine : STRUCT  //! <Type Public="true" Name="tRecipeLine"/>
	    productId : DINT;
	    amount : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  tRecipeLineList : ARRAY [0..cAssemDbMaxProdLines] OF tRecipeLine;  //! <Type Public="true" Name="tRecipeLineList"/>
#pragma pack(push, 1)
	  tRecipeData : STRUCT  //! <Type Public="true" Name="tRecipeData"/>
	    id : DINT;
	    description : gbl_datatypes::tStr20;
	    productCode : gbl_datatypes::tStr20;
	    reserveText : gbl_datatypes::tStr20;
	    inputLength : DINT;
	    MeasureInputProfiles : DINT;
	    profileId : DINT;
	    inputPackId : DINT;
	    amountToDo : DINT;
	    amountDone : DINT;
	    reserve2 : DINT;
	    recipeList : tRecipeLineList;
	  END_STRUCT;
#pragma pack(pop)
	  tData : ARRAY [0..1] OF tRecipeData;
	END_TYPE
  //Servers:
	RecipeId 	: SvrCh_UDINT;
	strDescription 	: SvrChCmd_UDINT;
	strProductCode 	: SvrChCmd_UDINT;
	inputLength 	: SvrCh_DINT;
	MeasureInputProfiles 	: SvrCh_DINT;
	ProfileId 	: SvrCh_DINT;
	InputPackId 	: SvrCh_DINT;
	AmountToDo 	: SvrCh_DINT;
	AmountDone 	: SvrCh_DINT;
	reserve2 	: SvrCh_DINT;
	firstIDX 	: SvrCh_DINT;
	HmiSaveRecipe 	: SvrCh_DINT;
	HmiReloadRecipe 	: SvrCh_DINT;
	HmiDeleteRecipe 	: SvrCh_DINT;
	stsUnsafeChanges 	: SvrCh_DINT;
	parAutoSave 	: SvrCh_DINT;
	csDeleting 	: SvrCh_DINT;
  //Clients:
	RamEx 	: CltChCmd_RAMex;
	FileSys 	: CltChCmd__FileSys;
	FB 	: CltChCmd_FileBase;
	str_Description 	: CltChCmd_EditString;
	str_ProductCode 	: CltChCmd_EditString;
	ProductDb 	: CltChCmd_ProductsDbV2;
	iStartDelete 	: CltCh_UDINT;
	AssemRule_5 	: CltChCmd_AssemblyOneProdRuleV2;
	AssemRule_2 	: CltChCmd_AssemblyOneProdRuleV2;
	AssemRule_4 	: CltChCmd_AssemblyOneProdRuleV2;
	AssemRule_3 	: CltChCmd_AssemblyOneProdRuleV2;
	AssemRule_1 	: CltChCmd_AssemblyOneProdRuleV2;
  //Variables:
		ActRecipeData 	: tRecipeData;
		tempRecipe 	: tRecipeData;
		sizeRecipedata 	: UDINT;
		emptyRecipe 	: tRecipeData;
		tmpText 	: tekst;
		dbAmountOfRecipes 	: UDINT;
		dbAmountOfLinesInRecipe 	: UDINT;
		checkForStorageProductData 	: tRecipeData;
		tmrAutoSave 	: UDINT;
		tmpNrDelete 	: UDINT;
		tmpInputNr 	: UDINT;
		stsRamResult 	: UINT;
		emptyStr20 	: gbl_datatypes::tStr20;
		tmpProduct 	: ProductsDbV2::tRecipeData;
		nrd 	: UDINT;
		delResult 	: UINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION GLOBAL GetRecipe
		VAR_INPUT
			id 	: DINT;
		END_VAR
		VAR_OUTPUT
			oRecipe 	: tRecipeData;
		END_VAR;
	
	FUNCTION UpdateServers;
	
	FUNCTION GLOBAL giveText
		VAR_INPUT
			progNr 	: DINT;
		END_VAR
		VAR_OUTPUT
			text 	: tekst;
		END_VAR;
	
	FUNCTION saveRecipe
		VAR_INPUT
			nr 	: UDINT;
			recipe 	: tRecipeData;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION loadRecipe
		VAR_INPUT
			nr 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION saveChanges
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION updateRecipeLines;
	
	FUNCTION VIRTUAL GLOBAL RecipeId::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strProductCode::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strProductCode::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL inputLength::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MeasureInputProfiles::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ProfileId::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InputPackId::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AmountToDo::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AmountDone::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reserve2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL firstIDX::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiSaveRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiReloadRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiDeleteRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stsUnsafeChanges::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using AssemblyOneProdRuleV2
#pragma using EditString
#pragma usingLtd _FileSys
#pragma usingLtd FileBase
#pragma usingLtd ProductsDbV2
#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AssemblyDbV2::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_ASSEMBLYDBV2
1$UINT, 0$UINT, (SIZEOF(::AssemblyDbV2))$UINT, 
17$UINT, 12$UINT, 0$UINT, 
TO_UDINT(2560758913), "AssemblyDbV2", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::AssemblyDbV2.RecipeId.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1433076410), "RecipeId", 
(::AssemblyDbV2.strDescription.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(415395287), "strDescription", 
(::AssemblyDbV2.strProductCode.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2943832204), "strProductCode", 
(::AssemblyDbV2.inputLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3199740018), "inputLength", 
(::AssemblyDbV2.MeasureInputProfiles.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(570383759), "MeasureInputProfiles", 
(::AssemblyDbV2.ProfileId.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1247850193), "ProfileId", 
(::AssemblyDbV2.InputPackId.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(847662556), "InputPackId", 
(::AssemblyDbV2.AmountToDo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2304864502), "AmountToDo", 
(::AssemblyDbV2.AmountDone.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3275892477), "AmountDone", 
(::AssemblyDbV2.reserve2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(855090055), "reserve2", 
(::AssemblyDbV2.firstIDX.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2939634995), "firstIDX", 
(::AssemblyDbV2.HmiSaveRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1848756402), "HmiSaveRecipe", 
(::AssemblyDbV2.HmiReloadRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(583644729), "HmiReloadRecipe", 
(::AssemblyDbV2.HmiDeleteRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3337502784), "HmiDeleteRecipe", 
(::AssemblyDbV2.stsUnsafeChanges.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1099579582), "stsUnsafeChanges", 
(::AssemblyDbV2.parAutoSave.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2771706058), "parAutoSave", 
(::AssemblyDbV2.csDeleting.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(869513859), "csDeleting", 
//Clients:
(::AssemblyDbV2.RamEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(933570811), "RamEx", TO_UDINT(933570811), "RAMex", 1$UINT, 17$UINT, 
(::AssemblyDbV2.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::AssemblyDbV2.FB.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2133383872), "FB", TO_UDINT(1689253198), "FileBase", 0$UINT, 5$UINT, 
(::AssemblyDbV2.str_Description.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3670666575), "str_Description", TO_UDINT(648754807), "EditString", 0$UINT, 0$UINT, 
(::AssemblyDbV2.str_ProductCode.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1836896276), "str_ProductCode", TO_UDINT(648754807), "EditString", 0$UINT, 0$UINT, 
(::AssemblyDbV2.ProductDb.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3153229616), "ProductDb", TO_UDINT(1214555786), "ProductsDbV2", 1$UINT, 0$UINT, 
(::AssemblyDbV2.iStartDelete.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4125418208), "iStartDelete", 
(::AssemblyDbV2.AssemRule_5.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1554656090), "AssemRule_5", TO_UDINT(1616900063), "AssemblyOneProdRuleV2", 0$UINT, 0$UINT, 
(::AssemblyDbV2.AssemRule_2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3268329209), "AssemRule_2", TO_UDINT(1616900063), "AssemblyOneProdRuleV2", 0$UINT, 0$UINT, 
(::AssemblyDbV2.AssemRule_4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(732765132), "AssemRule_4", TO_UDINT(1616900063), "AssemblyOneProdRuleV2", 0$UINT, 0$UINT, 
(::AssemblyDbV2.AssemRule_3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3049885295), "AssemRule_3", TO_UDINT(1616900063), "AssemblyOneProdRuleV2", 0$UINT, 0$UINT, 
(::AssemblyDbV2.AssemRule_1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1539829571), "AssemRule_1", TO_UDINT(1616900063), "AssemblyOneProdRuleV2", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_AssemblyDbV2 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AssemblyDbV2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AssemblyDbV2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AssemblyDbV2;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RecipeId.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RecipeId::Write() );
	IF RecipeId.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, strDescription.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #strDescription::Read();
	vmt.CmdTable.Write		:= #strDescription::Write();
	strDescription.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF strDescription.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, strProductCode.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #strProductCode::Read();
	vmt.CmdTable.Write		:= #strProductCode::Write();
	strProductCode.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF strProductCode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	inputLength.pMeth			:= StoreMethod( #M_RD_DIRECT(), #inputLength::Write() );
	IF inputLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MeasureInputProfiles.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MeasureInputProfiles::Write() );
	IF MeasureInputProfiles.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ProfileId.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ProfileId::Write() );
	IF ProfileId.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	InputPackId.pMeth			:= StoreMethod( #M_RD_DIRECT(), #InputPackId::Write() );
	IF InputPackId.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AmountToDo.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AmountToDo::Write() );
	IF AmountToDo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AmountDone.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AmountDone::Write() );
	IF AmountDone.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reserve2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reserve2::Write() );
	IF reserve2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	firstIDX.pMeth			:= StoreMethod( #M_RD_DIRECT(), #firstIDX::Write() );
	IF firstIDX.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiSaveRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiSaveRecipe::Write() );
	IF HmiSaveRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiReloadRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiReloadRecipe::Write() );
	IF HmiReloadRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiDeleteRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiDeleteRecipe::Write() );
	IF HmiDeleteRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsUnsafeChanges.pMeth			:= StoreMethod( #stsUnsafeChanges::Read(), #M_NO_F() );
	IF stsUnsafeChanges.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parAutoSave.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parAutoSave.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	csDeleting.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF csDeleting.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 5-12-2019 changed to assemblyDbV2, same way of working
// JdK 29-11-2019 productsDBV2 created to handle 'recipes' like products, assembly's etc.
// functions like autosave, save, save as, reload (undo changes) are available
// storage to usb and load from usb are not yet functional, will be added later

// 
//ErrorNr 1 no file present
//ErrorNr 2 USB not present
//ErrorNr 3 cannot open file
//ErrorNr 4 error reading file
//ErrorNr 5 wrong format
//ErrorNr 6 too many lines
//ErrorNr 7 too little chars in data string

FUNCTION VIRTUAL AssemblyDbV2::Init1

  IF initDone= 0 THEN
  
    dbAmountOfRecipes:= CASSEMDBMAXASSEMBLIES; //read in amounts
    dbAmountOfLinesInRecipe:= CASSEMDBMAXPRODLINES;
    sizeRecipedata := to_udint(sizeof(tRecipeData)); //put size of product data in var
    _memset(dest:=#emptyRecipe, usByte:=0, cntr:=sizeRecipedata); //set empty product
    _memset(dest:=#emptyStr20, usByte:=0, cntr:=sizeof(emptyStr20));
    
    IF RamEx.GetSize() <> (sizeRecipedata*dbAmountOfRecipes) THEN //check if ram size isn't set yet
      IF RamEx.SetSize(udsize:= (sizeRecipedata*dbAmountOfRecipes)) = C_OK THEN //only if setting is done, say init is done
        initDone:= 1;
        
        loadRecipe(nr:=RecipeId); //after setting size of db try to load the recipe

      END_IF;
    ELSE
      initDone:= 1;
      loadRecipe(nr:=RecipeId); //also if size is ok, load recipe
    END_IF;
    
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  //check if we need to update the strings
  if str_Description.NewData.Read() <> 0 then//description
    _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
    str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
    str_Description.NewData.Write(input:=0);
  end_if;

  if str_ProductCode.NewData.Read() <> 0 then//productCode
    _memset(dest:=#ActRecipeData.productCode[0], usByte:=0, cntr:=sizeof(ActRecipeData.productCode));
    str_ProductCode.ReadDataOff(udOff:=0, pData:=#ActRecipeData.productCode[0], udMax:=sizeof(ActRecipeData.productCode));
    str_ProductCode.NewData.Write(input:=0);
  end_if;

  //if autosave is active, check every ten seconds if we should save
  IF parAutoSave & ops.tAbsolute-tmrAutoSave> 10000 THEN
    saveChanges();
    tmrAutoSave:= ops.tAbsolute;
  END_IF;
  
  IF HmiDeleteRecipe= -10 THEN //means delete complete db
    IF tmpNrDelete > 0 & tmpNrDelete < dbAmountOfRecipes THEN
      IF saveRecipe(nr:=tmpNrDelete, recipe:=emptyRecipe)= 1 THEN
        tmpNrDelete+=1;
        IF tmpNrDelete = dbAmountOfRecipes THEN
          HmiDeleteRecipe:= 0; //all recipes are deleted now
          loadRecipe(nr:=RecipeId);//load active recipe to show it's empty
        END_IF;
      END_IF;
    END_IF;
  END_IF;

  stsUnsafeChanges.Read();

  updateRecipeLines(); //try to update data in line continues
  
  state:= 0;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL AssemblyDbV2::stsUnsafeChanges::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  IF ActRecipeData <> checkForStorageProductData THEN
    stsUnsafeChanges:= 1;
  ELSE
    stsUnsafeChanges:= 0;
  END_IF;

	output := stsUnsafeChanges;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::RecipeId::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  
  IF input > 0 & input < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    IF parAutoSave= 0 | saveChanges()= 1 THEN //only if autosave is active, else in screen project choose to save or not should be made before writing a new product ID
      IF loadRecipe(nr:=input)= 1 THEN
        RecipeId:= input; //keep input in memory
      END_IF;
    END_IF;
   
  ELSE
    Result := Access_Denied;
  End_If;

END_FUNCTION

FUNCTION AssemblyDbV2::saveRecipe
	VAR_INPUT
		nr 	: UDINT;
		recipe 	: tRecipeData;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  //function save recipe in input nr in ram db
  IF nr > 0 & nr < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    tempRecipe:= recipe;
    stsRamResult:= RamEx.SetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:=nr * sizeRecipedata);
    IF stsRamResult= 5 THEN
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION AssemblyDbV2::loadRecipe
	VAR_INPUT
		nr 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  //function loads recipe from nr into act recipe, also changes check saving recipe, used to control if saving is required
  IF nr>0 & nr<dbAmountOfRecipes THEN
    stsRamResult:= RamEx.GetDataAt(pData:=#ActRecipeData$USINT, udSize:=sizeRecipedata, udAt:=nr* sizeRecipedata);
    IF stsRamResult= 5 THEN
      checkForStorageProductData:= ActRecipeData; //no changes yet
      UpdateServers();
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION AssemblyDbV2::saveChanges
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  IF checkForStorageProductData <> ActRecipeData THEN //only do saving if there is a difference
    IF saveRecipe(nr:=RecipeId, recipe:=ActRecipeData) THEN
      checkForStorageProductData:= ActRecipeData;
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 1; //no changes, means no storage needed
  END_IF;

END_FUNCTION

FUNCTION AssemblyDbV2::UpdateServers

  //put data of new recipe into data servers
  inputLength := ActRecipeData.inputLength;
  MeasureInputProfiles := ActRecipeData.MeasureInputProfiles;
  ProfileId := ActRecipeData.profileId;
  InputPackId := ActRecipeData.inputPackId;
  AmountToDo     := ActRecipeData.amountToDo;
  AmountDone := ActRecipeData.amountDone;
  reserve2 := ActRecipeData.reserve2;
  
  str_Description.WriteDataOff(udLen:=sizeof(ActRecipeData.description), udOff:=0, pData:=#ActRecipeData.description[0]);
  str_ProductCode.WriteDataOff(udLen:=sizeof(ActRecipeData.productCode), udOff:=0, pData:=#ActRecipeData.productCode[0]);

  updateRecipeLines();

END_FUNCTION

////////////////////////////////////////////////////////////////////
// some functions for controlling recipe from HMI

FUNCTION VIRTUAL GLOBAL AssemblyDbV2::HmiSaveRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //function to save actual recipe into given nr
  //if used as regular save, write product id into this server to save,
  //else write nr. where you want to save it
  tmpInputNr:=to_udint(input);
  IF input> 0 & tmpInputNr < dbAmountOfRecipes THEN
    IF saveRecipe(nr:=tmpInputNr, recipe:=ActRecipeData) = 1 THEN
	    HmiSaveRecipe := 0; //saving done
    ELSE
      HmiSaveRecipe:= -1;
    END_IF;
  ELSE
    HmiSaveRecipe := -1; //saving not ok
  END_IF;
	result := HmiSaveRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::HmiReloadRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //means throw away all made changes
  IF loadRecipe(nr:=RecipeId)= 1 THEN
  	HmiReloadRecipe := 0; //done
  ELSE
    HmiReloadRecipe := -1; //not ok
  END_IF;
  
	result := HmiReloadRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::HmiDeleteRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //delete all recipes (if value = -10), or one (if value is between min and max recipes)
  tmpInputNr:=to_udint(input);
  IF input = -10 THEN
    HmiDeleteRecipe := input;
    tmpNrDelete:= 1;
  ELSIF input>0 & tmpInputNr < dbAmountOfRecipes THEN
    IF saveRecipe(nr:=tmpInputNr, recipe:=emptyRecipe) = 1 THEN
      IF tmpInputNr = RecipeId THEN //if actual recipe is deleted, reload it
        loadRecipe(nr:=RecipeId);
      END_IF;
      HmiDeleteRecipe:= 0;
    ELSE
      HmiDeleteRecipe:= -1;
    END_IF;
  END_IF;
	result := HmiDeleteRecipe;

END_FUNCTION


/////////////////////////////////////////////////////////////////
// USB functions
//////////////////////////////////////////////////////////////////
// function to get prog from other class

FUNCTION GLOBAL AssemblyDbV2::GetRecipe
	VAR_INPUT
		id 	: DINT;
	END_VAR
	VAR_OUTPUT
		oRecipe 	: tRecipeData;
	END_VAR
  
  if id >= 0 & id < to_dint(dbAmountOfRecipes) then
    if id = to_dint(RecipeId) then //JdK if product is active, just give it back, else db isn't written in right way
      tempRecipe:=ActRecipeData;
    else
      RamEx.GetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:= to_udint(id) * sizeRecipedata);
    end_if;
    oRecipe := tempRecipe;
  else
    oRecipe := emptyRecipe;
  end_if;


END_FUNCTION

//////////////////////////////////////////////////////////////
// functions to write data

FUNCTION VIRTUAL GLOBAL AssemblyDbV2::strDescription::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	strDescription := str_Description.Data.Read();
	output := strDescription;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::strDescription::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	strDescription := input;
	result := (str_Description.Data.Write(strDescription))$UDINT;
  _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
  str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::strProductCode::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	strProductCode := str_ProductCode.Data.Read();
	output := strProductCode;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::strProductCode::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	strProductCode := input;
	result := (str_ProductCode.Data.Write(strProductCode))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::inputLength::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	inputLength := input;
  ActRecipeData.inputLength := inputLength;
	result := inputLength;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::MeasureInputProfiles::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	MeasureInputProfiles := input;
  ActRecipeData.MeasureInputProfiles := MeasureInputProfiles;
	result := MeasureInputProfiles;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::ProfileId::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ProfileId := input;
  ActRecipeData.profileId := ProfileId;
	result := ProfileId;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::InputPackId::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	InputPackId := input;
  ActRecipeData.inputPackId := InputPackId;
	result := InputPackId;

END_FUNCTION
  

FUNCTION VIRTUAL GLOBAL AssemblyDbV2::AmountDone::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	AmountDone := input;
  ActRecipeData.amountDone:= AmountDone;
	result := AmountDone;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::reserve2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  IF input > 0 & input < 1800 THEN
	  reserve2 := input;
    ActRecipeData.reserve2:=reserve2;
  END_IF;
	result := reserve2;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::AmountToDo::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  IF input >= 0 THEN
	  AmountToDo := input;
    ActRecipeData.amountToDo:= AmountToDo;
  END_IF;
	result := AmountToDo;

END_FUNCTION


FUNCTION GLOBAL AssemblyDbV2::giveText
	VAR_INPUT
		progNr 	: DINT;
	END_VAR
	VAR_OUTPUT
		text 	: tekst;
	END_VAR

  _memset(dest:=#tmpText[0], usByte:=0, cntr:=sizeof(tmpText));


  if progNr >= 0 & progNr < cProdDbMaxProducts then
    if progNr = to_dint(RecipeId) then //JdK if product is active, just give it back, else db isn't written in right way
      tempRecipe:=ActRecipeData;
    else
      RamEx.GetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeof(tRecipeData), udat:= to_udint(id) * sizeof(tRecipeData));
    end_if;
    _memcpy(ptr1:=#tmpText[0], ptr2:=#tempRecipe.description[0], cntr:=21); //copy all 21 chars to tmp
    
  end_if;
  
  text:= tmpText;


END_FUNCTION



FUNCTION AssemblyDbV2::updateRecipeLines

  // update data for products in recipe
  // ssregel 1
  AssemRule_1.WritePtr(iptr:=#ActRecipeData.recipeList[firstIdx]);
  AssemRule_1.rnr:= firstIdx+1;
  if ActRecipeData.recipeList[firstIdx].productId<> 0 then
    tmpProduct := ProductDb.GetRecipe(id:=to_dint(ActRecipeData.recipeList[firstIdx].productId));
    AssemRule_1.WriteDescription(inStr:=tmpProduct.productCode);
    AssemRule_1.Length := tmpProduct.length; 
  else
    AssemRule_1.WriteDescription(inStr:=emptyStr20);// anders leeg maken
    AssemRule_1.Length := 0;       
  end_if;
    
  // ssregel 2
  AssemRule_2.WritePtr(iptr:=#ActRecipeData.recipeList[firstIdx+1]);
  AssemRule_2.rnr:= firstIdx+2;
  if ActRecipeData.recipeList[firstIdx + 1].productId<> 0 then
   tmpProduct := ProductDb.GetRecipe(id:=to_dint(ActRecipeData.recipeList[firstIdx + 1].productId));
   AssemRule_2.WriteDescription(inStr:=tmpProduct.productCode);
   AssemRule_2.Length := tmpProduct.length; 
  else
   AssemRule_2.WriteDescription(inStr:=emptyStr20);// anders leeg maken
   AssemRule_2.Length := 0;        
  end_if;
    
  // ssregel 3
  AssemRule_3.WritePtr(iptr:=#ActRecipeData.recipeList[firstIdx + 2]);     
  AssemRule_3.rnr:= firstIdx+3;
  if ActRecipeData.recipeList[firstIdx + 2].productId<> 0 then
   tmpProduct := ProductDb.GetRecipe(id:=to_dint(ActRecipeData.recipeList[firstIdx + 2].productId));
   AssemRule_3.WriteDescription(inStr:=tmpProduct.productCode);
   AssemRule_3.Length := tmpProduct.length; 
  else
    AssemRule_3.WriteDescription(inStr:=emptyStr20);// anders leeg maken
    AssemRule_3.Length := 0;        
  end_if;    
    
  // ssregel 4
  AssemRule_4.WritePtr(iptr:=#ActRecipeData.recipeList[firstIdx + 3]);     
  AssemRule_4.rnr:= firstIdx+4;
  if ActRecipeData.recipeList[firstIdx + 3].productId<> 0 then
   tmpProduct := ProductDb.GetRecipe(id:=to_dint(ActRecipeData.recipeList[firstIdx + 3].productId));
   AssemRule_4.WriteDescription(inStr:=tmpProduct.productCode);
   AssemRule_4.Length := tmpProduct.length; 
  else
   AssemRule_4.WriteDescription(inStr:=emptyStr20);// anders leeg maken
   AssemRule_4.Length := 0;        
  end_if;  

  // ssregel 5
  AssemRule_5.WritePtr(iptr:=#ActRecipeData.recipeList[firstIdx + 4]);     
  AssemRule_5.rnr:= firstIdx+5;
  if ActRecipeData.recipeList[firstIdx + 4].productId<> 0 then
   tmpProduct := ProductDb.GetRecipe(id:=to_dint(ActRecipeData.recipeList[firstIdx + 4].productId));
   AssemRule_5.WriteDescription(inStr:=tmpProduct.productCode);
   AssemRule_5.Length := tmpProduct.length; 
  else
   AssemRule_5.WriteDescription(inStr:=emptyStr20);// anders leeg maken
   AssemRule_5.Length := 0;        
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AssemblyDbV2::firstIDX::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if input>= 0 & input < cAssemDbMaxProdLines then
    firstIdx := input;
    updateRecipeLines();
    result := firstIdx;
  else
    result:= ACCESS_DENIED;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL AssemblyDbV2::work

  //JdK method to delete all assembly's from a certain nr
  CASE csDeleting OF
  
  -10: //start
//    iStartDelete:= iStartDelete.Read();
//    nrd:= iStartDelete;
    csDeleting:= 1;
    
  0: //just wait  
    
  1: //delete one
    delResult:=RamEx.SetDataAt(pdata:=#emptyRecipe$usint, udsize:=sizeRecipedata, udat:=nrd * sizeRecipedata);
    csDeleting+=1;
    
  2: //go to next
    IF delResult = 5 THEN
      nrd+=1;
    END_IF;
    IF nrd< dbAmountOfRecipes THEN
      csDeleting-=1;
    ELSE
      csDeleting:= 0; //done
    END_IF;
      
    
  
  END_CASE;


END_FUNCTION
