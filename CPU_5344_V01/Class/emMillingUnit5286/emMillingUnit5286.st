//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emMillingUnit5286"
	Revision           = "0.0"
	GUID               = "{BF04CC41-CCFB-4C60-96F9-A2FFD171BFF6}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(630,1080)">
	<Channels>
		<Server Name="csStartEndMilling" GUID="{392D83FC-F1EB-4BED-9A93-4108167480CD}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="oEnableLubrication" GUID="{A82BAF89-F1A3-4FCC-927E-C18BD97EA014}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="parTimeOutTime" GUID="{6E1C77BD-DCCE-4927-9258-B8F97AA55FA1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimePullingMillForward" GUID="{33DF276A-CE1C-475F-946B-DE5ADB8F70E5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="ParWaitForMotor" GUID="{2F3C8129-82F7-4176-B09B-E30E5B80D9F4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="patTimeoutMatDetection" GUID="{EF1A7FD3-43DA-4851-83B9-0704CAA625C8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="signalToSafetyMotorIsAllowed" GUID="{12CCF636-D4C9-4954-B55F-F1E1534DD8A6}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="ctrlClamp1" Required="false" Internal="false"/>
		<Client Name="ctrlClamp2" Required="false" Internal="false"/>
		<Client Name="ctrlEndStop" Required="false" Internal="false"/>
		<Client Name="FCmaterialAtMill" Required="true" Internal="false"/>
		<Client Name="iMotorActivated" Required="true" Internal="false"/>
		<Client Name="iOperationAllowed" Required="true" Internal="false"/>
		<Client Name="iPbClamp1" Required="true" Internal="false"/>
		<Client Name="iPbClamp2" Required="true" Internal="false"/>
		<Client Name="iSensorMillBack" Required="false" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
		</Servers>
	</Separators>
	<Network Name="emMillingUnit5286">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{908C3DF2-D9C0-4381-AA5A-6BD25887478D}"
				Class      = "emBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1156,210),(984,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1156,270),(984,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1156,330),(984,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1156,390),(984,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1156,450),(984,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1156,510),(984,510),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1156,570),(984,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1156,630),(984,630),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1156,690),(984,750),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1156,750),(984,810),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1156,810),(984,870),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1156,870),(984,930),"/>
			<Connection Source="this.cmdWaitReset" Destination="_base.cmdWaitReset" Vertices="(1156,930),(984,1050),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1156,990),(984,1170),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1156,1050),(984,1230),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emBase

emMillingUnit5286 : CLASS
: emBase
  //Servers:
	parTimePullingMillForward 	: SvrCh_UDINT;
	parTimeOutTime 	: SvrCh_UDINT;
	patTimeoutMatDetection 	: SvrCh_UDINT;
	oEnableLubrication 	: SvrCh_DINT;
	ParWaitForMotor 	: SvrCh_UDINT;
	csStartEndMilling 	: SvrCh_DINT;
	signalToSafetyMotorIsAllowed 	: SvrCh_DINT;
  //Clients:
	ctrlClamp1 	: CltChCmd_cmCil;
	ctrlClamp2 	: CltChCmd_cmCil;
	iPbClamp1 	: CltCh_DINT;
	iPbClamp2 	: CltCh_DINT;
	iSensorMillBack 	: CltCh_DINT;
	ctrlEndStop 	: CltChCmd_cmCil;
	iOperationAllowed 	: CltCh_DINT;
	FCmaterialAtMill 	: CltCh_DINT;
	iMotorActivated 	: CltCh_DINT;
  //Variables:
		stsPosClamp1 	: cilPos;
		stsPosClamp2 	: cilPos;
		stsStateMotor 	: motorPos;
		oldMode 	: eModePML;
		tmpMotorNotRunningDuringAction 	: DINT;
		motorConnected 	: DINT;
		clamp1Connected 	: DINT;
		clamp2connected 	: DINT;
		blowerConnected 	: DINT;
		timeOutTimer 	: strTimer;
		oldStprAction 	: DINT;
		oldAutoStprAction 	: DINT;
		timeoutMatDetection 	: strTimer;
		oldButtonClamp1 	: DINT;
		oldButtonClamp2 	: DINT;
		timeOutMotor 	: strTimer;
		timeoutPullingMillForward 	: strTimer;
  //Functions:
	
	FUNCTION VIRTUAL interlock;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION VIRTUAL execResetting;
	
	FUNCTION VIRTUAL execStarting;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION VIRTUAL execCompleting;
	
	FUNCTION VIRTUAL execHolding;
	
	FUNCTION VIRTUAL execHeld;
	
	FUNCTION VIRTUAL execUnHolding;
	
	FUNCTION VIRTUAL execStopping;
	
	FUNCTION VIRTUAL execSuspending;
	
	FUNCTION VIRTUAL execSuspended;
	
	FUNCTION VIRTUAL execUnSuspending;
	
	FUNCTION runAction;
	
	FUNCTION runMoving;
	
	FUNCTION VIRTUAL GLOBAL csStartEndMilling::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd cmCil


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emMillingUnit5286::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMMILLINGUNIT5286
0$UINT, 0$UINT, (SIZEOF(::emMillingUnit5286))$UINT, 
7$UINT, 9$UINT, 0$UINT, 
TO_UDINT(3489378326), "emMillingUnit5286", //Class
TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emMillingUnit5286.parTimePullingMillForward.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2034092667), "parTimePullingMillForward", 
(::emMillingUnit5286.parTimeOutTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4183149504), "parTimeOutTime", 
(::emMillingUnit5286.patTimeoutMatDetection.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2162705495), "patTimeoutMatDetection", 
(::emMillingUnit5286.oEnableLubrication.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1421400189), "oEnableLubrication", 
(::emMillingUnit5286.ParWaitForMotor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(416050239), "ParWaitForMotor", 
(::emMillingUnit5286.csStartEndMilling.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2223677132), "csStartEndMilling", 
(::emMillingUnit5286.signalToSafetyMotorIsAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1976478702), "signalToSafetyMotorIsAllowed", 
//Clients:
(::emMillingUnit5286.ctrlClamp1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2303827510), "ctrlClamp1", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::emMillingUnit5286.ctrlClamp2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(274255756), "ctrlClamp2", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::emMillingUnit5286.iPbClamp1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3066726219), "iPbClamp1", 
(::emMillingUnit5286.iPbClamp2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(801363697), "iPbClamp2", 
(::emMillingUnit5286.iSensorMillBack.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1728324171), "iSensorMillBack", 
(::emMillingUnit5286.ctrlEndStop.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2530327863), "ctrlEndStop", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::emMillingUnit5286.iOperationAllowed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(439506079), "iOperationAllowed", 
(::emMillingUnit5286.FCmaterialAtMill.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3516951453), "FCmaterialAtMill", 
(::emMillingUnit5286.iMotorActivated.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1376751410), "iMotorActivated", 
END_FUNCTION


#define USER_CNT_emMillingUnit5286 40

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emMillingUnit5286] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emMillingUnit5286::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emMillingUnit5286;
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #interlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #execResetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #execStarting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #execCompleting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #execHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #execHeld();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #execUnHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #execStopping();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #execSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #execSuspended();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #execUnSuspending();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimePullingMillForward.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimePullingMillForward.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeOutTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeOutTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	patTimeoutMatDetection.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF patTimeoutMatDetection.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParWaitForMotor.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParWaitForMotor.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	csStartEndMilling.pMeth			:= StoreMethod( #M_RD_DIRECT(), #csStartEndMilling::Write() );
	IF csStartEndMilling.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// IT 20-05-2022: class created for project 5286
// For this machine milling is done manually by pulling the mill forward and pressing 2 buttons with 2 hands
// Milling is enabled or dissabled with a switch, if that signal is not high, the production will go on without milling
// Milling is only possible when end sawing is done, FC detected a material at the mill, endstop is up and clamps are clamping



// errors: 1 - No material detected
//         2 - Mill is still back, pull it forward manually
//         3 - Mill motor is not ON 
//        101 - busy frontmilling
//        102 - busy endmilling


FUNCTION VIRTUAL emMillingUnit5286::preScanOverride
  
  //get status for clamps
  stsPosClamp1:=ctrlClamp1.stsPos;
  stsPosClamp2:=ctrlClamp2.stsPos;
  
  //get status for pb
  iPbClamp1:=iPbClamp1.Read();
  iPbClamp2:=iPbClamp2.Read();
  
  //read in if operation is allowed, and other digital inputs
  iOperationAllowed:=iOperationAllowed.Read();
  iMotorActivated:=iMotorActivated.Read();
  
  // get status for FC at mill or simulate detection during stprAction=2
  IF pmlCom.cmd.simulation<> allSimu THEN
    FCmaterialAtMill:=FCmaterialAtMill.Read();
  ELSIF stprAction=2 THEN
     FCmaterialAtMill:=1;
  ELSIF stprAction<>2 THEN
     FCmaterialAtMill:=0;
  END_IF;

  // get status for sensor mill is back
  IF pmlCom.cmd.simulation<> allSimu THEN
    iSensorMillBack:=iSensorMillBack.Read();
  ELSIF stprAction = 5 THEN // IT 24-05-2022 during milling simulate the sensor
    iSensorMillBack:= 0;
  ELSE
    iSensorMillBack:= 1;
  END_IF;


  IF stsInAlarm= 0 & tmpMotorNotRunningDuringAction= 2 THEN
    tmpMotorNotRunningDuringAction:= 0; //only reset after alarm is gone
  END_IF;    
  
  IF tmpMotorNotRunningDuringAction= 1 & timeOutMotor.done THEN
    giveAlarm(errorNr:=3);
    tmpMotorNotRunningDuringAction := 2; //means alarm is already given
  END_IF;
  
  //run timers
  timeoutMatDetection:= runTimer(Active:=stprAction=2, iMem:=timeoutMatDetection, TimerTime:=patTimeoutMatDetection, Pause:=FALSE);
  timeOutTimer:= runTimer(Active:=stprAction>0 & stprAction=oldStprAction, iMem:=timeOutTimer, TimerTime:=parTimeOutTime, Pause:=pmlCom.cmd.state<>Holding & pmlCom.cmd.state<>Suspending & pmlCom.cmd.state<>Execute);
  timeOutMotor:= runTimer(Active:=stprAction=6, iMem:=timeOutMotor, TimerTime:= parWaitForMotor, Pause:=FALSE);
  timeoutPullingMillForward:= runTimer(Active:=stprAction=5, iMem:=timeoutPullingMillForward, TimerTime:=parTimePullingMillForward, Pause:=FALSE);
 
  //make lubrication output 0
  oEnableLubrication:=0; 
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::work
   
  IF stsHMI_RunsAllowed & stprAction<> 0 & (pmlCom.sts.mode=manual | pmlCom.sts.mode= halfAuto | pmlCom.sts.mode= service) THEN //if hmi run is allowed, run action (if one was started)
    runAction();
  END_IF;

  IF ((pmlCom.sts.mode = auto & (oldMode = manual | oldMode = halfAuto)) | //stop movement if mode changes, but keep old auto stepper
    ((pmlCom.sts.mode = manual | pmlCom.sts.mode = halfAuto) & oldMode = auto)) & stprAction<> 0 THEN
    IF oldMode = auto | oldMode = service THEN
      oldAutoStprAction:=stprAction;
    END_IF;
    stprAction:=0;
  END_IF;
  oldMode:=pmlCom.sts.mode; 
  
  signalToSafetyMotorIsAllowed:= stsposClamp1= cilOut | stsPosClamp2= cilOut;
  
  oldButtonClamp1:=iPbClamp1;
  oldButtonClamp2:=iPbClamp2;
  
  IF stprAction = 2 & FCmaterialAtMill = 0 & timeoutMatDetection.done THEN
    giveAlarm(errorNr:=1); 
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::postScanOverride
  
  //if in manual mode, stop action if there is a problem
  IF (stsInAlarm= 1 | stsIsInterlocked= 1) & (pmlCom.sts.mode= manual | pmlCom.sts.mode= halfAuto) & stprAction<> 0 THEN 
    stprAction:=0;
  END_IF;

  //if in auto mode and there is an alarm, go to holding
  IF pmlCom.sts.inAlarm= 1 & pmlCom.sts.mode= auto THEN
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Holding;
  END_IF;
  
END_FUNCTION


FUNCTION emMillingUnit5286::runAction


  CASE stprAction OF
  
  0: // wait for start

  1: // started from calculation, direct send endstop up
    giveAlarm(errorNr:=101); //tell busy frontmilling
    pmlCom.sts.stateReq.ID:= id;
    pmlCom.sts.stateReq.state:= Suspending; //suspending because something is expected from operators, or it's an external fault  
    stprAction:= 3;
  
  2: // started from sawing, wait for sensor mat detection
    giveAlarm(errorNr:=102); //tell busy endmilling
    pmlCom.sts.stateReq.ID:= id;
    pmlCom.sts.stateReq.state:= Suspending; //suspending because something is expected from operators, or it's an external fault  
    IF FCmaterialAtMill THEN
      stprAction+= 1;
    END_IF;
    
  3: // send endstop up if IF is no longer detecting material
    IF FCmaterialAtMill = 0 THEN
      IF ctrlEndStop.stsPos = cilOut THEN
        stprAction+=1;
      ELSE
        ctrlEndStop.csMoveOut();
      END_IF;
    END_IF;
    
  4: // close clamps manually
    IF (iPbClamp1 & oldButtonClamp1 = 0) THEN
      IF stsPosClamp1= cilOut | stsPosClamp1= cilMovingOut THEN
        ctrlClamp1.csMoveIn();
      ELSE
        ctrlClamp1.csMoveOut();
      END_IF;
    END_IF;
    IF (iPbClamp2 & oldButtonClamp2 = 0) THEN
      IF stsPosClamp2= cilOut | stsPosClamp2= cilMovingOut THEN
        ctrlClamp2.csMoveIn();
      ELSE
        ctrlClamp2.csMoveOut();
      END_IF;
    END_IF;    
    
    IF (stsPosClamp1=cilOut | stsPosClamp2 = cilOut) & iMotorActivated THEN
      ctrlEndStop.csMoveIn(); // once the clamps are clamps are clamping, we can already send the endstop down        
      stprAction+=1;
    END_IF;
    
  5: // check if motor is ON and mill is pulled forward manually by the operator
    IF iMotorActivated & iSensorMillBack= 0 & signalToSafetyMotorIsAllowed THEN
      stprAction+=1;   
    ELSIF iSensorMillBack & timeoutPullingMillForward.done THEN
        giveAlarm(errorNr:=2);
//    ELSIF iMotorActivated = 0 & timeOutMotor.done THEN
//        giveAlarm(errorNr:=3); 
    END_IF; 
         
  6: // after mlling, check if mill is back
    IF iSensorMillBack THEN
      stprAction+=1;
    END_IF;     
      
  7: // open clamps automaticly after the motor is off
    IF iMotorActivated= 0 THEN
      stprAction +=1;
    END_IF;

  8: // check if clamps are open
    IF  stsPosClamp1 = cilIn & stsPosClamp2 = cilIn THEN
        stprAction+=1;
    ELSE
      ctrlClamp1.csMoveIn();
      ctrlClamp2.csMoveIn();
    END_IF;
        
  9: // check if endstop is down
    IF ctrlEndStop.stsPos = cilIn THEN
      stprAction+=1;
    ELSE
      ctrlEndStop.csMoveIn();
    END_IF;  

  10: //done, reset alarm
    IF _Alarm.ErrorNr = 101 | _Alarm.ErrorNr = 102 THEN
      resetAlarm();
    END_IF;
    stprAction:=0;
  
  END_CASE;

END_FUNCTION

FUNCTION emMillingUnit5286::runMoving

// we dont need this method

  CASE stprMoving OF
  
  0: //idle
  
  1: //start moving
    stprMoving:=0; 
  
  END_CASE;


END_FUNCTION

FUNCTION VIRTUAL emMillingUnit5286::interlock
  
  pmlCom.sts.isInterlocked:=pmlCom.cmd.interlock| tmpMotorNotRunningDuringAction<>0;  //also interlock if motor not running during movement
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execResetting
  
  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //send endstop down
    IF ctrlEndStop.stsPos = cilIn THEN
      stprState+=1;
    ELSE
      ctrlEndStop.csMoveIn();
    END_IF; 
  
  2://Open Clamps
    IF stsPosClamp1 = cilIn  & stsPosClamp2 = cilIn   THEN
      stprState+= 1;
    ELSE
      ctrlClamp1.csMoveIn();
      ctrlClamp2.csMoveIn();
    END_IF; 
  
  3: // done 
    stprState:= 1000;
      
  1000: //ready
  
  END_CASE;
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execStarting

  IF pmlCom.cmd.reRun= 0 THEN
    execResetting(); //just run reset
  ELSE
    execUnHolding();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execExecute
  
  runAction();
  runMoving();
  IF stprAction=0 THEN
    stprState:=1000; //only state completed if action is done
  ELSE
    stprState:=1;
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execSuspending

  runAction(); //just always run runaction, no need to be done before going to suspended
  stprState:= 1000;

END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execUnHolding
  CASE stprState OF
  
  0: //just go on
    stprState+=1;

  1: //reserve
      stprState+= 1;
   
  2: //check if old action nr. during was active, or action nr. still is active
//    IF oldAutoStprAction> 0 THEN
//      IF oldAutoStprAction <= 7 THEN //operation not yet done, start it again
//        stprAction:= 1;
//      ELSE
//        stprAction:=oldAutoStprAction; //operation already done, just do the things to make it complete
//      END_IF;
//      oldAutoStprAction:=0;
//    ELSIF stprAction> 0 THEN
//      IF stprAction<= 7 THEN //operation not yet done, start it again
//        stprAction:= 1;
//      END_IF;
//    END_IF;
    stprState+= 1;
    
  3: //all we have to do during unholding (and unsuspending and restarting) is to set the right nr. to the stprAction
    stprState:=1000;
    
  1000: //ready
  
  END_CASE;
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execUnSuspending
  
  execUnHolding();
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execCompleting
  
  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
   
  1: //that's it
    stprState:=1000;
    
  1000: //ready
  
  END_CASE;
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execHolding

  execSuspending();
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execStopping

  CASE stprState OF
  
  0: //just go on
    stprAction:= 0;
    stprMoving:= 0;
    oldStprAction:= 0;
    stprState+=1;
    
  1: //stop milling
  // here make sure the mill is back 
    stprState+= 1;
    // error? mill is not back

    
  2: //Open Clamps
    IF stsPosClamp1 = cilIn  & stsPosClamp2 = cilIn   THEN
      stprState+= 1;
    ELSE
      ctrlClamp1.csMoveIn();
      ctrlClamp2.csMoveIn();
    END_IF; 

     
  3: //that's it
    stprState:=1000;
    
  1000: //ready
  
  END_CASE;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL emMillingUnit5286::csStartEndMilling::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	csStartEndMilling := input;
  if stprAction = 0 then
    stprAction:= 2;
  end_if;

	result := csStartEndMilling;

END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execSuspended

    execExecute();
  
END_FUNCTION


FUNCTION VIRTUAL emMillingUnit5286::execHeld
  
    execExecute();
    
END_FUNCTION
