//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "FestoSimpelCANControl"
	Revision           = "0.4"
	GUID               = "{803752FE-7F84-4D63-A93B-B873DF5AE1E4}"
	RealtimeTask       = "true"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(364,120)">
	<Channels>
		<Server Name="CanRetour" GUID="{0D290EE5-5CA0-4A1C-9159-84D640970916}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="DeviceState" GUID="{9C9DDAC3-A32D-48AB-9BC1-FE689C6972DD}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="DOs_een" GUID="{092475A1-C9DC-4F4A-95AB-7A44BDF74115}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="DOs_twee" GUID="{46B2C008-6D05-4303-8D5E-19965698EC60}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ErrorCntr" GUID="{77215A95-E328-49E8-A663-A2D595FC7BD9}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ErrorNr" GUID="{AAB320DF-030D-41F3-8B3E-5584CDD5E067}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ResetAlarms" GUID="{C6AC172C-B795-43D7-BCC2-69FD564C85A1}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Status" GUID="{714F9BEF-8DB5-483F-B114-A7B1FC9D0525}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="State is 1 als alles goed is,&#13;&#10;anders 0. Wanneer deze nul is moet&#13;&#10;de machine volledig stoppen."/>
		<Server Name="Status_CommunicationOk" GUID="{4DF74A6A-5BA3-4790-99D9-64AEEF0C6EC1}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Stepper" GUID="{FEAED390-A04D-4E8C-B6AD-FE565741189F}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Alarm" Required="true" Internal="false"/>
		<Client Name="AutoRestart" Required="true" Internal="false"/>
		<Client Name="DIs_een" Required="true" Internal="false"/>
		<Client Name="DIs_twee" Required="true" Internal="false"/>
		<Client Name="Enable" Required="false" Internal="false" DefValue="1"/>
		<Client Name="iStuurstroom" Required="false" Internal="false"/>
		<Client Name="RtNext" Required="false" Internal="false"/>
		<Client Name="timeOutMachineState" Required="true" Internal="false"/>
		<Client Name="ToCanOpen" Required="true" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="SigmaControl" Author="Johan Embregts"/>
		<Dokumentation Revision="0.4" Date="2013-09-13" Author="Johan Embregts" Company="SigmaControl" Description="Timeouts in step 3, 4, 7, 8.&#13;&#10;Error_Counter is incermented."/>
		<Dokumentation Revision="0.3" Date="2013-06-20" Author="Johan Embregts" Company="SigmaControl" Description="Added &quot;Enable&quot; Client to enable/disable this object."/>
		<Dokumentation Revision="0.2" Date="2012-04-17" Author="Johan Embregts" Company="SigmaControl" Description="IO addjusted for festo."/>
		<Dokumentation Revision="0.1" Date="2011-12-27" Author="Johan Embregts" Company="SigmaControl" Description="Standerd initial with HeartBeat."/>
		<Dokumentation Revision="0.0" Date="2010-12-14" Author="Johan Embregts" Company="SigmaControl" Description="Created."/>
	</RevDoku>
</Class>
*)
FestoSimpelCANControl : CLASS
  //Servers:
	Status 	: SvrChCmd_DINT;
	Stepper 	: SvrCh_DINT;
	DeviceState 	: SvrCh_CanDeviceStateTxt;
	ResetAlarms 	: SvrCh_DINT;
	DOs_een 	: SvrCh_BDINT;
	DOs_twee 	: SvrCh_BDINT;
	ErrorCntr 	: SvrCh_DINT;
	CanRetour 	: SvrCh_DINT;
	ErrorNr 	: SvrCh_DINT;
	Status_CommunicationOk 	: SvrCh_DINT;
  //Clients:
	ToCanOpen 	: CltChCmd_CanOpenBase;
	Enable 	: CltCh_DINT;
	RtNext 	: CltChCmd_BDINT;
	DIs_een 	: CltCh_BDINT;
	DIs_twee 	: CltCh_BDINT;
	AutoRestart 	: CltCh_DINT;
	timeOutMachineState 	: CltCh_UDINT;
	iStuurstroom 	: CltCh_DINT;
	Alarm 	: CltCh_DINT;
  //Variables:
		FirstRt 	: UDINT;
		NotAlive 	: DINT;
		DeviceHomed 	: DINT;
		tMark 	: UDINT;
		IntDevState 	: CanDeviceStateTxt;
		SdoIn 	: SDOStr;
		SdoOut 	: SDOStr;
		Pdo1In 	: PDOStr;
		Pdo2In 	: PDOStr;
		Pdo3In 	: PDOStr;
		Pdo4In 	: PDOStr;
		Pdo1Out 	: PDOStr;
		Pdo2Out 	: PDOStr;
		Pdo3Out 	: PDOStr;
		Pdo4Out 	: PDOStr;
		RespConf 	: DINT;
		RespPdoTx 	: DINT;
		OldDeviceState 	: CanDeviceStateTxt;
		timerState 	: UDINT;
		errorTimer 	: UDINT;
		errorState : BDINT
		[
		];

		errorActive 	: DINT;
		FoutTeller 	: DINT;
		Fout : ARRAY [0..1000] OF Failure;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL PreScan;
	
	FUNCTION VIRTUAL BootUpMachine;
	
	FUNCTION VIRTUAL PostScan;
	
	FUNCTION VIRTUAL GLOBAL ResetAlarms::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd CanOpenBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB FestoSimpelCANControl::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_FESTOSIMPELCANCONTROL
0$UINT, 4$UINT, (SIZEOF(::FestoSimpelCANControl))$UINT, 
10$UINT, 9$UINT, 0$UINT, 
TO_UDINT(3174472929), "FestoSimpelCANControl", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::FestoSimpelCANControl.Status.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2348327578), "Status", 
(::FestoSimpelCANControl.Stepper.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(663165702), "Stepper", 
(::FestoSimpelCANControl.DeviceState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4203537714), "DeviceState", 
(::FestoSimpelCANControl.ResetAlarms.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1826422130), "ResetAlarms", 
(::FestoSimpelCANControl.DOs_een.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1438647486), "DOs_een", 
(::FestoSimpelCANControl.DOs_twee.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3972766258), "DOs_twee", 
(::FestoSimpelCANControl.ErrorCntr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3314517312), "ErrorCntr", 
(::FestoSimpelCANControl.CanRetour.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1547719231), "CanRetour", 
(::FestoSimpelCANControl.ErrorNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3474608145), "ErrorNr", 
(::FestoSimpelCANControl.Status_CommunicationOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1545610324), "Status_CommunicationOk", 
//Clients:
(::FestoSimpelCANControl.ToCanOpen.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3700372892), "ToCanOpen", TO_UDINT(4284412609), "CanOpenBase", 0$UINT, 9$UINT, 
(::FestoSimpelCANControl.Enable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(56102836), "Enable", 
(::FestoSimpelCANControl.RtNext.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(787039168), "RtNext", 
(::FestoSimpelCANControl.DIs_een.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2207901603), "DIs_een", 
(::FestoSimpelCANControl.DIs_twee.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2400956168), "DIs_twee", 
(::FestoSimpelCANControl.AutoRestart.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3115317655), "AutoRestart", 
(::FestoSimpelCANControl.timeOutMachineState.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2261258297), "timeOutMachineState", 
(::FestoSimpelCANControl.iStuurstroom.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(875734909), "iStuurstroom", 
(::FestoSimpelCANControl.Alarm.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2211153005), "Alarm", 
END_FUNCTION


#define USER_CNT_FestoSimpelCANControl 3

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_FestoSimpelCANControl] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION FestoSimpelCANControl::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_FestoSimpelCANControl, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #PreScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #BootUpMachine();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #PostScan();

#pragma warning (default : 74)
	Status.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Status.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Stepper.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Stepper.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ResetAlarms.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ResetAlarms::Write() );
	IF ResetAlarms.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DOs_een.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DOs_een.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DOs_twee.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DOs_twee.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//errornr 10 = undervoltage ventielen
//errornr 11 = kortsluiting ventielen
//errornr 12 = draadbreuk ventielen
//errornr 13 = anders ventielen
//errornr 20 = undervoltage outputs
//errornr 21 = kortsluiting outputs
//errornr 22 = draadbreuk outputs
//errornr 23 = anders outputs
//errornr 30 = undervoltage inputs
//errornr 31 = kortsluiting inputs
//errornr 32 = draadbreuk inputs
//errornr 33 = anders inputs
//errornr 40 = undervoltage ventielen en outputs
//errornr 41 = kortsluiting ventielen en outputs
//errornr 42 = draadbreuk ventielen en outputs
//errornr 43 = anders ventielen en outputs
//errornr 50 = undervoltage ventielen/outputs en inputs
//errornr 51 = kortsluiting ventielen/outputs en inputs
//errornr 52 = draadbreuk ventielen/outputs en inputs
//errornr 53 = anders ventielen/outputs en inputs

//#Define cNoNmtIfOk
#Define cCommTo     1000
#Define cHeartBeat  100


FUNCTION VIRTUAL GLOBAL FestoSimpelCANControl::Init

  // Set to initial 
  tMark := ops.tAbsolute;
  Status := 0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FestoSimpelCANControl::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // First flag from previous object
  FirstRt := Eax;
  
  // Only send Sync once!
  if FirstRt= 1 then
    ToCanOpen.BuildSync(SyncId := cSync);
  end_if;
  
  if Enable= 1 then // #JE 20130620 enable/disable this object.

    if Stepper = 100 then //PDO 1  enkel doen als stepper 100 is, PDO 4 (error etc.) ook proberen te doen als er 
                         //PDO 2 en 3 zijn voor de analoge in- en uitgangen, dat slaan we nog even over          
      // Send PDO
      //nog omwerken naar DOs een en twee
      Pdo1Out.Val1    := to_int(DOs_een and 16#0000FFFF); //enkel eerste 16 ingangen pakken
      Pdo1Out.Val2    := to_Int(( DOs_een shr 16) and 16#0000FFFF); //enkel laatste 16 ingangen pakken
      Pdo1Out.Val3    := to_int(DOs_twee and 16#0000FFFF); //enkel eerste 16 ingangen pakken
      Pdo1Out.Val4    := to_Int(( DOs_twee shr 16) and 16#0000FFFF); //enkel laatste 16 ingangen pakken
      CanRetour := RespPdoTx := ToCanOpen.BuildPDO(PdoId:=cPdoTx1, Value1:= Pdo1Out.Val1, Value2:= Pdo1Out.Val2, Value3:= Pdo1Out.Val3, Value4:= Pdo1Out.Val4);
    
      // Recieve PDO
      CanRetour := ToCanOpen.DecoPDO(PdoId:= cPdoRx1, Value1:= #Pdo1In.Val1, Value2:= #Pdo1In.Val2, Value3:= #Pdo1In.Val3, Value4:= #Pdo1In.Val4);
      if CanRetour <> -1 then
        // Recieved
        DIs_een := to_udint( Pdo1In.Val1 ) OR (to_udint( Pdo1In.Val2 ) Shl 16);
        DIs_twee := to_uDint( Pdo1In.Val3 ) OR (to_UDint( Pdo1In.Val4 ) Shl 16);
        DIs_een.Write(input:=DIs_een);
        DIs_twee.Write(input:=DIs_twee);

        // Alive flag is very direct
        NotAlive := 0;
      else
        NotAlive += 1;
      end_if;

    end_if;
    
    //foutmeldingen opvragen
    if ToCanOpen.DecoPDO(PdoId:= cPdoRx4, Value1:= #Pdo4In.Val1, Value2:= #Pdo4In.Val2, Value3:= #Pdo4In.Val3, Value4:= #Pdo4In.Val4)=0 then 
    
      //eerste gedeelte alleen voor testen
      Fout[FoutTeller].One := to_udint(Pdo4In.Val1) OR (to_udint(Pdo4In.Val2) Shl 16);
      Fout[FoutTeller].Two := to_uDint( Pdo1In.Val3) OR (to_UDint( Pdo1In.Val4) Shl 16);
      FoutTeller += 1;
      if FoutTeller > 1000 then
        FoutTeller := 0;
      end_if;
      
      
      //dit is de manier om errors te achterhalen, als er een error is nog dieper doorvragen, dat komt nog
      errorActive := Pdo4In.Val1 > 0;
      if errorActive <> 0 then
        if ops.tAbsolute - errorTimer < 100 then
          errorState := errorState OR to_udint(Pdo4In.Val1);
        else
          errorState := to_udint(Pdo4In.Val1);
        end_if;
        if errorState.3 = 1 then //betekend dat de ingangen niet meer werken, dus de status laag maken zodat alles stopt
          Status := 0;
        else
          Status := 1; //anders kan de status op 1 worden gezet, de verbinding is in de lucht anders zijn we hier niet, en de ingangen werken
        end_if;
      end_if;
      
      
    end_if;
      
    
  end_if;
  
  // Call next Objext if present
  if IsClientConnected(#RtNext) then
    RtNext.RtWork( 0);
  end_if;

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL FestoSimpelCANControl::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  PreScan();
  if Enable= 1 then // #JE 20130620 enable/disable this object.
    BootUpMachine();
//    StateMachine();
//    Guarding();
  end_if;
  PostScan();

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL FestoSimpelCANControl::PreScan

//errornr 10 = undervoltage ventielen
//errornr 11 = kortsluiting ventielen
//errornr 12 = draadbreuk ventielen
//errornr 13 = anders ventielen
//errornr 20 = undervoltage outputs
//errornr 21 = kortsluiting outputs
//errornr 22 = draadbreuk outputs
//errornr 23 = anders outputs
//errornr 30 = undervoltage inputs
//errornr 31 = kortsluiting inputs
//errornr 32 = draadbreuk inputs
//errornr 33 = anders inputs
//errornr 40 = undervoltage ventielen en outputs
//errornr 41 = kortsluiting ventielen en outputs
//errornr 42 = draadbreuk ventielen en outputs
//errornr 43 = anders ventielen en outputs
//errornr 50 = undervoltage ventielen/outputs en inputs
//errornr 51 = kortsluiting ventielen/outputs en inputs
//errornr 52 = draadbreuk ventielen/outputs en inputs
//errornr 53 = anders ventielen/outputs en inputs
  
  Enable  := Enable.Read();
  timeOutMachineState := timeOutMachineState.Read();
  
  
  
  //stukje alarmafhandeling, dit hoeft niet in het realtimegedeelte
  iStuurstroom := iStuurstroom.Read();
  if ops.tAbsolute - errorTimer > 100 then
    if errorActive = 1 & Alarm = 0 then
      if errorState.3 = 0 & errorState.5 = 1 & iStuurstroom = 0 then //als de ingangen geen error hebben ligt een undervoltage als er geen stuurstroom is aan deze stuurstroom, hier wordt elders een alarm voor gegeven
        ErrorNr := 0;
        Alarm := 0;
      else
        if errorState.1 = 1 & errorState.2 = 0 & errorState.3 = 0 then
          ErrorNr := 10;
        elsif errorState.1 = 0 & errorState.2 = 1 & errorState.3 = 0 then
          ErrorNr := 20;
        elsif errorState.1 = 0 & errorState.2 = 0 & errorState.3 = 1 then
          ErrorNr := 30;
        elsif errorState.1 = 1 & errorState.2 = 1 & errorState.3 = 0 then
          ErrorNr := 40;
        elsif (errorState.1 = 1 | errorState.2 = 1) & errorState.3 = 1 then
          ErrorNr := 50;
        end_if;
    
        if errorState.5 = 1 then
          ErrorNr += 0;
        elsif errorState.6 = 1 then
          ErrorNr += 1;
        elsif errorState.7 = 1 then
          ErrorNr += 2;
        elsif errorState.8 = 1 then
          ErrorNr += 3;
        end_if;
        Alarm := 1;
        Alarm.Write(input:=Alarm);
        
      end_if;
    elsif errorActive = 0 & Alarm = 1 then
      Alarm := 0;
      Alarm.Write(input:=Alarm);
    end_if;
  end_if;
  
  
END_FUNCTION


FUNCTION VIRTUAL FestoSimpelCANControl::BootUpMachine
  
  // Read node state (16#700 + node)
  
  if ops.tAbsolute - timerState > timeOutMachineState then
    DeviceState := cIdle;
  end_if;
  if ToCanOpen.DecoNMT( NmtId := cNmtErr, DeviceState := #IntDevState)= 0 then
    DeviceState:=IntDevState;
    timerState := ops.tAbsolute;
  end_if;

//********************************************************
//Initialiseren
//********************************************************

  case Stepper of
    
  0: // Wait for State change from cNmtErr
    
    if DeviceState<>cIdle then
      Stepper := 1;
      tMark:=ops.tAbsolute;
    elsif ops.tAbsolute-tMark>= cCommTo then
      // When not recieved trigger one
      ErrorCntr += 1;
      ToCanOpen.BuildNmt(NmtId:=cNmt, Cmnd:=cNMTResetNode);
      tMark:=ops.tAbsolute;
    end_if;
    
  1: // cNMT goto Pre-Op
    if DeviceState = cOperational then
      //avdb 26012019 when communication fails after it has been setup stepper is set to 0 but devicestate is not updated
      // so communicationcheck thinks all is still ok. SO set devicestate to cInitialising bc after this we try to restart 
      DeviceState:= cInitialising;
    end_If;
    
    if ToCanOpen.BuildNmt(NmtId:=cNmt, Cmnd:=cNMTGoPreOper)=0 then
      Stepper+=1;
      tMark:=ops.tAbsolute;
    end_if;
    
  2:  // Set HeartBeat to 1Sec
    if DeviceState = cOperational then
      //avdb 26012019 when communication fails after it has been setup stepper is set to 0 but devicestate is not updated
      // so communicationcheck thinks all is still ok. SO set devicestate to cInitialising bc after this we try to restart 
      DeviceState:= cInitialising;
    end_If;
    
    if ops.tAbsolute- tMark> 1000 then
      ToCanOpen.BuildSDO(SdoId:=cSdoTx1, Cmnd:=cWrReq2, Index:=16#1017, SIndex:=00, Value:= cHeartBeat);
      Stepper+=1;
      tMark:=ops.tAbsolute;
    end_if;
    
  3:
    if ToCanOpen.DecoSDO(SdoId:=cSdoRx1, CmndState:=#SdoIn.CmndCode, Index:=#SdoIn.Index, SIndex:=#SdoIn.SIndex, Value:=#SdoIn.Value)= 0 then
      if SdoIn.CmndCode<> cErrRsp then
        Stepper+=1;
        tMark:=ops.tAbsolute;
      else
        // What to do!!!
        ErrorCntr += 1;
      end_if;
    elsif ops.tAbsolute- tMark> cCommTo then
      ErrorCntr += 1;  // #JE 20130913
      Stepper := 2;
    end_if;
    
  4: // Wait for drive to reach Pre-Op
    #ifdef cNoNmtIfOk
      if ops.tAbsolute- tMark> 1000 then
        DeviceState:=cPreOperational;
      end_if;
    #endif
    if DeviceState=cPreOperational then
      Stepper+=3; //oversturen van de config overslaan
      tMark:=ops.tAbsolute;
    elsif ops.tAbsolute- tMark> cCommTo then  // #JE 20130913 On time out retry from the top.
      ErrorCntr += 1;
      Stepper := 1;
    end_if;
    
  5: // Start sending SDO's with config table
    RespConf  := ToCanOpen.StartConfig();
    case RespConf of
    0:
      Stepper +=1;
    -2: // No Config table
      Stepper +=2;
    -1: // Error;
      Stepper := 0;
    end_case;
    tMark :=ops.tAbsolute;
    
  6: // Wait for config table to be send.
    if ToCanOpen.CommandDone()=0 then
     Stepper+=1;
      tMark:=ops.tAbsolute;
//    elsif ops.tAbsolute- tMark> cCommTo then  // To dangerous for how large is the Config Table?
//      ErrorCntr += 1;
//      Stepper := 1;
    end_if;
    
  7: // cNMT goto Opperational
    if ToCanOpen.BuildNmt(NmtId:=cNmt, Cmnd:=cNMTStartRemote)=0 then
      Stepper+=1;
      tMark:=ops.tAbsolute;
    elsif ops.tAbsolute- tMark> cCommTo then  // #JE 20130913 On time out retry from the top.
      ErrorCntr += 1;
      Stepper := 1;
    end_if;
    
  8: // Wait for drive to reach Pre-Op
    #ifdef cNoNmtIfOk
      if ops.tAbsolute- tMark> 1000 then
        DeviceState:=cOperational;
      end_if;
    #endif
    if DeviceState=cOperational then
      Stepper+=1;
      tMark:=ops.tAbsolute;
    elsif ops.tAbsolute- tMark> cCommTo then  // #JE 20130913 On time out retry from the top.
      ErrorCntr += 1;
      Stepper := 1;
    end_if;
    
  9: // BootUp has finished
    Status := 1; //everything seems to be ok
    Stepper := 100;
    (*
     * State machine
     *)
     
  100: //keep controlling machine state
    if DeviceState <> cOperational then //not good
      OldDeviceState := DeviceState;
      

      
      Status := 0; //not ok any more
      Stepper += 1;
    end_if;
    
  101: //restart or wait
    if AutoRestart = 1 then

      Stepper := 0;
    end_if;

  end_case;

END_FUNCTION


FUNCTION VIRTUAL FestoSimpelCANControl::PostScan
Status_CommunicationOk := DeviceState = cOperational & Stepper = 100;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL FestoSimpelCANControl::ResetAlarms::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ResetAlarms := input;
  if Stepper = 101 then
    Stepper := 0;
  end_if;
	result := ResetAlarms;

END_FUNCTION
