//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define LOGENTRY_SIZE 999

#define RINGBUFFER_SIZE   30
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "UserParaLogger"
	Revision           = "1.23"
	GUID               = "{CCE911F0-5DB6-4AA5-9B05-BA3E7F791780}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Data_Logger\block.ico"
	SharedCommandTable = "true"
	Objectsize         = "(420,360)"
	Comment            = "UserParaLogger writes changed parameter into a log file&#13;&#10;&#13;&#10;">
	<Channels>
		<Server Name="EntryNo" GUID="{B3474E2B-C172-4074-A476-F72971961EEE}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Number of entries in the file"/>
		<Server Name="ErrorSaveFile" GUID="{6062D082-2FDF-4EA4-AA5E-AC5D04052332}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="ActDate" Required="false" Internal="false" Comment="Connection to the SysDate client of the _SysDateTime so that the date can be logged in the file (optional)"/>
		<Client Name="ActTime" Required="false" Internal="false" Comment="Connection the the SysDate client of the _SysDateTime so that the time can be logged in the file (optional)"/>
		<Client Name="AsyncSave" Required="false" Internal="false" Comment="1 = save value asynchronous"/>
		<Client Name="coFileSys" Required="false" Internal="false" Comment="Object channel to the _FileSys class"/>
		<Client Name="coStdLib" Required="false" Internal="false"/>
		<Client Name="MaxEntry" Required="true" Internal="false" DefValue="1000" Comment="Number of entries in a Log file"/>
		<Client Name="XAccessLevel" Required="false" Internal="false" Comment="Connection to the level client of the _XAccess class so that the user level can be entered in the file"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.23" Date="2016-11-23" Author="HubChr" Company="Sigmatek" Description="Fixed Access Exception that occurred when logging strings longer than 60 signs"/>
		<Dokumentation Revision="1.22" Date="2016-07-07" Author="slimic" Company="Sigmatek" Description="Add a Ringbuffer for the entrys so that no messages get lost."/>
		<Dokumentation Revision="1.21" Date="2014-04-30" Author="spimar" Company="Sigmatek" Description="Changed local method InsertDateTimeLevelStamp() to virtual;"/>
		<Dokumentation Revision="1.20" Date="2014-04-25" Author="spimar" Company="Sigmatek" Description="Pointer which is set as input parameter has no valid memory block"/>
		<Dokumentation Revision="1.10" Date="2013-01-09" Author="wesand" Company="Sigmatek" Description="Improvement: New client can be activated that the class works with asynchrone filefunctions;&#13;&#10;New server which shows the error state of the class"/>
		<Dokumentation Revision="1.4" Date="2012-03-20" Author="spimar" Company="Sigmatek" Description="Added performance improvements;"/>
		<Dokumentation Revision="1.3" Date="2012-03-09" Author="spimar" Company="Sigmatek" Description="Big local variables were set to member variables to save memory on the stack;"/>
		<Dokumentation Revision="1.2&#13;&#10;" Date="04.02.08" Author="ahö&#13;&#10;" Company="Sigmatek" Description="Compilerfehler wenn UC_Unicode eingeschalten wurde.&#13;&#10;"/>
	</RevDoku>
	<Network Name="UserParaLogger">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{05E1FF7C-949A-4780-B464-6EB6950224D1}"
				Class      = "_Global"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Lse"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(690,210),(518,210),"/>
			<Connection Source="_base.Lse" Destination="this.Lse" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using _Global

UserParaLogger : CLASS
: _Global
	TYPE
	  _SSWASYNC :
	  (
	    AsyncIdle,
	    AsyncFileOpen,
	    AsyncWait4Open,
	    AsyncFileSeek,
	    AsyncWait4Seek,
	    AsyncWrite,
	    AsyncWait4Write,
	    AsyncClose,
	    AsyncWait4Close
	  )$UDINT;
	  EntrySize : ARRAY [0..LOGENTRY_SIZE-1] OF _ASCII;
#pragma pack(push, 1)
	  MessageBuffer : STRUCT
	    udMemSize : UDINT;
	    pStart : ^EntrySize;
	    pEnd : ^EntrySize;
	    pWrite : ^EntrySize;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	EntryNo 	: SvrCh_UDINT;
	ErrorSaveFile 	: SvrCh_DINT;
  //Clients:
	MaxEntry 	: CltCh_UDINT;
	ActDate 	: CltCh_HDINT;
	ActTime 	: CltCh_HDINT;
	XAccessLevel 	: CltCh_DINT;
	AsyncSave 	: CltCh_DINT;
	coFileSys 	: CltChCmd__FileSys;
	coStdLib 	: CltChCmd__StdLib;
  //Variables:
		File 	: _LSEFILE;
		txt : ARRAY [0..LOGENTRY_SIZE] OF _CHAR;

		txt1 : ARRAY [0..LOGENTRY_SIZE] OF _ASCII;

		len 	: UDINT;
		AsyncSSW 	: _SSWASYNC;
		dTmpID 	: DINT;
		dTmpHandle 	: DINT;
		myst 	: BOOL;
		FileInfo 	: _DDE_INFO;
		dFindHandle 	: DINT;
		MsgBuffer 	: MessageBuffer;
		pMsgRead 	: ^EntrySize;
		pMsgToWrite 	: ^EntrySize;
		EntriesWritten 	: UDINT;
		dNewMsgs 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL IF_WindowRun
		VAR_INPUT
			whoami 	: ^_WHOAMI;
			pic 	: ^void;
			event 	: ^_EVENT;
		END_VAR;
				//! <Function Comment="This interface is called from the Lse, after the project was loaded.&#13;&#10;In this method it will be inspected, if the log file already exist. &#13;&#10;If the log file does not exist, it will be created.&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;" Name="IF_ProjectReady"/>
	FUNCTION VIRTUAL GLOBAL IF_ProjectReady
		VAR_INPUT
			state 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
				//! <Function Comment="This interface is called from the Lse, if the value&#13;&#10;of an Server has changed. Afterwards the methode will&#13;&#10;write the log file.  &#13;&#10;&#13;&#10;" Name="IF_Write"/>
	FUNCTION VIRTUAL GLOBAL IF_Write
		VAR_INPUT
			pres 	: ^_RESULT;
			pvar 	: ^_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION FormatResult
		VAR_INPUT
			ptxt 	: ^_CHAR;
			pres 	: ^_RESULT;
			pva 	: ^_VARIABLE;
		END_VAR;
	
	FUNCTION VIRTUAL InsertDateTimeLevelStamp
		VAR_INPUT
			ptxt 	: ^_CHAR;
		END_VAR;
				//! <Function Comment="In this method, the path and name of the log file will be set.&#13;&#10;" Name="GetDPNE"/>
	FUNCTION VIRTUAL GLOBAL GetDPNE
		VAR_INPUT
			selection 	: DINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_ASCII;
		END_VAR;
				//! <Function Comment="In this method it will be checked, if an entrance in the &#13;&#10;log file will be done." Name="DoLogging"/>
	FUNCTION VIRTUAL GLOBAL DoLogging
		VAR_INPUT
			pvar 	: ^_VARIABLE;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CreateFile;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys
#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB UserParaLogger::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_USERPARALOGGER
1$UINT, 23$UINT, (SIZEOF(::UserParaLogger))$UINT, 
2$UINT, 7$UINT, 0$UINT, 
TO_UDINT(310856993), "UserParaLogger", //Class
TO_UDINT(3788417926), "_Global", 0$UINT, 15$UINT, //Baseclass
//Servers:
(::UserParaLogger.EntryNo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4184763179), "EntryNo", 
(::UserParaLogger.ErrorSaveFile.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2215527186), "ErrorSaveFile", 
//Clients:
(::UserParaLogger.MaxEntry.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3477886175), "MaxEntry", 
(::UserParaLogger.ActDate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2248193448), "ActDate", 
(::UserParaLogger.ActTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1124735639), "ActTime", 
(::UserParaLogger.XAccessLevel.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2519733143), "XAccessLevel", 
(::UserParaLogger.AsyncSave.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(716315224), "AsyncSave", 
(::UserParaLogger.coFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(940542775), "coFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::UserParaLogger.coStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3815072667), "coStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_UserParaLogger 48

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_UserParaLogger] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION UserParaLogger::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= _Global::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= _Global::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, _Global::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_UserParaLogger;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #IF_WindowRun();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #IF_ProjectReady();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #IF_Write();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #InsertDateTimeLevelStamp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[46]		:= #GetDPNE();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[47]		:= #DoLogging();

#pragma warning (default : 74)
	_Global::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF _Global::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL UserParaLogger::Init

  _Global::Init();
  EntryNo := 0;
  EntriesWritten := 0;

  //SliMic 110716-----------------------------------
  // Allocate the Memory for the Ringbuffer
  if _FirstScan then
    MsgBuffer.udMemSize := (sizeof(EntrySize) * RINGBUFFER_SIZE);

    MsgBuffer.pStart$^void := coStdLib.Malloc(size:= MsgBuffer.udMemSize);

    if MsgBuffer.pStart <> NIL then
      
      MsgBuffer.pWrite := MsgBuffer.pStart;
      MsgBuffer.pEnd := (MsgBuffer.pStart + (MsgBuffer.udMemSize - sizeof(EntrySize)));   // (MsgBuffer.udMemSize - sizeof(EntrySize) because we want the last data field where can write a msg
      pMsgRead := MsgBuffer.pStart;
      
    else

      // ERROR

    end_if;
  end_if;
  //SliMic 110716-----------------------------------

END_FUNCTION


FUNCTION VIRTUAL GLOBAL UserParaLogger::IF_ProjectReady
	VAR_INPUT
		state 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    size      : udint;
    no        : udint;
    xeno      : udint;
//WESAND 130108    myst      : bool;
    tmp       : array[0..LOGENTRY_SIZE] of _ASCII;
  end_var

  // clarify environment for logfile

  myst := false;

  if(Lse_File_Open(#File, LOAD, GetDPNE(0)) = true) then
    // logfile already exists
    size := to_udint(Lse_File_Length(#File));
    if(size = (MaxEntry * LOGENTRY_SIZE)) then
      // logfile is at same size
      no   := MaxEntry;
      myst := true;
      
      // get number of entries
      while(no) do
        no -= 1;
        if(Lse_File_Read(#File, #tmp[0], LOGENTRY_SIZE) = true) then
          xeno := to_udint(AToD(#tmp[0], sizeof(_ASCII)));
          if(xeno > EntryNo) then
            EntryNo := xeno;
            EntriesWritten := xeno;     // SLiMic 110716
          end_if;
        else
          no   := 0;
          myst := false;
        end_if;
      end_while;
    end_if;
    Lse_File_Close(#File);
  end_if;

  if(myst = false) then
    // logfile doesn't exist, create new one
    if(Lse_File_Open(#File, SAVE, GetDPNE(0)) = true) then
      CreateFile();//WESAND 130108
(*WESAND 130108    
      no := MaxEntry;
      _memset(#tmp[0], ' ', LOGENTRY_SIZE);
      tmp[LOGENTRY_SIZE - 2] := 13;
      tmp[LOGENTRY_SIZE - 1] := 10;
      tmp[0] := '0';
      tmp[1] := ':';
      myst   := true;
      
      // initialize all entries
      while(no) do
        no -= 1;
        if(Lse_File_Write(#File, #tmp[0], LOGENTRY_SIZE) = false) then
          myst := false;
          no := 0;
        end_if;
      end_while;
      Lse_File_Close(#File);
WESAND 130108*)           
    end_if;
  end_if;

  if(myst = true) then
    // logfile is already existing and status is ok
    EntryNo += 1;
    EntriesWritten += 1;      // SLiMic 110716
  else
    // unknown error at logfile
    EntryNo := 0;
    EntriesWritten := 0;      // SliMic 110716
  end_if;
  
  retcode := true;

END_FUNCTION


FUNCTION UserParaLogger::FormatResult
	VAR_INPUT
		ptxt 	: ^_CHAR;
		pres 	: ^_RESULT;
		pva 	: ^_VARIABLE;
	END_VAR
  var
    tmpstr : array[0..60] of _CHAR;
    result : _RESULT;
  end_var

  result := pres^;

  if(pres^.ftype = RES_ANUMERIC) then // string
    StrNCpy(p0:=#tmpstr[0], x1:=sizeof(_CHAR), p2:=result.ptr$^_CHAR, x3:=sizeof(_CHAR), ml:=60); // HubChr v1.23
  elsif(pres^.ftype = RES_TIME) then // time
    format_time(#tmpstr[0], #result.datim.ftime, pva^.info.format);
    DelSpace(#tmpstr[0], sizeof(_CHAR));
  elsif(pres^.ftype = RES_DATE) then // date
    format_date(#tmpstr[0], #result.datim.fdate, pva^.info.format);
    DelSpace(#tmpstr[0], sizeof(_CHAR));
  else // value
    recalculate(#result, pva, true);
    lse_format_value(#tmpstr[0], result.value, #pva^.info, NIL);
    DelSpace(#tmpstr[0], sizeof(_CHAR));
  end_if;

  StrCpy(ptxt, sizeof(_CHAR), #tmpstr[0], sizeof(_CHAR));

END_FUNCTION


FUNCTION VIRTUAL UserParaLogger::InsertDateTimeLevelStamp
	VAR_INPUT
		ptxt 	: ^_CHAR;
	END_VAR
  var
    xdat : _DATE;
    xtim : _TIME;
  end_var

  if(IsClientConnected(#ActDate)) then
    ActDate$udint := ActDate.Read();
    lasal_to_date(#xdat, ActDate$dint);
    format_date(ptxt$^_CHAR + StrLen(ptxt, sizeof(_CHAR))*SIZEOF(_CHAR), #xdat, SIZE_DDMMYY);
    StrCat(ptxt, sizeof(_CHAR), ", ", sizeof(_ASCII));
  end_if;
  
  if(IsClientConnected(#ActTime)) then
    ActTime$udint := ActTime.Read();
    lasal_to_time(#xtim, ActTime$dint);
    format_time(ptxt$^_CHAR + StrLen(ptxt, sizeof(_CHAR))*SIZEOF(_CHAR), #xtim, SIZE_HHMMSS);
    StrCat(ptxt, sizeof(_CHAR), ", ", sizeof(_ASCII));
  end_if;
  
  if(IsClientConnected(#XAccessLevel)) then
    StrCat(ptxt, sizeof(_CHAR), "Level-", sizeof(_ASCII));
    DToA(ptxt + StrLen(ptxt, sizeof(_CHAR))*SIZEOF(_CHAR), XAccessLevel.Read(), 16#0800, sizeof(_CHAR));
    StrCat(ptxt, sizeof(_CHAR), ", ", sizeof(_ASCII));
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL UserParaLogger::IF_Write
	VAR_INPUT
		pres 	: ^_RESULT;
		pvar 	: ^_VARIABLE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  var
    tmpres : _RESULT;
    tmpvl : _VARLABEL;
    tmpvar : _VARIABLE;
//    txt : array[0..LOGENTRY_SIZE] of _CHAR; //spimar 9.3.2012
    tmpvo : _UBYTE;
    punit : ^_CHAR;
//WESAND 130108    len : udint;
//    txt1 : array[0..LOGENTRY_SIZE] of _ASCII; //spimar 9.3.2012
    pTempPath : ^_ASCII;
    pTempFile : ^_ASCII;
  end_var

//  udStartTime := OS_READMICROSEC();

  retcode := true;

  // look if logfile is ok and protocolbit is set at server
  if((EntryNo > 0) & (DoLogging(pvar) = true)) then
//WESAND 130108------------------------------------------------- 

    pTempPath := GetDPNE(2);// get the path
    pTempFile := GetDPNE(3);// get the filename
    dFindHandle := coFileSys.FindFirst(path:=pTempPath, file:=pTempFile, infostruct:=#FileInfo, atts_inkl:=0, atts_exkl:=0);
    if (dFindHandle < 0) then
      if(Lse_File_Open(#File, SAVE, GetDPNE(0)) = true) then
        CreateFile();
        EntryNo := 1;
        EntriesWritten := 1;    // SLiMic 110716
      end_if;
    else
      coFileSys.FindClose(dFindHandle);
    end_if;
    
//WESAND 130108-------------------------------------------------    
    // get old value
    init_RESULT(#tmpres);
    init_VARIABLE(#tmpvar);
    init_VARLABEL(#tmpvl);
    tmpvl.no := 1;
    tmpvl.info[0].state       := VAR_VAL;
    tmpvl.info[0].value$udint := pvar^.no;
    if(VarList_GetSystemData(#tmpres, #tmpvar,  #tmpvl, true) = true) then
    
      // insert entryno
      DToA(#txt[0], EntryNo$dint, 16#0800, sizeof(_CHAR));
      StrCat(#txt[0], sizeof(_CHAR), ": ", sizeof(_ASCII));

      // insert date-time-level stamp
      InsertDateTimeLevelStamp(#txt[StrLen(#txt[0], sizeof(_CHAR))]);

      // get varname
      if(VarList_GetLabel(#txt1[0], #tmpvo, pvar^.no) = true) then
        StrCat(#txt[0], sizeof(_CHAR), #txt1[0], sizeof(_ASCII));
        StrCat(#txt[0], sizeof(_CHAR), ", ", sizeof(_ASCII));
        FormatResult(#txt[StrLen(#txt[0], sizeof(_CHAR))], #tmpres, #tmpvar);
        StrCat(#txt[0], sizeof(_CHAR), " -> ", sizeof(_ASCII));
        FormatResult(#txt[StrLen(#txt[0], sizeof(_CHAR))], pres, pvar);
        punit := VarList_GetTextByNo(pvar^.no, 5);
        if(punit <> NIL) then
          StrCat(#txt[0], sizeof(_CHAR), ", [", sizeof(_ASCII));
          StrCat(#txt[0], sizeof(_CHAR), punit, sizeof(_CHAR));
          StrCat(#txt[0], sizeof(_CHAR), "]", sizeof(_ASCII));
        end_if;
        
        //_MemSet(#txt1[0],0,SIZEOF(txt1)); //spimar 1.4 --> 20.3.2012 
        txt1[0] := 0;
        StrCpy(#txt1[0], sizeof(_ASCII), #txt[0], sizeof(_CHAR));
        // finish record
        len := StrLen(#txt1[0], sizeof(_ASCII));
        _memset(#txt1[len], ' ', (LOGENTRY_SIZE - len));
        txt1[LOGENTRY_SIZE - 2] := 13;
        txt1[LOGENTRY_SIZE - 1] := 10;
        
        // write record into logfile
        len := ((EntryNo - 1) mod MaxEntry) * LOGENTRY_SIZE;
//WESAND 130108-------------------------------------------------          
        if (AsyncSave = 1) then
        
          //SliMic 110716-----------------------------------
          _memcpy(ptr1:= MsgBuffer.pWrite, ptr2:= #txt1[0], cntr:= sizeof(txt1));
          
          if MsgBuffer.pWrite >= MsgBuffer.pEnd then
            MsgBuffer.pWrite := MsgBuffer.pStart;
          else  
            MsgBuffer.pWrite += sizeof(EntrySize);
          end_if;
          //SliMic 110716-----------------------------------
          
          AsyncSSW := AsyncFileOpen;
        
        else
        
          if(Lse_File_Open(#File, LOADSAVE, GetDPNE(0)) = true) then
            Lse_File_Seek(#File, to_dint(len), SEEK_SET);
            Lse_File_Write(#File, #txt1[0], LOGENTRY_SIZE );
            Lse_File_Close(#File);
          end_if;
          
        end_if;
//WESAND 130108-------------------------------------------------  
(*WESAND 130108        
        if(Lse_File_Open(#File, LOADSAVE, GetDPNE(0)) = true) then
          Lse_File_Seek(#File, to_dint(len), SEEK_SET);
          Lse_File_Write(#File, #txt1[0], LOGENTRY_SIZE );
          Lse_File_Close(#File);
        end_if;
WESAND 130108*)        
        EntryNo += 1;
        //SliMic 110716-----------------------------------
        if AsyncSave = 0 then
          EntriesWritten += 1;
        end_if;
        //SliMic 110716-----------------------------------
      
      end_if;
    end_if;
  end_if;
  
//  udStoppTime := OS_READMICROSEC();
//  
//  udDiffTime := udStoppTime - udStartTime;
//  if (udDiffTime > udMaxTime) then
//    udMaxTime := udDiffTime;
//  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL UserParaLogger::GetDPNE
	VAR_INPUT
		selection 	: DINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_ASCII;
	END_VAR

  // DPNE -> Drive Path Name Extension
//WESAND 130108-------------------------------------------------
  case (selection) of
  
    0: retcode := "RAM@C:\DATALOG.TXT";
    
    1: retcode := "C:\DATALOG.TXT";
    
    2: retcode := "C:\";
    
    3: retcode := "DATALOG.TXT";
    
  else
  
    retcode := "WRONG PARAMETER";
  
  end_case;
//WESAND 130108-------------------------------------------------   
//WESAND 13010  retcode := "RAM@C:\DATALOG.TXT";
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL UserParaLogger::DoLogging
	VAR_INPUT
		pvar 	: ^_VARIABLE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  retcode := false;
  if(pvar^.info.statistic.parameter and 2) then
    retcode := true;
  end_if;

END_FUNCTION

//WESAND 130108-------------------------------------------------
FUNCTION VIRTUAL GLOBAL UserParaLogger::IF_WindowRun
	VAR_INPUT
		whoami 	: ^_WHOAMI;
		pic 	: ^void;
		event 	: ^_EVENT;
	END_VAR
  VAR
  	dTempErg : DINT;  // Result asyncstate
    dTempEnties : UDINT;
  END_VAR
  
//********************************************************************************************************************
// Fileoperation
//********************************************************************************************************************

  //******************************************************************
  // Start AsyncSSW **************************************************
  //******************************************************************
  case (AsyncSSW) of
    // ---------------------------------------------------------------
    // Do nothing ----------------------------------------------------
    // ---------------------------------------------------------------
    AsyncIdle:
      
      //SliMic 110716-----------------------------------
      if ErrorSaveFile = 0 then
        if MsgBuffer.pWrite <> pMsgRead then
          AsyncSSW := AsyncFileOpen;
        end_if;
      end_if;
      
    // ---------------------------------------------------------------
    // Open file -----------------------------------------------------
    // ---------------------------------------------------------------
    AsyncFileOpen:
      
      dTmpID   := coFileSys.FileOpen_A(Async:=1, filename:=GetDPNE(1), attributes:=(ATT_READ_WRITE + ATT_CREATE));
      AsyncSSW := AsyncWait4Open;
    
    // ---------------------------------------------------------------
    // Wait until the file open --------------------------------------
    // ---------------------------------------------------------------
    AsyncWait4Open:
      
      if (coFileSys.GetAsyncState(ID:=dTmpID$UDINT, Erg:=#dTmpHandle) >= 0) then
        if (dTmpHandle >= 0) then
          
          //SliMic 110716-----------------------------------
          // calculate the len of the data for the new entries
          if MsgBuffer.pWrite < pMsgRead then
            
//            if pMsgRead > MsgBuffer.pEnd then
//              pMsgRead := MsgBuffer.pWrite;
//            end_if;
          
            dNewMsgs := ((MsgBuffer.pEnd - pMsgRead)$UDINT / sizeof(EntrySize)) +1;    // In the pEnd there is also a message
            
            if ((EntriesWritten mod MaxEntry) + dNewMsgs) > MaxEntry then
              dTempEnties := (EntriesWritten mod MaxEntry);
              dNewMsgs := MaxEntry - ((EntriesWritten mod MaxEntry)-1);
              pMsgToWrite := pMsgRead;
              pMsgRead := pMsgRead + (sizeof(EntrySize) * dNewMsgs);
              if pMsgRead > MsgBuffer.pEnd then
                pMsgRead := MsgBuffer.pEnd;
                dNewMsgs := ((pMsgRead - pMsgToWrite)/ sizeof(EntrySize))$UDINT;
              end_if;
            else
              pMsgToWrite := pMsgRead;
              pMsgRead := MsgBuffer.pStart;
            end_if;
            
          else
            dNewMsgs := ((MsgBuffer.pWrite - pMsgRead)$UDINT /sizeof(EntrySize));
            
            if ((EntriesWritten mod MaxEntry) + dNewMsgs) > MaxEntry then
              dTempEnties := (EntriesWritten mod MaxEntry);
              dNewMsgs := MaxEntry - ((EntriesWritten mod MaxEntry)-1);
              pMsgToWrite := pMsgRead;
              pMsgRead := pMsgRead + (sizeof(EntrySize) * dNewMsgs);
              if pMsgRead > MsgBuffer.pEnd then
                pMsgRead := MsgBuffer.pEnd;
                dNewMsgs := ((pMsgRead - pMsgToWrite)/ sizeof(EntrySize))$UDINT;
              end_if;
            else
              pMsgToWrite := pMsgRead;
              pMsgRead := MsgBuffer.pWrite;
            end_if;

          end_if;

          len := ((EntriesWritten - 1) mod MaxEntry) * LOGENTRY_SIZE;
          //SliMic 110716-----------------------------------
          
          ErrorSaveFile := 0;
          AsyncSSW      := AsyncFileSeek;
        
        else
        
          ErrorSaveFile := 1;
          AsyncSSW      := AsyncIdle;
        
        end_if;
      end_if;
    
    // ---------------------------------------------------------------
    // Get the end of file -------------------------------------------
    // ---------------------------------------------------------------
    AsyncFileSeek:
    
      dTmpID   := coFileSys.Filelseek_AV1(Async:=1, handle:=dTmpHandle, offset:=TO_DINT(len), fromwhere:=SEEK_SET);
      AsyncSSW := AsyncWait4Seek;
    
    // ---------------------------------------------------------------
    // Wait until get the end of file --------------------------------
    // ---------------------------------------------------------------
    AsyncWait4Seek:
    
      if (coFileSys.GetAsyncState(ID:=dTmpID$UDINT, Erg:=#dTempErg) >= 0) then
        if (dTempErg >= 0) then
          ErrorSaveFile := 0;
          AsyncSSW      := AsyncWrite;
        else
          ErrorSaveFile := 1;
          AsyncSSW      := AsyncClose;
        end_if;
      end_if;
    
    // ---------------------------------------------------------------
    // Write into the file -------------------------------------------
    // ---------------------------------------------------------------
    AsyncWrite:      
      //SliMic 110716-----------------------------------
      dTmpID   := coFileSys.FileWrite_AV1(Async:=1, handle:=dTmpHandle, buffer:=pMsgToWrite, length:= (sizeof(EntrySize) * dNewMsgs)$UDINT);
      
//      dTmpID   := coFileSys.FileWrite_AV1(Async:=1, handle:=dTmpHandle, buffer:=#txt1[0], length:=LOGENTRY_SIZE);
      //SliMic 110716-----------------------------------
      AsyncSSW := AsyncWait4Write;
    
    // ---------------------------------------------------------------
    // Wait until the file is written --------------------------------
    // ---------------------------------------------------------------
    AsyncWait4Write:
    
      if (coFileSys.GetAsyncState(ID:=dTmpID$UDINT, Erg:=#dTempErg) >= 0) then
        if (dTempErg >= 0) then
          ErrorSaveFile := 0;
          EntriesWritten += dNewMsgs$UDINT;
          AsyncSSW := AsyncClose;
        else
          ErrorSaveFile := 1;
          AsyncSSW      := AsyncClose;
        end_if;
      end_if;
    
    // ---------------------------------------------------------------
    // Close the file ------------------------------------------------
    // ---------------------------------------------------------------
    AsyncClose:
      
      dTmpID   := coFileSys.FileClose_A(Async:=1, handle:=dTmpHandle); 
      AsyncSSW := AsyncWait4Close;
    
    // ---------------------------------------------------------------
    // Wait until the file is closed ---------------------------------
    // ---------------------------------------------------------------
    AsyncWait4Close:
    
      if (coFileSys.GetAsyncState(ID:=dTmpID$UDINT, Erg:=#dTempErg) >= 0) then
        if (dTempErg >= 0) then
          ErrorSaveFile := 0;
          AsyncSSW      := AsyncIdle;

        else
          ErrorSaveFile := 1;
          AsyncSSW      := AsyncIdle;
        end_if;
        
//        udStoppTime := OS_READMICROSEC();
//  
//        udDiffTime := udStoppTime - udStartTime;
//        if (udDiffTime > udMaxTime) then
//          udMaxTime := udDiffTime;
//        end_if;
        
      end_if;
      
  end_case;
  
  //******************************************************************
  // End AsyncSSW ****************************************************
  //******************************************************************
  
END_FUNCTION
//WESAND 130108-------------------------------------------------

//WESAND 130108-------------------------------------------------
FUNCTION UserParaLogger::CreateFile
  VAR
  	no  : UDINT;
    tmp : ARRAY[0..LOGENTRY_SIZE] of _ASCII;
  END_VAR

  no := MaxEntry;
  _memset(#tmp[0], ' ', LOGENTRY_SIZE);
  tmp[LOGENTRY_SIZE - 2] := 13;
  tmp[LOGENTRY_SIZE - 1] := 10;
  tmp[0] := '0';
  tmp[1] := ':';
  myst   := true;
  
  // initialize all entries
  while(no) do
    no -= 1;
    if(Lse_File_Write(#File, #tmp[0], LOGENTRY_SIZE) = false) then
      myst := false;
      no := 0;
    end_if;
  end_while;
  
  Lse_File_Close(#File);

END_FUNCTION
//WESAND 130108-------------------------------------------------
