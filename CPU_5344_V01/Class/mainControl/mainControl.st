//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "mainControl"
	Revision           = "2.1"
	GUID               = "{C73EF0C9-7B8F-4F3A-B020-96FA70B18FBE}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(1170,720)"
	Comment            = "The mainControl is the highest control in the PackML hierarchy.&#13;&#10;All units are controlled from here.">
	<Channels>
		<Server Name="actLengthInInput" GUID="{A28C0EE5-307A-4151-83CB-1427B51F3D8E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="actRnrInputToPC" GUID="{46770921-7C3A-4749-8FD3-80991344CAF6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="actRnrOutputToPC" GUID="{CA4A17C1-B16A-4565-BE35-FD8CFEE8341E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="amountDone" GUID="{064A0F88-6420-4440-B9CF-5F5D0FD0BC64}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="amountToDo" GUID="{33134EEA-DF7A-4A48-B0E2-D81C495C08C2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="BackOffMaterial" GUID="{7D247BC2-F403-49BE-BC8C-B4254F5CD19B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonHold" GUID="{6229064E-EE17-4783-B4A5-82324EDCD79F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonReset" GUID="{5ACDF453-0477-4D55-A680-FD95FD1AC9F9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonResetAlarm" GUID="{EDFE8D10-5CE8-4439-83A8-269B6228C4EA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonStart" GUID="{5A34649E-1CAE-4E11-B405-6845EDAC9741}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonStop" GUID="{E50196F8-5418-4E89-BDB1-A0C47EDDB3E8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonSuspend" GUID="{90304D01-F01B-4F6E-A8BB-73AC9D28DC71}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonUnhold" GUID="{ED574BCF-418D-4EEA-8F96-C73DC261E485}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="buttonUnsuspend" GUID="{77EC3635-C26E-4985-82F6-E386E26F5D6A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ClassSvr" GUID="{34E579E1-C71B-488C-B75C-979C14365788}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="FrontOffMaterial" GUID="{6C7A16CD-545C-4E51-8C4A-AECD10D1EEBC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="idStartFromPC" GUID="{F20875E6-750A-4D0D-ACDA-DE93FA3F3145}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="lineNrInput" GUID="{6FC0D15E-2363-4F65-B083-6E35E27ECF9B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="LineNrInputFromScreen" GUID="{C6A9638C-CAAB-45F6-9076-E3029DBE9B98}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="lineNrOutput" GUID="{2C9F556D-6042-469F-B120-290632F2A6C9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="MaxRnrInputToPC" GUID="{10208F42-287C-4E4A-985D-75C17E98DB8F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="oActSimuMode" GUID="{43894C88-2199-44D4-BA58-37B43156830D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="parActLength" GUID="{6961EB32-35BD-43E8-A87E-EB15677C4E65}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="parManualLengthActive" GUID="{B7925957-E460-4B93-AFB2-165F8B364378}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="parNrWindowLength" GUID="{97276140-B0E6-41DD-91AC-DC32A6416FAB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="progChangesAllowed" GUID="{86C5958D-E0BE-4ACC-9F43-66A04BA198C8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="readyForNewFileToPC" GUID="{A830C1C7-EB10-4FB8-A290-8561CAEC733B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reReadAmountToDo" GUID="{2D2FACA0-B24B-45D7-9C74-3FF8121C3651}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ResetBackOffMaterial" GUID="{10789F8E-D3B1-4617-913B-4FB45684EBDA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ResetFrontOffMaterialToTakeIn" GUID="{A854B511-F225-4627-A7D1-7D8ACACFA72A}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ResumeProgram" GUID="{E45B0508-A619-4F2C-83B7-7D6E563AC21F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ScreenAssemNrAllowed" GUID="{6EF0383F-904D-4563-9D3B-4110ADDE0BDE}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ScreenAxisSettingsAllowed" GUID="{796C14AE-502A-4ED7-98F8-8140D91BDF5E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ScreenCommonSettingsAllowed" GUID="{C0EE3CA2-89C6-46E0-B155-510B64286346}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ScreenManualControlAllowed" GUID="{B4AADACF-B3E1-451C-B58E-A415974FE161}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ScreenProgChangesAllowed" GUID="{987B3A97-37D1-45A4-BAB5-E04B0868E988}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ScreenProgChangesMillAllowed" GUID="{D895F277-9360-40A2-91CA-DA3E6AA79D48}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ScreenPuchOnOffAllowed" GUID="{9726D4E2-2234-44B0-9DD8-BACCB22A909B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="sParMinLevelCom" GUID="{85E798AD-DC2E-49A5-85C4-E87AB09FE222}" Visualized="false" Initialize="true" DefValue="2" WriteProtected="false" Retentive="false"/>
		<Server Name="sParMinLevelManual" GUID="{C9E14AE8-8D7C-44A5-932F-A63A83FC0D89}" Visualized="false" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false"/>
		<Server Name="sParMinLevelProg" GUID="{BCDD93A1-4D3A-431E-BCC1-32A39AB35CA7}" Visualized="false" Initialize="true" DefValue="2" WriteProtected="false" Retentive="false"/>
		<Server Name="sParMinLevelServos" GUID="{4376963A-397D-48B6-9833-97E0F56538C1}" Visualized="false" Initialize="true" DefValue="4" WriteProtected="false" Retentive="false"/>
		<Server Name="startFromPC" GUID="{C663C4CF-ABB7-4C1B-8C2D-ED45643D7EAF}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stateToPC" GUID="{21047230-ADC9-49B6-A491-1857FFCBBEA9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stopAfterLength" GUID="{A4E0AE39-C29A-4240-BFA0-B81E546CECB9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stopFromPC" GUID="{0EEDC1B7-7904-41A3-BBAA-CECB390D927A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprInputSide" GUID="{CB6F31B4-8A40-4DF4-BA7D-B135AA7B050F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprOutputSide" GUID="{B7B53589-0482-4913-AC16-75E9F42375A0}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprStart" GUID="{C80C7D12-106B-4AEE-BE35-AC128F915D35}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsStopSafetyAllowed" GUID="{4B38CB5D-3CDB-4353-86F8-37CDA9A651EF}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="ctrlAssembly" Required="true" Internal="false" Comment="The assembly database is only needed for the sLineHandler functionblock."/>
		<Client Name="ctrlCalc" Required="true" Internal="false" Comment="The ctrlCalc is used in the mainControl to give the machine te command to start an calculation and to read if the calculation is ready."/>
		<Client Name="ctrlMain" Required="true" Internal="false"/>
		<Client Name="ctrlScreen" Required="true" Internal="false"/>
		<Client Name="ctrlUnit1" Required="true" Internal="false" Comment="Connect a unit from the standard library here. &#13;&#10;This connection is not required, so can be left empty."/>
		<Client Name="ctrlUnit2" Required="false" Internal="false" Comment="Connect a unit from the standard library here. &#13;&#10;This connection is not required, so can be left empty."/>
		<Client Name="ctrlUnit3" Required="false" Internal="false" Comment="Connect a unit from the standard library here. &#13;&#10;This connection is not required, so can be left empty."/>
		<Client Name="ctrlUnit4" Required="false" Internal="false" Comment="Connect a unit from the standard library here. &#13;&#10;This connection is not required, so can be left empty."/>
		<Client Name="ctrlUnit5" Required="false" Internal="false" Comment="Connect a unit from the standard library here. &#13;&#10;This connection is not required, so can be left empty."/>
		<Client Name="FileBase1" Required="true" Internal="true"/>
		<Client Name="fileName" Required="true" Internal="false"/>
		<Client Name="folderName" Required="true" Internal="false"/>
		<Client Name="iActMathHeigth" Required="true" Internal="false"/>
		<Client Name="iActMathWidth" Required="true" Internal="false"/>
		<Client Name="iAmountToDo" Required="true" Internal="false"/>
		<Client Name="iBlinkFast" Required="true" Internal="false"/>
		<Client Name="iBlinkSlow" Required="true" Internal="false"/>
		<Client Name="iInputLength" Required="true" Internal="false"/>
		<Client Name="iLiveXPos" Required="true" Internal="false"/>
		<Client Name="iOffsetInputMaterial" Required="true" Internal="false"/>
		<Client Name="iStprActionSaw" Required="true" Internal="false"/>
		<Client Name="listSLines0" Required="true" Internal="false"/>
		<Client Name="nwEmOrUnit" Required="false" Internal="false"/>
		<Client Name="oAlarmLamp" Required="true" Internal="false"/>
		<Client Name="oAmountDone" Required="true" Internal="false"/>
		<Client Name="oAmountDoneOutput" Required="true" Internal="false"/>
		<Client Name="oCycleLamp" Required="true" Internal="false"/>
		<Client Name="oLineNrInput" Required="true" Internal="false"/>
		<Client Name="oLineNrOutput" Required="true" Internal="false"/>
		<Client Name="oResetAlarm" Required="true" Internal="false"/>
		<Client Name="readInGlobalList1" Required="true" Internal="true"/>
		<Client Name="sLineHandler1" Required="true" Internal="true"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="13"/>
			<SepChn Position="29"/>
			<SepChn Position="43"/>
			<SepChn Position="52"/>
			<SepChn Position="56"/>
			<SepChn Position="1"/>
			<SepChn Position="11"/>
			<SepChn Position="17"/>
			<SepChn Position="22"/>
			<SepChn Position="38"/>
		</Servers>
		<Clients>
			<SepChn Position="7"/>
			<SepChn Position="1"/>
		</Clients>
	</Separators>
	<RevDoku>
		<Owner Company="Van Dulst Techniek B.V." Author="M. Bloem"/>
		<Dokumentation Revision="2.0" Date="2022-05-23" Author="M. Bloem" Company="Van Dulst Techniek B.V." Description="Changed the mainControl function block in an modular design so that units can be removed or added without program changes."/>
	</RevDoku>
	<Network Name="mainControl">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "FileBase1"
				GUID       = "{0CE6209C-9951-497B-AC17-0305EF0C2E35}"
				Class      = "FileBase"
				Position   = "(90,2310)"
				Visualized = "true">
				<Channels>
					<Server Name="ErrorNr"/>
					<Server Name="Server0"/>
					<Client Name="FileOs"/>
					<Client Name="System"/>
				</Channels>
			</Object>
			<Object
				Name           = "readInGlobalList1"
				GUID           = "{764E8B30-CDEE-41DC-BE22-F3126640E6AC}"
				Class          = "readInGlobalList"
				Position       = "(720,1830)"
				Visualized     = "true"
				CyclicTime     = "10 ms"
				BackgroundTime = "10 ms">
				<Channels>
					<Server Name="BU2used"/>
					<Server Name="BU3used"/>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprReadIn"/>
					<Server Name="stsActInputHeigth"/>
					<Server Name="stsActInputLength"/>
					<Server Name="stsActInputWidth"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsReadInDoneUntilEnd"/>
					<Server Name="testUnits"/>
					<Client Name="fileBase"/>
					<Client Name="fileName"/>
					<Client Name="fileSys"/>
					<Client Name="folderName"/>
					<Client Name="globalList"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name       = "sLineHandler1"
				GUID       = "{AB43F224-012D-4A87-A362-0C09014B77BB}"
				Class      = "sLineHandler"
				Position   = "(960,120)"
				Visualized = "true"
				CyclicTime = "10 ms">
				<Channels>
					<Server Name="actLengthInInput"/>
					<Server Name="actMathHeigth"/>
					<Server Name="actMathWidth"/>
					<Server Name="amountDone"/>
					<Server Name="amountToDo"/>
					<Server Name="BackOffMaterial"/>
					<Server Name="ClassSvr"/>
					<Server Name="FrontOffMaterial"/>
					<Server Name="lineNrInput"/>
					<Server Name="lineNrOutput"/>
					<Server Name="reReadAmountToDo"/>
					<Server Name="ResetBackOffMaterial"/>
					<Server Name="ResetFrontOffMaterialToTakeIn"/>
					<Server Name="rnrInput"/>
					<Server Name="rnrOutput"/>
					<Server Name="sSetBackOffMaterialAfterSawing"/>
					<Server Name="stopAfterLength"/>
					<Server Name="stprInputSide"/>
					<Server Name="stprOutputSide"/>
					<Server Name="stsCompleted"/>
					<Server Name="stsStartedFromPC"/>
					<Server Name="thisUnitIsSaw"/>
					<Client Name="ctrlMain"/>
					<Client Name="ctrlReadIn"/>
					<Client Name="iActMathHeigth"/>
					<Client Name="iActMathWidth"/>
					<Client Name="iAmountToDo"/>
					<Client Name="iInputLength"/>
					<Client Name="iLiveXPos"/>
					<Client Name="iOffsetInputMaterial"/>
					<Client Name="listSLines"/>
					<Client Name="oAmountDone"/>
					<Client Name="oAmountDoneOutput"/>
					<Client Name="oLineNrInput"/>
					<Client Name="oLineNrOutput"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.sLineHandler1" Destination="sLineHandler1.ClassSvr"/>
			<Connection Source="sLineHandler1.listSLines" Destination="this.listSLines0" Vertices="(960,210),(270,330),(270,690),(38,690),"/>
			<Connection Source="sLineHandler1.iInputLength" Destination="this.iInputLength" Vertices="(960,330),(330,390),(330,750),(38,750),"/>
			<Connection Source="sLineHandler1.iAmountToDo" Destination="this.iAmountToDo" Vertices="(960,390),(390,450),(390,810),(38,810),"/>
			<Connection Source="sLineHandler1.oAmountDone" Destination="this.oAmountDone" Vertices="(960,690),(570,630),(570,990),(38,990),"/>
			<Connection Source="sLineHandler1.oLineNrInput" Destination="this.oLineNrInput" Vertices="(960,810),(690,750),(690,1110),(38,1110),"/>
			<Connection Source="sLineHandler1.oLineNrOutput" Destination="this.oLineNrOutput" Vertices="(960,870),(750,810),(750,1170),(38,1170),"/>
			<Connection Source="sLineHandler1.ctrlMain" Destination="this.ctrlMain" Vertices="(960,270),(38,210),"/>
			<Connection Source="sLineHandler1.iOffsetInputMaterial" Destination="this.iOffsetInputMaterial" Vertices="(960,450),(450,510),(450,870),(38,870),"/>
			<Connection Source="sLineHandler1.iLiveXPos" Destination="this.iLiveXPos" Vertices="(960,510),(510,570),(510,930),(38,930),"/>
			<Connection Source="sLineHandler1.oAmountDoneOutput" Destination="this.oAmountDoneOutput" Vertices="(960,750),(630,690),(630,1050),(38,1050),"/>
			<Connection Source="this.stprInputSide" Destination="sLineHandler1.stprInputSide" Vertices="(2288,930),(2116,390),"/>
			<Connection Source="this.stprOutputSide" Destination="sLineHandler1.stprOutputSide" Vertices="(2288,990),(2116,450),"/>
			<Connection Source="this.FrontOffMaterial" Destination="sLineHandler1.FrontOffMaterial" Vertices="(2288,1050),(2116,510),"/>
			<Connection Source="this.BackOffMaterial" Destination="sLineHandler1.BackOffMaterial" Vertices="(2288,1110),(2116,570),"/>
			<Connection Source="this.ResetBackOffMaterial" Destination="sLineHandler1.ResetBackOffMaterial" Vertices="(2288,1170),(2116,630),"/>
			<Connection Source="this.ResetFrontOffMaterialToTakeIn" Destination="sLineHandler1.ResetFrontOffMaterialToTakeIn" Vertices="(2288,1230),(2116,690),"/>
			<Connection Source="this.lineNrInput" Destination="sLineHandler1.lineNrInput" Vertices="(2288,1290),(2116,930),"/>
			<Connection Source="this.lineNrOutput" Destination="sLineHandler1.lineNrOutput" Vertices="(2288,1350),(2116,990),"/>
			<Connection Source="this.stopAfterLength" Destination="sLineHandler1.stopAfterLength" Vertices="(2288,750),(2116,1050),"/>
			<Connection Source="this.reReadAmountToDo" Destination="sLineHandler1.reReadAmountToDo" Vertices="(2288,1410),(2116,1230),"/>
			<Connection Source="this.amountToDo" Destination="sLineHandler1.amountToDo" Vertices="(2288,1470),(2116,1110),"/>
			<Connection Source="this.amountDone" Destination="sLineHandler1.amountDone" Vertices="(2288,1530),(2116,1170),"/>
			<Connection Source="sLineHandler1.iActMathHeigth" Destination="this.iActMathHeigth" Vertices="(960,630),(870,930),(870,1290),(38,1290),"/>
			<Connection Source="sLineHandler1.iActMathWidth" Destination="this.iActMathWidth" Vertices="(960,570),(810,870),(810,1230),(38,1230),"/>
			<Connection Source="this.FileBase1" Destination="FileBase1.Server0"/>
			<Connection Source="this.readInGlobalList1" Destination="readInGlobalList1.ClassSvr"/>
			<Connection Source="readInGlobalList1.fileBase" Destination="FileBase1.Server0" Vertices="(720,2040),(556,2400),"/>
			<Connection Source="readInGlobalList1.fileName" Destination="this.fileName" Vertices="(720,2160),(38,1770),"/>
			<Connection Source="readInGlobalList1.globalList" Destination="this.listSLines0" Vertices="(720,2220),(570,1950),(570,1560),(270,1560),(270,690),(38,690),"/>
			<Connection Source="readInGlobalList1.folderName" Destination="this.folderName" Vertices="(720,2100),(38,1830),"/>
			<Connection Source="sLineHandler1.ctrlReadIn" Destination="readInGlobalList1.ClassSvr" Vertices="(960,930),(930,990),(930,1650),(1020,1920),"/>
			<Connection Source="this.actLengthInInput" Destination="sLineHandler1.actLengthInInput" Vertices="(2288,2970),(2116,750),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
mainControl : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	buttonStart 	: SvrCh_DINT;
	buttonStop 	: SvrCh_DINT;
	buttonReset 	: SvrCh_DINT;
	buttonSuspend 	: SvrCh_DINT;
	buttonUnsuspend 	: SvrCh_DINT;
	buttonHold 	: SvrCh_DINT;
	buttonUnhold 	: SvrCh_DINT;
	buttonResetAlarm 	: SvrCh_DINT;
	stopAfterLength 	: SvrCh_DINT;
	oActSimuMode 	: SvrCh_eSimuState;
	stprStart 	: SvrCh_DINT;
	stprInputSide 	: SvrCh_DINT;
	stprOutputSide 	: SvrCh_DINT;
	FrontOffMaterial 	: SvrCh_DINT;
	BackOffMaterial 	: SvrCh_DINT;
	ResetBackOffMaterial 	: SvrCh_DINT;
	ResetFrontOffMaterialToTakeIn 	: SvrCh_DINT;
	lineNrInput 	: SvrCh_DINT;
	lineNrOutput 	: SvrCh_DINT;
	reReadAmountToDo 	: SvrCh_DINT;
	amountToDo 	: SvrCh_DINT;
	amountDone 	: SvrCh_DINT;
	stsStopSafetyAllowed 	: SvrCh_DINT;
	progChangesAllowed 	: SvrCh_DINT;
	ScreenManualControlAllowed 	: SvrCh_DINT;
	ScreenProgChangesAllowed 	: SvrCh_DINT;
	ScreenProgChangesMillAllowed 	: SvrCh_DINT;
	ScreenCommonSettingsAllowed 	: SvrCh_DINT;
	ScreenAxisSettingsAllowed 	: SvrCh_DINT;
	ScreenAssemNrAllowed 	: SvrCh_DINT;
	ScreenPuchOnOffAllowed 	: SvrCh_DINT;
	sParMinLevelManual 	: SvrCh_DINT;
	sParMinLevelProg 	: SvrCh_DINT;
	sParMinLevelCom 	: SvrCh_DINT;
	sParMinLevelServos 	: SvrCh_DINT;
	startFromPC 	: SvrCh_DINT;
	stopFromPC 	: SvrCh_DINT;
	idStartFromPC 	: SvrCh_DINT;
	stateToPC 	: SvrCh_eStatePML;
	actRnrInputToPC 	: SvrCh_DINT;
	actRnrOutputToPC 	: SvrCh_DINT;
	readyForNewFileToPC 	: SvrCh_DINT;
	MaxRnrInputToPC 	: SvrCh_DINT;
	ResumeProgram 	: SvrCh_DINT;
	LineNrInputFromScreen 	: SvrCh_DINT;
	actLengthInInput 	: SvrCh_DINT;
	parNrWindowLength 	: SvrCh_DINT;
	parActLength 	: SvrCh_DINT;
	parManualLengthActive 	: SvrCh_DINT;
  //Clients:
	ctrlMain 	: CltChCmd_mainControl;
	ctrlUnit1 	: CltChCmd_unitBase;
	ctrlUnit2 	: CltChCmd_unitBase;
	ctrlUnit3 	: CltChCmd_unitBase;
	ctrlUnit4 	: CltChCmd_unitBase;
	ctrlUnit5 	: CltChCmd_unitBase;
	ctrlAssembly 	: CltChCmd_AssemblyDbV2;
	ctrlCalc 	: CltChCmd_calcComplete;
	listSLines0 	: CltChCmd_GlobalList;
	iInputLength 	: CltCh_DINT;
	iAmountToDo 	: CltCh_DINT;
	iOffsetInputMaterial 	: CltCh_DINT;
	iLiveXPos 	: CltCh_DINT;
	oAmountDone 	: CltCh_DINT;
	oAmountDoneOutput 	: CltCh_DINT;
	oLineNrInput 	: CltCh_DINT;
	oLineNrOutput 	: CltCh_DINT;
	iActMathWidth 	: CltCh_DINT;
	iActMathHeigth 	: CltCh_DINT;
	oResetAlarm 	: CltCh_DINT;
	oCycleLamp 	: CltCh_DINT;
	oAlarmLamp 	: CltCh_DINT;
	iBlinkFast 	: CltCh_DINT;
	iBlinkSlow 	: CltCh_DINT;
	ctrlScreen 	: CltChCmd_ScreenCtrl;
	nwEmOrUnit 	: CltChCmd_emBase;
	FileBase1 	: CltChCmd_FileBase;
	readInGlobalList1 	: CltChCmd_readInGlobalList;
	fileName 	: CltChCmd_StringRAM;
	folderName 	: CltChCmd_StringRAM;
	iStprActionSaw 	: CltCh_DINT;
	sLineHandler1 	: CltChCmd_sLineHandler;
  //Variables:
		tmpUnits 	: Units;
		timerWindow 	: UDINT;
		IsConnected_Unit1 	: DINT;
		IsConnected_Unit2 	: DINT;
		IsConnected_Unit3 	: DINT;
		IsConnected_Unit4 	: DINT;
		IsConnected_Unit5 	: DINT;
		amountOfUnitsActive 	: DINT;
		MainControlState 	: eStatePML;
		MainControlSimu 	: eSimuState;
		allUnitStatesEqual 	: DINT;
		allUnitSimuEqual 	: DINT;
		UnitState : ARRAY [0..10] OF eStatePML;

		UnitSimulation : ARRAY [0..10] OF eSimuState;

		UnitProgChangesAllowed : ARRAY [0..10] OF DINT;

		i 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION GLOBAL startSLine
		VAR_INPUT
			sLine 	: SRegelInfo;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL askReadySLine
		VAR_INPUT
			sLine 	: SRegelInfo;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL calcNext;
	
	FUNCTION VIRTUAL GLOBAL buttonStart::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL buttonStop::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL buttonReset::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL buttonSuspend::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL buttonUnsuspend::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL buttonHold::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL buttonUnhold::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL buttonResetAlarm::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stopAfterLength::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stopAfterLength::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stprInputSide::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stprInputSide::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stprOutputSide::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stprOutputSide::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrontOffMaterial::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL FrontOffMaterial::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BackOffMaterial::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BackOffMaterial::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ResetBackOffMaterial::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ResetBackOffMaterial::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ResetFrontOffMaterialToTakeIn::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ResetFrontOffMaterialToTakeIn::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL lineNrInput::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL lineNrInput::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL lineNrOutput::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL lineNrOutput::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reReadAmountToDo::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reReadAmountToDo::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL amountToDo::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL amountToDo::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL amountDone::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL amountDone::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stsStopSafetyAllowed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL progChangesAllowed::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL startFromPC::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stopFromPC::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL actRnrInputToPC::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL readyForNewFileToPC::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL readyForNewFileToPC::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL actLengthInInput::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL actLengthInInput::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL parActLength::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using FileBase
#pragma using readInGlobalList
#pragma using sLineHandler
#pragma usingLtd AssemblyDbV2
#pragma usingLtd calcComplete
#pragma usingLtd emBase
#pragma usingLtd GlobalList
#pragma usingLtd ScreenCtrl
#pragma usingLtd StringRAM
#pragma usingLtd unitBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB mainControl::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MAINCONTROL
2$UINT, 1$UINT, (SIZEOF(::mainControl))$UINT, 
50$UINT, 32$UINT, 0$UINT, 
TO_UDINT(116908342), "mainControl", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::mainControl.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::mainControl.buttonStart.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1834139430), "buttonStart", 
(::mainControl.buttonStop.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4038914501), "buttonStop", 
(::mainControl.buttonReset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2729858532), "buttonReset", 
(::mainControl.buttonSuspend.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2684592925), "buttonSuspend", 
(::mainControl.buttonUnsuspend.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2994939469), "buttonUnsuspend", 
(::mainControl.buttonHold.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1444997748), "buttonHold", 
(::mainControl.buttonUnhold.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1714894472), "buttonUnhold", 
(::mainControl.buttonResetAlarm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4289611307), "buttonResetAlarm", 
(::mainControl.stopAfterLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4005214858), "stopAfterLength", 
(::mainControl.oActSimuMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3183701149), "oActSimuMode", 
(::mainControl.stprStart.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2955326536), "stprStart", 
(::mainControl.stprInputSide.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2305139321), "stprInputSide", 
(::mainControl.stprOutputSide.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1594253634), "stprOutputSide", 
(::mainControl.FrontOffMaterial.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2084825204), "FrontOffMaterial", 
(::mainControl.BackOffMaterial.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2359158756), "BackOffMaterial", 
(::mainControl.ResetBackOffMaterial.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4089552674), "ResetBackOffMaterial", 
(::mainControl.ResetFrontOffMaterialToTakeIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2043206199), "ResetFrontOffMaterialToTakeIn", 
(::mainControl.lineNrInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(511418896), "lineNrInput", 
(::mainControl.lineNrOutput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4067832021), "lineNrOutput", 
(::mainControl.reReadAmountToDo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2605041502), "reReadAmountToDo", 
(::mainControl.amountToDo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2304864502), "amountToDo", 
(::mainControl.amountDone.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3275892477), "amountDone", 
(::mainControl.stsStopSafetyAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1840557767), "stsStopSafetyAllowed", 
(::mainControl.progChangesAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(197841655), "progChangesAllowed", 
(::mainControl.ScreenManualControlAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(721919904), "ScreenManualControlAllowed", 
(::mainControl.ScreenProgChangesAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1320827730), "ScreenProgChangesAllowed", 
(::mainControl.ScreenProgChangesMillAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3234241515), "ScreenProgChangesMillAllowed", 
(::mainControl.ScreenCommonSettingsAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2431190977), "ScreenCommonSettingsAllowed", 
(::mainControl.ScreenAxisSettingsAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(155677582), "ScreenAxisSettingsAllowed", 
(::mainControl.ScreenAssemNrAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1868869312), "ScreenAssemNrAllowed", 
(::mainControl.ScreenPuchOnOffAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1186828394), "ScreenPuchOnOffAllowed", 
(::mainControl.sParMinLevelManual.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4128963652), "sParMinLevelManual", 
(::mainControl.sParMinLevelProg.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1431133486), "sParMinLevelProg", 
(::mainControl.sParMinLevelCom.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1209229775), "sParMinLevelCom", 
(::mainControl.sParMinLevelServos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(826560362), "sParMinLevelServos", 
(::mainControl.startFromPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1188916476), "startFromPC", 
(::mainControl.stopFromPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(955650797), "stopFromPC", 
(::mainControl.idStartFromPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(726895710), "idStartFromPC", 
(::mainControl.stateToPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4077742146), "stateToPC", 
(::mainControl.actRnrInputToPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(792981437), "actRnrInputToPC", 
(::mainControl.actRnrOutputToPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1191204907), "actRnrOutputToPC", 
(::mainControl.readyForNewFileToPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3551721932), "readyForNewFileToPC", 
(::mainControl.MaxRnrInputToPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(291650319), "MaxRnrInputToPC", 
(::mainControl.ResumeProgram.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(241667144), "ResumeProgram", 
(::mainControl.LineNrInputFromScreen.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1287320667), "LineNrInputFromScreen", 
(::mainControl.actLengthInInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(645540562), "actLengthInInput", 
(::mainControl.parNrWindowLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1986400681), "parNrWindowLength", 
(::mainControl.parActLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(347073344), "parActLength", 
(::mainControl.parManualLengthActive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1537208082), "parManualLengthActive", 
//Clients:
(::mainControl.ctrlMain.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(1628845243), "ctrlMain", TO_UDINT(116908342), "mainControl", 2$UINT, 1$UINT, 
(::mainControl.ctrlUnit1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1741727049), "ctrlUnit1", TO_UDINT(1584517769), "unitBase", 1$UINT, 0$UINT, 
(::mainControl.ctrlUnit2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4275696883), "ctrlUnit2", TO_UDINT(1584517769), "unitBase", 1$UINT, 0$UINT, 
(::mainControl.ctrlUnit3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2313077861), "ctrlUnit3", TO_UDINT(1584517769), "unitBase", 1$UINT, 0$UINT, 
(::mainControl.ctrlUnit4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(398086598), "ctrlUnit4", TO_UDINT(1584517769), "unitBase", 1$UINT, 0$UINT, 
(::mainControl.ctrlUnit5.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1623023952), "ctrlUnit5", TO_UDINT(1584517769), "unitBase", 1$UINT, 0$UINT, 
(::mainControl.ctrlAssembly.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3356493697), "ctrlAssembly", TO_UDINT(2560758913), "AssemblyDbV2", 1$UINT, 0$UINT, 
(::mainControl.ctrlCalc.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2182073200), "ctrlCalc", TO_UDINT(2835426986), "calcComplete", 0$UINT, 0$UINT, 
(::mainControl.listSLines0.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(3394816826), "listSLines0", TO_UDINT(2390595228), "GlobalList", 0$UINT, 0$UINT, 
(::mainControl.iInputLength.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(52482704), "iInputLength", 
(::mainControl.iAmountToDo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(2892598790), "iAmountToDo", 
(::mainControl.iOffsetInputMaterial.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(2417428025), "iOffsetInputMaterial", 
(::mainControl.iLiveXPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(2530943056), "iLiveXPos", 
(::mainControl.oAmountDone.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(251597390), "oAmountDone", 
(::mainControl.oAmountDoneOutput.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(3352254237), "oAmountDoneOutput", 
(::mainControl.oLineNrInput.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(1289682194), "oLineNrInput", 
(::mainControl.oLineNrOutput.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(472577190), "oLineNrOutput", 
(::mainControl.iActMathWidth.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(585657478), "iActMathWidth", 
(::mainControl.iActMathHeigth.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(2482056624), "iActMathHeigth", 
(::mainControl.oResetAlarm.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(415226770), "oResetAlarm", 
(::mainControl.oCycleLamp.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(838988144), "oCycleLamp", 
(::mainControl.oAlarmLamp.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3063930810), "oAlarmLamp", 
(::mainControl.iBlinkFast.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4129747389), "iBlinkFast", 
(::mainControl.iBlinkSlow.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3863464356), "iBlinkSlow", 
(::mainControl.ctrlScreen.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3009882124), "ctrlScreen", TO_UDINT(4196661951), "ScreenCtrl", 0$UINT, 0$UINT, 
(::mainControl.nwEmOrUnit.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1188868355), "nwEmOrUnit", TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, 
(::mainControl.FileBase1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(316419285), "FileBase1", TO_UDINT(1689253198), "FileBase", 0$UINT, 5$UINT, 
(::mainControl.readInGlobalList1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3671092591), "readInGlobalList1", TO_UDINT(3217018748), "readInGlobalList", 0$UINT, 0$UINT, 
(::mainControl.fileName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(4198004009), "fileName", TO_UDINT(2408581120), "StringRAM", 1$UINT, 10$UINT, 
(::mainControl.folderName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000110$UINT, TO_UDINT(3955695189), "folderName", TO_UDINT(2408581120), "StringRAM", 1$UINT, 10$UINT, 
(::mainControl.iStprActionSaw.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(855592653), "iStprActionSaw", 
(::mainControl.sLineHandler1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3385529407), "sLineHandler1", TO_UDINT(3361655140), "sLineHandler", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_mainControl 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_mainControl] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION mainControl::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_mainControl, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonStart.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonStart::Write() );
	IF buttonStart.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonStop.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonStop::Write() );
	IF buttonStop.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonReset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonReset::Write() );
	IF buttonReset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonSuspend.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonSuspend::Write() );
	IF buttonSuspend.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonUnsuspend.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonUnsuspend::Write() );
	IF buttonUnsuspend.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonHold.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonHold::Write() );
	IF buttonHold.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonUnhold.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonUnhold::Write() );
	IF buttonUnhold.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	buttonResetAlarm.pMeth			:= StoreMethod( #M_RD_DIRECT(), #buttonResetAlarm::Write() );
	IF buttonResetAlarm.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stopAfterLength.pMeth			:= StoreMethod( #stopAfterLength::Read(), #stopAfterLength::Write() );
	IF stopAfterLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprStart.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprStart.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprInputSide.pMeth			:= StoreMethod( #stprInputSide::Read(), #stprInputSide::Write() );
	IF stprInputSide.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprOutputSide.pMeth			:= StoreMethod( #stprOutputSide::Read(), #stprOutputSide::Write() );
	IF stprOutputSide.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrontOffMaterial.pMeth			:= StoreMethod( #FrontOffMaterial::Read(), #FrontOffMaterial::Write() );
	IF FrontOffMaterial.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BackOffMaterial.pMeth			:= StoreMethod( #BackOffMaterial::Read(), #BackOffMaterial::Write() );
	IF BackOffMaterial.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ResetBackOffMaterial.pMeth			:= StoreMethod( #ResetBackOffMaterial::Read(), #ResetBackOffMaterial::Write() );
	IF ResetBackOffMaterial.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ResetFrontOffMaterialToTakeIn.pMeth			:= StoreMethod( #ResetFrontOffMaterialToTakeIn::Read(), #ResetFrontOffMaterialToTakeIn::Write() );
	IF ResetFrontOffMaterialToTakeIn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	lineNrInput.pMeth			:= StoreMethod( #lineNrInput::Read(), #lineNrInput::Write() );
	IF lineNrInput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	lineNrOutput.pMeth			:= StoreMethod( #lineNrOutput::Read(), #lineNrOutput::Write() );
	IF lineNrOutput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reReadAmountToDo.pMeth			:= StoreMethod( #reReadAmountToDo::Read(), #reReadAmountToDo::Write() );
	IF reReadAmountToDo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	amountToDo.pMeth			:= StoreMethod( #amountToDo::Read(), #amountToDo::Write() );
	IF amountToDo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	amountDone.pMeth			:= StoreMethod( #amountDone::Read(), #amountDone::Write() );
	IF amountDone.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsStopSafetyAllowed.pMeth			:= StoreMethod( #stsStopSafetyAllowed::Read(), #M_WR_DIRECT() );
	IF stsStopSafetyAllowed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	progChangesAllowed.pMeth			:= StoreMethod( #progChangesAllowed::Read(), #M_NO_F() );
	IF progChangesAllowed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParMinLevelManual.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParMinLevelManual.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParMinLevelProg.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParMinLevelProg.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParMinLevelCom.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParMinLevelCom.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParMinLevelServos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParMinLevelServos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startFromPC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startFromPC::Write() );
	IF startFromPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stopFromPC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #stopFromPC::Write() );
	IF stopFromPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	idStartFromPC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF idStartFromPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stateToPC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stateToPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	actRnrInputToPC.pMeth			:= StoreMethod( #actRnrInputToPC::Read(), #M_WR_DIRECT() );
	IF actRnrInputToPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	actRnrOutputToPC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF actRnrOutputToPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	readyForNewFileToPC.pMeth			:= StoreMethod( #readyForNewFileToPC::Read(), #readyForNewFileToPC::Write() );
	IF readyForNewFileToPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MaxRnrInputToPC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF MaxRnrInputToPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LineNrInputFromScreen.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LineNrInputFromScreen.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	actLengthInInput.pMeth			:= StoreMethod( #actLengthInInput::Read(), #actLengthInInput::Write() );
	IF actLengthInInput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parNrWindowLength.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parNrWindowLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parActLength.pMeth			:= StoreMethod( #M_RD_DIRECT(), #parActLength::Write() );
	IF parActLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parManualLengthActive.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parManualLengthActive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//****************************************************************************************************************************
//mainControl
//****************************************************************************************************************************
//The mainControl is the highest level of control.
//Commands can be given to the lower levels units.
//Here we control the following things:
//- Usercommands like pushbuttons.
//- Calculation. This must be done before the machine is allowed to start.
//- Control between the sLineHandler and the lower level Units.

//****************************************************************************************************************************
//Version control
//****************************************************************************************************************************
//Name          | Marking | Date        | Comment
//============================================================================================================================
//Jacco de Kloe | //      | 20-06-2019  | First version
//Marc Bloem    | //      | 01-03-2022  | Adding informative comments.
//Marc Bloem    | //      | 20-05-2022  | It's now possible to add and delete units without changing the code.

//****************************************************************************************************************************
//Alarms
//****************************************************************************************************************************
//Nr  | Comment
//============================================================================================================================
// -  | -mainControlV2

FUNCTION VIRTUAL GLOBAL mainControl::Init
  
  //Detect if a unit is connected. So a unit can be added or removed without changing the code.
  IF IsClientConnected(#ctrlUnit1) THEN IsConnected_Unit1 := 1; amountOfUnitsActive += 1; ELSE IsConnected_Unit1 := 0; END_IF;
  IF IsClientConnected(#ctrlUnit2) THEN IsConnected_Unit2 := 1; amountOfUnitsActive += 1; ELSE IsConnected_Unit2 := 0; END_IF;
  IF IsClientConnected(#ctrlUnit3) THEN IsConnected_Unit3 := 1; amountOfUnitsActive += 1; ELSE IsConnected_Unit3 := 0; END_IF;
  IF IsClientConnected(#ctrlUnit4) THEN IsConnected_Unit4 := 1; amountOfUnitsActive += 1; ELSE IsConnected_Unit4 := 0; END_IF;
  IF IsClientConnected(#ctrlUnit5) THEN IsConnected_Unit5 := 1; amountOfUnitsActive += 1; ELSE IsConnected_Unit5 := 0; END_IF;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR
  
  //Grab the data from the lower Units and put them in an local variable to use in this function blok.
  IF IsConnected_Unit1 = 1 THEN
    UnitState[1] := ctrlUnit1.state;
    UnitSimulation[1] := ctrlUnit1.simulation;
  ELSE
    UnitState[1] := NotActive;
    UnitSimulation[1] := noActiveSimu;
  END_IF;

  IF IsConnected_Unit2 = 1 THEN
    UnitState[2] := ctrlUnit2.state;
    UnitSimulation[2] := ctrlUnit2.simulation;
  ELSE
    UnitState[2] := NotActive;
    UnitSimulation[2] := noActiveSimu;
  END_IF;

  IF IsConnected_Unit3 = 1 THEN
    UnitState[3] := ctrlUnit3.state;
    UnitSimulation[3] := ctrlUnit3.simulation;
  ELSE
    UnitState[3] := NotActive;
    UnitSimulation[3] := noActiveSimu;
  END_IF;

  IF IsConnected_Unit4 = 1 THEN
    UnitState[4] := ctrlUnit4.state;
    UnitSimulation[4] := ctrlUnit4.simulation;
  ELSE
    UnitState[4] := NotActive;
    UnitSimulation[4] := noActiveSimu;
  END_IF;

  IF IsConnected_Unit5 = 1 THEN
    UnitState[5] := ctrlUnit5.state;
    UnitSimulation[5] := ctrlUnit5.simulation;
  ELSE
    UnitState[5] := NotActive;
    UnitSimulation[5] := noActiveSimu;
  END_IF;

  //Check if all unit states are equal.
  //===================================================================
  IF (UnitState[1] = UnitState[2] | UnitState[2] = NotActive) & (UnitState[1] = UnitState[3] | UnitState[3] = NotActive) & (UnitState[1] = UnitState[4] | UnitState[4] = NotActive) & (UnitState[1] = UnitState[5] | UnitState[5] = NotActive)   THEN
    MainControlState := UnitState[1];
    allUnitStatesEqual := 1;
  ELSE
    allUnitStatesEqual := 0;
  END_IF;

  //Check if all unit simualtion states are equal.
  //===================================================================  
  IF (UnitSimulation[1] = UnitSimulation[2] | UnitSimulation[2] = noActiveSimu) & (UnitSimulation[1] = UnitSimulation[3] | UnitSimulation[3] = noActiveSimu) & (UnitSimulation[1] = UnitSimulation[4] | UnitSimulation[4] = noActiveSimu) & (UnitSimulation[1] = UnitSimulation[5] | UnitSimulation[5] = noActiveSimu)   THEN
    MainControlSimu := UnitSimulation[1];
    allUnitSimuEqual := 1;
  ELSE
    allUnitSimuEqual := 0;
  END_IF;
  
  //Changing the simulation state of the main control.
  //===================================================================
  IF MainControlSimu = allSimu  & allUnitSimuEqual = 1 THEN
    oActSimuMode:= ctrlUnit1.simulation;
  ELSIF (UnitSimulation[1] = noneSimu | UnitSimulation[1] = noActiveSimu) & (UnitSimulation[2] = noneSimu | UnitSimulation[2] = noActiveSimu) & (UnitSimulation[3] = noneSimu | UnitSimulation[3] = noActiveSimu) & (UnitSimulation[4] = noneSimu | UnitSimulation[4] = noActiveSimu) & (UnitSimulation[5] = noneSimu | UnitSimulation[5] = noActiveSimu)THEN
    oActSimuMode:= noneSimu;
  ELSIF (UnitSimulation[1] = noMatSimu | UnitSimulation[1] = noActiveSimu) & (UnitSimulation[2] = noMatSimu | UnitSimulation[2] = noActiveSimu) & (UnitSimulation[3] = noMatSimu | UnitSimulation[3] = noActiveSimu) & (UnitSimulation[4] = noMatSimu | UnitSimulation[4] = noActiveSimu) & (UnitSimulation[5] = noMatSimu | UnitSimulation[5] = noActiveSimu)THEN
    oActSimuMode:= noMatSimu;
  ELSE
    oActSimuMode:= noActiveSimu;
  END_IF;


  IF stprStart <> 0 THEN
    actRnrInputToPC:= sLineHandler1.rnrInput;
  ELSE
    idStartFromPC:= 0;
    actRnrInputToPC:= 0; //JdK 18-5-2022: write to zero if not running batch
  END_IF;


  CASE stprStart OF
  
  0: //wait for start
  
  1: //start calculation
    IF ctrlCalc.stprCalc=0 THEN
      ctrlCalc.startCalc.Write(input:=1);
      idStartFromPC:= 0; //not started from pc, so reset id
      sLineHandler1.stsStartedFromPC:= 0;
      IF ctrlCalc.calcDone= -1 THEN //means is started
//        sLineHandler1.actMathHeigth.Read(); //JdK 29-9-2020 temp solution, we need something to get the rollers on the right place during execute
//        sLineHandler1.actMathWidth.Read();
        stprStart+=2;
      END_IF;
    END_IF;
    
  2: //start reading in file, if done go to stepper 5
    IF readInGlobalList1.stprReadIn= 0 THEN
      readInGlobalList1.stprReadIn:= 1;
    ELSIF readInGlobalList1.stprReadIn= 3 THEN
      stprStart:= 5;
    END_IF;
    
  3: //wait until calculation is ready
    IF ctrlCalc.stprCalc= 0 & ctrlCalc.calcDone>= 0 THEN
      IF ctrlCalc.calcDone= 1 THEN
        stprStart+=1;
      ELSE
        stprStart:=0; //if calc done isn't ok 
      END_IF;
    END_IF;
    
  4: //now start all the lines, but only if they are all still in idle
    IF MainControlState = Idle & allUnitStatesEqual= 1 THEN
      IF IsConnected_Unit1 = 1 THEN
        ctrlUnit1.startButton.Write(input:=1);
      END_IF;

      IF IsConnected_Unit2 = 1 THEN
        ctrlUnit2.startButton.Write(input:=1);
      END_IF;  
      
      IF IsConnected_Unit3 = 1 THEN  
        ctrlUnit3.startButton.Write(input:=1);
      END_IF;
      
        IF IsConnected_Unit4 = 1 THEN  
        ctrlUnit4.startButton.Write(input:=1);
      END_IF;
      
      IF IsConnected_Unit5 = 1 THEN  
        ctrlUnit5.startButton.Write(input:=1);
      END_IF;
      
      stprStart+=1;
    END_IF;
    
  5: //start sline handler, wait until all in execute
    IF MainControlState= Execute & allUnitStatesEqual= 1 THEN
      IF ResumeProgram = 1 & LineNrInputFromScreen > 0 then
        sLineHandler1.startProgram(LineNrInput2:=LineNrInputFromScreen);
      ELSE
        sLineHandler1.startProgram(LineNrInput2:=0);
      END_IF;
      ResumeProgram:=0;
      LineNrInputFromScreen:=0;
      stprStart+=1;
    END_IF;
    
  6: //if sLineHandler is completed, wait for all units untill they are completed/idle
    IF sLineHandler1.stsCompleted= 1 THEN
      IF (MainControlState= Complete | MainControlState= Idle) & allUnitStatesEqual THEN
        IF IsConnected_Unit1 = 1 THEN
          ctrlUnit1.resetRerun(); //make sure restart isn't possible any more
        END_IF;

        IF IsConnected_Unit2 = 1 THEN
          ctrlUnit2.resetRerun();
        END_IF;  
        
        IF IsConnected_Unit3 = 1 THEN  
          ctrlUnit3.resetRerun();
        END_IF;
        
          IF IsConnected_Unit4 = 1 THEN  
          ctrlUnit4.resetRerun();
        END_IF;
        
        IF IsConnected_Unit5 = 1 THEN  
          ctrlUnit5.resetRerun();
        END_IF;
      END_IF;
      
      IF (MainControlState= Complete | MainControlState= Idle) & allUnitStatesEqual  THEN
        sLineHandler1.stopProgram();
        idStartFromPC:= 0;
        readInGlobalList1.stprReadIn:= 10; //stop reading in        
        stprStart:=0; //and stop it
      END_IF;
      
    ELSIF sLineHandler1.stprInputSide= 10 THEN //means waiting for stop after lenght, input done, output not yet
      IF UnitState[1]= Holding & UnitState[1]= Held THEN
        ctrlUnit1.holdButton.Write(input:=1); //set input already to held
      END_IF;
    ELSIF sLineHandler1.stprInputSide= 11 THEN //means waiting for stop after length, both input and output are done
      IF (UnitState[1]= Held | UnitState[1]= NotActive) & (UnitState[2]= Held | UnitState[2]= NotActive)  & (UnitState[3]= Held | UnitState[3]= NotActive) & (UnitState[4]= Held | UnitState[4]= NotActive) & (UnitState[5]= Held | UnitState[5]= NotActive) THEN
        sLineHandler1.stprInputSide:=17; //start it again, but for real action, operator first need to unhold machine
      ELSE
        IF UnitState[1]<> Holding & UnitState[1]<>  Held THEN
          ctrlUnit1.holdButton.Write(input:=1);
        END_IF;  
        IF UnitState[2]<> Holding & UnitState[2]<>  Held THEN
          ctrlUnit2.holdButton.Write(input:=1);
        END_IF; 
        IF UnitState[3]<> Holding & UnitState[3]<>  Held THEN
          ctrlUnit3.holdButton.Write(input:=1);
        END_IF;
        IF UnitState[4]<> Holding & UnitState[4]<>  Held THEN
          ctrlUnit4.holdButton.Write(input:=1);
        END_IF;  
        IF UnitState[5]<> Holding & UnitState[5]<>  Held THEN
          ctrlUnit5.holdButton.Write(input:=1);
        END_IF;  
      END_IF;
    ELSIF sLineHandler1.stprInputSide= 12 THEN //means waiting for next program
      IF readInGlobalList1.stprReadIn= 3 THEN
        readInGlobalList1.startNextProfile();
        sLineHandler1.stprInputSide:= 13;
      ELSIF readInGlobalList1.stprReadIn= 4 THEN //means reached end of file
        sLineHandler1.stprInputSide:= 15; //stop producting
      END_IF;
    ELSIF sLineHandler1.stprInputSide= 13 THEN //waiting for next start
      IF readInGlobalList1.stprReadIn= 3 THEN
        sLineHandler1.stprInputSide:= 14;
      ELSIF readInGlobalList1.stprReadIn= 4 | readInGlobalList1.stprReadIn= 0 THEN //done with reading in (alarm or failure)
        sLineHandler1.stprInputSide:= 15; //stop with reading in
      END_IF;
    END_IF;
  
  END_CASE;  

  //SlineHandler complete
  //===================================================================
  
  IF IsConnected_Unit1 = 1 THEN
    ctrlUnit1.cmdCompleted:= sLineHandler1.stsCompleted;
  END_IF;

  IF IsConnected_Unit2 = 1 THEN
    ctrlUnit2.cmdCompleted:= sLineHandler1.stsCompleted;
  END_IF;  
  
  IF IsConnected_Unit3 = 1 THEN  
    ctrlUnit3.cmdCompleted:= sLineHandler1.stsCompleted;
  END_IF;
  
    IF IsConnected_Unit4 = 1 THEN  
    ctrlUnit4.cmdCompleted:= sLineHandler1.stsCompleted;
  END_IF;
  
  IF IsConnected_Unit5 = 1 THEN  
    ctrlUnit5.cmdCompleted:= sLineHandler1.stsCompleted;
  END_IF;

  //===================================================================

  iBlinkFast:=iBlinkFast.Read();
  iBlinkSlow:= iBlinkSlow.Read();

  //When one state is aborting or aborted then the main state will be aborted.
  IF UnitState[1]= Aborting | UnitState[1]= Aborted | UnitState[2]= Aborting | UnitState[2]= Aborted | UnitState[3]= Aborting | UnitState[3]= Aborted | UnitState[4]= Aborting | UnitState[4]= Aborted | UnitState[5]= Aborting | UnitState[5]= Aborted   THEN
    oCycleLamp:= 0;
    stateToPC:= Aborted;
  //
  ELSIF UnitState[1]= Stopping | UnitState[1]= Stopped | UnitState[2]= Stopping | UnitState[2]= Stopped | UnitState[3]= Stopping | UnitState[3]= Stopped | UnitState[4]= Stopping | UnitState[4]= Stopped | UnitState[5]= Stopping | UnitState[5]= Stopped THEN
    oCycleLamp:= 0;
    stateToPC:= Stopped;
  ELSIF(UnitState[1] = Execute | UnitState[1] = Completing | UnitState[1] = Complete | UnitState[1] = NotActive) & (UnitState[2] = Execute | UnitState[2] = Completing | UnitState[2] = Complete | UnitState[2] = NotActive) & (UnitState[3] = Execute | UnitState[3] = Completing | UnitState[3] = Complete | UnitState[3] = NotActive) & (UnitState[4] = Execute | UnitState[4] = Completing | UnitState[4] = Complete | UnitState[4] = NotActive) & (UnitState[5] = Execute | UnitState[5] = Completing | UnitState[5] = Complete | UnitState[5] = NotActive) THEN
    oCycleLamp:=1;
    stateToPC:= Execute;
  ELSIF stprStart<> 0 THEN // (ctrlUnit1.state = Execute | ctrlUnit1.state = Completing | ctrlUnit2.state = Execute | ctrlUnit2.state = Completing |
                           //ctrlUnit3.state = Execute | ctrlUnit3.state = Completing) THEN
    IF (UnitState[1] = Idle | UnitState[1] = NotActive) & (UnitState[2] = Idle | UnitState[2] = NotActive) & (UnitState[3] = Idle | UnitState[3] = NotActive) & (UnitState[4] = Idle | UnitState[4] = NotActive) & (UnitState[5] = Idle | UnitState[5] = NotActive) THEN
      oCycleLamp:= iBlinkSlow;
      stateToPC:= Idle;
    ELSIF (UnitState[1] = Idle | UnitState[1] = Held | UnitState[1] = Suspended | UnitState[1] = Execute | UnitState[1] = NotActive) & 
          (UnitState[2] = Idle | UnitState[2]= Held | UnitState[2]= Suspended | UnitState[2]= Execute | UnitState[2] = NotActive) &
          (UnitState[3] = Idle | UnitState[3]= Held | UnitState[3]= Suspended | UnitState[3]= Execute | UnitState[3] = NotActive) &
          (UnitState[4] = Idle | UnitState[4]= Held | UnitState[4]= Suspended | UnitState[4]= Execute | UnitState[4] = NotActive) &
          (UnitState[5] = Idle | UnitState[5]= Held | UnitState[5]= Suspended | UnitState[5]= Execute | UnitState[5] = NotActive) THEN
      oCycleLamp:= iBlinkSlow; //paused, possible to restart
      
      IF (UnitState[1] = Idle | UnitState[1] = Held | UnitState[1] = Execute | UnitState[1] = NotActive) & 
         (UnitState[2] = Idle | UnitState[2] = Held | UnitState[2] = Execute | UnitState[2] = NotActive) &
         (UnitState[3] = Idle | UnitState[3] = Held | UnitState[3] = Execute | UnitState[3] = NotActive) &
         (UnitState[4] = Idle | UnitState[4] = Held | UnitState[4] = Execute | UnitState[4] = NotActive) &
         (UnitState[5] = Idle | UnitState[5] = Held | UnitState[5] = Execute | UnitState[5] = NotActive) THEN
        stateToPC:= Suspended;
      ELSE
        stateToPC:= Held;
      END_IF;
    ELSIF UnitState[1] <> Aborted | UnitState[2] <> Aborted | UnitState[3] <> Aborted  | UnitState[4] <> Aborted  | UnitState[5] <> Aborted THEN
      oCycleLamp:= iBlinkFast; //in not stable state (going to held/??)
      stateToPC:= ctrlUnit1.state; //just give state of machine to do something
    ELSE
      oCycleLamp:= 0;
      stateToPC:= Aborted;
    END_IF;
  ELSE
    oCycleLamp:= 0;
    IF UnitState[1]= Resetting | UnitState[2]= Resetting | UnitState[3]= Resetting | UnitState[4]= Resetting | UnitState[5]= Resetting THEN
      stateToPC:= Resetting;
    ELSIF UnitState[1]= Stopped | UnitState[2]= Stopped | UnitState[3]= Stopped | UnitState[4]= Stopped | UnitState[5]= Stopped THEN
      stateToPC:= Stopped;
    ELSE
      stateToPC:= ctrlUnit1.state;
    END_IF;
  END_IF;
  
  IF allUnitStatesEqual THEN //overwrite state if all are the same
    stateToPC:= ctrlUnit1.state;
  END_IF;
  
  oCycleLamp.Write(input:=oCycleLamp);

  //write alarm lamp
  IF (IsConnected_Unit1= 1 & ctrlUnit1.stsInAlarm) & (IsConnected_Unit2= 1 & ctrlUnit2.stsInAlarm) & (IsConnected_Unit3= 1 & ctrlUnit3.stsInAlarm) &
       (IsConnected_Unit4= 1 & ctrlUnit4.stsInAlarm) & (IsConnected_Unit5= 1 & ctrlUnit5.stsInAlarm) THEN
    oAlarmLamp:= iBlinkFast;
  ELSE
    oAlarmLamp:= 0;
  END_IF;
  oAlarmLamp.Write(input:=oAlarmLamp);



  //some servers to show and hide buttons and possibilities in the screen project
  progChangesAllowed.Read();
  
// RVDL 21-10-2019 permisson control for screen

  IF ctrlScreen.UserLevel >= sParMinLevelManual & 
                (UnitState[1] = idle | UnitState[1] = Suspended | UnitState[1] = Held | UnitState[1] = NotActive) &
                (UnitState[2] = idle | UnitState[2] = Suspended | UnitState[2] = Held | UnitState[2] = NotActive) &
                (UnitState[3] = idle | UnitState[3] = Suspended | UnitState[3] = Held | UnitState[3] = NotActive) &
                (UnitState[4] = idle | UnitState[4] = Suspended | UnitState[4] = Held | UnitState[4] = NotActive) &
                (UnitState[5] = idle | UnitState[5] = Suspended | UnitState[5] = Held | UnitState[5] = NotActive) THEN 
    ScreenManualControlAllowed:=1;
  ELSE
    ScreenManualControlAllowed:=0;
  END_IF;
  
  IF ctrlScreen.UserLevel >= sParMinLevelProg & progChangesAllowed.Read()= 1 THEN 
    ScreenProgChangesAllowed:=1;
  ELSE
    ScreenProgChangesAllowed:=0;
  END_IF;
  
  IF ctrlScreen.UserLevel >= sParMinLevelProg & progChangesAllowed.Read()= 1THEN 
    ScreenProgChangesmillAllowed:=1;
  ELSE
    ScreenProgChangesmillAllowed:=0;
  END_IF;
  
  IF progChangesAllowed.Read() = 1 THEN
    ScreenAssemNrAllowed:=1;
  ELSE
    ScreenAssemNrAllowed:=0;
  END_IF;
  
  IF ctrlScreen.UserLevel >= sParMinLevelCom THEN 
    ScreenCommonSettingsAllowed:=1;
  ELSE
    ScreenCommonSettingsAllowed:=0;
  END_IF;

  IF ctrlScreen.UserLevel >= sParMinLevelServos THEN 
   ScreenAxisSettingsAllowed:=1;
  ELSE
    ScreenAxisSettingsAllowed:=0;
  END_IF;  
  
  if progChangesAllowed.Read()= 1 then//TP 28-7-2021 punch on/off only allowed when machine is in stop
    ScreenPuchOnOffAllowed:=1;
  else
    ScreenPuchOnOffAllowed:=0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::buttonStart::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonStart := input;
  
  //Preparing for starting.
  IF buttonStart = -1 THEN
    //ctrlCalc.prepareProfileData();
    
  //First time start from the screen.
  ELSIF buttonStart= 2 & stprStart=0 THEN
    IF MainControlState = Idle & allUnitStatesEqual = 1 THEN
      stprStart:=1;
    END_IF;

  //Resume program from a lineNr.
  ELSIF buttonStart= 3 & stprStart=0  THEN
    IF MainControlState = Idle & allUnitStatesEqual = 1 THEN
      stprStart:=1;  
      ResumeProgram:=1;
    END_IF;

  //When the machine was already started, we give an command to restart.
  ELSIF stprStart>= 5 THEN 
  
    IF IsConnected_Unit1 THEN
      CASE ctrlUnit1.state OF
      
        Idle:
          ctrlUnit1.startButton.Write(input:=1);
      
        Held:
          ctrlUnit1.unHoldButton.Write(input:=1);
      
        Suspended:
          ctrlUnit1.unsuspendButton.Write(input:=1);
      
      END_CASE;
    END_IF;


    IF IsConnected_Unit2 THEN
      CASE ctrlUnit2.state OF
      
        Idle:
          ctrlUnit2.startButton.Write(input:=1);
      
        Held:
          ctrlUnit2.unHoldButton.Write(input:=1);
      
        Suspended:
          ctrlUnit2.unsuspendButton.Write(input:=1);
      
      END_CASE;
    END_IF;


    IF IsConnected_Unit3 THEN    
      CASE ctrlUnit3.state OF
      
        Idle:
          ctrlUnit3.startButton.Write(input:=1);
      
        Held:
          ctrlUnit3.unHoldButton.Write(input:=1);
      
        Suspended:
          ctrlUnit3.unsuspendButton.Write(input:=1);
      
      END_CASE;
     END_IF;

    IF IsConnected_Unit4 THEN    
      CASE ctrlUnit4.state OF
      
        Idle:
          ctrlUnit4.startButton.Write(input:=1);
      
        Held:
          ctrlUnit4.unHoldButton.Write(input:=1);
      
        Suspended:
          ctrlUnit4.unsuspendButton.Write(input:=1);
      
      END_CASE;
     END_IF;
     
     IF IsConnected_Unit5 THEN    
      CASE ctrlUnit5.state OF
      
        Idle:
          ctrlUnit5.startButton.Write(input:=1);
      
        Held:
          ctrlUnit5.unHoldButton.Write(input:=1);
      
        Suspended:
          ctrlUnit5.unsuspendButton.Write(input:=1);
      
      END_CASE;
     END_IF;
 
  ELSE
    //Position to add an alarm.
  END_IF;
  
  //Reset result value to 0 when function is done.
  buttonStart:= 0;  
	result := buttonStart;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::buttonStop::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonStop := input;
  
  //Give the unit the command to stop and makes an rerun impossible.
  IF IsConnected_Unit1 THEN
    ctrlUnit1.stopButton.Write(input:=1); 
    ctrlUnit1.resetRerun();  
  END_IF;

  IF IsConnected_Unit2 THEN
    ctrlUnit2.stopButton.Write(input:=1);
    ctrlUnit2.resetRerun();  
  END_IF;

  IF IsConnected_Unit3 THEN
    ctrlUnit3.stopButton.Write(input:=1);
    ctrlUnit3.resetRerun();  
  END_IF;

  IF IsConnected_Unit4 THEN
    ctrlUnit4.stopButton.Write(input:=1);
    ctrlUnit4.resetRerun();  
  END_IF;

  IF IsConnected_Unit5 THEN
    ctrlUnit5.stopButton.Write(input:=1);
    ctrlUnit5.resetRerun();  
  END_IF;

  //Stopping the sLineHandler.
  sLineHandler1.stopProgram();
  
  //Setting the servers to make an restart rerun impossible.
  stprStart:=0;
  ResumeProgram:=0;
  LineNrInputFromScreen:=0;
  
  //Reset result value to 0 when function is done.  
  buttonStop:= 0;
	result := buttonStop;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::buttonReset::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonReset := input;
  
  //Give command to the lower lever units to go to the resetting state.
  //The unit will determine if this is possible.
  IF IsConnected_Unit1 THEN ctrlUnit1.resetButton.Write(input:=1); END_IF;
  IF IsConnected_Unit2 THEN ctrlUnit2.resetButton.Write(input:=1); END_IF;
  IF IsConnected_Unit3 THEN ctrlUnit3.resetButton.Write(input:=1); END_IF;
  IF IsConnected_Unit4 THEN ctrlUnit4.resetButton.Write(input:=1); END_IF;
  IF IsConnected_Unit5 THEN ctrlUnit5.resetButton.Write(input:=1); END_IF;
  
  //Reset result value to 0 when function is done.
  buttonReset:= 0;
	result := buttonReset;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::buttonSuspend::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonSuspend := input;
  
  //Give command to the lower lever units to go to the suspend state.
  //The unit will determine if this is possible.
  IF IsConnected_Unit1 THEN ctrlUnit1.suspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit2 THEN ctrlUnit2.suspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit3 THEN ctrlUnit3.suspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit4 THEN ctrlUnit4.suspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit5 THEN ctrlUnit5.suspendButton.Write(input:=1); END_IF;
  
  //Reset result value to 0 when function is done.  
  buttonSuspend:= 0;
	result := buttonSuspend;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::buttonUnsuspend::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonUnsuspend := input;
  
  //Give command to the lower lever units to go to the unsuspend state.
  //The unit will determine if this is possible.
  IF IsConnected_Unit1 THEN ctrlUnit1.unsuspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit2 THEN ctrlUnit2.unsuspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit3 THEN ctrlUnit3.unsuspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit4 THEN ctrlUnit4.unsuspendButton.Write(input:=1); END_IF;
  IF IsConnected_Unit5 THEN ctrlUnit5.unsuspendButton.Write(input:=1); END_IF;

   //Reset result value to 0 when function is done.  
  buttonUnsuspend:= 0;
	result := buttonUnsuspend;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::buttonHold::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonHold := input;

  //Give command to the lower lever units to go to the holding state.
  //The unit will determine if this is possible.   
  IF IsConnected_Unit1 THEN ctrlUnit1.holdButton.Write(input:=1); END_IF;
  IF IsConnected_Unit2 THEN ctrlUnit2.holdButton.Write(input:=1); END_IF;
  IF IsConnected_Unit3 THEN ctrlUnit3.holdButton.Write(input:=1); END_IF;
  IF IsConnected_Unit4 THEN ctrlUnit4.holdButton.Write(input:=1); END_IF;
  IF IsConnected_Unit5 THEN ctrlUnit5.holdButton.Write(input:=1); END_IF;

   //Reset result value to 0 when function is done.    
  buttonHold:= 0;
	result := buttonHold;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::buttonUnhold::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonUnhold := input;

  //Give command to the lower lever units to go to the unholding state.
  //The unit will determine if this is possible. 
  IF IsConnected_Unit1 THEN ctrlUnit1.unHoldButton.Write(input:=1); END_IF;
  IF IsConnected_Unit2 THEN ctrlUnit2.unHoldButton.Write(input:=1); END_IF;
  IF IsConnected_Unit3 THEN ctrlUnit3.unHoldButton.Write(input:=1); END_IF;
  IF IsConnected_Unit4 THEN ctrlUnit4.unHoldButton.Write(input:=1); END_IF;
  IF IsConnected_Unit5 THEN ctrlUnit5.unHoldButton.Write(input:=1); END_IF;
  
   //Reset result value to 0 when function is done.  
  buttonUnhold:= 0;
	result := buttonUnhold;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::buttonResetAlarm::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variables.
	buttonResetAlarm := input;

  IF IsConnected_Unit1 THEN ctrlUnit1.cmdResetAlarm(); END_IF;
  IF IsConnected_Unit2 THEN ctrlUnit2.cmdResetAlarm(); END_IF;
  IF IsConnected_Unit3 THEN ctrlUnit3.cmdResetAlarm(); END_IF;
  IF IsConnected_Unit4 THEN ctrlUnit4.cmdResetAlarm(); END_IF;
  IF IsConnected_Unit5 THEN ctrlUnit5.cmdResetAlarm(); END_IF;
  
  oResetAlarm.Write(input:=1);
  
  //Set the result value to the value . 
	result := buttonResetAlarm;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::stopAfterLength::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	stopAfterLength := sLineHandler1.stopAfterLength.Read();
	output := stopAfterLength;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::stopAfterLength::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	stopAfterLength := input;
	result := (sLineHandler1.stopAfterLength.Write(stopAfterLength))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::stprInputSide::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Collect the data.
	stprInputSide := sLineHandler1.stprInputSide.Read();
  
  //Return the data.
	output := stprInputSide;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::stprInputSide::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variabe.
	stprInputSide := input;
  
  //Execute te command.
	result := (sLineHandler1.stprInputSide.Write(stprInputSide))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::stprOutputSide::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  //Collect the data.
	stprOutputSide := sLineHandler1.stprOutputSide.Read();

  //Return the data.  
	output := stprOutputSide;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::stprOutputSide::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variabe.
	stprOutputSide := input;
  
  //Execute the command.
	result := (sLineHandler1.stprOutputSide.Write(stprOutputSide))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::FrontOffMaterial::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Collecting the data.
	FrontOffMaterial := sLineHandler1.FrontOffMaterial.Read();
  
  //Return the data.
	output := FrontOffMaterial;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::FrontOffMaterial::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variable.
	FrontOffMaterial := input;

  //Execute the command.
	result := (sLineHandler1.FrontOffMaterial.Write(FrontOffMaterial))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::BackOffMaterial::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Collecting the data.
	BackOffMaterial := sLineHandler1.BackOffMaterial.Read();
  
  //Return the data.
	output := BackOffMaterial;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::BackOffMaterial::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variable.
	BackOffMaterial := input;
  
  //Execute the command.
	result := (sLineHandler1.BackOffMaterial.Write(BackOffMaterial))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::ResetBackOffMaterial::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	ResetBackOffMaterial := sLineHandler1.ResetBackOffMaterial.Read();
	output := ResetBackOffMaterial;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::ResetBackOffMaterial::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ResetBackOffMaterial := input;
	result := (sLineHandler1.ResetBackOffMaterial.Write(ResetBackOffMaterial))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::ResetFrontOffMaterialToTakeIn::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	ResetFrontOffMaterialToTakeIn := sLineHandler1.ResetFrontOffMaterialToTakeIn.Read();
	output := ResetFrontOffMaterialToTakeIn;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::ResetFrontOffMaterialToTakeIn::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ResetFrontOffMaterialToTakeIn := input;
	result := (sLineHandler1.ResetFrontOffMaterialToTakeIn.Write(ResetFrontOffMaterialToTakeIn))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::lineNrInput::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Collecting the data.
	lineNrInput := sLineHandler1.lineNrInput.Read();
  
  //Return the data.
	output := lineNrInput;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::lineNrInput::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variable.
	lineNrInput := input;
  
  //Execute te command.
	result := (sLineHandler1.lineNrInput.Write(lineNrInput))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::lineNrOutput::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Collecting the data.
	lineNrOutput := sLineHandler1.lineNrOutput.Read();

  //Return the data.
	output := lineNrOutput;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::lineNrOutput::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variable.
	lineNrOutput := input;
  
  //Execute te command.
	result := (sLineHandler1.lineNrOutput.Write(lineNrOutput))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::reReadAmountToDo::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	reReadAmountToDo := sLineHandler1.reReadAmountToDo.Read();
	output := reReadAmountToDo;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::reReadAmountToDo::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	reReadAmountToDo := input;
	result := (sLineHandler1.reReadAmountToDo.Write(reReadAmountToDo))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::amountToDo::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	amountToDo := sLineHandler1.amountToDo.Read();
	output := amountToDo;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::amountToDo::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	amountToDo := input;
	result := (sLineHandler1.amountToDo.Write(amountToDo))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::amountDone::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	amountDone := sLineHandler1.amountDone.Read();
	output := amountDone;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::amountDone::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	amountDone := input;
	result := (sLineHandler1.amountDone.Write(amountDone))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::progChangesAllowed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Set all states in an array so we can easly add more units.
  IF IsConnected_Unit1 = 1 THEN
    UnitProgChangesAllowed[1] := ctrlUnit1.stsProgChangesAllowed;
  ELSE
    UnitProgChangesAllowed[1] := -1;
  END_IF;

  IF IsConnected_Unit2 = 1 THEN
    UnitProgChangesAllowed[2] := ctrlUnit2.stsProgChangesAllowed;
  ELSE
    UnitProgChangesAllowed[2] := -1;
  END_IF;

  IF IsConnected_Unit3 = 1 THEN
    UnitProgChangesAllowed[3] := ctrlUnit3.stsProgChangesAllowed;
  ELSE
    UnitProgChangesAllowed[3] := -1;
  END_IF;

  IF IsConnected_Unit4 = 1 THEN
    UnitProgChangesAllowed[4] := ctrlUnit4.stsProgChangesAllowed;
  ELSE
    UnitProgChangesAllowed[4] := -1;
  END_IF;

  IF IsConnected_Unit5 = 1 THEN
    UnitProgChangesAllowed[5] := ctrlUnit5.stsProgChangesAllowed;
  ELSE
    UnitProgChangesAllowed[5] := -1;
  END_IF;
  
  //Determine the state of the main control.
  //===================================================================
  IF (UnitProgChangesAllowed[1] = 1 | UnitProgChangesAllowed[1] = -1) & (UnitProgChangesAllowed[2] = 1 | UnitProgChangesAllowed[2] = -1) & (UnitProgChangesAllowed[3] = 1 | UnitProgChangesAllowed[3] = -1) & (UnitProgChangesAllowed[4] = 1 | UnitProgChangesAllowed[4] = -1) & (UnitProgChangesAllowed[5] = 1 | UnitProgChangesAllowed[5] = -1)  THEN
    progChangesAllowed := 1;
  ELSE
    progChangesAllowed := 0;
  END_IF;

  //===================================================================

	output := progChangesAllowed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::startFromPC::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variable.
	startFromPC := input;
  idStartFromPC:= startFromPC;  
  
  IF stprStart= 0 & readInGlobalList1.stprReadIn= 0 THEN //only allow start if stprReadin is 0
    sLineHandler1.rnrInput.Write(input:=0);
    sLineHandler1.rnrOutput.Write(input:=0);
    sLineHandler1.stsStartedFromPC:= 1;
    stprStart:= 2;
  END_IF;
  
  //Returns the input value.
	result := startFromPC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::stopFromPC::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variable.
	stopFromPC := input;
  
  //Give the sLineHandler the information that is has been started from the PC.
  sLineHandler1.stsStartedFromPC:= 0;
  
  //stprReadIn = 10 in the readInGlobal list is closing the file.
  IF readInGlobalList1.stprReadIn<> 0 THEN
    readInGlobalList1.stprReadIn:= 10;
  END_IF;
  
  //The machine will stop, so the machine is not started from the PC anymore.
  idStartFromPC:= 0;
  
  //Stopping the machine by ussing the buttonStop command.
  buttonStop.Write(input:=1);
  
  //Returns the input value.  
	result := stopFromPC;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL mainControl::actRnrInputToPC::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  IF stprStart <> 0 THEN
    actRnrInputToPC:= sLineHandler1.rnrInput;
  ELSE
    idStartFromPC:= 0;
    actRnrInputToPC:= 0; //JdK 18-5-2022: write to zero if not running batch
  END_IF;
	output := actRnrInputToPC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::readyForNewFileToPC::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Look if all lower level units are available to have an program change.
  readyForNewFileToPC:= progChangesAllowed = 1 & stateToPC= Idle;

  //Return the collected value.
	output := readyForNewFileToPC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::readyForNewFileToPC::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Getting the data by using the read function.
  readyForNewFileToPC.Write(input:=input);

  //Return the collected value.  
	result := readyForNewFileToPC;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::actLengthInInput::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  //Getting the data from the sLineHandler.
	actLengthInInput := sLineHandler1.actLengthInInput.Read();
  
  //Return the collected value.
	output := actLengthInInput;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::actLengthInInput::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //Setting the variable.
	actLengthInInput := input;
  
  //Execute the command in the sLineHandler and return if the command succeeded.
	result := (sLineHandler1.actLengthInInput.Write(actLengthInInput))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::stsStopSafetyAllowed::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	stsStopSafetyAllowed:= (UnitState[1]= Stopped | UnitState[1]= Idle | UnitState[1]= Held | UnitState[1]= Suspended | UnitState[1]= Aborted | UnitState[1]= NotActive) &
                         (UnitState[2]= Stopped | UnitState[2]= Idle | UnitState[2]= Held | UnitState[2]= Suspended | UnitState[2]= Aborted | UnitState[2]= NotActive) &
                         (UnitState[3]= Stopped | UnitState[3]= Idle | UnitState[3]= Held | UnitState[3]= Suspended | UnitState[3]= Aborted | UnitState[3]= NotActive) &
                         (UnitState[4]= Stopped | UnitState[4]= Idle | UnitState[4]= Held | UnitState[4]= Suspended | UnitState[4]= Aborted | UnitState[4]= NotActive) &
                         (UnitState[5]= Stopped | UnitState[5]= Idle | UnitState[5]= Held | UnitState[5]= Suspended | UnitState[5]= Aborted | UnitState[5]= NotActive);

	output := stsStopSafetyAllowed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL mainControl::parActLength::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  IF input >= 30000 & input <= 63100 THEN
	  parActLength := input;
    IF stprStart= 7 | stprStart= 8 THEN
      //ctrlReadInProduct.inputLength:= parActLength;
      IF ctrlScreen.ActWindow= parNrWindowLength THEN
        ctrlScreen.CloseWindow.Write(input:=1);
      END_IF;
      stprStart:= 10;
    END_IF;
  END_IF;
	result := parActLength;

END_FUNCTION


FUNCTION GLOBAL mainControl::startSLine
	VAR_INPUT
		sLine 	: SRegelInfo;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  tmpUnits:=0;
  IF IsConnected_Unit1 THEN tmpUnits+=ctrlUnit1.Start(sLine:=sLine); END_IF;
  IF IsConnected_Unit2 THEN tmpUnits+=ctrlUnit2.Start(sLine:=sLine); END_IF;
  IF IsConnected_Unit3 THEN tmpUnits+=ctrlUnit3.Start(sLine:=sLine); END_IF;
  IF IsConnected_Unit4 THEN tmpUnits+=ctrlUnit4.Start(sLine:=sLine); END_IF;
  IF IsConnected_Unit5 THEN tmpUnits+=ctrlUnit5.Start(sLine:=sLine); END_IF;
  
  IF tmpUnits = sLine.Units | (tmpUnits+Units.DoWithOutput) = sLine.Units THEN
    ok:=1;
  ELSE
    ok:=0;
  END_IF;
  //ok:=ctrlUnit1.Start(sLine:=sLine) | ctrlUnit2.Start(sLine:=sLine) | ctrlUnit3.Start(sLine:=sLine); //if one of them picks the line, it's ok

END_FUNCTION


FUNCTION GLOBAL mainControl::askReadySLine
	VAR_INPUT
		sLine 	: SRegelInfo;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  IF IsConnected_Unit1 = 1 THEN
    IF IsConnected_Unit2 = 1 THEN
      IF IsConnected_Unit3 = 1 THEN
        IF IsConnected_Unit4 = 1 THEN
          IF IsConnected_Unit5 = 1 THEN
            ok:=ctrlUnit1.Ready(sLine:=sLine) & ctrlUnit2.Ready(sLine:=sLine) & ctrlUnit3.Ready(sLine:=sLine) & ctrlUnit4.Ready(sLine:=sLine) & ctrlUnit5.Ready(sLine:=sLine);
          ELSE
            ok:=ctrlUnit1.Ready(sLine:=sLine) & ctrlUnit2.Ready(sLine:=sLine) & ctrlUnit3.Ready(sLine:=sLine) & ctrlUnit4.Ready(sLine:=sLine);
          END_IF;
        ELSE
          ok:=ctrlUnit1.Ready(sLine:=sLine) & ctrlUnit2.Ready(sLine:=sLine) & ctrlUnit3.Ready(sLine:=sLine);
        END_IF;
      ELSE
        ok:=ctrlUnit1.Ready(sLine:=sLine) & ctrlUnit2.Ready(sLine:=sLine);
      END_IF;
    ELSE
      ok:=ctrlUnit1.Ready(sLine:=sLine);
    END_IF;
  ELSE
    ok:= 1;
  END_IF;
  
END_FUNCTION


FUNCTION GLOBAL mainControl::calcNext

  stprStart:= 1;

END_FUNCTION






