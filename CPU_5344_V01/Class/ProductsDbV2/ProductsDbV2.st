//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ProductsDbV2"
	Revision           = "1.0"
	GUID               = "{6A899055-7499-46E1-AC7B-0F0AA8A95F81}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(600,1500)">
	<Channels>
		<Server Name="endAngle" GUID="{16C427F7-7143-454E-91BE-A1F794A2CA38}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="frontEndFlipAllowed" GUID="{4E377574-0F4C-46ED-8B40-8DA739218498}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiDeleteRecipe" GUID="{C1234778-2710-430C-988C-F134E3A6F726}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiReloadRecipe" GUID="{76F950CF-0661-40EA-A8F8-5360CB84E3C8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiSaveRecipe" GUID="{4CEA7B00-F4E2-4043-9F8C-8578BAB4ADEB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="noEndSaw" GUID="{199480F7-5E64-442B-9D39-E68CDBD8B033}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="OperationId1" GUID="{D330C57C-5DA2-4B94-A251-BA0645128342}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="OperationId2" GUID="{DBBD2CFC-0F32-4B96-867F-28FC143CFD0F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="OperationId3" GUID="{49536141-A4DF-496E-B8F8-3C40571E3A91}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="parAutoSave" GUID="{9C10AF9C-2919-4012-973F-1E9095F6BD91}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="ProductHeight" GUID="{A4CB60A9-DAE7-40D4-B6A5-32C5F5C0F608}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ProductLength" GUID="{D6D277A0-AE9D-45A2-94FC-FEF496275F5A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ProductWidth" GUID="{CB141915-8EC6-4CD0-9340-A15E9B7B1E73}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="RecipeId" GUID="{4AF525BD-A507-40C1-B6A7-0409D46E43A3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="setZposAtHalfWidth" GUID="{8F63BEEE-9F91-4284-8BD9-82B452E99D67}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="startAngle" GUID="{76CAF999-3BA9-4D05-9473-764A2D4473C4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="strDescription" GUID="{F51AD83E-F508-45E6-B734-FB88B8E22C5E}" Class="EditString" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="strProductCode" GUID="{99FF5FC0-6821-48D9-BEFF-868CB5AB8F59}" Class="EditString" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="stsUnsafeChanges" GUID="{3B97CF2E-A120-4379-809C-BFABFDAE2372}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="upDownFlipAllowed" GUID="{8D47E1FD-7A14-4624-816F-B31ED2C21893}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="FB" Required="true" Internal="false"/>
		<Client Name="FileSys" Required="false" Internal="false"/>
		<Client Name="OperationData" Required="true" Internal="true"/>
		<Client Name="RamEx" Required="true" Internal="false"/>
		<Client Name="str_Description" Required="true" Internal="true"/>
		<Client Name="str_ProductCode" Required="true" Internal="true"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="14"/>
			<SepChn Position="16"/>
		</Servers>
		<Clients>
			<SepChn Position="1"/>
		</Clients>
	</Separators>
	<Network Name="ProductsDbV2">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{74B6855E-E0F3-45D1-814D-563560B0C530}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name       = "OperationData"
				GUID       = "{B98A1886-7B47-497B-8399-2A701A84EB22}"
				Class      = "OperationDataV2"
				Position   = "(420,1470)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="firstIdx"/>
				</Channels>
			</Object>
			<Object
				Name       = "str_Description"
				GUID       = "{92E5D3D8-55DD-41C7-A568-814580D925EF}"
				Class      = "EditString"
				Position   = "(360,810)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="Handle"/>
					<Server Name="NewData"/>
				</Channels>
			</Object>
			<Object
				Name       = "str_ProductCode"
				GUID       = "{304F2F62-AAA1-4548-BD4E-62AD8F4E8AD6}"
				Class      = "EditString"
				Position   = "(360,1110)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="Handle"/>
					<Server Name="NewData"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1058,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1058,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1058,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1058,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1058,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1058,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1058,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1058,630),(864,690),"/>
			<Connection Source="this.str_ProductCode" Destination="str_ProductCode.Data"/>
			<Connection Source="this.str_Description" Destination="str_Description.Data"/>
			<Connection Source="this.OperationData" Destination="OperationData.ClassSvr"/>
			<Connection Source="this.strProductCode" Destination="str_ProductCode.Data" Vertices="(1058,810),(676,1200),"/>
			<Connection Source="this.strDescription" Destination="str_Description.Data" Vertices="(1058,750),(676,900),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

ProductsDbV2 : CLASS
: cmBase
	TYPE
	  str_100 : ARRAY [0..225] OF CHAR;
	  str_3000 : ARRAY [0..3000] OF CHAR;
#pragma pack(push, 1)
	  tBewerkingsRegel : STRUCT  //! <Type Public="true" Name="tBewerkingsRegel"/>
	    Bewerking : Units;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  tRecipeLine : STRUCT  //! <Type Public="true" Name="tRecipeLine"/>
	    rnr : DINT;
	    xpos : DINT;
	    ypos : DINT;
	    zpos : DINT;
	    amount : DINT;
	    pitch : DINT;
	    operationId : DINT;
	    operations : Units;
	  END_STRUCT;
#pragma pack(pop)
	  tRecipeLineList : ARRAY [0..cProdDbMaxOperationLines] OF tRecipeLine;  //! <Type Public="true" Name="tRecipeLineList"/>
#pragma pack(push, 1)
	  tRecipeData : STRUCT  //! <Type Public="true" Name="tRecipeData"/>
	    id : DINT;
	    description : gbl_datatypes::tStr20;
	    productCode : gbl_datatypes::tStr20;
	    length : DINT;
	    operationId1 : DINT;
	    operationId2 : DINT;
	    operationId3 : DINT;
	    noEndSaw : DINT;
	    upDownFlipAllowed : DINT;
	    frontEndFilpAllowed : DINT;
	    startAngle : DINT;
	    endAngle : DINT;
	    operations : tRecipeLineList;
	    productWidth : DINT;
	    productHeight : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  tData : ARRAY [0..1] OF tRecipeData;
#pragma pack(push, 1)
	  tOperationtype : STRUCT
	    BU1 : DINT;
	    BU2 : DINT;
	    BU3 : DINT;
	    BU4 : DINT;
	    BU5 : DINT;
	    BU6 : DINT;
	    BU7 : DINT;
	    BU8 : DINT;
	    BU9 : DINT;
	    BU10 : DINT;
	    BU12 : DINT;
	    BU13 : DINT;
	    BU14 : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	RecipeId 	: SvrCh_UDINT;
	strDescription 	: SvrChCmd_UDINT;
	strProductCode 	: SvrChCmd_UDINT;
	ProductLength 	: SvrCh_DINT;
	ProductWidth 	: SvrCh_DINT;
	ProductHeight 	: SvrCh_DINT;
	OperationId1 	: SvrCh_DINT;
	OperationId2 	: SvrCh_DINT;
	OperationId3 	: SvrCh_DINT;
	noEndSaw 	: SvrCh_DINT;
	upDownFlipAllowed 	: SvrCh_DINT;
	frontEndFlipAllowed 	: SvrCh_DINT;
	startAngle 	: SvrCh_DINT;
	endAngle 	: SvrCh_DINT;
	setZposAtHalfWidth 	: SvrCh_DINT;
	HmiSaveRecipe 	: SvrCh_DINT;
	HmiReloadRecipe 	: SvrCh_DINT;
	HmiDeleteRecipe 	: SvrCh_DINT;
	stsUnsafeChanges 	: SvrCh_DINT;
	parAutoSave 	: SvrCh_DINT;
  //Clients:
	RamEx 	: CltChCmd_RAMex;
	FileSys 	: CltChCmd__FileSys;
	FB 	: CltChCmd_FileBase;
	str_Description 	: CltChCmd_EditString;
	str_ProductCode 	: CltChCmd_EditString;
	OperationData 	: CltChCmd_OperationDataV2;
  //Variables:
		ActRecipeData 	: tRecipeData;
		tempRecipe 	: tRecipeData;
		sizeRecipedata 	: UDINT;
		emptyRecipe 	: tRecipeData;
		tmpText 	: tekst;
		dbAmountOfRecipes 	: UDINT;
		dbAmountOfLinesInRecipe 	: UDINT;
		checkForStorageProductData 	: tRecipeData;
		tmrAutoSave 	: UDINT;
		tmpNrDelete 	: UDINT;
		tmpInputNr 	: UDINT;
		stsRamResult 	: UINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION GLOBAL GetRecipe
		VAR_INPUT
			id 	: DINT;
		END_VAR
		VAR_OUTPUT
			oRecipe 	: tRecipeData;
		END_VAR;
	
	FUNCTION UpdateServers;
	
	FUNCTION GLOBAL giveText
		VAR_INPUT
			progNr 	: DINT;
		END_VAR
		VAR_OUTPUT
			text 	: tekst;
		END_VAR;
	
	FUNCTION saveRecipe
		VAR_INPUT
			nr 	: UDINT;
			recipe 	: tRecipeData;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION loadRecipe
		VAR_INPUT
			nr 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION saveChanges
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RecipeId::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strProductCode::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strProductCode::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ProductLength::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ProductWidth::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ProductHeight::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OperationId1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OperationId2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL OperationId3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL noEndSaw::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL upDownFlipAllowed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL frontEndFlipAllowed::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL startAngle::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL endAngle::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiSaveRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiReloadRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiDeleteRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stsUnsafeChanges::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using EditString
#pragma using OperationDataV2
#pragma usingLtd _FileSys
#pragma usingLtd FileBase
#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ProductsDbV2::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_PRODUCTSDBV2
1$UINT, 0$UINT, (SIZEOF(::ProductsDbV2))$UINT, 
20$UINT, 6$UINT, 0$UINT, 
TO_UDINT(1214555786), "ProductsDbV2", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::ProductsDbV2.RecipeId.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1433076410), "RecipeId", 
(::ProductsDbV2.strDescription.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(415395287), "strDescription", 
(::ProductsDbV2.strProductCode.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2943832204), "strProductCode", 
(::ProductsDbV2.ProductLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(206900119), "ProductLength", 
(::ProductsDbV2.ProductWidth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3387252357), "ProductWidth", 
(::ProductsDbV2.ProductHeight.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4167397418), "ProductHeight", 
(::ProductsDbV2.OperationId1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1689853519), "OperationId1", 
(::ProductsDbV2.OperationId2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4256190453), "OperationId2", 
(::ProductsDbV2.OperationId3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2327281507), "OperationId3", 
(::ProductsDbV2.noEndSaw.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(901878337), "noEndSaw", 
(::ProductsDbV2.upDownFlipAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2310806559), "upDownFlipAllowed", 
(::ProductsDbV2.frontEndFlipAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2002586523), "frontEndFlipAllowed", 
(::ProductsDbV2.startAngle.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1770145263), "startAngle", 
(::ProductsDbV2.endAngle.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3042256154), "endAngle", 
(::ProductsDbV2.setZposAtHalfWidth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1932830872), "setZposAtHalfWidth", 
(::ProductsDbV2.HmiSaveRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1848756402), "HmiSaveRecipe", 
(::ProductsDbV2.HmiReloadRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(583644729), "HmiReloadRecipe", 
(::ProductsDbV2.HmiDeleteRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3337502784), "HmiDeleteRecipe", 
(::ProductsDbV2.stsUnsafeChanges.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1099579582), "stsUnsafeChanges", 
(::ProductsDbV2.parAutoSave.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2771706058), "parAutoSave", 
//Clients:
(::ProductsDbV2.RamEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(933570811), "RamEx", TO_UDINT(933570811), "RAMex", 1$UINT, 17$UINT, 
(::ProductsDbV2.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::ProductsDbV2.FB.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2133383872), "FB", TO_UDINT(1689253198), "FileBase", 0$UINT, 5$UINT, 
(::ProductsDbV2.str_Description.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3670666575), "str_Description", TO_UDINT(648754807), "EditString", 0$UINT, 0$UINT, 
(::ProductsDbV2.str_ProductCode.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1836896276), "str_ProductCode", TO_UDINT(648754807), "EditString", 0$UINT, 0$UINT, 
(::ProductsDbV2.OperationData.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3656777280), "OperationData", TO_UDINT(3482579014), "OperationDataV2", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_ProductsDbV2 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ProductsDbV2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ProductsDbV2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ProductsDbV2;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RecipeId.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RecipeId::Write() );
	IF RecipeId.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, strDescription.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #strDescription::Read();
	vmt.CmdTable.Write		:= #strDescription::Write();
	strDescription.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF strDescription.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, strProductCode.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #strProductCode::Read();
	vmt.CmdTable.Write		:= #strProductCode::Write();
	strProductCode.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF strProductCode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ProductLength.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ProductLength::Write() );
	IF ProductLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ProductWidth.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ProductWidth::Write() );
	IF ProductWidth.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ProductHeight.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ProductHeight::Write() );
	IF ProductHeight.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OperationId1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #OperationId1::Write() );
	IF OperationId1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OperationId2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #OperationId2::Write() );
	IF OperationId2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	OperationId3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #OperationId3::Write() );
	IF OperationId3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	noEndSaw.pMeth			:= StoreMethod( #M_RD_DIRECT(), #noEndSaw::Write() );
	IF noEndSaw.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	upDownFlipAllowed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #upDownFlipAllowed::Write() );
	IF upDownFlipAllowed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	frontEndFlipAllowed.pMeth			:= StoreMethod( #M_RD_DIRECT(), #frontEndFlipAllowed::Write() );
	IF frontEndFlipAllowed.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startAngle.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startAngle::Write() );
	IF startAngle.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	endAngle.pMeth			:= StoreMethod( #M_RD_DIRECT(), #endAngle::Write() );
	IF endAngle.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	setZposAtHalfWidth.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF setZposAtHalfWidth.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiSaveRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiSaveRecipe::Write() );
	IF HmiSaveRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiReloadRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiReloadRecipe::Write() );
	IF HmiReloadRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiDeleteRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiDeleteRecipe::Write() );
	IF HmiDeleteRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsUnsafeChanges.pMeth			:= StoreMethod( #stsUnsafeChanges::Read(), #M_NO_F() );
	IF stsUnsafeChanges.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parAutoSave.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parAutoSave.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 29-11-2019 productsDBV2 created to handle 'recipes' like products, assembly's etc.
// functions like autosave, save, save as, reload (undo changes) are available
// storage to usb and load from usb are not yet functional, will be added later

// 
//ErrorNr 1 no file present
//ErrorNr 2 USB not present
//ErrorNr 3 cannot open file
//ErrorNr 4 error reading file
//ErrorNr 5 wrong format
//ErrorNr 6 too many lines
//ErrorNr 7 too little chars in data string

FUNCTION VIRTUAL ProductsDbV2::Init1

  IF initDone= 0 THEN
  
    dbAmountOfRecipes:= CPRODDBMAXPRODUCTS; //read in amounts
    dbAmountOfLinesInRecipe:= CPRODDBMAXOPERATIONLINES;
    sizeRecipedata := to_udint(sizeof(tRecipeData)); //put size of product data in var
    _memset(dest:=#emptyRecipe, usByte:=0, cntr:=sizeRecipedata); //set empty product
    
    IF RamEx.GetSize() <> (sizeRecipedata*dbAmountOfRecipes) THEN //check if ram size isn't set yet
      IF RamEx.SetSize(udsize:= (sizeRecipedata*dbAmountOfRecipes)) = C_OK THEN //only if setting is done, say init is done
        initDone:= 1;
        
        loadRecipe(nr:=RecipeId); //after setting size of db try to load the recipe

      END_IF;
    ELSE
      initDone:= 1;
      loadRecipe(nr:=RecipeId); //also if size is ok, load recipe
    END_IF;
    
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  
  //check if we need to update the strings
  if str_Description.NewData.Read() <> 0 then//description
    _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
    str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
    str_Description.NewData.Write(input:=0);
  end_if;

  if str_ProductCode.NewData.Read() <> 0 then//productCode
    _memset(dest:=#ActRecipeData.productCode[0], usByte:=0, cntr:=sizeof(ActRecipeData.productCode));
    str_ProductCode.ReadDataOff(udOff:=0, pData:=#ActRecipeData.productCode[0], udMax:=sizeof(ActRecipeData.productCode));
    str_ProductCode.NewData.Write(input:=0);
  end_if;

  //if autosave is active, check every ten seconds if we should save
  IF parAutoSave & ops.tAbsolute-tmrAutoSave> 10000 THEN
    saveChanges();
    tmrAutoSave:= ops.tAbsolute;
  END_IF;
  
  IF HmiDeleteRecipe= -10 THEN //means delete complete db
    IF tmpNrDelete > 0 & tmpNrDelete < dbAmountOfRecipes THEN
      IF saveRecipe(nr:=tmpNrDelete, recipe:=emptyRecipe)= 1 THEN
        tmpNrDelete+=1;
        IF tmpNrDelete = dbAmountOfRecipes THEN
          HmiDeleteRecipe:= 0; //all recipes are deleted now
          loadRecipe(nr:=RecipeId);//load active recipe to show it's empty
        END_IF;
      END_IF;
    END_IF;
  END_IF;

  stsUnsafeChanges.Read();

  state:= 0;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL ProductsDbV2::stsUnsafeChanges::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  IF ActRecipeData <> checkForStorageProductData THEN
    stsUnsafeChanges:= 1;
  ELSE
    stsUnsafeChanges:= 0;
  END_IF;

	output := stsUnsafeChanges;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::RecipeId::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  
  IF input > 0 & input < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    IF parAutoSave= 0 | saveChanges()= 1 THEN //only if autosave is active, else in screen project choose to save or not should be made before writing a new product ID
      RecipeId:= input; //keep input in memory
      loadRecipe(nr:=RecipeId);
    END_IF;
   
  ELSE
    Result := Access_Denied;
  End_If;

END_FUNCTION

FUNCTION ProductsDbV2::saveRecipe
	VAR_INPUT
		nr 	: UDINT;
		recipe 	: tRecipeData;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  //function save recipe in input nr in ram db
  IF nr > 0 & nr < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    tempRecipe:= recipe;
    stsRamResult:= RamEx.SetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:=nr * sizeRecipedata);
    IF stsRamResult= 5 THEN
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION ProductsDbV2::loadRecipe
	VAR_INPUT
		nr 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  //function loads recipe from nr into act recipe, also changes check saving recipe, used to control if saving is required
  IF nr>0 & nr<dbAmountOfRecipes THEN
    stsRamResult:= RamEx.GetDataAt(pData:=#ActRecipeData$USINT, udSize:=sizeRecipedata, udAt:=nr* sizeRecipedata);
    IF stsRamResult= 5 THEN
      checkForStorageProductData:= ActRecipeData; //no changes yet
      UpdateServers();
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION ProductsDbV2::saveChanges
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  IF checkForStorageProductData <> ActRecipeData THEN //only do saving if there is a difference
    IF saveRecipe(nr:=RecipeId, recipe:=ActRecipeData) THEN
      checkForStorageProductData:= ActRecipeData;
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 1; //no changes, means no storage needed
  END_IF;

END_FUNCTION

FUNCTION ProductsDbV2::UpdateServers

//put data of new recipe into data servers
  ProductLength := ActRecipeData.length;
  operationId1 := ActRecipeData.operationId1;
  OperationId2 := ActRecipeData.OperationId2;
  OperationId3 := ActRecipeData.OperationId3;
  noEndSaw     := ActRecipeData.noEndSaw;
  ProductWidth := ActRecipeData.productWidth;
  ProductHeight := ActRecipeData.productHeight;
  upDownFlipAllowed := ActRecipeData.upDownFlipAllowed;
  frontEndFlipAllowed := ActRecipeData.frontEndFilpAllowed;
  //tp 22-04-2020 set angles to 90 if is zero
  if ActRecipeData.startAngle = 0 then
    ActRecipeData.startAngle:=900;
  end_if;
  startAngle := ActRecipeData.startAngle;
  if ActRecipeData.endAngle = 0 then
    ActRecipeData.endAngle:=900;
  end_if;
  endAngle := ActRecipeData.endAngle;
  
  OperationData.WritePtrs(ptr:=#ActRecipeData.operations, ptrProdHeigth:=#ActRecipeData.productHeight, useHeigth:=setZposAtHalfWidth, maxLines:=to_dint(dbAmountOfLinesInRecipe));    
  str_Description.WriteDataOff(udLen:=sizeof(ActRecipeData.description), udOff:=0, pData:=#ActRecipeData.description[0]);
  str_ProductCode.WriteDataOff(udLen:=sizeof(ActRecipeData.productCode), udOff:=0, pData:=#ActRecipeData.productCode[0]);

END_FUNCTION

////////////////////////////////////////////////////////////////////
// some functions for controlling recipe from HMI

FUNCTION VIRTUAL GLOBAL ProductsDbV2::HmiSaveRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //function to save actual recipe into given nr
  //if used as regular save, write product id into this server to save,
  //else write nr. where you want to save it
  tmpInputNr:=to_udint(input);
  IF input> 0 & tmpInputNr < dbAmountOfRecipes THEN
    IF saveRecipe(nr:=tmpInputNr, recipe:=ActRecipeData) = 1 THEN
	    HmiSaveRecipe := 0; //saving done
    ELSE
      HmiSaveRecipe:= -1;
    END_IF;
  ELSE
    HmiSaveRecipe := -1; //saving not ok
  END_IF;
	result := HmiSaveRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::HmiReloadRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //means throw away all made changes
  IF loadRecipe(nr:=RecipeId)= 1 THEN
  	HmiReloadRecipe := 0; //done
  ELSE
    HmiReloadRecipe := -1; //not ok
  END_IF;
  
	result := HmiReloadRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::HmiDeleteRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //delete all recipes (if value = -10), or one (if value is between min and max recipes)
  tmpInputNr:=to_udint(input);
  IF input = -10 THEN
    HmiDeleteRecipe := input;
    tmpNrDelete:= 1;
  ELSIF input>0 & tmpInputNr < dbAmountOfRecipes THEN
    IF saveRecipe(nr:=tmpInputNr, recipe:=emptyRecipe) = 1 THEN
      IF tmpInputNr = RecipeId THEN //if actual recipe is deleted, reload it
        loadRecipe(nr:=RecipeId);
      END_IF;
      HmiDeleteRecipe:= 0;
    ELSE
      HmiDeleteRecipe:= -1;
    END_IF;
  END_IF;
	result := HmiDeleteRecipe;

END_FUNCTION


/////////////////////////////////////////////////////////////////
// USB functions
//////////////////////////////////////////////////////////////////
// function to get prog from other class

FUNCTION GLOBAL ProductsDbV2::GetRecipe
	VAR_INPUT
		id 	: DINT;
	END_VAR
	VAR_OUTPUT
		oRecipe 	: tRecipeData;
	END_VAR
  
  if id >= 0 & id < to_dint(dbAmountOfRecipes) then
    if id = to_dint(RecipeId) then //JdK if product is active, just give it back, else db isn't written in right way
      tempRecipe:=ActRecipeData;
    else
      RamEx.GetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:= to_udint(id) * sizeRecipedata);
    end_if;
    oRecipe := tempRecipe;
  else
    oRecipe := emptyRecipe;
  end_if;


END_FUNCTION

//////////////////////////////////////////////////////////////
// functions to write data

FUNCTION VIRTUAL GLOBAL ProductsDbV2::strDescription::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	strDescription := str_Description.Data.Read();
	output := strDescription;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::strDescription::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	strDescription := input;
	result := (str_Description.Data.Write(strDescription))$UDINT;
  _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
  str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::strProductCode::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	strProductCode := str_ProductCode.Data.Read();
	output := strProductCode;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::strProductCode::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	strProductCode := input;
	result := (str_ProductCode.Data.Write(strProductCode))$UDINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::ProductLength::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ProductLength := input;
  ActRecipeData.length := ProductLength;
	result := ProductLength;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::OperationId1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	operationId1 := input;
  ActRecipeData.operationId1 := operationId1;
	result := operationId1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::OperationId2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	OperationId2 := input;
  ActRecipeData.OperationId2 := OperationId2;
	result := OperationId2;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::OperationId3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	OperationId3 := input;
  ActRecipeData.OperationId3 := OperationId3;
	result := OperationId3;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL ProductsDbV2::ProductWidth::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ProductWidth := input;
  ActRecipeData.productWidth := ProductWidth;
	result := ProductWidth;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::ProductHeight::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ProductHeight := input;
  ActRecipeData.productHeight := ProductHeight;
	result := ProductHeight;

END_FUNCTION
  

FUNCTION VIRTUAL GLOBAL ProductsDbV2::upDownFlipAllowed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	upDownFlipAllowed := input;
  ActRecipeData.upDownFlipAllowed:= upDownFlipAllowed;
	result := upDownFlipAllowed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::frontEndFlipAllowed::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	frontEndFlipAllowed := input;
  ActRecipeData.frontEndFilpAllowed:= frontEndFlipAllowed;
	result := frontEndFlipAllowed;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::startAngle::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  IF input > 0 & input < 1800 THEN
	  startAngle := input;
    ActRecipeData.startAngle:=startAngle;
  END_IF;
	result := startAngle;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::endAngle::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  IF input > 0 & input < 1800 THEN
  	endAngle := input;
    ActRecipeData.endAngle:=endAngle;
  END_IF;
	result := endAngle;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ProductsDbV2::noEndSaw::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  IF input >= 0 & input <= 1 THEN
	  noEndSaw := input;
    ActRecipeData.noEndSaw:= noEndSaw;
  END_IF;
	result := noEndSaw;

END_FUNCTION


FUNCTION GLOBAL ProductsDbV2::giveText
	VAR_INPUT
		progNr 	: DINT;
	END_VAR
	VAR_OUTPUT
		text 	: tekst;
	END_VAR

  _memset(dest:=#tmpText[0], usByte:=0, cntr:=sizeof(tmpText));


  if progNr >= 0 & progNr < cProdDbMaxProducts then
    if progNr = to_dint(RecipeId) then //JdK if product is active, just give it back, else db isn't written in right way
      tempRecipe:=ActRecipeData;
    else
      RamEx.GetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeof(tRecipeData), udat:= to_udint(id) * sizeof(tRecipeData));
    end_if;
    _memcpy(ptr1:=#tmpText[0], ptr2:=#tempRecipe.description[0], cntr:=21); //copy all 21 chars to tmp
    
  end_if;
  
  text:= tmpText;


END_FUNCTION




