//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "SDI101"
	Revision           = "1.22"
	GUID               = "{50DCBB06-7C48-46B0-B1E3-C1313F469632}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\sdi.ico"
	SharedCommandTable = "true"
	Objectsize         = "(532,120)">
	<Channels>
		<Server Name="Safe_Input1" GUID="{5F880DAE-A5F7-47D8-83FE-F0B97B332D7F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input10" GUID="{01276B8B-D93F-4955-A33A-FC4136E6CC85}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input2" GUID="{4402F754-17E8-4258-91E3-39E03F290781}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input3" GUID="{A7AF1FB1-FD51-44D6-8D40-4101D60512F3}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input4" GUID="{9DE53DD8-EAF1-4F94-8884-833FD175FD63}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input5" GUID="{3592DE01-1735-4940-A514-E9854B2B6989}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input6" GUID="{E4F7CA6B-879D-4C5A-963B-53A6856B890E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input7" GUID="{F964678D-E231-43C1-B551-5A1BE7960A93}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input8" GUID="{09334D8F-C40E-4422-97C7-36EBDAFDA736}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="Safe_Input9" GUID="{356DB7E7-F678-462E-B161-6FB792B7A0FC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of input (read only)&#13;&#10;&#13;&#10;-1..Error&#13;&#10; 0..Input Low&#13;&#10; 1..Input High"/>
		<Server Name="SafeIOError" GUID="{888118B3-7527-405A-AEA4-FD3EF8367ACB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows which safe inputs are in error.&#13;&#10;The inputs are bitcoded.&#13;&#10;Bit0 = Input1&#13;&#10;Bit1 = Input2&#13;&#10;..."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.22" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.21" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.20" Date="24.04.2018" Author="RamAnd" Company="Sigmatek" Description="Added server to show hardware version if this feature is supported by the safety firmware of the SCP."/>
		<Dokumentation Revision="1.19" Date="30.11.2017" Author="FurDom" Company="Sigmatek" Description="Added QuitComError server description to .lhd file"/>
		<Dokumentation Revision="1.18" Date="24.10.2016" Author="ZoePat" Company="Sigmatek" Description="Set the base class to visualized, so the embedded string object &quot;SerialNoStr&quot; can be used in the LSE."/>
		<Dokumentation Revision="1.17" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.16" Date="21.01.2016" Author="EisMic" Company="Sigmatek" Description="Outputs are now written in RtPostScan instead of RtPreScan to improve the reaction speed.(Change in base)"/>
		<Dokumentation Revision="1.15" Date="16.04.2015" Author="EisMic" Company="Sigmatek" Description="Added support for graphical hardware editor."/>
		<Dokumentation Revision="1.14" Date="31.10.2014" Author="lanste" Company="Sigmatek" Description="Fixed error: Safe IO were displayed on wrong safety hardwareclass if the class is not required and not online.&#13;&#10;Fixed error: Safe IO were displayed on wrong safety hardwareclass if the hardware configuration did not match the project configuration.&#13;&#10;Set IOs to -2 if Class is not online."/>
		<Dokumentation Revision="1.13" Date="31.07.2014" Author="PieSte" Company="Sigmatek" Description="Added QuitComError server to quit errors on safety cpu."/>
		<Dokumentation Revision="1.12" Date="24.04.2014" Author="RamAnd" Company="Sigmatek" Description="Clear module info at the servers if a disconnect event occurs."/>
		<Dokumentation Revision="1.11" Date="28.03.2014" Author="EisMic" Company="Sigmatek" Description="Added server RetryCounteruC1 and RetryCounteruC2."/>
		<Dokumentation Revision="1.10" Date="22.01.2014" Author="RamAnd&#13;&#10;LanSte" Company="Sigmatek" Description="Added functionality to use module optional via define DEACTIVATED_LSL as Place value.&#13;&#10;Read Client Required and Place in Init SdiasSafetyBase"/>
		<Dokumentation Revision="1.0" Date="04.12.2013" Author="RamAnd" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="SDI101">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{9518C8B5-2AD3-4491-BE65-30FF740C7BF0}"
				Class      = "SdiasSafetyBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="CallCommand"/>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="HwVersion"/>
					<Server Name="QuitComError"/>
					<Server Name="RetryCounteruC1"/>
					<Server Name="RetryCounteruC2"/>
					<Server Name="SafetyNumber"/>
					<Server Name="SerialNo"/>
					<Client Name="InputsNeeded" Value="10"/>
					<Client Name="OutputsNeeded" Value="0"/>
					<Client Name="Place"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasSafetyIn"/>
					<Client Name="SetDeviceID" Value="2#00001001"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(992,210),(820,210),"/>
			<Connection Source="_base.SdiasSafetyIn" Destination="this.SdiasSafetyIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(992,270),(820,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(992,390),(820,390),"/>
			<Connection Source="this.SafetyNumber" Destination="_base.SafetyNumber" Vertices="(992,450),(820,450),"/>
			<Connection Source="this.RetryCounteruC1" Destination="_base.RetryCounteruC1" Vertices="(992,510),(820,510),"/>
			<Connection Source="this.RetryCounteruC2" Destination="_base.RetryCounteruC2" Vertices="(992,570),(820,570),"/>
			<Connection Source="this.QuitComError" Destination="_base.QuitComError" Vertices="(992,630),(820,690),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(992,330),(820,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasSafetyBase

SDI101 : CLASS
: SdiasSafetyBase
  //Servers:
	Safe_Input1 	: SvrCh_DINT;
	Safe_Input2 	: SvrCh_DINT;
	Safe_Input3 	: SvrCh_DINT;
	Safe_Input4 	: SvrCh_DINT;
	Safe_Input5 	: SvrCh_DINT;
	Safe_Input6 	: SvrCh_DINT;
	Safe_Input7 	: SvrCh_DINT;
	Safe_Input8 	: SvrCh_DINT;
	Safe_Input9 	: SvrCh_DINT;
	Safe_Input10 	: SvrCh_DINT;
	SafeIOError 	: SvrCh_BDINT;
  //Clients:
  //Variables:
		TempInputState : ARRAY [0..9] OF DINT;

		Filter : ARRAY [0..9] OF DINT;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL RtWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Called when class state was set to _NoHardware &#13;&#10;No Implementation Overload in derived classes if needed " Name="SetClassStateError"/>
	FUNCTION VIRTUAL SetClassStateError;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SDI101::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDI101
1$UINT, 22$UINT, (SIZEOF(::SDI101))$UINT, 
11$UINT, 0$UINT, 0$UINT, 
TO_UDINT(3683027882), "SDI101", //Class
TO_UDINT(2010300054), "SdiasSafetyBase", 1$UINT, 9$UINT, //Baseclass
//Servers:
(::SDI101.Safe_Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(53251858), "Safe_Input1", 
(::SDI101.Safe_Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2586173096), "Safe_Input2", 
(::SDI101.Safe_Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3978489406), "Safe_Input3", 
(::SDI101.Safe_Input4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1933999005), "Safe_Input4", 
(::SDI101.Safe_Input5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(71387915), "Safe_Input5", 
(::SDI101.Safe_Input6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2638748337), "Safe_Input6", 
(::SDI101.Safe_Input7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3931056679), "Safe_Input7", 
(::SDI101.Safe_Input8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2062563254), "Safe_Input8", 
(::SDI101.Safe_Input9.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(234293024), "Safe_Input9", 
(::SDI101.Safe_Input10.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(123831014), "Safe_Input10", 
(::SDI101.SafeIOError.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1952502172), "SafeIOError", 
//Clients:
END_FUNCTION


#define USER_CNT_SDI101 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SDI101] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SDI101::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasSafetyBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasSafetyBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasSafetyBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_SDI101;
	vmt.CmdTable.RtWork		:= #RtWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #SetClassStateError();

#pragma warning (default : 74)
	SdiasSafetyBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasSafetyBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL SDI101::RtWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  // 0 = inputs, 1 = outputs
  if EAX = 0 then

#ifdef SB_SAFETY_INPUT_FILTER
    // if AcceptState bit is set => accept state
    if IOStates AND 2#10 then
      TempInputState[0] := to_dint(IOStates AND 2#1);
      
      if TempInputState[0] < Safe_Input1 then
        if Filter[0] <= 0 then
          Safe_Input1 := TempInputState[0];
        else
          Filter[0] -= 1;
        end_if;
      else
        Safe_Input1 := TempInputState[0];
        Filter[0] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.1 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input1 := -1;

      // show error state of this IO
      SafeIOError.1 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000 then
      TempInputState[1] := to_dint(IOStates AND 2#100) SHR 2;
      
      if TempInputState[1] < Safe_Input2 then
        if Filter[1] <= 0 then
          Safe_Input2 := TempInputState[1];
        else
          Filter[1] -= 1;
        end_if;
      else
        Safe_Input2 := TempInputState[1];
        Filter[1] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.2 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input2 := -1;

      // show error state of this IO
      SafeIOError.2 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000 then
      TempInputState[2] := to_dint(IOStates AND 2#10000) SHR 4;

      if TempInputState[2] < Safe_Input3 then
        if Filter[2] <= 0 then
          Safe_Input3 := TempInputState[2];
        else
          Filter[2] -= 1;
        end_if;
      else
        Safe_Input3 := TempInputState[2];
        Filter[2] := SB_SAFETY_INPUT_FILTER;
      end_if;
      
      // show error state of this IO
      SafeIOError.3 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input3 := -1;

      // show error state of this IO
      SafeIOError.3 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000 then
      TempInputState[3] := to_dint(IOStates AND 2#1000000) SHR 6;

      if TempInputState[3] < Safe_Input4 then
        if Filter[3] <= 0 then
          Safe_Input4 := TempInputState[3];
        else
          Filter[3] -= 1;
        end_if;
      else
        Safe_Input4 := TempInputState[3];
        Filter[3] := SB_SAFETY_INPUT_FILTER;
      end_if;
      
      // show error state of this IO
      SafeIOError.4 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input4 := -1;

      // show error state of this IO
      SafeIOError.4 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000000000 then
      TempInputState[4] := to_dint(IOStates AND 2#100000000) SHR 8;

      if TempInputState[4] < Safe_Input5 then
        if Filter[4] <= 0 then
          Safe_Input5 := TempInputState[4];
        else
          Filter[4] -= 1;
        end_if;
      else
        Safe_Input5 := TempInputState[4];
        Filter[4] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.5 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input5 := -1;

      // show error state of this IO
      SafeIOError.5 := TRUE;
    end_if;
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000000000 then
      TempInputState[5] := to_dint(IOStates AND 2#10000000000) SHR 10;
      
      if TempInputState[5] < Safe_Input6 then
        if Filter[5] <= 0 then
          Safe_Input6 := TempInputState[5];
        else
          Filter[5] -= 1;
        end_if;
      else
        Safe_Input6 := TempInputState[5];
        Filter[5] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.6 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input6 := -1;

      // show error state of this IO
      SafeIOError.6 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000000000 then
      TempInputState[6] := to_dint(IOStates AND 2#1000000000000) SHR 12;
      
      if TempInputState[6] < Safe_Input7 then
        if Filter[6] <= 0 then
          Safe_Input7 := TempInputState[6];
        else
          Filter[6] -= 1;
        end_if;
      else
        Safe_Input7 := TempInputState[6];
        Filter[6] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.7 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input7 := -1;

      // show error state of this IO
      SafeIOError.7 := TRUE;
    end_if;
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000000000000000 then
      TempInputState[7] := to_dint(IOStates AND 2#100000000000000) SHR 14;
      
      if TempInputState[7] < Safe_Input8 then
        if Filter[7] <= 0 then
          Safe_Input8 := TempInputState[7];
        else
          Filter[7] -= 1;
        end_if;
      else
        Safe_Input8 := TempInputState[7];
        Filter[7] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.8 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input8 := -1;

      // show error state of this IO
      SafeIOError.8 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000000000000000 then
      TempInputState[8] := to_dint(IOStates AND 2#10000000000000000) SHR 16;
      
      if TempInputState[8] < Safe_Input9 then
        if Filter[8] <= 0 then
          Safe_Input9 := TempInputState[8];
        else
          Filter[8] -= 1;
        end_if;
      else
        Safe_Input9 := TempInputState[8];
        Filter[8] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.9 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input9 := -1;

      // show error state of this IO
      SafeIOError.9 := TRUE;
    end_if;  
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000000000000000 then
      TempInputState[9] := to_dint(IOStates AND 2#1000000000000000000) SHR 18;
      
      if TempInputState[9] < Safe_Input10 then
        if Filter[9] <= 0 then
          Safe_Input10 := TempInputState[9];
        else
          Filter[9] -= 1;
        end_if;
      else
        Safe_Input10 := TempInputState[9];
        Filter[9] := SB_SAFETY_INPUT_FILTER;
      end_if;

      // show error state of this IO
      SafeIOError.10 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input10 := -1;

      // show error state of this IO
      SafeIOError.10 := TRUE;
    end_if;  
     
#else

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10 then
      Safe_Input1 := to_dint(IOStates AND 2#1);

      // show error state of this IO
      SafeIOError.1 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input1 := -1;

      // show error state of this IO
      SafeIOError.1 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000 then
      Safe_Input2 := to_dint(IOStates AND 2#100) SHR 2;

      // show error state of this IO
      SafeIOError.2 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input2 := -1;

      // show error state of this IO
      SafeIOError.2 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000 then
      Safe_Input3 := to_dint(IOStates AND 2#10000) SHR 4;

      // show error state of this IO
      SafeIOError.3 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input3 := -1;

      // show error state of this IO
      SafeIOError.3 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000 then
      Safe_Input4 := to_dint(IOStates AND 2#1000000) SHR 6;

      // show error state of this IO
      SafeIOError.4 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input4 := -1;

      // show error state of this IO
      SafeIOError.4 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000000000 then
      Safe_Input5 := to_dint(IOStates AND 2#100000000) SHR 8;

      // show error state of this IO
      SafeIOError.5 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input5 := -1;

      // show error state of this IO
      SafeIOError.5 := TRUE;
    end_if;
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000000000 then
      Safe_Input6 := to_dint(IOStates AND 2#10000000000) SHR 10;

      // show error state of this IO
      SafeIOError.6 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input6 := -1;

      // show error state of this IO
      SafeIOError.6 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000000000 then
      Safe_Input7 := to_dint(IOStates AND 2#1000000000000) SHR 12;

      // show error state of this IO
      SafeIOError.7 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input7 := -1;

      // show error state of this IO
      SafeIOError.7 := TRUE;
    end_if;
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#1000000000000000 then
      Safe_Input8 := to_dint(IOStates AND 2#100000000000000) SHR 14;

      // show error state of this IO
      SafeIOError.8 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input8 := -1;

      // show error state of this IO
      SafeIOError.8 := TRUE;
    end_if;

    // if AcceptState bit is set => accept state
    if IOStates AND 2#100000000000000000 then
      Safe_Input9 := to_dint(IOStates AND 2#10000000000000000) SHR 16;

      // show error state of this IO
      SafeIOError.9 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input9 := -1;

      // show error state of this IO
      SafeIOError.9 := TRUE;
    end_if;  
    
    // if AcceptState bit is set => accept state
    if IOStates AND 2#10000000000000000000 then
      Safe_Input10 := to_dint(IOStates AND 2#1000000000000000000) SHR 18;

      // show error state of this IO
      SafeIOError.10 := FALSE;
    else
      // otherwise, there's an error
      Safe_Input10 := -1;

      // show error state of this IO
      SafeIOError.10 := TRUE;
    end_if;  
#endif
  end_if;
  
	state := READY;

END_FUNCTION


FUNCTION VIRTUAL SDI101::SetClassStateError
  VAR
    i : UDINT;
    pServer : ^DINT;
  END_VAR
  
  pServer := #Safe_Input1;
  
  for i := 0 to 9 do
    pServer^ := SDIAS_SAFETY_INVALID_IO_NOHW;
    pServer += sizeof(SvrCh);
  end_for;
  

END_FUNCTION
