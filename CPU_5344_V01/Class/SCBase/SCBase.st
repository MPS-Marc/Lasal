//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

(*
 * Precompiler option
 *)
#define cAddObjectName  // Add objectname in Mesage text.

(*
 * Ops.tAbsolute time constante
 *)
#define cMaxMsgTo       10 Sec

(*
 * Array size
 *)
#define cMaxValueArray    15
#define cSCbMaxNameArray  1024
#define cMaxMsgBufArray   100000
#define cMaxMsgFileSize   10 Mb

(*
 * My Units
 *)
// Time
#define _1Sec    *100         // 0.1Sec   ( 100* 1mSec= 0.1Sec)
#define _01Sec   *10          // 0.01Sec  ( 10* 1mSec= 0.01Sec)
// Length
#define _1mm      *100        // 0.1mm    ( 100* umeter= 0.1mm)
#define _01mm     *10         // 0.01mm   ( 10* umeter= 0.01mm)
#define _1m       *1000 _1mm  // 0.1m     ( 100* 1000* umeter= 0.1m)
#define _01m      *1000 _01mm // 0.01m    ( 10* 1000* umeter= 0.01m)
// Memory
//#define Kb        *1024       // 1Kb      ( 1.024 byte)
//#define Mb        *1024 KB    // 1Mb      ( 1.048.576 byte)
//#define Gb        *1024 MB    // 1Gb      ( 1.073.741.824 byte)

(*
 * Include files
 *)
#include <LoaderItf.h>
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "SCBase"
	Revision           = "0.7"
	GUID               = "{EBFFE66D-94EF-4923-841B-48D37EF9A7D7}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "1000 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{D074BE83-12A3-43D8-AF97-815A381FB04D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="LogID" GUID="{38876035-C2F5-4EAE-80EB-894B8BC925F1}" Visualized="false" Initialize="true" DefValue="NoEventLog" WriteProtected="true" Retentive="false" Comment="Nr 0..8 posible, for Event10.log to Event 18.log&#13;&#10;Nr -1 is no Log.&#13;&#10;Every Event1x.log file can only be used by one Class object."/>
		<Client Name="ToGrafix" Required="false" Internal="false"/>
		<Client Name="ToLinker" Required="false" Internal="false"/>
		<Client Name="ToSigCLib" Required="false" Internal="false"/>
		<Client Name="ToSysMsg" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\SCBase\SCBaseGl.h" Include="true"/>
			<File Path=".\Class\SCBase\SCBase.doc"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SigmaControl" Author="Johan Embregts"/>
		<Dokumentation Revision="0.7" Date="2015-05-04" Author="Johan Embregts" Company="SigmaControl" Description="Value&apos;s for BuildTraceMsg are $ cast instead of ToCast()."/>
		<Dokumentation Revision="0.6" Date="2014-11-18" Author="Johan Embregts" Company="SigmaControl" Description="Changed &apos;tTime&apos; in stepper log record &apos;LogRecStr&apos; to &apos;tOpsTime&apos;.&#13;&#10;Added &apos;tElapsTime&apos; to stepper log record &apos;LogRecStr&apos;.&#13;&#10;Moved &apos;pActLog&apos; to StepperDataStr to log tElapsTime."/>
		<Dokumentation Revision="0.5" Date="2014-11-01" Author="Johan Embregts" Company="SigmaControl" Description="Added tTime to StepperHndl(). This is the time in mSec that active step is active.&#13;&#10;Removed Freeze time from StapperHndl().&#13;&#10;Added comment to Global types."/>
		<Dokumentation Revision="0.4" Date="2014-10-20" Author="Johan Embregts" Company="SigmaControl" Description="Added GetProjectName()."/>
		<Dokumentation Revision="0.3" Date="2014-10-16" Author="Johan Embregts" Company="SigmaControl" Description="Added Help text."/>
		<Dokumentation Revision="0.2" Date="2014-10-07" Author="Johan Embregts" Company="SigmaControl" Description="Added TruncateString().&#13;&#10;Added ObjectName to BuildEventMsg(). "/>
		<Dokumentation Revision="0.1" Date="2014-10-07" Author="Johan Embregts" Company="SigmaControl" Description="Moved functions from Standard Class."/>
		<Dokumentation Revision="0.0" Date="2014-10-07" Author="Johan Embregts" Company="SigmaControl" Description="Created."/>
	</RevDoku>
</Class>
*)
SCBase : CLASS
	TYPE
	  EventTypeTxt :  //! <Type Public="true" Name="EventTypeTxt"/>
	  (
	    Event10Log,
	    Event11Log,
	    Event12Log,
	    Event13Log,
	    Event14Log,
	    Event15Log,
	    Event16Log,
	    Event17Log,
	    Event18Log,
	    NoEventLog,
	    ErrorEventLog
	  )$DINT;
#pragma pack(push, 1)
	  MsgBufStr : STRUCT
	    Hndl : UDINT;
	    Status : DINT;
	    pBuffer : pVoid;
	  END_STRUCT;
#pragma pack(pop)
	  SCbTraceMsgTxt :
	  (
	    SCbInvalidArchitectureType,
	    SCbInvalidPointerMess,
	    SCbCantWriteEvent01LogMess,
	    SCbCantFlushEvent01LogMess,
	    SCbCantCreateEvent1xLogMess,
	    SCbCantWriteEvent1xLogMess,
	    SCbCantFlushEvent1xLogMess,
	    SCbCantFlushWithoutHandelMess,
	    SCbCantAllocateMemoryMess,
	    SCbInvalidLogIdMess
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	LogID 	: SvrCh_EventTypeTxt_PTofCls_SCBase;
  //Clients:
	ToSysMsg 	: CltChCmd__SysMsg;
	ToSigCLib 	: CltChCmd_SigCLib;
	ToGrafix 	: CltChCmd__Grafix;
	ToLinker 	: CltChCmd__Linker;
  //Variables:
		tDelta 	: UDINT;
		tMarkULMsg 	: UDINT;
		tMarkLMsg 	: UDINT;
		First 	: DINT;
		aObjName : ARRAY [0..cSCbMaxNameArray] OF CHAR;

		ObjNameLength 	: UDINT;
		NextRandom 	: DINT;
		MsgBuf 	: MsgBufStr;
		SCbMessInvalidPointer 	: DINT;
		aValue1 : ARRAY [0..cMaxValueArray] OF CHAR;

		aValue2 : ARRAY [0..cMaxValueArray] OF CHAR;

		aValue3 : ARRAY [0..cMaxValueArray] OF CHAR;

		aValue4 : ARRAY [0..cMaxValueArray] OF CHAR;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="StepperHndl( ActStep , pSteperData)&#13;&#10;Handle’s case stepper.&#13;&#10;Generates information like;&#13;&#10;- First time this step.&#13;&#10;- Time in this step.&#13;&#10;- Log of step’s in sequence for diagnosis.&#13;&#10;ActStep:  (* The actual stepper *&#41;&#13;&#10;pStepperData: (* pointer to the stepper data and log buffer *&#41;&#13;&#10;&#13;&#10;Look out! This function must be called cyclically. There for this may not be skipped by IF or CASE function&apos;s." Name="StepperHndl"/>
	FUNCTION VIRTUAL GLOBAL StepperHndl
		VAR_INPUT
			ActStep 	: DINT;			//! <Variable Comment="The actual stepper." Name="StepperHndl.ActStep"/>
			pStepperData 	: ^StepperDataStr;			//! <Variable Comment="Pointer to the stepper data and log buffer." Name="StepperHndl.pStepperData"/>
		END_VAR;
				//! <Function Comment="Build messages for Debug Trace and Eventxx.log.&#13;&#10;Debug Trace, is for the first 100 messages after start-up in LASAL and therefore more for Software development. &#13;&#10;Eventxx.Log, is for history messages therefore equip for finding strange situations that rarely occur. Flushes automatic when buffer full or when nothing is written to this buffer for 5Sec ( cMaxMsgTo).&#13;&#10;Event01.log is a circular File with logs&#13;&#10;Event10.log up to Event18.log is in principle the same as Event01.log only for 1 object.&#13;&#10;That means max 9 object can each have their own event1x.log to be specified by the Server &quot;LogId&quot;.&#13;&#10;Double use of an ID is not guarded and can have unexpected results.&#13;&#10;&#13;&#10;Mode:   (* Destination of the message*&#41;&#13;&#10;Text:  (* Text to be logged. Suggest &quot;My-text %d more-text.&quot; *&#41;&#13;&#10;Value1..4 (* Value&apos;s to be placed in text. These are optional. *&#41;&#13;&#10;Status  (* Result &gt;=0 is oké and &lt; 0 error *&#41;&#13;&#10;&#13;&#10;Deferent mode&apos;s;&#13;&#10;Event01Log:&#13;&#10;  to Event01.log.&#13;&#10;  %d for place of Value1..2. Max 2 Values possible.&#13;&#10;Event1xLog:&#13;&#10;  to Event1x.log ( 10..18).&#13;&#10;  %d for place of Value1..4.&#13;&#10;    file size is 10Mb or defined by cMaxMsgFileSize.&#13;&#10;    file Event10..18 is defined by server &quot;LogId&quot;, -1 is off.&#13;&#10;TraceLog:&#13;&#10;  to Debug Trace.&#13;&#10;  {0} for place of Value1..3. Max 3 Values possible. {0}{1}{2}&#13;&#10;&#13;&#10;There is a precompiler switch &quot;cAddObjectName&quot; with this one can disable the text to start with the &apos;Class object name&apos;.&#13;&#10;&#13;&#10;" Name="BuildEventMsg"/>
	FUNCTION VIRTUAL GLOBAL BuildEventMsg
		VAR_INPUT
			Mode 	: EventModeTxt;			//! <Variable Comment="Destination of the message." Name="BuildEventMsg.Mode"/>
			pText 	: ^CHAR;			//! <Variable Comment="Text to be logged. Suggest &quot;My-text %P more-text." Name="BuildEventMsg.pText"/>
			Value1 	: DINT := 0;			//! <Variable Comment="Value&apos;s to be placed in text. These are optional." Name="BuildEventMsg.Value1"/>
			Value2 	: DINT := 0;			//! <Variable Comment="Value&apos;s to be placed in text. These are optional." Name="BuildEventMsg.Value2"/>
			Value3 	: DINT := 0;			//! <Variable Comment="Value&apos;s to be placed in text. These are optional." Name="BuildEventMsg.Value3"/>
			Value4 	: DINT := 0;			//! <Variable Comment="Value&apos;s to be placed in text. These are optional." Name="BuildEventMsg.Value4"/>
		END_VAR
		VAR_OUTPUT
			Status 	: DINT;			//! <Variable Comment="Result &gt;=0 is oké and &lt; 0 error." Name="BuildEventMsg.Status"/>
		END_VAR;
				//! <Function Comment="This function gets the checksum that LASAL calculates over the code in the Class.&#13;&#10;GetClassCheckSum: (* Pointer to a string containing the name of the Class.  *&#41;&#13;&#10;CheckSum:   (* The check sum. *&#41;&#13;&#10;" Name="GetClassCheckSum"/>
	FUNCTION VIRTUAL GLOBAL GetClassCheckSum
		VAR_INPUT
			pClassName 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the name of the Class." Name="GetClassCheckSum.pClassName"/>
		END_VAR
		VAR_OUTPUT
			CheckSum 	: HDINT;			//! <Variable Comment="The check sum." Name="GetClassCheckSum.CheckSum"/>
		END_VAR;
				//! <Function Comment="This function generates a random value from 0 to MaxValue- 1&#13;&#10;MaxValue: (* Random Value runs from 0 to MaxValue- 1. *&#41;&#13;&#10;Value:  (* Random generated value. *&#41;" Name="RandomGenerator"/>
	FUNCTION VIRTUAL GLOBAL RandomGenerator
		VAR_INPUT
			MaxValue 	: DINT;			//! <Variable Comment="Random Value runs from 0 to MaxValue- 1." Name="RandomGenerator.MaxValue"/>
		END_VAR
		VAR_OUTPUT
			Value 	: DINT;			//! <Variable Comment="Random generated value." Name="RandomGenerator.Value"/>
		END_VAR;
				//! <Function Comment="This function exchanges high byte and low byte in a word.&#13;&#10;Conversion from Motorola format to Intel format.&#13;&#10;Also referred to as big-endian Little-endian&#13;&#10;In: (* Input word. *&#41;&#13;&#10;Out: (* Exchanged output word *&#41;" Name="Swap2b"/>
	FUNCTION VIRTUAL GLOBAL Swap2b
		VAR_INPUT
			In 	: UINT;			//! <Variable Comment="Input word." Name="Swap2b.In"/>
		END_VAR
		VAR_OUTPUT
			Out 	: UINT;			//! <Variable Comment="Exchanged output word." Name="Swap2b.Out"/>
		END_VAR;
				//! <Function Comment="This function exchanges high byte and low byte in a double-word.&#13;&#10;Conversion from Motorola format to Intel format. Also referred to as big-endian Little-endian&#13;&#10;In: (* input double-word. *&#41;&#13;&#10;Out: (* Exchanged output double-word. *&#41;" Name="Swap4b"/>
	FUNCTION VIRTUAL GLOBAL Swap4b
		VAR_INPUT
			In 	: UDINT;			//! <Variable Comment="Input double-word." Name="Swap4b.In"/>
		END_VAR
		VAR_OUTPUT
			Out 	: UDINT;			//! <Variable Comment="Exchanged output double-word." Name="Swap4b.Out"/>
		END_VAR;
				//! <Function Comment="This function removes the last part of a string starting at length and down to a specified character.&#13;&#10;pString: (* Pointer to the string that must be truncated. *&#41;&#13;&#10;Length  (* Length of the original string. *&#41;&#13;&#10;FindChat (* The character to which the string must be shortened. *&#41;&#13;&#10;StrLength: (* The length of the string that is left. *&#41;" Name="TruncateString"/>
	FUNCTION VIRTUAL GLOBAL TruncateString
		VAR_INPUT
			pString 	: ^CHAR;			//! <Variable Comment="Pointer to the string that must be truncated." Name="TruncateString.pString"/>
			Length 	: UDINT;			//! <Variable Comment="Length of the original string." Name="TruncateString.Length"/>
			FindChar 	: CHAR;			//! <Variable Comment="The character to which the string must be shortened." Name="TruncateString.FindChar"/>
		END_VAR
		VAR_OUTPUT
			StrLength 	: UDINT;			//! <Variable Comment="The length of the string that is left." Name="TruncateString.StrLength"/>
		END_VAR;
	
	FUNCTION VIRTUAL SCbBuildTraceMsg
		VAR_INPUT
			MsgNr 	: SCbTraceMsgTxt;
			Value1 	: DINT := 0;
			Value2 	: DINT := 0;
			Value3 	: DINT := 0;
		END_VAR
		VAR_OUTPUT
			Status 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL CreateMsg;
	
	FUNCTION VIRTUAL FlushMsg;
	
	FUNCTION VIRTUAL GLOBAL GetProjectName
		VAR_INPUT
			pRevHi 	: ^BYTE;
			pRevLo 	: ^BYTE;
			pName 	: ^CHAR;
			MaxNameSize 	: DINT;
		END_VAR
		VAR_OUTPUT
			Status 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Grafix
#pragma usingLtd _Linker
#pragma usingLtd _SysMsg
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SCBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_SCBASE
0$UINT, 7$UINT, (SIZEOF(::SCBase))$UINT, 
2$UINT, 4$UINT, 0$UINT, 
TO_UDINT(4092474794), "SCBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SCBase.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::SCBase.LogID.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3179929790), "LogID", 
//Clients:
(::SCBase.ToSysMsg.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1640010845), "ToSysMsg", TO_UDINT(792524216), "_SysMsg", 0$UINT, 0$UINT, 
(::SCBase.ToSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2700849093), "ToSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 34$UINT, 
(::SCBase.ToGrafix.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1161257498), "ToGrafix", TO_UDINT(197854207), "_Grafix", 1$UINT, 3$UINT, 
(::SCBase.ToLinker.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(605753693), "ToLinker", TO_UDINT(1793552568), "_Linker", 0$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_SCBase 12

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SCBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SCBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SCBase, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #StepperHndl();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #BuildEventMsg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #GetClassCheckSum();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #RandomGenerator();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #Swap2b();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #Swap4b();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #TruncateString();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #SCbBuildTraceMsg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #CreateMsg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #FlushMsg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetProjectName();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL SCBase::Init

  First += 1;
  // First Init Cycle
  Case First of
  1:  // First Init Cycle! 
    // Get object name.
    ObjNameLength := _GetObjName( pThis  := this, pName  := #aObjName[0]);
    if ObjNameLength>= cSCbMaxNameArray then
      // Limit the length and name.
      ObjNameLength := cSCbMaxNameArray/10;
      aObjName[ cSCbMaxNameArray/10]  := 0;
      // Build event messages.
      BuildEventMsg( Mode:= TraceLog
                   , pText:= "Objectname longer than {0} char, defined by 'cSCbMaxNameArray'."
                   , Value1:= cSCbMaxNameArray);
      BuildEventMsg( Mode:= Event01Log
                   , pText := "Objectname longer than %d char, defined by 'cSCbMaxNameArray'."
                   , Value1:= cSCbMaxNameArray);
    else
      ObjNameLength := TruncateString( #aObjName[0], ObjNameLength, '\');
    end_if;
  end_case;
  // Last Init Cycle.
  if _FirstScan then
    // Create Message buffers
    CreateMsg();
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  FlushMsg();
	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::StepperHndl
	VAR_INPUT
		ActStep 	: DINT;
		pStepperData 	: ^StepperDataStr;
	END_VAR

  if pStepperData<> nil then     // Test for invalid pointer.
    pStepperData^.First := 0;
    if pStepperData^.OerInit= 0 then  // The very first time.
      pStepperData^.StepperOld  := ActStep- 1;
      pStepperData^.OerInit     := 1;
    end_if;
//    pStepperData^.tMark += tDelta;  // Freeze time
    if ActStep<> pStepperData^.StepperOld then
      pStepperData^.StepperOld  := ActStep;         // Old new detection.
      pStepperData^.First       := 1;               // First time flag.
      pStepperData^.tMark       := ops.tAbsolute;   // Start time this step.
      // Log data.
      pStepperData^.pActLog := #pStepperData^.StepLog.Logger[ pStepperData^.StepLog.Nr];
      pStepperData^.pActLog^.Stepper      := ActStep;
      pStepperData^.pActLog^.tOpsTime     := ops.tAbsolute;
      if pStepperData^.StepLog.Nr< cSCbMaxLogArray then
        pStepperData^.StepLog.Nr  += 1;
      else
        pStepperData^.StepLog.Nr  := 0;
      end_if;
    end_if;
    pStepperData^.tTime := Ops.tAbsolute- pStepperData^.tMark;
    pStepperData^.pActLog^.tElapsTime := pStepperData^.tTime;   // Elapse time in log.
  else
    // Invalid pStepperData pointer.
    if SCbMessInvalidPointer= 0 then
      ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
      SCbMessInvalidPointer := 1;
    end_if;
  end_if;
  
END_FUNCTION

(* **********************************************************************************************************************************
 * Excample of calls to BuildEvenMsg()
 * **********************************************************************************************************************************
 *  tValue  := -4321;
 *  tReal   := 12.34;
 *  _memcpy(ptr1:= #tString[0], ptr2:= "ABCDEFGHIJKLMNOPQRSTUVWXYZ", cntr:= 27);
 *  pValue  := #tValue;
 *  pString := #tString[0];
 *
 *  SCB.BuildEventMsg(Mode:= TraceLog, pText:= "Trace 2 value's; 1= {0}, 2= {1}.", Value1 := tValue, Value2 := tValue+1);
 *  SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code A for Address: %A.", Value1 := tValue);
 *  SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code c,C for Character: %c, %C.", Value1 := To_Dint( tString[0]), Value2 := 'c');
 *  SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code d for Decimal: %d.", Value1 := tValue);
 *  ? SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code E for Exponential: %E.", Value1 := tReal$Dint);
 *  ? SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code F for Float: %F.", Value1 := tReal$Dint);
 *  ? SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code G for Real: %G.", Value1 := tReal$Dint);
 *  ? SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Non existing Baudrate value: M - %M - %m.", Value1 := tValue, Value2 := tValue+1);
 *  SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code o for Octal:  %o.", Value1 := tValue);
 *  SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code p for Hexadecimal:  %p.", Value1 := tValue);
 *  ? SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Non existing Baudrate value: S - %S - %s.", Value1 := pString$Dint, Value2 := pString$Dint);
 *  SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code u for unsigned: %u.", Value1 := tValue, Value2 := tValue+1);
 *  SCB.BuildEventMsg(Mode:= Event01Log, pText:= "Event log value with code x,X for Hexadecimal: %x - %X.", Value1 := tValue, Value2 := tValue+1);
 *  
 * **********************************************************************************************************************************)
FUNCTION VIRTUAL GLOBAL SCBase::BuildEventMsg
	VAR_INPUT
		Mode 	: EventModeTxt;
		pText 	: ^CHAR;
		Value1 	: DINT;(* := 0 *)
		Value2 	: DINT;(* := 0 *)
		Value3 	: DINT;(* := 0 *)
		Value4 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		Status 	: DINT;
	END_VAR
  VAR
  	aLocText : Array [0..cSCbMaxNameArray] of char;
		pLocText 	: ^CHAR;
    StrLength : Udint;
  END_VAR

  Status  := 0;
#ifdef cAddObjectName
  StrLength := ObjNameLength-1;
  if ObjNameLength> 1
   & ObjNameLength+StrLength+2< cSCbMaxNameArray
  then
    _memcpy(ptr1:= #aLocText[1], ptr2:= #aObjName[0], cntr := StrLength);
    aLocText[0] := ''';
    aLocText[ObjNameLength] := ''';
    aLocText[ObjNameLength+1] := ' ';
    StrLength := _strlen(src  := pText);
    _memcpy(ptr1:= #aLocText[ObjNameLength+2], ptr2:= pText, cntr := StrLength);
    aLocText[ObjNameLength+StrLength+2] := 0;
    pLocText  := #aLoctext[0];
  else
    pLocText  := pText;
    Status  := -4;
  end_if;
#else
  pLocText  := pText;
  StrLength := 0;
#endif

  case Mode of
    Event01log:
      // To Event01.log.  %d, %u, %x, %X, %o, %p, %c, %C
      // %A - Address ( a is in lowercase, A in uppercase)
      // %c %C - Charakter ( c is in lowercase, C in uppercase)
      // %E - Real with Exponent (1.234E+8)
      // %F - Real with 6 digit  (123.400000)
      // %G - Real with Exponent (1.234E+8)
      // %m - multibyte or wide char?
      // %o - Octal value
      // %p - Hex value ( C-format 0xffff)
      // %s %S - Pointer to string.
      // %u - Unsigned value
      // %x %X - Hex value ( x is in lowercase, X in uppercase)
      MsgBuf.Status := ToSysMsg.ULPrintfln2( pLocText , Value1 , Value2);
      if ( MsgBuf.Status <= 0) then
        Status  := -3;
        SCbBuildTraceMsg( MsgNr := SCbCantWriteEvent01LogMess, Value1 := MsgBuf.Status);
      else
        tMarkULMsg  := ops.tAbsolute;
      end_if;
    Event1xlog:
      if ( MsgBuf.Hndl > 0) then
        // To Event10.log.. Event18.log.  %d, %u, %x, %X, %o, %p, %c, %C
        // %A - Address ( a is in lowercase, A in uppercase)
        // %c %C - Charakter ( c is in lowercase, C in uppercase)
        // %E - Real with Exponent (1.234E+8)
        // %F - Real with 6 digit  (123.400000)
        // %G - Real with Exponent (1.234E+8)
        // %m - multibyte or wide char?
        // %o - Octal value
        // %p - Hex value ( C-format 0xffff)
        // %s %S - 
        // %u - Unsigned value
        // %x %X - Hex value ( x is in lowercase, X in uppercase)
        MsgBuf.Status := to_Dint( ToSysMsg.LPrintfln4( hLog           := MsgBuf.Hndl 
                                                     , udAddTimeStamp := 1 
                                                     , pMsg           := pLocText 
                                                     , udParam1       := Value1$Udint 
                                                     , udParam2       := Value2$Udint 
                                                     , udParam3       := Value3$Udint 
                                                     , udParam4       := Value4$Udint));
        if ( MsgBuf.Status <= 0) then
          Status  := -2;
          SCbBuildTraceMsg( MsgNr := SCbCantWriteEvent1xLogMess, Value1 := MsgBuf.Status);
        else
          if tMarkLMsg= 0 then
            tMarkLMsg  := ops.tAbsolute;
          end_if;
        end_if;
      end_if;
    TraceLog:
      // To Debugger Trace.   {0}, {1}, {2} for first, second an third value.
      ToSigCLib.IToA( val := Value1 , dst := #aValue1[0] , base := 10);
      ToSigCLib.IToA( val := Value2 , dst := #aValue2[0] , base := 10);
      ToSigCLib.IToA( val := Value3 , dst := #aValue3[0] , base := 10);
      TRACE2( pLocText , #aValue1[0] , #aValue2[0] , #aValue3[0]);
  else
    Status  := -1;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::GetClassCheckSum
	VAR_INPUT
		pClassName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		CheckSum 	: HDINT;
	END_VAR
  
  if pClassName<> nil then
    CheckSum  := ToLinker.GetChkSumFromClassName( pClassName);
  else
    // Invalid pClassName pointer.
    if SCbMessInvalidPointer= 0 then
      ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidPointerMess);
      SCbMessInvalidPointer := 1;
    end_if;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::RandomGenerator
	VAR_INPUT
		MaxValue 	: DINT;
	END_VAR
	VAR_OUTPUT
		Value 	: DINT;
	END_VAR

  //* magic formula to generate pseudorandom number *//
  NextRandom := NextRandom* 1103515245+ 12345;
  Value      := to_dint((to_udint(NextRandom )/ 65536) mod to_udint(MaxValue));

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::Swap2b
	VAR_INPUT
		In 	: UINT;
	END_VAR
	VAR_OUTPUT
		Out 	: UINT;
	END_VAR
  
  Out := In ROR 8;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::Swap4b
	VAR_INPUT
		In 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Out 	: UDINT;
	END_VAR
  VAR
  	Temp  : UINT;
  END_VAR
  
  Temp := To_UINT( In);
  Out := Temp ROR 8;
  In  := In Shr 16;
  Out := Out Shl 16;
  Temp := To_UINT( In);
  Out := Out OR ( Temp ROR 8);  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::TruncateString
	VAR_INPUT
		pString 	: ^CHAR;
		Length 	: UDINT;
		FindChar 	: CHAR;
	END_VAR
	VAR_OUTPUT
		StrLength 	: UDINT;
	END_VAR
  VAR
    pObjChar  : ^Char;
  	Loop      : UDint;
  END_VAR

  StrLength := Length;            // For when no truncate char!
  Length  -= 1;                   // Skip the last NIL
  pObjChar  := pString+ Length;   // Start at the end
  for Loop:= Length to 1 by -1 do // Truncate from the end.
    pObjChar  -= 1;               // Move pointer back.
    if pObjChar^= FindChar then   // Find char
      pObjChar^ := nil;           // Place NIL
      StrLength := Loop;          // New size
      Loop  := 1;                 // Exit for_next.
    end_if;
  end_for;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SCBase::GetProjectName
	VAR_INPUT
		pRevHi 	: ^BYTE;
		pRevLo 	: ^BYTE;
		pName 	: ^CHAR;
		MaxNameSize 	: DINT;
	END_VAR
	VAR_OUTPUT
		Status 	: DINT;
	END_VAR
  VAR
  	ppName  : pCHAR;
    NameLength  : UDint;
  END_VAR
  
  if pName<> nil
   & MaxNameSize>= 0
  then
    if LDR_GetPrjInfo( pRevHi, pRevLo, #ppName) then
      NameLength  := _strlen(src:= ppName);
      if To_Udint( MaxNameSize)> NameLength then
        _memcpy( ptr1 := pName, ptr2  := ppName, cntr  := ( NameLength+1));
        Status  := 1; // Oke
      else
        _memcpy( ptr1 := pName, ptr2  := ppName, cntr  := to_Udint( MaxNameSize));
        ( pName+ MaxNameSize- 1)^:= nil;
        Status  := 0; // Oke, name longer then MaxNameSize, therefor only maxNameSize copied and limited with a nil!
      end_if;
    else
      Status  := -2; // error.
    end_if;
  else
    Status  := -1; // error.
  end_if;

END_FUNCTION

FUNCTION VIRTUAL SCBase::SCbBuildTraceMsg
	VAR_INPUT
		MsgNr 	: SCbTraceMsgTxt;
		Value1 	: DINT;(* := 0 *)
		Value2 	: DINT;(* := 0 *)
		Value3 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		Status 	: DINT;
	END_VAR

  case MsgNr of
(*
 * System Errors
 *)
  SCbInvalidArchitectureType:
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Object: '%s'. CPU Invalid Architecture Type.",  (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Object: '{0}'. CPU Invalid Architecture Type.", #aObjName[0]);
    Status  := -1;
  SCbInvalidPointerMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Invalid pointer message from Object: '%s'.", (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Invalid pointer message from Object: '{0}'.", #aObjName[0]);
    Status  := -2;
(*
 * Eventxx.Log error's
 *)
  SCbInvalidLogIdMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Object: '%s'. Invalid Log ID for Eventlog1x.",  (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Object: '{0}'. Invalid Log ID for Eventlog1x.", #aObjName[0]);
    Status  := -11;
  SCbCantAllocateMemoryMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Object: '%s'. Can't allocate memory with MemoryV1() for Eventlog1x.",  (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Object: '{0}'. Can't allocate memory with MemoryV1() for Eventlog1x.", #aObjName[0]);
    Status  := -12;
  SCbCantWriteEvent01LogMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln2("Can't write to internal Event01.log ULBuffer from Object: '%s'. Error code is: %d.", (#aObjName)$Dint, Value1);
    // To Debugger Trace.
    ToSigCLib.IToA( val:= Value1, dst:= #aValue1[0], base:= 10);
    TRACE1("Can't write to internal Event01.log ULBuffer from Object: '{0}'. Error code is {1}.", #aObjName[0], #aValue1[0]);
    Status  := -13;
  SCbCantFlushEvent01LogMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln2("Can't ULFlush Event01.log from Object: '%s'. Error code is: %d.", (#aObjName)$Dint, Value1);
    // To Debugger Trace.
    ToSigCLib.IToA( val:= Value1, dst:= #aValue1[0], base:= 10);
    TRACE1("Can't ULFlush Event01.log from Object: '{0}'. Error code is {1}.", #aObjName[0], #aValue1[0]);
    Status  := -14;
  SCbCantCreateEvent1xLogMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln2("Can't create Event1x.log in object: '%s'. Error code is: %d.", (#aObjName)$Dint, Value1);
    // To Debugger Trace.
    ToSigCLib.IToA( val:= Value1, dst:= #aValue1[0], base:= 10);
    TRACE1("Can't create Event1x.log in object: '{0}'. Error code is {1}.", #aObjName[0], #aValue1[0]);
    Status  := -15;
  SCbCantWriteEvent1xLogMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln2("Can't write to internal Event1x.log ULBuffer from Object: '%s'. Error code is: %d.", (#aObjName)$Dint, Value1);
    // To Debugger Trace.
    ToSigCLib.IToA( val:= Value1, dst:= #aValue1[0], base:= 10);
    TRACE1("Can't write to internal Event1x.log ULBuffer from Object: '{0}'. Error code is {1}.", #aObjName[0], #aValue1[0]);
    Status  := -16;
  SCbCantFlushEvent1xLogMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln2("Can't LFlush Event1x.log from Object: '%s'. Error code is: %d.", (#aObjName)$Dint, Value1);
    // To Debugger Trace.
    ToSigCLib.IToA( val:= Value1, dst:= #aValue1[0], base:= 10);
    TRACE1("Can't LFlush Event1x.log from Object: '{0}'. Error code is {1}.", #aObjName[0], #aValue1[0]);
    Status  := -17;
  SCbCantFlushWithoutHandelMess:
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Object: '%s'. Tries to use LFush Event1x.log without handel.",  (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Object: '{0}'. Tries to use LFush Event1x.log without handel.", #aObjName[0]);
    Status  := -18;
(*
 * Next
 *)
  else  // Unknown
    // To Event01.log.
    ToSysMsg.ULPrintfln1("Object: '%s'. Unknown TraceMsgTxt type.",  (#aObjName)$Dint);
    // To Debugger Trace.
    TRACE0("Object: '{0}'. Unknown TraceMsgTxt type.", #aObjName[0]);
    Status  := -999999;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL SCBase::CreateMsg

  case LogID of
  NoEventLog:               // No LogID
  Event10Log ..Event18Log:  // create Event1x.Log.
      if ToGrafix.MemoryV1(MemPtr0:= #MsgBuf.pBuffer, size0:= cMaxMsgBufArray, mark0:= 123)<> 0 then
        MsgBuf.Hndl := ToSysMsg.LCreate( nID          := LogId
                                       , pBuffer      := MsgBuf.pBuffer$^char // #MsgBuf.aBuffer[0]
                                       , udBufferSize := cMaxMsgBufArray
                                       , dFileQuota   := cMaxMsgFileSize
                                       , udFlags      := 0);
        if ( MsgBuf.Hndl<= 0) then
          ClassSvr  := SCbBuildTraceMsg( MsgNr := SCbCantCreateEvent1xLogMess, Value1 := to_Dint( MsgBuf.Hndl));
        end_if;
      else
        ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbCantAllocateMemoryMess);
      end_if;
  else                      // No valid LogID
    ClassSvr  := SCbBuildTraceMsg(MsgNr:= SCbInvalidLogIdMess);
    LogID := ErrorEventLog;
  end_case;

END_FUNCTION


FUNCTION VIRTUAL SCBase::FlushMsg
  VAR
  	FlushState  : Dint;
  END_VAR
  
  FlushState  := 0;
  
  if tMarkULMsg<> 0
   & ops.tAbsolute- tMarkULMsg> cMaxMsgTo
  then  // Event00..02.Log
    FlushState  := ToSysMsg.ULFlush( LogBuffID := 1 , usNonBlocking := 1);  // UL buffer and none blocking
    if FlushState< 0 then
//      -1:  // Invalid Handle.
//      -2:  // Invalid ID.
//      -3:  // No Interface.
//      -4:  // Intern Error.
//      -5:  // Flush Error.
//      -6:  // Export error.
//      -7:  // File Error.
//      -8:  // No Path.
//      -9:  // Pointer Nil.
//      -10: // Busy.
//      -11: // Buffer to Big.
      if FlushState<> -10 then
        ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbCantFlushEvent01LogMess, Value1:= FlushState);
      end_if;
    else  // No Error
      tMarkULMsg  := 0;
    end_if;
  end_if;

  if tMarkLMsg<> 0
   & ops.tAbsolute- tMarkLMsg> cMaxMsgTo
  then  // Event10..18.Log
    if MsgBuf.Hndl<> nil then
      FlushState  := ToSysMsg.LFlush( hLog:= MsgBuf.Hndl);
      if FlushState< 0 then
//      -1:  // Invalid Handle.
//      -2:  // Invalid ID.
//      -3:  // No Interface.
//      -4:  // Intern Error.
//      -5:  // Flush Error.
//      -6:  // Export error.
//      -7:  // File Error.
//      -8:  // No Path.
//      -9:  // Pointer Nil.
//      -10: // Busy.
//      -11: // Buffer to Big.
        if FlushState<> -10 then
          ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbCantFlushEvent1xLogMess, Value1:= FlushState);
        end_if;
      else  // No Error
        tMarkLMsg  := 0;
      end_if;
    else
      ClassSvr  := SCbBuildTraceMsg( MsgNr:= SCbCantFlushWithoutHandelMess);
    end_if;
  end_if;

END_FUNCTION
