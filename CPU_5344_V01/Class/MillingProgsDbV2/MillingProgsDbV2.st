//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MillingProgsDbV2"
	Revision           = "0.0"
	GUID               = "{12CAE3AB-1976-4B7C-89BA-E0BD5A6EF912}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(600,1500)">
	<Channels>
		<Server Name="HmiDeleteRecipe" GUID="{98A41230-6332-464F-8DAE-3EA07A94DB25}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiFileNrRecipe" GUID="{AFE166F9-3C2B-4F4B-B692-169149CEA3B2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiLoadRecipeFromUsb" GUID="{EF785F24-6256-499C-806A-37A81327EC88}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiReloadRecipe" GUID="{8753A490-9960-4451-8531-BD8CD97C99A7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiSaveRecipe" GUID="{8D13D993-A02F-4E80-82F0-E837B57ED196}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiSaveRecipeToUsb" GUID="{08AC8636-6D43-408A-ACF5-F4E2BBBB9BB9}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="offsetForXmovement" GUID="{F934A71F-7B9F-47A1-A3E5-49DE81139F4F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="RecipeId" GUID="{E647E923-C847-4061-93DF-2703A9171F54}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="reqRpm" GUID="{9AD87BD8-1FF1-4D7E-9A50-4C1285D305A2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ReRun_" GUID="{73C7408A-14D1-4F8C-B097-B823BB3C055F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Reserve1" GUID="{49AB1849-131A-4152-AED2-996592025D0D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Reserve2" GUID="{F07AE772-D94E-4C49-9CA2-FE2855A4B476}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Reserve3" GUID="{5A80B3F6-2E37-4344-8A82-EFDAA6697BE6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sparAutoSave" GUID="{DC5F2DDB-A45F-4B31-8B15-1E977D69B208}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false"/>
		<Server Name="startPosX" GUID="{CB8FDC20-D6F7-4E8B-8866-3FE78B3E07CC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="startPosY" GUID="{3C95BFAC-E9AC-470E-A3A1-F179A04A1928}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="startPosZ" GUID="{2CF76402-B792-4398-BB50-30275E20CBAC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="strDescription" GUID="{316CB7A4-C791-4822-A9B7-D098A98760A5}" Class="EditString" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="stsUnsafeChanges" GUID="{934FFF6C-A08C-4642-9A36-0B1E391068CA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ToolId" GUID="{90691C7A-ECA6-4723-8B87-44F589327532}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="TypeMillProg" GUID="{B8BF1F84-2420-4718-99AB-79571BE32B65}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="xDimension" GUID="{D6C74D56-1227-4B62-B0DC-A9AD44C6E56A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="yDimension" GUID="{53AE08B4-F69F-4108-8D4D-8BD788412C5B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="yToolComp" GUID="{AF8211B4-FE27-4D38-B6A2-39E4621FDCDC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="FB" Required="true" Internal="false"/>
		<Client Name="FileSys" Required="false" Internal="false"/>
		<Client Name="oCheckScreen" Required="true" Internal="false"/>
		<Client Name="OperationData" Required="true" Internal="true"/>
		<Client Name="RamEx" Required="true" Internal="false"/>
		<Client Name="Rerun" Required="true" Internal="false"/>
		<Client Name="str_Description" Required="true" Internal="true"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="15"/>
		</Servers>
		<Clients>
			<SepChn Position="1"/>
		</Clients>
	</Separators>
	<Network Name="MillingProgsDbV2">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{D418A709-DF9E-415F-ABCB-FB694E80C551}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name       = "OperationData"
				GUID       = "{CF1D1FE6-6D15-4880-B662-59BDCEFDD23C}"
				Class      = "MillPlanes"
				Position   = "(330,1230)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="firstIdx"/>
				</Channels>
			</Object>
			<Object
				Name       = "str_Description"
				GUID       = "{554277FD-C42A-4248-AF94-2AAA5FC243CC}"
				Class      = "EditString"
				Position   = "(390,780)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="Handle"/>
					<Server Name="NewData"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="this.str_Description" Destination="str_Description.Data"/>
			<Connection Source="this.OperationData" Destination="OperationData.ClassSvr"/>
			<Connection Source="this.strDescription" Destination="str_Description.Data" Vertices="(1036,750),(706,870),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

MillingProgsDbV2 : CLASS
: cmBase
	TYPE
	  str_100 : ARRAY [0..225] OF CHAR;
	  str_3000 : ARRAY [0..3000] OF CHAR;
#pragma pack(push, 1)
	  tBewerkingsRegel : STRUCT  //! <Type Public="true" Name="tBewerkingsRegel"/>
	    Bewerking : Units;
	  END_STRUCT;
#pragma pack(pop)
	  tData : ARRAY [0..1] OF strMillRecipe;
	  tRecipeData : strMillRecipe;  //! <Type Public="true" Name="tRecipeData"/>
	END_TYPE
  //Servers:
	RecipeId 	: SvrCh_UDINT;
	strDescription 	: SvrChCmd_UDINT;
	reqRpm 	: SvrCh_DINT;
	startPosX 	: SvrCh_DINT;
	startPosY 	: SvrCh_DINT;
	startPosZ 	: SvrCh_DINT;
	xDimension 	: SvrCh_DINT;
	yDimension 	: SvrCh_DINT;
	yToolComp 	: SvrCh_eMillToolComp;
	offsetForXmovement 	: SvrCh_DINT;
	ToolId 	: SvrCh_DINT;
	TypeMillProg 	: SvrCh_eTypeMillProg;
	Reserve1 	: SvrCh_DINT;
	Reserve2 	: SvrCh_DINT;
	Reserve3 	: SvrCh_DINT;
	HmiSaveRecipe 	: SvrCh_DINT;
	HmiReloadRecipe 	: SvrCh_DINT;
	HmiDeleteRecipe 	: SvrCh_DINT;
	HmiSaveRecipeToUsb 	: SvrCh_DINT;
	HmiLoadRecipeFromUsb 	: SvrCh_DINT;
	HmiFileNrRecipe 	: SvrCh_DINT;
	stsUnsafeChanges 	: SvrCh_DINT;
	sparAutoSave 	: SvrCh_DINT;
	ReRun_ 	: SvrCh_DINT;
  //Clients:
	RamEx 	: CltChCmd_RAMex;
	FileSys 	: CltChCmd__FileSys;
	FB 	: CltChCmd_FileBase;
	oCheckScreen 	: CltCh_DINT;
	Rerun 	: CltCh_DINT;
	str_Description 	: CltChCmd_EditString;
	OperationData 	: CltChCmd_MillPlanes;
  //Variables:
		ActRecipeData 	: tRecipeData;
		tempRecipe 	: tRecipeData;
		sizeRecipedata 	: UDINT;
		emptyRecipe 	: tRecipeData;
		tmpText 	: tekst;
		dbAmountOfRecipes 	: UDINT;
		dbAmountOfLinesInRecipe 	: UDINT;
		dbAmountOfLinesInLine 	: DINT;
		checkForStorageProductData 	: tRecipeData;
		tmrAutoSave 	: UDINT;
		tmpNrDelete 	: UDINT;
		tmpInputNr 	: UDINT;
		stsRamResult 	: UINT;
		sswSaveUsb 	: DINT;
		checkDisk : ARRAY [0..20] OF CHAR;

		tmpString : ARRAY [0..500] OF CHAR;

		strName : ARRAY [0..100] OF CHAR;

		tmpNrUsbStored 	: DINT;
		tmpRecipeNrUsb 	: DINT;
		tmpRecipeUsb 	: tRecipeData;
		actStrLen 	: DINT;
		usbLineNr 	: DINT;
		usbLineInLineNr 	: DINT;
		sswLoadUsb 	: DINT;
		fileHandle 	: DINT;
		fileToLoadNotFound 	: DINT;
		buffer : ARRAY [0..3000] OF CHAR;

		actBufferLength 	: DINT;
		offsetBuffer 	: DINT;
		tmpString2 : ARRAY [0..20] OF CHAR;

		FileInfo 	: _DDE_INFO;
		cntrUsb 	: DINT;
		cntrTje 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION GLOBAL GetRecipe
		VAR_INPUT
			id 	: DINT;
		END_VAR
		VAR_OUTPUT
			oRecipe 	: strMillRecipe;
		END_VAR;
	
	FUNCTION UpdateServers;
	
	FUNCTION saveRecipe
		VAR_INPUT
			nr 	: UDINT;
			recipe 	: strMillRecipe;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION loadRecipe
		VAR_INPUT
			nr 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION saveChanges
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION saveToUsb;
	
	FUNCTION loadFromUsb;
	
	FUNCTION VIRTUAL GLOBAL RecipeId::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reqRpm::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL startPosX::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL startPosY::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL startPosZ::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL xDimension::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL yDimension::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL yToolComp::Write
		VAR_INPUT
			input (EAX) 	: eMillToolComp;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: eMillToolComp;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL offsetForXmovement::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ToolId::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TypeMillProg::Write
		VAR_INPUT
			input (EAX) 	: eTypeMillProg;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: eTypeMillProg;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Reserve1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Reserve2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Reserve3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiSaveRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiReloadRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiDeleteRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiSaveRecipeToUsb::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiLoadRecipeFromUsb::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stsUnsafeChanges::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using EditString
#pragma using MillPlanes
#pragma usingLtd _FileSys
#pragma usingLtd FileBase
#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MillingProgsDbV2::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MILLINGPROGSDBV2
0$UINT, 0$UINT, (SIZEOF(::MillingProgsDbV2))$UINT, 
24$UINT, 7$UINT, 0$UINT, 
TO_UDINT(2538437693), "MillingProgsDbV2", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::MillingProgsDbV2.RecipeId.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1433076410), "RecipeId", 
(::MillingProgsDbV2.strDescription.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(415395287), "strDescription", 
(::MillingProgsDbV2.reqRpm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3469225222), "reqRpm", 
(::MillingProgsDbV2.startPosX.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1459501077), "startPosX", 
(::MillingProgsDbV2.startPosY.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(569968771), "startPosY", 
(::MillingProgsDbV2.startPosZ.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3102759225), "startPosZ", 
(::MillingProgsDbV2.xDimension.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(555312407), "xDimension", 
(::MillingProgsDbV2.yDimension.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3470462505), "yDimension", 
(::MillingProgsDbV2.yToolComp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3825290060), "yToolComp", 
(::MillingProgsDbV2.offsetForXmovement.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2263908455), "offsetForXmovement", 
(::MillingProgsDbV2.ToolId.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(377711056), "ToolId", 
(::MillingProgsDbV2.TypeMillProg.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3618926321), "TypeMillProg", 
(::MillingProgsDbV2.Reserve1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2885612093), "Reserve1", 
(::MillingProgsDbV2.Reserve2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(855090055), "Reserve2", 
(::MillingProgsDbV2.Reserve3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1173394193), "Reserve3", 
(::MillingProgsDbV2.HmiSaveRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1848756402), "HmiSaveRecipe", 
(::MillingProgsDbV2.HmiReloadRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(583644729), "HmiReloadRecipe", 
(::MillingProgsDbV2.HmiDeleteRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3337502784), "HmiDeleteRecipe", 
(::MillingProgsDbV2.HmiSaveRecipeToUsb.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2900115486), "HmiSaveRecipeToUsb", 
(::MillingProgsDbV2.HmiLoadRecipeFromUsb.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2513126847), "HmiLoadRecipeFromUsb", 
(::MillingProgsDbV2.HmiFileNrRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1875755963), "HmiFileNrRecipe", 
(::MillingProgsDbV2.stsUnsafeChanges.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1099579582), "stsUnsafeChanges", 
(::MillingProgsDbV2.sparAutoSave.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4270006197), "sparAutoSave", 
(::MillingProgsDbV2.ReRun_.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4274707194), "ReRun_", 
//Clients:
(::MillingProgsDbV2.RamEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(933570811), "RamEx", TO_UDINT(933570811), "RAMex", 1$UINT, 17$UINT, 
(::MillingProgsDbV2.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::MillingProgsDbV2.FB.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2133383872), "FB", TO_UDINT(1689253198), "FileBase", 0$UINT, 5$UINT, 
(::MillingProgsDbV2.oCheckScreen.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(277377924), "oCheckScreen", 
(::MillingProgsDbV2.Rerun.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(296484065), "Rerun", 
(::MillingProgsDbV2.str_Description.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3670666575), "str_Description", TO_UDINT(648754807), "EditString", 0$UINT, 0$UINT, 
(::MillingProgsDbV2.OperationData.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3656777280), "OperationData", TO_UDINT(2955608246), "MillPlanes", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_MillingProgsDbV2 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MillingProgsDbV2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MillingProgsDbV2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_MillingProgsDbV2;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RecipeId.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RecipeId::Write() );
	IF RecipeId.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, strDescription.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #strDescription::Read();
	vmt.CmdTable.Write		:= #strDescription::Write();
	strDescription.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF strDescription.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reqRpm.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reqRpm::Write() );
	IF reqRpm.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startPosX.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startPosX::Write() );
	IF startPosX.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startPosY.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startPosY::Write() );
	IF startPosY.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startPosZ.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startPosZ::Write() );
	IF startPosZ.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	xDimension.pMeth			:= StoreMethod( #M_RD_DIRECT(), #xDimension::Write() );
	IF xDimension.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	yDimension.pMeth			:= StoreMethod( #M_RD_DIRECT(), #yDimension::Write() );
	IF yDimension.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	yToolComp.pMeth			:= StoreMethod( #M_RD_DIRECT(), #yToolComp::Write() );
	IF yToolComp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	offsetForXmovement.pMeth			:= StoreMethod( #M_RD_DIRECT(), #offsetForXmovement::Write() );
	IF offsetForXmovement.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ToolId.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ToolId::Write() );
	IF ToolId.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TypeMillProg.pMeth			:= StoreMethod( #M_RD_DIRECT(), #TypeMillProg::Write() );
	IF TypeMillProg.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Reserve1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Reserve1::Write() );
	IF Reserve1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Reserve2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Reserve2::Write() );
	IF Reserve2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Reserve3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Reserve3::Write() );
	IF Reserve3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiSaveRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiSaveRecipe::Write() );
	IF HmiSaveRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiReloadRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiReloadRecipe::Write() );
	IF HmiReloadRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiDeleteRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiDeleteRecipe::Write() );
	IF HmiDeleteRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiSaveRecipeToUsb.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiSaveRecipeToUsb::Write() );
	IF HmiSaveRecipeToUsb.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiLoadRecipeFromUsb.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiLoadRecipeFromUsb::Write() );
	IF HmiLoadRecipeFromUsb.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiFileNrRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF HmiFileNrRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsUnsafeChanges.pMeth			:= StoreMethod( #stsUnsafeChanges::Read(), #M_NO_F() );
	IF stsUnsafeChanges.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sparAutoSave.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sparAutoSave.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 19-11-2020 added type of mill prog and some reserves, not yet added to possibilities of writing to and reading from files

// JdK 2-1-2020 millingProgsDbV2 created by changing productsDbV2, goal is to store milling progs
// most important difference is that millingprogs have lines in lines
// JdK 29-11-2019 productsDBV2 created to handle 'recipes' like products, assembly's etc.
// functions like autosave, save, save as, reload (undo changes) are available
// storage to usb and load from usb are not yet functional, will be added later

// 
//ErrorNr 1 no file present
//ErrorNr 2 USB not present
//ErrorNr 3 cannot open file
//ErrorNr 4 error reading file
//ErrorNr 5 wrong format
//ErrorNr 6 too many lines
//ErrorNr 7 too little chars in data string

FUNCTION VIRTUAL MillingProgsDbV2::Init1

  IF initDone= 0 THEN
  
    dbAmountOfRecipes:= cMillDbMaxProgs; //read in amounts
    dbAmountOfLinesInRecipe:= cMaxMillPlanesInRecipe;
    dbAmountOfLinesInLine:= cMaxMillLinesInPlane;
    sizeRecipedata := to_udint(sizeof(tRecipeData)); //put size of product data in var
    _memset(dest:=#emptyRecipe, usByte:=0, cntr:=sizeRecipedata); //set empty product
    
    IF RamEx.GetSize() <> (sizeRecipedata*dbAmountOfRecipes) THEN //check if ram size isn't set yet
      IF RamEx.SetSize(udsize:= (sizeRecipedata*dbAmountOfRecipes)) = C_OK THEN //only if setting is done, say init is done
        initDone:= 1;
        
        loadRecipe(nr:=RecipeId); //after setting size of db try to load the recipe

      END_IF;
    ELSE
      initDone:= 1;
      loadRecipe(nr:=RecipeId); //also if size is ok, load recipe
    END_IF;
    
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  //check if we need to update the strings
  if str_Description.NewData.Read() <> 0 then//description
    _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
    str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
    str_Description.NewData.Write(input:=0);
  end_if;


  //if autosave is active, check every ten seconds if we should save
  IF sparAutoSave & ops.tAbsolute-tmrAutoSave> 10000 THEN
    saveChanges();
    tmrAutoSave:= ops.tAbsolute;
  END_IF;
  
  IF HmiDeleteRecipe= -10 THEN //means delete complete db
    IF tmpNrDelete > 0 & tmpNrDelete < dbAmountOfRecipes THEN
      IF saveRecipe(nr:=tmpNrDelete, recipe:=emptyRecipe)= 1 THEN
        tmpNrDelete+=1;
        IF tmpNrDelete = dbAmountOfRecipes THEN
          HmiDeleteRecipe:= 0; //all recipes are deleted now
          loadRecipe(nr:=RecipeId);//load active recipe to show it's empty
        END_IF;
      END_IF;
    END_IF;
  END_IF;

  stsUnsafeChanges.Read();

  //run usb load/save stuff
  IF HmiSaveRecipeToUsb <> 0 THEN
    SaveToUsb(); 
    IF sswSaveUsb= 0 THEN //stopped for some reason
      HmiSaveRecipeToUsb:=0;
    ELSIF sswSaveUsb= 21 THEN //done 
      IF HmiSaveRecipeToUsb= -10 & cntrUsb < TO_DINT(dbAmountOfRecipes) THEN
        cntrUsb+=1;
        tmpNrUsbStored:= cntrUsb; 
        tmpRecipeNrUsb:= cntrUsb;        
        sswSaveUsb:=1;
      ELSE
        sswSaveUsb:=0;
        HmiSaveRecipeToUsb:=0;
      END_IF;
    END_IF;
  ELSIF HmiLoadRecipeFromUsb <> 0 THEN
    loadFromUsb();
    IF sswLoadUsb= 0 THEN //stopped for some reason
      IF HmiLoadRecipeFromUsb<> -10 & fileToLoadNotFound= 1 THEN
        giveAlarm(errorNr:=3);
      END_IF;    
      HmiLoadRecipeFromUsb:= 0;
    ELSIF sswLoadUsb= 21 THEN //done
      IF HmiLoadRecipeFromUsb= -10 & cntrUsb < TO_DINT(dbAmountOfRecipes) THEN
        cntrUsb+=1;
        tmpNrUsbStored:= cntrUsb;
        tmpRecipeNrUsb:= cntrUsb;
        sswLoadUsb:= 1;
      ELSE
        IF HmiLoadRecipeFromUsb<> -10 & fileToLoadNotFound= 1 THEN
          giveAlarm(errorNr:=3);
        END_IF;
        sswLoadUsb:=0;
        HmiLoadRecipeFromUsb:= 0;
      END_IF;
    END_IF;
  END_IF;
  Rerun:= Rerun.Read();
  ReRun_:=Rerun;

  state:= 0;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::stsUnsafeChanges::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  IF ActRecipeData <> checkForStorageProductData THEN
    stsUnsafeChanges:= 1;
  ELSE
    stsUnsafeChanges:= 0;
  END_IF;

	output := stsUnsafeChanges;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::RecipeId::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  
  IF input > 0 & input < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    IF sparAutoSave= 0 | saveChanges()= 1 THEN //only if autosave is active, else in screen project choose to save or not should be made before writing a new product ID
      RecipeId:= input; //keep input in memory
      loadRecipe(nr:=RecipeId);
    END_IF;
   
  ELSE
    Result := Access_Denied;
  End_If;

END_FUNCTION

FUNCTION MillingProgsDbV2::saveRecipe
	VAR_INPUT
		nr 	: UDINT;
		recipe 	: tRecipeData;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  //function save recipe in input nr in ram db
  IF nr > 0 & nr < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    tempRecipe:= recipe;
    stsRamResult:= RamEx.SetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:=nr * sizeRecipedata);
    IF stsRamResult= 5 THEN
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION MillingProgsDbV2::loadRecipe
	VAR_INPUT
		nr 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  //function loads recipe from nr into act recipe, also changes check saving recipe, used to control if saving is required
  IF nr>0 & nr<dbAmountOfRecipes THEN
    stsRamResult:= RamEx.GetDataAt(pData:=#ActRecipeData$USINT, udSize:=sizeRecipedata, udAt:=nr* sizeRecipedata);
    IF stsRamResult= 5 THEN
      checkForStorageProductData:= ActRecipeData; //no changes yet
      UpdateServers();
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION MillingProgsDbV2::saveChanges
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  IF checkForStorageProductData <> ActRecipeData THEN //only do saving if there is a difference
    IF saveRecipe(nr:=RecipeId, recipe:=ActRecipeData) THEN
      checkForStorageProductData:= ActRecipeData;
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 1; //no changes, means no storage needed
  END_IF;

END_FUNCTION

FUNCTION MillingProgsDbV2::UpdateServers

//put data of new recipe into data servers
  reqRpm := ActRecipeData.reqRPM;
  startPosX := ActRecipeData.startX;
  startPosY := ActRecipeData.startY;  
  startPosZ := ActRecipeData.startZ;
  xDimension := ActRecipeData.xDimension;
  yDimension := ActRecipeData.yDimension;
  yToolComp     := ActRecipeData.yToolComp;
  ToolId := ActRecipeData.ToolId;
  offsetForXmovement := ActRecipeData.offsetForXmovement;
  TypeMillProg := ActRecipeData.typeMillProg;
  oCheckScreen.Write(input:=1);
  Reserve1 := ActRecipeData.Reserve1;
  Reserve2 := ActRecipeData.Reserve2;
  Reserve3 := ActRecipeData.Reserve3;
  
  OperationData.WritePtrs(ptr:=#ActRecipeData);
  str_Description.WriteDataOff(udLen:=sizeof(ActRecipeData.description), udOff:=0, pData:=#ActRecipeData.description[0]);

END_FUNCTION

////////////////////////////////////////////////////////////////////
// some functions for controlling recipe from HMI

FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::HmiSaveRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //function to save actual recipe into given nr
  //if used as regular save, write product id into this server to save,
  //else write nr. where you want to save it
  tmpInputNr:=to_udint(input);
  IF input> 0 & tmpInputNr < dbAmountOfRecipes THEN
    IF saveRecipe(nr:=tmpInputNr, recipe:=ActRecipeData) = 1 THEN
	    HmiSaveRecipe := 0; //saving done
    ELSE
      HmiSaveRecipe:= -1;
    END_IF;
  ELSE
    HmiSaveRecipe := -1; //saving not ok
  END_IF;
	result := HmiSaveRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::HmiReloadRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //means throw away all made changes
  IF loadRecipe(nr:=RecipeId)= 1 THEN
  	HmiReloadRecipe := 0; //done
  ELSE
    HmiReloadRecipe := -1; //not ok
  END_IF;
  
	result := HmiReloadRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::HmiDeleteRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //delete all recipes (if value = -10), or one (if value is between min and max recipes)
  if Rerun = 0 then
    tmpInputNr:=to_udint(input);
    IF input = -10 THEN
      HmiDeleteRecipe := input;
      tmpNrDelete:= 1;
    ELSIF input>0 & tmpInputNr < dbAmountOfRecipes THEN
      IF saveRecipe(nr:=tmpInputNr, recipe:=emptyRecipe) = 1 THEN
        IF tmpInputNr = RecipeId THEN //if actual recipe is deleted, reload it
          loadRecipe(nr:=RecipeId);
        END_IF;
        HmiDeleteRecipe:= 0;
      ELSE
        HmiDeleteRecipe:= -1;
      END_IF;
    END_IF;
    result := HmiDeleteRecipe;
  else
    result := ACCESS_DENIED;
  end_if;
END_FUNCTION


/////////////////////////////////////////////////////////////////
// USB functions
//////////////////////////////////////////////////////////////////
// function to get prog from other class

FUNCTION GLOBAL MillingProgsDbV2::GetRecipe
	VAR_INPUT
		id 	: DINT;
	END_VAR
	VAR_OUTPUT
		oRecipe 	: tRecipeData;
	END_VAR
  
  if id >= 0 & id < to_dint(dbAmountOfRecipes) then
    if id = to_dint(RecipeId) then //JdK if product is active, just give it back, else db isn't written in right way
      tempRecipe:=ActRecipeData;
    else
      RamEx.GetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:= to_udint(id) * sizeRecipedata);
    end_if;
    oRecipe := tempRecipe;
  else
    oRecipe := emptyRecipe;
  end_if;


END_FUNCTION

//////////////////////////////////////////////////////////////
// functions to write data

FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::strDescription::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	strDescription := str_Description.Data.Read();
	output := strDescription;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::strDescription::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	strDescription := input;
	result := (str_Description.Data.Write(strDescription))$UDINT;
  _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
  str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::reqRpm::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if Rerun = 0 then
    reqRpm := input;
    ActRecipeData.reqRPM := reqRpm;
    result := reqRpm;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::startPosZ::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if Rerun = 0 then
    startPosZ := input;
    ActRecipeData.startZ := startPosZ;
    result := startPosZ;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::xDimension::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if Rerun = 0 then
    xDimension := input;
    ActRecipeData.xDimension := xDimension;
    result := xDimension;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::yDimension::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if Rerun = 0 then
    yDimension := input;
    ActRecipeData.yDimension := yDimension;
    result := yDimension;
  else
    result:=ACCESS_DENIED;
  end_if;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::startPosX::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if Rerun = 0 then
    startPosX := input;
    ActRecipeData.startX := startPosX;
    result := startPosX;
  else
    result:=ACCESS_DENIED;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::startPosY::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if Rerun = 0 then
    startPosY := input;
    ActRecipeData.startY := startPosY;
    result := startPosY;
  else
    result:=ACCESS_DENIED;
  end_if;
  
END_FUNCTION
  

FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::offsetForXmovement::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	if Rerun = 0 then
    offsetForXmovement := input;
    ActRecipeData.offsetForXmovement:= offsetForXmovement;
    result := offsetForXmovement;
  else
    result:=ACCESS_DENIED;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::yToolComp::Write
	VAR_INPUT
		input (EAX) 	: eMillToolComp;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: eMillToolComp;
	END_VAR

  if Rerun = 0 then
    yToolComp := input;
    ActRecipeData.yToolComp:= yToolComp;
    result := yToolComp;
  end_if;

END_FUNCTION



FUNCTION MillingProgsDbV2::saveToUsb
//method to save one recipe to usb stick, nr of recipe to save is in tmpRecipeNrUsb
//nr of recipe name on usb is in tmpNrUsbStored, same vars are used for loading and saving from/to usb, so we have to make sure only one of them is used

  case sswSaveUsb of

  0://idle
            
  1:// create file name, load data to sve

    FileSys.GetDriveListShort(drivelist:=#CheckDisk[0]);//get active drive names
    
    if CheckDisk[4] <> 0 then// check if drive e is available

      fb.BuildValue2Ascii(Value:=to_dint(tmpNrUsbStored), Dest:=#tmpString[0], Offset:=0);
      _strcpy(dest:=#strname[0], src:="e:\Millprog");                             // make localfilename
      _strcat(dest:=#strname[0], src:=#tmpString[0]);                             // recipe nummer
      _strcat(dest:=#strname[0], src:=".csv");                                    // data type
    
      tmpRecipeUsb:= GetRecipe(id:=tmpRecipeNrUsb);
      IF tmpRecipeUsb.reqRPM > 0 THEN
        sswSaveUsb +=1;
      ELSE
        sswSaveUsb:= 21; //just don't save, because there is no inputlength
      END_IF;

    else
      sswSaveUsb:= 0;
      giveAlarm(errorNr:=2);// USB not present
    end_if;
    
  2://empty a few things and open file
    _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString)); 
    fb.OpenFile(FileName:=#strname[0], Attribute:=ATT_READ_WRITE or ATT_CREATE_ALWAYS);
    sswSaveUsb +=1;

  3: // write general stuff

    _strcat(dest:=#tmpString[0], src:=#tmpRecipeUsb.description[0]);  
    _strcat(dest:=#tmpString[0], src:=",");  
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.reqRPM , Dest:=#tmpString[0], Offset:=actStrLen); 
    _strcat(dest:=#tmpString[0], src:=",");
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.startX , Dest:=#tmpString[0], Offset:=actStrLen); 
    _strcat(dest:=#tmpString[0], src:=",");    

    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.startY , Dest:=#tmpString[0], Offset:=actStrLen); 
    _strcat(dest:=#tmpString[0], src:=",");
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.startZ , Dest:=#tmpString[0], Offset:=actStrLen); 
    _strcat(dest:=#tmpString[0], src:=",");
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.xDimension , Dest:=#tmpString[0], Offset:=actStrLen); 
    _strcat(dest:=#tmpString[0], src:=",");
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.yDimension , Dest:=#tmpString[0], Offset:=actStrLen); 
    _strcat(dest:=#tmpString[0], src:=",");    
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=TO_DINT(tmpRecipeUsb.yToolComp) , Dest:=#tmpString[0], Offset:=actStrLen); 
    _strcat(dest:=#tmpString[0], src:=",");    
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.offsetForXmovement , Dest:=#tmpString[0], Offset:=actStrLen); //end angle
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    tmpString[actStrLen]:=CRASC;           
    tmpString[actStrLen+1]:=LF; //JdK 6-2-2020: also add linefeed, so file is also ok in wordpad    
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    
    fb.WriteFile(Source:=#tmpString[0], Length:=actStrLen); //write every line apart
         
    sswSaveUsb +=1;
        
       
  4: //write line stuff  
    _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString)); 
    
    for usbLineNr:= 0 to to_dint(dbAmountOfLinesInRecipe) do
      if tmpRecipeUsb.planes[usbLineNr].amount<> 0 then //stop if there is no value in it           
        fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].depth , Dest:=#tmpString[0], Offset:=0);
        _strcat(dest:=#tmpString[0], src:=",");  
        actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
        
        fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].amount , Dest:=#tmpString[0], Offset:=actStrLen);
        _strcat(dest:=#tmpString[0], src:=",");  
        actStrLen:=to_dint(_strlen(src:=#tmpString[0]));        

        fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].feedRate , Dest:=#tmpString[0], Offset:=actStrLen);
        _strcat(dest:=#tmpString[0], src:=",");  
        actStrLen:=to_dint(_strlen(src:=#tmpString[0]));        
        
        fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].lowerRate , Dest:=#tmpString[0], Offset:=actStrLen);

        actStrLen:=to_dint(_strlen(src:=#tmpString[0]));    
        tmpString[actStrLen]:=CRASC;
        tmpString[actStrLen+1]:=LF; //JdK 6-2-2020: also add linefeed, so file is also ok in wordpad
        
        actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
       
        
        fb.WriteFile(Source:=#tmpString[0], Length:=actStrLen); //write every line apart
            
        if actStrLen>= sizeof(tmpString) then //if data doesnt fit
          giveAlarm(errorNr:=7); 
          sswSaveUsb := 20;
        end_if;   
        
        _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString)); 
        for usbLineInLineNr:=0 to dbAmountOfLinesInLine do //always write al lines, because else we don't know how much to read in before next plane
          fb.BuildValue2Ascii(Value:=to_dint(tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].millType) , Dest:=#tmpString[0], Offset:=0);
          _strcat(dest:=#tmpString[0], src:=",");  
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
          
          fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].xGoal , Dest:=#tmpString[0], Offset:=actStrLen);
          _strcat(dest:=#tmpString[0], src:=",");  
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));        

          fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].yGoal , Dest:=#tmpString[0], Offset:=actStrLen);
          _strcat(dest:=#tmpString[0], src:=",");  
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));        

          fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].radius , Dest:=#tmpString[0], Offset:=actStrLen);
          _strcat(dest:=#tmpString[0], src:=",");  
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));   

          fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].middleX , Dest:=#tmpString[0], Offset:=actStrLen);
          _strcat(dest:=#tmpString[0], src:=",");  
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));   

          fb.BuildValue2Ascii(Value:=tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].middleY , Dest:=#tmpString[0], Offset:=actStrLen);
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));    
          tmpString[actStrLen]:=CRASC;
          tmpString[actStrLen+1]:=LF; //JdK 6-2-2020: also add linefeed, so file is also ok in wordpad
 
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
       
          fb.WriteFile(Source:=#tmpString[0], Length:=actStrLen); //write every line apart
 
        end_for;

        
      else 
        sswSaveUsb :=20;     //ready
      end_if;    
    end_for;

      
  20: // save file
    fb.CloseFile();
    sswSaveUsb+=1;              
    
  21: //wait until stopped from other part of program
      
end_case;


END_FUNCTION


FUNCTION MillingProgsDbV2::loadFromUsb
//method to load one recipe from usb stick, nr of recipe to load is in tmpNrUsbStored
//nr where to store tmpRecipeNrUsb, same vars are used for loading and saving from/to usb, so we have to make sure only one of them is used

  case sswLoadUsb of
  
  0://idle
         
  1:// create file name
    FileSys.GetDriveListShort(drivelist:=#CheckDisk[0]);//get active drive names
    fileToLoadNotFound:= 0;
    if CheckDisk[4] <> 0 then// check if drive e is available
      _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString));
      fb.BuildValue2Ascii(Value:=tmpNrUsbStored, Dest:=#tmpString[0], Offset:=0);
      _strcpy(dest:=#strname[0], src:="e:\Millprog");                             // make localfilename
      _strcat(dest:=#strname[0], src:=#tmpString[0]);                             // recipe number
      _strcat(dest:=#strname[0], src:=".csv");                                    // data type
      fileHandle := FileSys.FindFirst(path:="", file:=#strname[0], infostruct:=#FileInfo, atts_inkl:=0, atts_exkl:=0);
      if fileHandle > 0 then
        sswLoadUsb +=1;
      else
        fileToLoadNotFound:= 0;
        sswLoadUsb := 21;
      end_if;
    else
      giveAlarm(errorNr:=2);   //USB not present
      sswLoadUsb:=0;
    end_if;
    
  2://open file
    fb.OpenFile(FileName:=#strName[0], Attribute:=ATTR_READ_ONLY);
    sswLoadUsb +=1;
  
  3://read in first line
    actBufferLength:= fb.ReadFileSkipLineFeeds(Dest:=#buffer[0], Offset:=0);
    offsetBuffer:= 0;
    if actBufferLength > sizeof(buffer) | actBufferLength= 0 then
      giveAlarm(errorNr:=4); //error reading file
      sswLoadUsb := 21;
    else
      sswLoadUsb := 4;
    end_if;
  
  4: //close file, data in buffer
    fb.CloseFile();
    _memset(dest:=#tmpRecipeUsb, usByte:=0, cntr:=sizeof(tmpRecipeUsb));
    sswLoadUsb +=1;
    
  5:// read assembly
    _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString));
    offsetBuffer := FB.Read2Cr(Source:=#Buffer[0], Dest:=#tmpString[0], Offset:=0); //R1
    offsetBuffer+= 1;
    if  offsetBuffer > actBufferLength+1 then
      giveAlarm(errorNr:=5);   //wrong format
      sswLoadUsb :=0;
    else
      actStrLen := fb.Read2Seperator(Source:=#tmpString[0], Dest:=#tmpRecipeUsb.description[0], Offset:=0); //description
      actStrLen+= 1; //ignore seperator
      
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.reqRPM:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
      
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.startX:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.startY:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.startZ:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.xDimension:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.yDimension:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.yToolComp:= to_dint(fb.ConvAscii2Value(Source:=#tmpString2[0]))$eMillToolComp;
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
      tmpRecipeUsb.offsetForXmovement:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator

      sswLoadUsb +=1;
    end_if;
    
  6: // read recipe lines
    
    for usbLineNr:= 0 to TO_DINT(dbAmountOfLinesInRecipe) do
      _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString));
      offsetBuffer += FB.Read2Cr(Source:=#Buffer[offsetBuffer], Dest:=#tmpString[0], Offset:=0); //R2 en verder
      offsetBuffer+= 1;
      actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
      if actStrLen<= 0 then
        sswLoadUsb :=20;     //ready
      else
        _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
        actStrLen:= fb.Read2Seperator(Source:=#tmpString[0], Dest:=#tmpString2[0], Offset:=0); 
        tmpRecipeUsb.planes[usbLineNr].depth := fb.ConvAscii2Value(Source:=#tmpString2[0]);
        actStrLen+= 1; //ignore seperator

        _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
        actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
        tmpRecipeUsb.planes[usbLineNr].amount := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
        actStrLen+= 1; //ignore seperator
        
        _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
        actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
        tmpRecipeUsb.planes[usbLineNr].feedRate := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
        actStrLen+= 1; //ignore seperator
        
        _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
        actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
        tmpRecipeUsb.planes[usbLineNr].lowerRate := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
     
        if usbLineNr >= TO_DINT(dbAmountOfLinesInRecipe)-1 then
         giveAlarm(errorNr:=6); //too many lines
         sswLoadUsb := 20;
        end_if;
        
        for usbLineInLineNr:=0 to dbAmountOfLinesInLine do
          _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString));
          offsetBuffer += FB.Read2Cr(Source:=#Buffer[offsetBuffer], Dest:=#tmpString[0], Offset:=0); //R2 en verder
          offsetBuffer+= 1;
          actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
          if actStrLen<= 0 then
            giveAlarm(errorNr:=5); //wrong format
            sswLoadUsb :=20;     //ready
          else     
            _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
            actStrLen:= fb.Read2Seperator(Source:=#tmpString[0], Dest:=#tmpString2[0], Offset:=0); 
            tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].millType := to_dint(fb.ConvAscii2Value(Source:=#tmpString2[0]))$::eMillType;
            actStrLen+= 1; //ignore seperator

            _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
            actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
            tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].xGoal := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
            actStrLen+= 1; //ignore seperator

            _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
            actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
            tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].yGoal := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
            actStrLen+= 1; //ignore seperator        

            _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
            actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
            tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].radius := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
            actStrLen+= 1; //ignore seperator

            _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
            actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
            tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].radius := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
            actStrLen+= 1; //ignore seperator

            _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
            actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
            tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].middleX := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
            actStrLen+= 1; //ignore seperator

            _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
            actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); 
            tmpRecipeUsb.planes[usbLineNr].lines[usbLineInLineNr].middleY := fb.ConvAscii2Value(Source:=#tmpString2[0]);    
            actStrLen+= 1; //ignore seperator 
            
          end_if;
        end_for;

        
      end_if;
    end_for;

    
  20: //save recipe
    IF saveRecipe(nr:=TO_UDINT(tmpRecipeNrUsb), recipe:=tmpRecipeUsb)= 1 THEN
      IF tmpRecipeNrUsb= TO_DINT(RecipeId) THEN //act loaded recipe is same as loaded from usb
        ActRecipeData:= tmpRecipeUsb;
        loadRecipe(nr:=TO_UDINT(RecipeId));
      END_IF;
      sswLoadUsb+= 1;
    END_IF;
    
  21: //wait until stopped from somewhere else in the program
    cntrTje+=1;
    
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::HmiSaveRecipeToUsb::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	HmiSaveRecipeToUsb := input;
  IF HmiLoadRecipeFromUsb = 0 & sswLoadUsb= 0 & sswSaveUsb = 0 THEN
	  
    IF HmiSaveRecipeToUsb <> -10 & (HmiSaveRecipeToUsb <= 0 | HmiSaveRecipeToUsb > TO_DINT(dbAmountOfRecipes)) THEN
      HmiSaveRecipeToUsb:= 0; //only activate if nr is right, -10 means save them all, other numbers mean save this nr
    ELSIF HmiSaveRecipeToUsb > 0 & HmiSaveRecipeToUsb <= TO_DINT(dbAmountOfRecipes) THEN
      IF HmiFileNrRecipe> 0 & HmiFileNrRecipe <= TO_DINT(dbAmountOfRecipes) THEN
        tmpNrUsbStored:= HmiFileNrRecipe; //save on specified nr
      ELSE
        tmpNrUsbStored:= HmiSaveRecipeToUsb; //save on used nr
        tmpRecipeNrUsb:= HmiSaveRecipeToUsb;
      END_IF;
    ELSE
      tmpNrUsbStored:= 1; //store them all, start with 1
      tmpRecipeNrUsb:= 1;
      cntrUsb:= 1;
    END_IF;
    sswSaveUsb:=1;
  ELSE
    HmiSaveRecipeToUsb:= 0;
  END_IF;  
	result := HmiSaveRecipeToUsb;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::HmiLoadRecipeFromUsb::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	HmiLoadRecipeFromUsb := input;
  IF HmiSaveRecipeToUsb = 0 & sswLoadUsb= 0 & sswSaveUsb = 0 THEN
      
    IF HmiLoadRecipeFromUsb <> -10 & (HmiLoadRecipeFromUsb <= 0 | HmiLoadRecipeFromUsb > TO_DINT(dbAmountOfRecipes)) THEN
      HmiLoadRecipeFromUsb:= 0; //only activate if nr is right, -10 means save them all, other numbers mean save this nr
    ELSIF HmiLoadRecipeFromUsb > 0 & HmiLoadRecipeFromUsb <= TO_DINT(dbAmountOfRecipes) THEN
      IF HmiFileNrRecipe> 0 & HmiFileNrRecipe <= TO_DINT(dbAmountOfRecipes) THEN
        tmpNrUsbStored:= HmiFileNrRecipe; //save on specified nr
      ELSE
        tmpNrUsbStored:= HmiLoadRecipeFromUsb; //save on used nr
        tmpRecipeNrUsb:= HmiLoadRecipeFromUsb;
      END_IF;
    ELSE
      tmpNrUsbStored:= 1; //load them all, start with 1
      tmpRecipeNrUsb:= 1;
      cntrUsb:= 1;      
    END_IF;
    sswLoadUsb:=1;
  ELSE
    HmiLoadRecipeFromUsb:= 0;
  END_IF;  
	result := HmiLoadRecipeFromUsb;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::ToolId::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if Rerun = 0 then
    ToolId := input;
    ActRecipeData.ToolId := ToolId;
    result := ToolId;
  else
    result:=ACCESS_DENIED;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::TypeMillProg::Write
	VAR_INPUT
		input (EAX) 	: eTypeMillProg;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: eTypeMillProg;
	END_VAR
  
  if Rerun = 0 then
    TypeMillProg := input;
    ActRecipeData.typeMillProg:= TypeMillProg;
    oCheckScreen.Write(input:=1);
    result := TypeMillProg;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::Reserve1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Reserve1 := input;
  ActRecipeData.Reserve1:= Reserve1;
	result := Reserve1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::Reserve2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Reserve2 := input;
  ActRecipeData.Reserve2:= Reserve2;
	result := Reserve2;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MillingProgsDbV2::Reserve3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Reserve3 := input;
  ActRecipeData.Reserve3:= Reserve3;
	result := Reserve3;

END_FUNCTION
