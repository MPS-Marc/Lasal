//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emWagon"
	Revision           = "1.1"
	GUID               = "{AE64A99C-4829-406B-A1CB-4350769D696E}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "500 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(630,1620)">
	<Channels>
		<Server Name="cmdMaxSpeedNegative" GUID="{2ED80E8C-CE2F-414A-ACBB-A91F1EC2CEF8}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ParBlowerGripper" GUID="{441F6FE5-BED1-45A9-BBD8-FFE3D78E51C3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parCheckMaterialInGripper" GUID="{CC0426D2-FD75-4C67-A4C7-AB581726361A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parDelayMatInGripper" GUID="{AFDE52DD-E284-4E92-8C59-4A54BCFB1CAF}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parDirectionBlowing" GUID="{EC687E6C-698E-4614-A9B1-3E74BF382B29}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parDistanceBetweenWagons" GUID="{E38EDFF5-0CCE-4313-96BB-FDC1E863D060}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parFilterVDifference" GUID="{45C7D000-B1BA-4F83-912B-B1BEC135DDE5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parMoveUpBeforeHoming" GUID="{9F795975-C628-4F3B-B713-AE98C8A2CB2F}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="parResetAction" GUID="{5B0AEFFF-79DB-4A6B-BC71-6CA8B6307D99}" Visualized="false" Initialize="true" WriteProtected="true" Retentive="false" Comment="Value 0 means do nothing, &#13;&#10;value 1 means go to max pos&#13;&#10;value 2 means go to min pos&#13;&#10;"/>
		<Server Name="parStartPosBlowing" GUID="{50CF1892-B1F2-4F1D-B18C-EC60D1D893FC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parWagonIsFollower" GUID="{5DB16E75-8738-407C-A334-7FD3A6D5CE64}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false"/>
		<Server Name="parWagonIsLeader" GUID="{A8DCF869-E3D7-4816-A4F8-8DBFAC399734}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false"/>
		<Server Name="stsGoalOverride" GUID="{F3118993-AC1F-44E0-A2C6-FB5A1D612937}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsMaxOverride" GUID="{289147E7-8A28-489F-97EB-40B11E0456C4}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsOverride" GUID="{C872BF22-BC3A-4A67-87E9-6F73EAEE44F4}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsWagonSafeForLoading" GUID="{C7C5BE3F-54F4-4A3F-AF5B-5DDA175C42EE}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="ctrlBlowValve" Required="false" Internal="false"/>
		<Client Name="ctrlClamp" Required="false" Internal="false"/>
		<Client Name="ctrlLiftingRol" Required="false" Internal="false"/>
		<Client Name="ctrlServo" Required="true" Internal="false"/>
		<Client Name="ctrlUpDown" Required="false" Internal="false"/>
		<Client Name="iClampOpenAllowed" Required="true" Internal="false"/>
		<Client Name="iFcMatInGripper" Required="false" Internal="false"/>
		<Client Name="iMaterialLength" Required="false" Internal="false"/>
		<Client Name="iMaxForce" Required="false" Internal="false" DefValue="1000"/>
		<Client Name="iMinPosWagonUp" Required="false" Internal="false"/>
		<Client Name="iOffsetInputPos" Required="false" Internal="false"/>
		<Client Name="ioFrontOfMaterial" Required="false" Internal="false"/>
		<Client Name="ioRearOfMaterial" Required="false" Internal="false"/>
		<Client Name="iSpeedNextWagon" Required="false" Internal="false"/>
		<Client Name="oBlowGripper" Required="true" Internal="false"/>
		<Client Name="oTorqueControl" Required="false" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="7"/>
			<SepChn Position="0"/>
			<SepChn Position="2"/>
		</Servers>
	</Separators>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="0.2" Date="2020-03-10" Description="par for send first up before homing"/>
		<Dokumentation Revision="0.1" Date="2019-09-24" Description="made check before start moving is wagon isn&apos;t coupled"/>
	</RevDoku>
	<Network Name="emWagon">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{141377EF-3012-447D-AFFD-59C147FF5034}"
				Class      = "emBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1156,210),(984,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1156,270),(984,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1156,330),(984,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1156,390),(984,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1156,450),(984,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1156,510),(984,510),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1156,570),(984,570),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1156,690),(984,750),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1156,750),(984,810),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1156,810),(984,870),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1156,870),(984,930),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1156,990),(984,1170),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1156,1050),(984,1230),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1156,630),(984,630),"/>
			<Connection Source="this.cmdWaitReset" Destination="_base.cmdWaitReset" Vertices="(1156,930),(984,1050),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emBase

emWagon : CLASS
: emBase
  //Servers:
	cmdMaxSpeedNegative 	: SvrCh_DINT;
	stsWagonSafeForLoading 	: SvrCh_DINT;
	stsOverride 	: SvrCh_DINT;
	stsMaxOverride 	: SvrCh_DINT;
	stsGoalOverride 	: SvrCh_DINT;
	parDelayMatInGripper 	: SvrCh_UDINT;
	parDistanceBetweenWagons 	: SvrCh_DINT;
	parWagonIsLeader 	: SvrCh_DINT;
	parWagonIsFollower 	: SvrCh_DINT;
	parFilterVDifference 	: SvrCh_DINT;
	parStartPosBlowing 	: SvrCh_DINT;
	parDirectionBlowing 	: SvrCh_DINT;
	parCheckMaterialInGripper 	: SvrCh_DINT;
	parResetAction 	: SvrCh_DINT;
	parMoveUpBeforeHoming 	: SvrCh_DINT;
	ParBlowerGripper 	: SvrCh_UDINT;
  //Clients:
	ctrlServo 	: CltChCmd_cmServo;
	ctrlClamp 	: CltChCmd_cmMultipleCil;
	ctrlUpDown 	: CltChCmd_cmMultipleCil;
	ctrlLiftingRol 	: CltChCmd_cmCil;
	ctrlBlowValve 	: CltChCmd_cmBlower;
	iFcMatInGripper 	: CltCh_DINT;
	ioFrontOfMaterial 	: CltCh_DINT;
	ioRearOfMaterial 	: CltCh_DINT;
	iSpeedNextWagon 	: CltCh_DINT;
	iMaterialLength 	: CltCh_DINT;
	iOffsetInputPos 	: CltCh_DINT;
	iMinPosWagonUp 	: CltCh_DINT;
	oBlowGripper 	: CltCh_DINT;
	iClampOpenAllowed 	: CltCh_DINT;
	iMaxForce 	: CltCh_DINT;
	oTorqueControl 	: CltCh_UDINT;
  //Variables:
		stsPosClamp 	: cilPos;
		stsPosUpDown 	: cilPos;
		stsGoalPosClamp 	: cilPos;
		clampIsConnected 	: DINT;
		upDownIsConnected 	: DINT;
		blowValveIsConnected 	: DINT;
		fcMatInGripperIsConnected 	: DINT;
		livePos 	: DINT;
		timerMatDetected 	: strTimer;
		actDistanceToPrevMat 	: DINT;
		maxSpeedToStopInTime 	: DINT;
		startRearMaterial 	: DINT;
		startXposWagon 	: DINT;
		tmpBlowStarted 	: DINT;
		stsPosLiftingRol 	: cilPos;
		liftingRolIsConnected 	: DINT;
		TimerBlower 	: strTimer;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION VIRTUAL execResetting;
	
	FUNCTION VIRTUAL execStarting;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION VIRTUAL execHolding;
	
	FUNCTION VIRTUAL execStopping;
	
	FUNCTION VIRTUAL execSuspending;
	
	FUNCTION VIRTUAL GLOBAL Ready
		VAR_INPUT
			sLine 	: SRegelInfo;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL runAction;
	
	FUNCTION VIRTUAL runMovement;
	
	FUNCTION calcMaxSpeetToStopInTime
		VAR_INPUT
			actDistance 	: DINT;
		END_VAR
		VAR_OUTPUT
			maxSpeed 	: DINT;
		END_VAR;
	
	FUNCTION updateRearFrontMaterial;
	
	FUNCTION updateSpeed;
	
	FUNCTION checkForce;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd cmBlower
#pragma usingLtd cmCil
#pragma usingLtd cmMultipleCil
#pragma usingLtd cmServo


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emWagon::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMWAGON
1$UINT, 1$UINT, (SIZEOF(::emWagon))$UINT, 
16$UINT, 16$UINT, 0$UINT, 
TO_UDINT(38933641), "emWagon", //Class
TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emWagon.cmdMaxSpeedNegative.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1258820969), "cmdMaxSpeedNegative", 
(::emWagon.stsWagonSafeForLoading.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2903854697), "stsWagonSafeForLoading", 
(::emWagon.stsOverride.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1357452424), "stsOverride", 
(::emWagon.stsMaxOverride.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2352733250), "stsMaxOverride", 
(::emWagon.stsGoalOverride.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2874669198), "stsGoalOverride", 
(::emWagon.parDelayMatInGripper.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(188050012), "parDelayMatInGripper", 
(::emWagon.parDistanceBetweenWagons.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(941049361), "parDistanceBetweenWagons", 
(::emWagon.parWagonIsLeader.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1478281448), "parWagonIsLeader", 
(::emWagon.parWagonIsFollower.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2592262923), "parWagonIsFollower", 
(::emWagon.parFilterVDifference.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3002059129), "parFilterVDifference", 
(::emWagon.parStartPosBlowing.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(45850843), "parStartPosBlowing", 
(::emWagon.parDirectionBlowing.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1640030867), "parDirectionBlowing", 
(::emWagon.parCheckMaterialInGripper.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4241044153), "parCheckMaterialInGripper", 
(::emWagon.parResetAction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3848536271), "parResetAction", 
(::emWagon.parMoveUpBeforeHoming.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3744694608), "parMoveUpBeforeHoming", 
(::emWagon.ParBlowerGripper.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3734127191), "ParBlowerGripper", 
//Clients:
(::emWagon.ctrlServo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2859050432), "ctrlServo", TO_UDINT(3985303601), "cmServo", 1$UINT, 0$UINT, 
(::emWagon.ctrlClamp.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2380244622), "ctrlClamp", TO_UDINT(3389912646), "cmMultipleCil", 0$UINT, 0$UINT, 
(::emWagon.ctrlUpDown.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1114626821), "ctrlUpDown", TO_UDINT(3389912646), "cmMultipleCil", 0$UINT, 0$UINT, 
(::emWagon.ctrlLiftingRol.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1232704682), "ctrlLiftingRol", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::emWagon.ctrlBlowValve.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3198723833), "ctrlBlowValve", TO_UDINT(2593188663), "cmBlower", 0$UINT, 0$UINT, 
(::emWagon.iFcMatInGripper.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2942726126), "iFcMatInGripper", 
(::emWagon.ioFrontOfMaterial.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3987849005), "ioFrontOfMaterial", 
(::emWagon.ioRearOfMaterial.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1904781683), "ioRearOfMaterial", 
(::emWagon.iSpeedNextWagon.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1811355107), "iSpeedNextWagon", 
(::emWagon.iMaterialLength.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2355868271), "iMaterialLength", 
(::emWagon.iOffsetInputPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2080075072), "iOffsetInputPos", 
(::emWagon.iMinPosWagonUp.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1407589245), "iMinPosWagonUp", 
(::emWagon.oBlowGripper.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1469836638), "oBlowGripper", 
(::emWagon.iClampOpenAllowed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1654886312), "iClampOpenAllowed", 
(::emWagon.iMaxForce.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2183083036), "iMaxForce", 
(::emWagon.oTorqueControl.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(756810666), "oTorqueControl", 
END_FUNCTION


#define USER_CNT_emWagon 42

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emWagon] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emWagon::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emWagon;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #execResetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #execStarting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #execHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #execStopping();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #execSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #Ready();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #runAction();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[41]		:= #runMovement();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parDelayMatInGripper.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parDelayMatInGripper.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parDistanceBetweenWagons.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parDistanceBetweenWagons.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parWagonIsLeader.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parWagonIsLeader.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parWagonIsFollower.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parWagonIsFollower.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parFilterVDifference.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parFilterVDifference.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parStartPosBlowing.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parStartPosBlowing.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parDirectionBlowing.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parDirectionBlowing.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parCheckMaterialInGripper.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parCheckMaterialInGripper.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMoveUpBeforeHoming.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parMoveUpBeforeHoming.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParBlowerGripper.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParBlowerGripper.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// TP 01-06-2022 add force control. so the wagon can max use that force. add for valk
// JdK 24-9-2019: before starting movement make check if servo isn't coupled
// JdK 4-6-2019: emWagon created for 4284TraffiRoad/ standard lib
// goal is to handle an input/output wagon with functions like up/down, gripper open/close, blowing at position, following other material etc.
// there are no manual of half automatic functions for this one

// cil in means up for updown and cil in means open for clamp

// errornrs
// 1 = Command not recognized
// 2 = 
// 3 = servo in idle without reaching destination 
// 4 = material lost from gripper
// 5 = no material found in gripper
// 6 = sensor in gripper active before start gripping material
// 7 = cant move up, gripper not out machine
// 8 = X-position out of reach servo
// 9 = 
// 10 = 

// vars
// mTargetClamp  = target position clamp, where clamp should be. Used for calculating front/rear position, more reliable than real position clamp
//
// unitstartcom actions
// 1 = Close clamp
// 2 = Open clamp
// 3 = move gripper up
// 4 = move gripper down

FUNCTION VIRTUAL emWagon::Init1

  //check connected equipment
  IF initDone=0 THEN
    clampIsConnected:=IsClientConnected(input:=#ctrlClamp);
    upDownIsConnected:=IsClientConnected(input:=#ctrlUpDown);
    blowValveIsConnected:=IsClientConnected(input:=#ctrlBlowValve);
    liftingRolIsConnected:=IsClientConnected(input:=#ctrlLiftingRol);
    fcMatInGripperIsConnected:=IsClientConnected(input:=#iFcMatInGripper);
    cmdWaitReset:= 1;
    initDone:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emWagon::execResetting

  IF pmlCom.cmd.reRun=1 THEN //during rerun don't do a thing
  
    stprState:=1000;
    
  ELSE

    //reset, means home wagon, send it back, open clamp and send up
    CASE stprState OF
    
    0: //wait for command
      IF cmdWaitReset= 0 THEN
        stprState+=1;
      END_IF;
    
    1: //reset steppers
      stprAction:=0;
      stprMoving:=0;
      stprState+=1;
      
    2: //open clamp //Jdk send first up before homing
     
    IF clampIsConnected=0 | stsPosClamp= cilIn THEN
      IF parMoveUpBeforeHoming= 0 | (upDownIsConnected=0 | stsPosUpDown= cilIn) THEN
        stprState+=1;
      ELSIF upDownIsConnected= 1 THEN
        ctrlUpDown.csMoveIn();
      END_IF;
    ELSE
      ctrlClamp.csMoveIn();
    END_IF;
      
    3: //if required start homing
      IF ctrlServo.stsIsHomed=0 | ctrlServo.parHomeAgain= 1 THEN
        ctrlServo.csStartHoming();
        stprState+=1;
      ELSE
        stprState:=5;
      END_IF;
      
    4: //wait until homing is done
      IF ctrlServo.stsState=seIdle THEN
        stprState-=1;
      END_IF;
      
    5: //send to required pos
      IF parResetAction=0 THEN
        stprState+=2;
      ELSIF parResetAction= 1 THEN
        ctrlServo.csStartMoveAbs(iReqPos:=ctrlServo.parMaxPos, iReqSpeed:=500);
        stprState+=1;
      ELSIF parResetAction= 2 THEN
        ctrlServo.csStartMoveAbs(iReqPos:=ctrlServo.parMinPos, iReqSpeed:=500);
        stprState+=1;
      END_IF;
      
    6: //wait until in pos
      IF ctrlServo.stsState=seIdle & ((parResetAction=1 & ctrlServo.checkInPos(checkPos:=ctrlServo.parMaxPos)) |
        (parResetAction=2 & ctrlServo.checkInPos(checkPos:=ctrlServo.parMinPos))) THEN
        stprState+=1;
      ELSIF ctrlServo.stsState=seIdle THEN
        stprState-=1;
      END_IF;
//    JdK 30-10-2019 only send up is wagon is at waiting pos, because else it can try to lift the material in the clamp
//      IF upDownIsConnected=1 & livePos>iMinPosWagonUp & stsPosUpDown<> cilIn THEN
//        ctrlUpDown.csMoveIn();
//      END_IF;
      
    7: //move gripper up
      IF upDownIsConnected=0 | stsPosUpDown=cilIn THEN
        stprState+=1;
      ELSE
        ctrlUpDown.csMoveIn();
      END_IF;
      
    8: //send lifting rol down
      IF liftingRolIsConnected= 0 | stsPosLiftingRol=cilIn THEN
        stprState+=1;
      ELSIF liftingRolIsConnected= 1 THEN
        ctrlLiftingRol.csMoveIn();
      END_IF;
      
    9: //done
      stprState:=1000;
      
    1000: //ready
      
   
    END_CASE;


  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emWagon::execStarting

  execResetting(); //just run resetting
  

END_FUNCTION


FUNCTION VIRTUAL emWagon::execHolding

  CASE stprState OF
  
  0: //wait until action and movement are done, also go on if there is an problem in this em
    IF (stprAction=0 & stprMoving=0) | stsInAlarm= 1 THEN
      stprState+= 1;
    ELSE
      runAction();
      runMovement();
    END_IF;
    
  1: //stop moving servo
    IF ctrlServo.stsState=seIdle | ctrlServo.stsState=seWaitReset THEN
      stprState+= 1;
    ELSE
      ctrlServo.csStop();
    END_IF;
    
  2: //power off servo
    IF ctrlServo.stsControllerIsOn= 0 THEN
      stprState:= 1000;
    ELSE
      ctrlServo.csPowerOff();
    END_IF;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emWagon::execSuspending

  execHolding(); //suspening and holding just do the same thing

END_FUNCTION


FUNCTION VIRTUAL emWagon::execStopping

  CASE stprState OF
  
  0: //wait until action and movement are done, also go on if there is an problem in this em
    IF (stprAction=0 & (stprMoving=0 | stsOverride=0) ) | stsInAlarm= 1 THEN
      stprState+= 1;
    ELSE
      runAction();
      runMovement();
    END_IF;
    
  1: //stop moving servo
    IF ctrlServo.stsState=seIdle | ctrlServo.stsState=seWaitReset THEN
      stprState+= 1;
    ELSE
      ctrlServo.csStop();
    END_IF;
    
  2: //power off servo, in this way servo doesn't get an alarm if you switch of the safety system
    IF ctrlServo.stsControllerIsOn= 0 THEN
      stprState:= 1000;
    ELSE
      ctrlServo.csPowerOff();
    END_IF;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emWagon::runAction

  CASE stprAction OF
  
  1: //make choice what to do
    CASE actionLine.actione OF
    
    1: //close clamps
      stprAction:=10;
      
    2: //open clamps
      stprAction:=20;
      
    3: //go up
      stprAction:=30;
      
    4: //go down
      stprAction:=40;
      
    5://Blow valve gripper  
      stprAction:=50;
    ELSE
      stprAction:=0;
      giveAlarm(errorNr:=1);
    END_CASE;

  10: //close clamp
    IF stsPosClamp=cilOut | stsPosClamp=cilNotConnected THEN
      stsGoalPosClamp:=cilOut;
      stprAction:=0;
    ELSIF clampIsConnected= 1 THEN
      ctrlClamp.csMoveOut();
    END_IF;
    
  20: //open clamp, wait until it is allowed
    IF iClampOpenAllowed THEN
      IF stsPosClamp=cilIn | stsPosClamp=cilNotConnected THEN
        stsGoalPosClamp:=cilIn;
        stprAction:=0;
      ELSIF clampIsConnected= 1 THEN
        ctrlClamp.csMoveIn();
      END_IF;
    END_IF;

  30: //send wagon up
    IF livePos > iMinPosWagonUp THEN
      IF stsPosUpDown=cilIn | stsPosUpDown=cilNotConnected THEN
        stprAction:=0;
      ELSIF upDownIsConnected= 1 THEN
        ctrlUpDown.csMoveIn();
      END_IF;
    ELSE
      giveAlarm(errorNr:=7);
    END_IF;
    
  40: //send wagon down
    IF stsPosUpDown=cilOut | stsPosUpDown=cilNotConnected THEN
      stprAction:=0;
    ELSIF upDownIsConnected= 1 THEN
      ctrlUpDown.csMoveOut();
    END_IF;
    
  50://start blower  
    oBlowGripper:=1;
    if TimerBlower.done then //wait for be done
      stprAction:=0;
    end_if;
    
    
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emWagon::runMovement
  
  IF stprMoving > 1 THEN
    updateRearFrontMaterial(); //update both rear and or front of material if required
  END_IF;

  IF stprMoving=5 | stprMoving=7 | stprMoving=10 THEN //if moving to position
    updateSpeed();
  END_IF;

  CASE stprMoving OF
  
  0: //just wait
  
  1: //check command, but before check if servo isn't coupled, this is possible for miter saw (retracting, coupling with clamps)
    IF ctrlServo.stsState<> seWaitCoupling & ctrlServo.stsState<> seStartCoupling & ctrlServo.stsState<> seCoupled & ctrlServo.stsState<> seWaitUnCoupling THEN
      IF moveLine.x1Pos<> FAULTVALUE & moveLine.x1Pos >= ctrlServo.parMinPos & moveLine.x1Pos <= ctrlServo.parMaxPos THEN
        IF moveLine.speed=0 | moveLine.speed= FAULTVALUE THEN
          stsGoalOverride:=100; //if no speed specified, run with 10% of max
        ELSE
          stsGoalOverride:=moveLine.speed;
        END_IF;
        tmpBlowStarted:= 0;
        IF parWagonIsLeader & stsGoalPosClamp = cilOut THEN
          ioRearOfMaterial:=ioRearOfMaterial.Read();
          startRearMaterial:=ioRearOfMaterial;
        END_IF;
        startXposWagon:=livePos;        
        stprMoving+=1;
      ELSE
        giveAlarm(errorNr:=8);
      END_IF;
    END_IF;
    
  2: //check if gripper is empty if action is close gripper
    IF moveLine.actione<> CILDICHT | iFcMatInGripper=0 THEN
      stprMoving+=1;
    ELSE //means actione is to close gripper, but material is already there
      giveAlarm(errorNr:=6);
    END_IF;
    
  3: //wait until movement fits, also control liftingrol
    IF parWagonIsFollower=0 | stsOverride>0 THEN
        stprMoving+=1;

    END_IF;
    
  4: //start movement
    IF ctrlServo.checkInPos(checkPos:=moveLine.x1Pos)<> 1 THEN
      IF liftingRolIsConnected= 0 | (moveLine.actione <> CILDICHT & stsPosClamp <> cilOut) | stsPosLiftingRol = cilOut THEN //if gripper closed, or action to close gripper, send liftingrollers up
        IF pmlCom.sts.inAlarm = 0 THEN //only start movement if we don't have an alarm 
          ctrlServo.csStartMoveAbs(iReqPos:=moveLine.x1Pos, iReqSpeed:=stsOverride);
          stprMoving+=1;
        END_IF;
      ELSIF liftingRolIsConnected= 1 THEN
        ctrlLiftingRol.csMoveOut();
      END_IF;
    ELSE
      stprMoving+=1;
    END_IF;
    
    
  5: //check if we have to close the clamp
    IF moveLine.actione = CILDICHT THEN
      IF timerMatDetected.done=1 | fcMatInGripperIsConnected=0  | pmlCom.cmd.simulation<>noneSimu THEN  
        stprMoving+=2;
      ELSIF ctrlServo.stsState= seIdle THEN //position reached without detecting material, or without being in position
        IF ctrlServo.checkInPos(checkPos:=moveLine.x1Pos)=0 THEN
          stprMoving-=1;
          giveAlarm(errorNr:=3);
        ELSE
          giveAlarm(errorNr:=5);
          ctrlServo.csStartMoveAbs(iReqPos:=startXposWagon, iReqSpeed:=100); //in position and material not picked, try again, so move wagon back
          stprMoving+=1;
        END_IF;
      END_IF;
    ELSE
      stprMoving:=10; //just wait until in position
    END_IF;
    
  6: //wait until alarm is gone, then start again
    IF pmlCom.sts.inAlarm=0 THEN
      stprMoving-=2;
    END_IF;
    
  7: //close clamp
    IF stsPosClamp= cilOut | stsPosClamp= cilNotConnected THEN
      stprMoving:=0;
    ELSIF clampIsConnected= 1 THEN
      ctrlClamp.csMoveOut();
    END_IF;
    
    
  10:  //wait until at position
    IF parWagonIsFollower=1 THEN //if this is a follower wagon, keep updating override, this depends on distance to next wagon/material
      ctrlServo.reqSpeed:=stsOverride;
    END_IF;
    IF blowValveIsConnected=1 & tmpBlowStarted= 0 THEN //only if connected, check if we have to blow
      IF parDirectionBlowing= 1 & livePos<moveLine.x1Pos & livePos > parStartPosBlowing THEN
        tmpBlowStarted:= 1; //only start blowing once
        ctrlBlowValve.cmdBlow:= 1;
      ELSIF parDirectionBlowing= 0 & livePos>moveLine.x1Pos & livePos < parStartPosBlowing THEN
        tmpBlowStarted:= 1;
        ctrlBlowValve.cmdBlow:= 1;
      END_IF;
    END_IF;
    IF ctrlServo.stsState=seIdle & ctrlServo.checkInPos(checkPos:=moveLine.x1Pos)= 1 THEN
      IF clampIsConnected= 1 & parCheckMaterialInGripper= 1 & stsPosClamp= cilOut & pmlCom.cmd.simulation=noneSimu & iFcMatInGripper=0 THEN //if clamp is closed, check after movement if material is still in gripper
        giveAlarm(errorNr:=4); //after alarm we go to Holding, so just stay in this stepper
      ELSE
        IF liftingRolIsConnected= 0 | stsPosLiftingRol= cilIn THEN
          stprMoving:=0; //movement is done, but only if lifting rol is in right position
        ELSE
          ctrlLiftingRol.csMoveIn();
        END_IF;
      END_IF;
    ELSIF ctrlServo.stsState=seIdle THEN
      giveAlarm(errorNr:=3);
      stprMoving:=1; //start movement again, because we go to holding, this will not start before alarm is solved
    END_IF;
        
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL emWagon::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR


  //read in offsets etc
  iOffsetInputPos := iOffsetInputPos.Read();
  iMinPosWagonUp := iMinPosWagonUp.Read();
  CheckForce(); // TP 28-07-2022 added in the background so this method is called always
  
  state:= 0;

END_FUNCTION


FUNCTION VIRTUAL emWagon::execExecute

  runAction();
  runMovement();
  IF stprAction=0 & stprMoving=0 THEN
    stprState:=1000; //only state completed if both are done
  ELSE
    stprState:=1;
  END_IF;

END_FUNCTION


FUNCTION emWagon::calcMaxSpeetToStopInTime
	VAR_INPUT
		actDistance 	: DINT;
	END_VAR
	VAR_OUTPUT
		maxSpeed 	: DINT;
	END_VAR

  VAR
  	relativeSpeed: DINT;
    relativeSquareSpeed: DINT;
    maxDecelInDistance: REAL;
    beforeSqrt: REAL;
  END_VAR

  relativeSpeed:= ctrlServo.stsSpeed - iSpeedNextWagon;
  IF relativeSpeed < parFilterVDifference THEN
    relativeSpeed:=0;
  END_IF;
  
  IF actDistance> 120000 THEN
    actDistance:= 120000;
  END_IF;
  // Vmax^2 = Vstart^2 + 2 * A * S
  relativeSquareSpeed := relativeSpeed*relativeSpeed;
  maxDecelInDistance := 2 * to_real(ctrlServo.parMaxDec) *  to_real(actDistance);
  beforeSqrt := to_real(relativeSquareSpeed) + maxDecelIndistance;
  maxSpeed := to_dint(sqrt(beforeSqrt));


END_FUNCTION


FUNCTION emWagon::updateRearFrontMaterial

  // check if we need to update the rear/front of material
  if stprMoving > 4 & stsGoalPosClamp = cilOut | livePos > ctrlServo.reqPos then //if gripper closed or moving negative
    if parWagonIsLeader=1  then
      // to update rear of material
      if stsGoalPosClamp = cilOut then
        ioRearOfMaterial := startRearMaterial - (startXposWagon - livePos);
        ioRearOfMaterial.Write(input:=ioRearOfMaterial);
      end_if;
    end_if;
    if parWagonIsFollower=1 then
      ioFrontOfMaterial.Write(input:=livePos-iMaterialLength);
    end_if;
  end_if;

END_FUNCTION


FUNCTION emWagon::updateSpeed

  IF parWagonIsFollower=1 THEN //if this is a follower wagon, keep updating override, this depends on distance to next wagon/material
    ctrlServo.reqSpeed:=stsOverride;
  END_IF;
  IF ctrlServo.reqPos < livePos & cmdMaxSpeedNegative < ctrlServo.reqSpeed THEN //if wagon if moving negative, always limit this speed at max given speed (from pressure rol)
    ctrlServo.reqSpeed:= cmdMaxSpeedNegative;
  END_IF;
  
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL emWagon::Ready
	VAR_INPUT
		sLine 	: SRegelInfo;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  IF pmlCom.cmd.state<> Execute & (sLine.Units=0 | (sLine.Units AND includesUnit)>0) THEN //if not in execute, we can't handle sLines, so we also can't be ready
    ok:=0;
  ELSIF pmlCom.sts.allReady | ((sLine.Units AND includesUnit)=0 & sLine.Units>0) THEN
    ok:=1;                       //all ready's are put together, if one unit is under this em, it should be ready
  ELSIF ((sLine.Units AND thisIsUnit)>0) & ((thisIsUnit XOR includesUnit) AND sLine.Units)=0 THEN //if only this unit is asked //JdK 4-11-2019 brackets changed from position to get right value
    IF stprAction=0 & stprMoving=0 THEN
      ok:=1;
    ELSIF stprAction=0 & sLine.actione<>1 & sLine.x1Pos<>0 & sLine.x1Pos<>FAULTVALUE THEN
      IF startXposWagon <= moveLine.x1Pos THEN //moving forward
        IF sLine.x1Pos < moveLine.x1Pos & sLine.x1Pos > startXposWagon & livePos > sLine.x1Pos THEN //asked value is between start and endpos, and wagon is above this value
          ok:= 1;
        ELSE
          ok:= 0;
        END_IF;
      ELSE //if not moving forward, we are moving backwards
        IF sLine.x1Pos > moveLine.x1Pos & sLine.x1Pos < startXposWagon & livePos < sLine.x1Pos THEN //asked value is between start and endpos, and wagon is under this value
          ok:= 1;
        END_IF;
      END_IF;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:=readySpecial(sLine:=sLine);
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emWagon::preScanOverride

  //read in servers
  iFcMatInGripper := iFcMatInGripper.Read();
  iSpeedNextWagon := iSpeedNextWagon.Read();
  iMaterialLength := iMaterialLength.Read();
  ioFrontOfMaterial := ioFrontOfMaterial.Read();
  ioRearOfMaterial := ioRearOfMaterial.Read();
  iClampOpenAllowed := iClampOpenAllowed.Read();
  iMaxForce:= iMaxForce.Read();
  oBlowGripper:=0;// write null every cylus
 
  //get positions of cilinders
  IF clampIsConnected=1 THEN
    stsPosClamp:=ctrlClamp.stsPos;
  ELSE
    stsPosClamp:=cilNotConnected;
  END_IF;
  IF upDownIsConnected=1 THEN
    stsPosUpDown:=ctrlUpDown.stsPos;
  ELSE
    stsPosUpDown:=cilNotConnected;
  END_IF;
  IF liftingRolIsConnected=1 THEN
    stsPosLiftingRol:=ctrlLiftingRol.stsPos;
  ELSE
    stsPosLiftingRol:=cilNotConnected;
  END_IF;

  //get livepos
  livePos:=ctrlServo.stsPos;

  //run timers
  timerMatDetected:=runTimer(Active:=iFcMatInGripper=1, iMem:=timerMatDetected, TimerTime:=parDelayMatInGripper, Pause:=FALSE);
  TimerBlower:=runTimer(Active:=stprAction=50, iMem:=TimerBlower, TimerTime:=ParBlowerGripper, Pause:=FALSE);
  
  IF parWagonIsFollower=1 & moveLine.x1Pos<livePos THEN //if wagon is follower and if moving negative, check distance
    actDistanceToPrevMat:=ioFrontOfMaterial-ioRearOfMaterial;
    maxSpeedToStopInTime:=calcMaxSpeetToStopInTime(actDistance:=actDistanceToPrevMat-parDistanceBetweenWagons);
    IF maxSpeedToStopInTime = 0 THEN
      stsMaxOverride:=0;
    ELSE
      stsMaxOverride:=maxSpeedToStopInTime*1000/ctrlServo.parMaxSpeed; //recalculate max speed to override
    END_IF;
    IF stsGoalOverride > stsMaxOverride THEN
      stsOverride:=stsMaxOverride;
    ELSE
      stsOverride:=stsGoalOverride;
    END_IF;
  ELSE
    stsOverride:=stsGoalOverride;
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL emWagon::postScanOverride

  //set sts wagon safe for loading
  stsWagonSafeForLoading:= stsPosUpDown=cilIn | livePos>iMaterialLength+iOffsetInputPos;

  //JdK 15-8-2022 should be done automaticly IF _Alarm.ErrorNr>0 & pmlCom.cmd.state=Execute THEN //alarm in this em means, go to held
  //  pmlCom.sts.stateReq.ID:=id; //for this alarm, go to hold, doesn't solve itself
  //  pmlCom.sts.stateReq.state:=Holding;
  //END_IF;
  
  //write outputs
  oBlowGripper.Write(input:=oBlowGripper);
  oTorqueControl.Write (oTorqueControl);

END_FUNCTION


FUNCTION emWagon::checkForce

  IF iMaxForce > 0 & ctrlServo.stsPos >= ctrlServo.reqPos  THEN
    oTorqueControl:=To_udint(iMaxForce);
  ELSE
    oTorqueControl:=1000;//if zero just set max
  END_IF;

END_FUNCTION
