//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emBase"
	Revision           = "1.0"
	GUID               = "{28A293E2-931F-4D38-AE8B-40BD7E3F262A}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(750,1200)">
	<Channels>
		<Server Name="cmdWaitReset" GUID="{65A2D5CD-6734-4042-89EA-2C7EBF0678EE}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="includesUnit" GUID="{24500D87-F55D-4AF0-B8E5-C2F8B0CF5E75}" Visualized="false" Initialize="true" WriteProtected="true" Retentive="false"/>
		<Server Name="stprAction" GUID="{18FEF983-6F70-468F-8363-ED7C69FB0F73}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprMoving" GUID="{FF530D28-1AE9-4697-899C-D74A091E652F}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprState" GUID="{1182661C-83F9-43C2-997E-4DE07B8F378C}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsStateCompleted" GUID="{B0851315-DB76-4A27-8BE4-017D1FF1A8F0}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="thisIsUnit" GUID="{5E690A7B-1237-4C2F-B58E-FB6E38524441}" Visualized="false" Initialize="true" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
			<SepChn Position="7"/>
			<SepChn Position="5"/>
		</Servers>
	</Separators>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="0.2" Date="2019-11-05" Description="made it possible to change to holding/suspending from cm"/>
		<Dokumentation Revision="0.1" Date="2019-10-24" Author="RvdL" Description="added cmdWaitReset, command to use if reset can&apos;t be done directly"/>
	</RevDoku>
	<Network Name="emBase">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{20958F90-4A77-4659-80AB-E914C8759617}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

emBase : CLASS
: cmBase
  //Servers:
	stprAction 	: SvrCh_DINT;
	stprMoving 	: SvrCh_DINT;
	stprState 	: SvrCh_DINT;
	stsStateCompleted 	: SvrCh_DINT;
	cmdWaitReset 	: SvrCh_DINT;
	thisIsUnit 	: SvrCh_Units;
	includesUnit 	: SvrCh_Units;
  //Clients:
  //Variables:
		emList : ARRAY [0..defMaxEmsInEm] OF ^strPmlCom;

		cntrEmList 	: DINT;
		cmList : ARRAY [0..defMaxCmsInEm] OF ^strPmlCom;

		cntrCmList 	: DINT;
		tmpStateComplete 	: DINT;
		actionLine 	: SRegelInfo;
		moveLine 	: SRegelInfo;
		tmpUnit 	: Units;
		oldState 	: eStatePML;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL sendCommandsDown;
	
	FUNCTION VIRTUAL collectStatusUp;
	
	FUNCTION VIRTUAL stateControl;
	
	FUNCTION GLOBAL connectPtr
		VAR_INPUT
			ptr 	: ^strPmlCom;
			isEm 	: DINT;
		END_VAR
		VAR_OUTPUT
			done 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL execStopped;
	
	FUNCTION VIRTUAL execResetting;
	
	FUNCTION VIRTUAL execIdle;
	
	FUNCTION VIRTUAL execStarting;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION VIRTUAL execCompleting;
	
	FUNCTION VIRTUAL execComplete;
	
	FUNCTION VIRTUAL execHolding;
	
	FUNCTION VIRTUAL execHeld;
	
	FUNCTION VIRTUAL execUnHolding;
	
	FUNCTION VIRTUAL execAborting;
	
	FUNCTION VIRTUAL execAborted;
	
	FUNCTION VIRTUAL execClearing;
	
	FUNCTION VIRTUAL execStopping;
	
	FUNCTION VIRTUAL execSuspending;
	
	FUNCTION VIRTUAL execSuspended;
	
	FUNCTION VIRTUAL execUnSuspending;
	
	FUNCTION standardState;
	
	FUNCTION GLOBAL Start
		VAR_INPUT
			sLine 	: SRegelInfo;
		END_VAR
		VAR_OUTPUT
			okUnits 	: Units;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Ready
		VAR_INPUT
			sLine 	: SRegelInfo;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL startOtherUnits
		VAR_INPUT
			sLine 	: SRegelInfo;
		END_VAR
		VAR_OUTPUT
			okUnits 	: Units;
		END_VAR;
	
	FUNCTION VIRTUAL readySpecial
		VAR_INPUT
			sLine 	: SRegelInfo;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL storeChange;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMBASE
1$UINT, 0$UINT, (SIZEOF(::emBase))$UINT, 
7$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2572249677), "emBase", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emBase.stprAction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2039325864), "stprAction", 
(::emBase.stprMoving.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(24234172), "stprMoving", 
(::emBase.stprState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2362192700), "stprState", 
(::emBase.stsStateCompleted.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1119232075), "stsStateCompleted", 
(::emBase.cmdWaitReset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1657163322), "cmdWaitReset", 
(::emBase.thisIsUnit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2388530675), "thisIsUnit", 
(::emBase.includesUnit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1506052512), "includesUnit", 
//Clients:
END_FUNCTION


#define USER_CNT_emBase 40

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emBase;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #sendCommandsDown();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #collectStatusUp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #stateControl();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #execStopped();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #execResetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #execIdle();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #execStarting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #execCompleting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #execComplete();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #execHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #execHeld();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #execUnHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #execAborting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[30]		:= #execAborted();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[31]		:= #execClearing();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #execStopping();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #execSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #execSuspended();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #execUnSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[36]		:= #Ready();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[37]		:= #startOtherUnits();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[38]		:= #readySpecial();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[39]		:= #storeChange();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprAction.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprAction.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprMoving.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprMoving.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprState.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	cmdWaitReset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF cmdWaitReset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 5-11-2019: made it possible to change state to holding/suspending for cm
// RvdL 24-10-2019: added cmdWaitReset, because we need more control about order of resetting
// JdK 23-5-2019: class emBase created for MPS library and project Traffiroad 4284
// goal is to handle all basethings of a equipment module
// em is based on PackML principle, pointer to communication is given to layer above (other em or unit) 
// cs communication is given to em's and cm's downwards, sts communication is assembled and given upwards
// choosen base is cmBase, because this one has everything we need, only difference is, the em can send commands down, and has to gather status information

FUNCTION VIRTUAL emBase::sendCommandsDown

  //send all commands to underlaying em's
  FOR i:=0 TO cntrEmList-1 DO
    IF emList[i]^.Active THEN
      emList[i]^.cmd.interlock:=pmlCom.sts.isInterlocked;
      IF tmpModeChange THEN //only send new mode if mode changed
        IF pmlCom.sts.mode = halfAuto THEN
          emList[i]^.cmd.mode:= auto; //half auto means software below should be in auto
        ELSE
          emList[i]^.cmd.mode:= pmlCom.sts.mode; //else just send actual mode
        END_IF;
      END_IF;
      emList[i]^.cmd.state:=pmlCom.cmd.state;
      emList[i]^.cmd.simulation:=pmlCom.cmd.simulation;
      emList[i]^.cmd.resetAlarms:=pmlCom.cmd.resetAlarms|tmpResetAlarms; //send both cmd and HMI value
      emList[i]^.cmd.reRun:=pmlCom.cmd.reRun; //set rerun bit, means no new start, but restart in old situation, only relevant in resetting and starting
    END_IF;
  END_FOR;

  //send all commands to underlaying cm's
  FOR i:=0 TO cntrCmList-1 DO
    IF cmList[i]^.Active THEN
      cmList[i]^.cmd.interlock:=pmlCom.sts.isInterlocked;
      IF tmpModeChange THEN //only send new mode if mode changed
        IF pmlCom.sts.mode = halfAuto THEN
          cmList[i]^.cmd.mode:= auto; //half auto means software below should be in auto
        ELSE
          cmList[i]^.cmd.mode:= pmlCom.sts.mode; //else just send actual mode
        END_IF;
      END_IF;
      cmList[i]^.cmd.state:=pmlCom.cmd.state;
      cmList[i]^.cmd.simulation:=pmlCom.cmd.simulation;
      cmList[i]^.cmd.resetAlarms:=pmlCom.cmd.resetAlarms|tmpResetAlarms; //send both cmd and HMI value
    END_IF;
  END_FOR;

  //handle changed state
  IF oldState<>pmlCom.cmd.state THEN
    stprState:=0; //before any action, set stpr state to 0, every state has to start at 0
    storeChange();
    oldState:=pmlCom.cmd.state;
  END_IF;  

END_FUNCTION


FUNCTION GLOBAL emBase::connectPtr
	VAR_INPUT
		ptr 	: ^strPmlCom;
		isEm 	: DINT;
	END_VAR
	VAR_OUTPUT
		done 	: DINT;
	END_VAR

  //set pointer in list of em's/cm's this module should control
  done:=0; //always say false, except when pointer is added
  //if still space in list, add pointer to list
  IF isEm THEN //add to em list
    IF cntrEmList <= DEFMAXEMSINEM THEN
      emList[cntrEmList]:=ptr;
      cntrEmList+=1;
      done:=1;
    END_IF;
  ELSE //add to cm list
    IF cntrCmList <= DEFMAXCMSINEM THEN
      cmList[cntrCmList]:=ptr;
      cntrCmList+=1;
      done:=1;
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emBase::stateControl

//state control just handles that the right method is done in the right place
//every wait state gives state complete = 0 (wait method is only possible to come out if there is a command)
//every acting state give state complete = 1 als stepper = 1000 (are states that are done if task is done)


  tmpStateComplete:=0;//on start just make this one 0, if necessary, it will be changed
  
  CASE pmlCom.cmd.state OF
  
    Stopped:
      execStopped();
    
    Resetting:
      execResetting();
      tmpStateComplete:=stprState=1000;
      
    Idle:
      execIdle();

    Starting:
      execStarting();
      tmpStateComplete:=stprState=1000;
      
    Execute:
      execExecute();
      tmpStateComplete:=stprState=1000;
      
    Completing:
      execCompleting();
      tmpStateComplete:=stprState=1000;
      
    Complete:
      execComplete();
    
    Holding:
      execHolding();
      tmpStateComplete:=stprState=1000;
      
    Held:
      execHeld();
    
    UnHolding:
      execUnHolding();
      tmpStateComplete:=stprState=1000;
      
    Aborting:
      execAborting();
      tmpStateComplete:=stprState=1000;
      
    Aborted:
      execAborted();
    
    Clearing:
      execClearing();
      tmpStateComplete:=stprState=1000;
    
    Stopping:
      execStopping();
      tmpStateComplete:=stprState=1000;
      
    Suspending:
      execSuspending();
      tmpStateComplete:=stprState=1000;
      
    Suspended:
      execSuspended();
    
    UnSuspending:
      execUnSuspending();
      tmpStateComplete:=stprState=1000;
  
  
  END_CASE;


  

END_FUNCTION


FUNCTION VIRTUAL emBase::collectStatusUp

  //set allReady to required value, reset if one of underlaying em's isn't ready
  pmlCom.sts.allReady:=stprAction=0 & stprMoving=0;
  
  //set state completed
  pmlCom.sts.stateCompleted:=tmpStateComplete;
  
  //set also unit readys
  IF stprMoving= 0 THEN
    pmlCom.sts.moveReady:=thisIsUnit;
  ELSE
    pmlCom.sts.moveReady:=0;
  END_IF;
  IF stprAction= 0 THEN
    pmlCom.sts.actionReady:=thisIsUnit;
  ELSE
    pmlCom.sts.actionReady:=0;
  END_IF;

  //before reading in all info, check if this em needs another state
  IF pmlCom.sts.stateReq.state<> tmpReqState & pmlCom.sts.stateReq.state<> Stopped THEN
    tmpReqState:=pmlCom.sts.stateReq.state;
  END_IF;


  //get all information from connected em's
  FOR i:=0 TO cntrEmList-1 DO
    IF emList[i]^.Active THEN
      IF emList[i]^.sts.inAlarm THEN
        pmlCom.sts.inAlarm:=1;
      END_IF;
      IF tmpReqState=Stopped & emList[i]^.sts.stateReq.state>Stopped THEN //only send first state that was presented up
        tmpReqState:= emList[i]^.sts.stateReq.state;
        pmlCom.sts.stateReq:= emList[i]^.sts.stateReq;
      END_IF;
      IF emList[i]^.sts.stateCompleted=0 | emList[i]^.sts.state<>pmlCom.cmd.state THEN
        pmlCom.sts.stateCompleted:=0;
      END_IF;
      IF emList[i]^.sts.modesNotEqual | (emList[i]^.sts.mode <> pmlCom.sts.mode & (pmlCom.sts.mode <> halfAuto | emList[i]^.sts.mode <> auto)) | 
                                                                                        (pmlCom.sts.mode= halfAuto & emList[i]^.sts.mode<> auto) THEN
        pmlCom.sts.modesNotEqual:=1;
      END_IF;
      IF emList[i]^.sts.allReady=0 THEN
        pmlCom.sts.allReady:=0;
      END_IF;
      pmlCom.sts.actionReady:= pmlCom.sts.actionReady OR emList[i]^.sts.actionReady; //calculate with bits is a problem if one bit is set in both
      pmlCom.sts.moveReady:= pmlCom.sts.actionReady OR emList[i]^.sts.moveReady;
    END_IF;
  END_FOR;  

  //get all information from connected cm's, they are not allowed to change states, only to holding/suspending, ignore other required states
  FOR i:=0 TO cntrcmList-1 DO
    IF cmList[i]^.Active THEN
      IF cmList[i]^.sts.inAlarm THEN
        pmlCom.sts.inAlarm:=1;
      END_IF;
      IF tmpReqState=Stopped & (cmList[i]^.sts.stateReq.state=Holding | cmList[i]^.sts.stateReq.state=Suspending)  THEN //only send first state that was presented up, for cm only to holding/suspending
        tmpReqState:= cmList[i]^.sts.stateReq.state;
        pmlCom.sts.stateReq:= cmList[i]^.sts.stateReq;
        cmList[i]^.sts.stateReq.state:= Stopped;
      END_IF;      
      IF cmList[i]^.sts.modesNotEqual | (cmList[i]^.sts.mode <> pmlCom.sts.mode & (pmlCom.sts.mode <> halfAuto | cmList[i]^.sts.mode <> auto)) | 
                                                                                        (pmlCom.sts.mode= halfAuto & cmList[i]^.sts.mode<> auto) THEN
        pmlCom.sts.modesNotEqual:=1;
      END_IF;
    END_IF;
  END_FOR; 

  //write state complete
  stsStateCompleted:=pmlCom.sts.stateCompleted;

//  //set tmp's to 0, we only want to change once 
  IF oldTmpReqState=tmpReqState THEN
    tmpReqState:=Stopped;
    pmlCom.sts.stateReq.state:=Stopped;
  ELSE
    oldTmpReqState:=tmpReqState;
  END_IF;

  //only after everything is finisched change sts.state, so before state completed is given, all code is done at least once
  pmlCom.sts.state:= pmlCom.cmd.state;

END_FUNCTION


FUNCTION VIRTUAL emBase::execStopped

  //if other action required then go direct to ready, derive it
  standardState();

END_FUNCTION


FUNCTION VIRTUAL emBase::execResetting

  //if other action required then go direct to ready, derive it
  IF pmlCom.cmd.reRun=0 THEN //means don't start again, but restart running
    stprAction:=0;
    stprMoving:=0;
  END_IF;
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execIdle

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execStarting

  //if other action required then go direct to ready, derive it
  IF pmlCom.cmd.reRun=0 THEN //means don't start again, but restart running
    stprAction:=0;
    stprMoving:=0;
  END_IF;
  standardState();
  
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execExecute

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execCompleting

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execComplete

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execHolding

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execHeld

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execUnHolding

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execAborting

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execAborted

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execClearing

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execStopping

  //if other action required then go direct to ready, derive it
  stprAction:=0; //standard, just stop running actions
  stprMoving:=0;
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execSuspending

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execSuspended

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION VIRTUAL emBase::execUnSuspending

  //if other action required then go direct to ready, derive it
  standardState();
  
END_FUNCTION


FUNCTION emBase::standardState

//standard acting state, go direct to ready

  CASE stprState OF

    0,1,2,3,4: //only once isn't always enough to switch state to all em's
      stprState+=1;
    
    5:
      stprState:=1000;
      
    1000: //ready
    
    else
      stprState:=0;

  END_CASE;
  
END_FUNCTION


FUNCTION GLOBAL emBase::Start
	VAR_INPUT
		sLine 	: SRegelInfo;
	END_VAR
	VAR_OUTPUT
		okUnits 	: Units;
	END_VAR

  //if unit is in this em or in underlaying em
  IF (sLine.Units AND includesUnit)>0 THEN 
    okUnits:=startOtherUnits(sLine:=sLine);
  ELSE
    okUnits:=0; //unit not available
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL emBase::Ready
	VAR_INPUT
		sLine 	: SRegelInfo;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  IF pmlCom.cmd.state<> Execute & (sLine.Units=0 | (sLine.Units AND includesUnit)>0) THEN //if not in execute, we can't handle sLines, so we also can't be ready
    ok:=0;
  ELSIF pmlCom.sts.allReady | ((sLine.Units AND includesUnit)=0 & sLine.Units>0) THEN
    ok:=1;                       //all ready's are put together, if one unit is under this em, it should be ready
  ELSIF (sLine.Units AND thisIsUnit) & ((thisIsUnit XOR includesUnit) AND sLine.Units=0) & stprAction=0 & stprMoving=0 THEN //if only this unit is asked
    ok:=1;
  ELSE
    ok:=readySpecial(sLine:=sLine);
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emBase::startOtherUnits
	VAR_INPUT
		sLine 	: SRegelInfo;
	END_VAR
	VAR_OUTPUT
		okUnits 	: Units;
	END_VAR

  //should be derived for every em wich has other em's connected
  
  //standard start action, do storage for rule
  IF sLine.Units AND thisIsUnit THEN //only if command is for one of those units
    IF (sLine.Command=UNITSTARTCOM & stprAction=0) THEN
      stprAction:=1;
      actionLine:=sLine;
      okUnits:=thisIsUnit; //give unit back if starting is ok
    ELSIF (sLine.Command=UNITMOVECOM & stprMoving=0) THEN
      stprMoving:=1;
      moveLine:=sLine;
      okUnits:=thisIsUnit;
    ELSIF sLine.Command=UNITSTARTCOM | sLine.Command=UNITMOVECOM THEN
      okUnits:=0;
    ELSE
      okUnits:=0;
    END_IF;
  ELSE
    okUnits:=0;
  END_IF;  
  
END_FUNCTION


FUNCTION VIRTUAL emBase::readySpecial
	VAR_INPUT
		sLine 	: SRegelInfo;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  //if other version of ready then action and moving cntrs are 0 is required in one of the undelaying em's, then do something special here
  ok:=0;

  
END_FUNCTION


FUNCTION VIRTUAL emBase::storeChange
//changes are only stored in unit, but unit derives from here
END_FUNCTION


FUNCTION VIRTUAL GLOBAL emBase::Init

  //on init tell software above you are alive, and give pointer to communication  
  IF pmlCom.Active=0 THEN //only if connection isn't working
    
    IF IsClientConnected(#nwEmOrUnit) THEN
      pmlCom.Active:=nwEmOrUnit.connectPtr(ptr:=#pmlCom, isEm:=1);
    END_IF;
    id:=id.Read();
   
  END_IF;
  Init1();
  
END_FUNCTION
