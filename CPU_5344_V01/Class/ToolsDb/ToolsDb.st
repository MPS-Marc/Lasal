//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "ToolsDb"
	Revision           = "0.0"
	GUID               = "{6CC70550-9577-4385-8701-0610960CA1C1}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(600,1500)">
	<Channels>
		<Server Name="diameter" GUID="{37328B4C-A3F9-475F-B2C9-067E6EBBC7C3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiDeleteRecipe" GUID="{A2F5E432-3E65-4EB0-B189-753794FC2578}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiFileNrRecipe" GUID="{296DD85F-9F41-4DB2-B296-67DCC6EEF1BB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiLoadRecipeFromUsb" GUID="{1C66C64F-678B-4191-A4BE-8CE67F9204C4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiReloadRecipe" GUID="{86602430-65E9-4D07-A6B3-70C1FB752CE3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiSaveRecipe" GUID="{D33B756E-B521-45AD-AE60-35D7B2217EF2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HmiSaveRecipeToUsb" GUID="{F9773D0D-D321-4AF8-9529-A0D6AD8EE3E2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Id_" GUID="{2EEB34C6-301F-4885-B10C-07382F628362}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="length" GUID="{AED7EC79-C853-49E5-9E33-0299F3C32C9C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="RecipeId" GUID="{B6DE16A0-8F5D-4B48-8C37-9483BDA86755}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="reserve1" GUID="{81760294-A5A6-46F7-8D41-4AF25BA20B50}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reserve2" GUID="{CBCC498A-76BA-47A9-9434-30F1D1B31705}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reserve3" GUID="{D94D613C-01B7-4C1D-A3D4-54E1A667F048}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reserve4" GUID="{3D31E0A8-1FE1-49DC-A12A-CCA03AF4BE67}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sparAutoSave" GUID="{33652164-84DC-4CFF-AA82-45B709977374}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false"/>
		<Server Name="speedRPM" GUID="{8828B11E-FADC-451D-9B9C-B636E67FEBF2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="strDescription" GUID="{8AAE049E-0F2F-4586-8545-64EEE0C81FCF}" Class="EditString" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="strReserveText" GUID="{FAA41866-0825-4459-A022-4BC9DCCE61AB}" Class="EditString" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="use this channel to access the string functions"/>
		<Server Name="stsUnsafeChanges" GUID="{938EF93D-C1C5-465C-A271-87A5685C77AA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="FB" Required="true" Internal="false"/>
		<Client Name="FileSys" Required="false" Internal="false"/>
		<Client Name="RamEx" Required="true" Internal="false"/>
		<Client Name="str_Description" Required="true" Internal="true"/>
		<Client Name="str_ReserveText" Required="true" Internal="true"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="11"/>
		</Servers>
		<Clients>
			<SepChn Position="1"/>
		</Clients>
	</Separators>
	<Network Name="ToolsDb">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{5723E783-F586-4644-BE19-0E8FBAB0E7BA}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name       = "str_Description"
				GUID       = "{AE107C8F-9AA5-4443-AE8D-D4093977B1E2}"
				Class      = "EditString"
				Position   = "(660,810)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="Handle"/>
					<Server Name="NewData"/>
				</Channels>
			</Object>
			<Object
				Name       = "str_ReserveText"
				GUID       = "{AED61715-D1AD-48E0-80FC-0A8D9E170610}"
				Class      = "EditString"
				Position   = "(660,1080)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Server Name="Handle"/>
					<Server Name="NewData"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1148,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1148,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1148,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1148,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1148,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1148,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1148,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1148,630),(864,690),"/>
			<Connection Source="this.str_ReserveText" Destination="str_ReserveText.Data"/>
			<Connection Source="this.str_Description" Destination="str_Description.Data"/>
			<Connection Source="this.strReserveText" Destination="str_ReserveText.Data" Vertices="(1148,810),(976,1170),"/>
			<Connection Source="this.strDescription" Destination="str_Description.Data" Vertices="(1148,750),(976,900),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

ToolsDb : CLASS
: cmBase
	TYPE
	  str_100 : ARRAY [0..225] OF CHAR;
	  str_3000 : ARRAY [0..3000] OF CHAR;
#pragma pack(push, 1)
	  tBewerkingsRegel : STRUCT  //! <Type Public="true" Name="tBewerkingsRegel"/>
	    Bewerking : Units;
	  END_STRUCT;
#pragma pack(pop)
	  tRecipeData : strToolRecipe;  //! <Type Public="true" Name="tRecipeData"/>
	END_TYPE
  //Servers:
	RecipeId 	: SvrCh_UDINT;
	strDescription 	: SvrChCmd_UDINT;
	strReserveText 	: SvrChCmd_UDINT;
	Id_ 	: SvrCh_DINT;
	diameter 	: SvrCh_DINT;
	length 	: SvrCh_DINT;
	speedRPM 	: SvrCh_DINT;
	reserve1 	: SvrCh_DINT;
	reserve2 	: SvrCh_DINT;
	reserve3 	: SvrCh_DINT;
	reserve4 	: SvrCh_DINT;
	HmiSaveRecipe 	: SvrCh_DINT;
	HmiReloadRecipe 	: SvrCh_DINT;
	HmiDeleteRecipe 	: SvrCh_DINT;
	HmiSaveRecipeToUsb 	: SvrCh_DINT;
	HmiLoadRecipeFromUsb 	: SvrCh_DINT;
	HmiFileNrRecipe 	: SvrCh_DINT;
	stsUnsafeChanges 	: SvrCh_DINT;
	sparAutoSave 	: SvrCh_DINT;
  //Clients:
	RamEx 	: CltChCmd_RAMex;
	FileSys 	: CltChCmd__FileSys;
	FB 	: CltChCmd_FileBase;
	str_Description 	: CltChCmd_EditString;
	str_ReserveText 	: CltChCmd_EditString;
  //Variables:
		ActRecipeData 	: tRecipeData;
		tempRecipe 	: tRecipeData;
		sizeRecipedata 	: UDINT;
		emptyRecipe 	: tRecipeData;
		tmpText 	: tekst;
		dbAmountOfRecipes 	: UDINT;
		dbAmountOfLinesInRecipe 	: UDINT;
		checkForStorageProductData 	: tRecipeData;
		tmrAutoSave 	: UDINT;
		tmpNrDelete 	: UDINT;
		tmpInputNr 	: UDINT;
		stsRamResult 	: UINT;
		sswSaveUsb 	: DINT;
		checkDisk : ARRAY [0..20] OF CHAR;

		tmpString : ARRAY [0..500] OF CHAR;

		strName : ARRAY [0..100] OF CHAR;

		tmpNrUsbStored 	: DINT;
		tmpRecipeNrUsb 	: DINT;
		tmpRecipeUsb 	: tRecipeData;
		actStrLen 	: DINT;
		usbLineNr 	: DINT;
		sswLoadUsb 	: DINT;
		fileHandle 	: DINT;
		fileToLoadNotFound 	: DINT;
		buffer : ARRAY [0..3000] OF CHAR;

		actBufferLength 	: DINT;
		offsetBuffer 	: DINT;
		tmpString2 : ARRAY [0..20] OF CHAR;

		FileInfo 	: _DDE_INFO;
		cntrUsb 	: DINT;
		cntrTje 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION GLOBAL GetRecipe
		VAR_INPUT
			id 	: DINT;
		END_VAR
		VAR_OUTPUT
			oRecipe 	: strToolRecipe;
		END_VAR;
	
	FUNCTION UpdateServers;
	
	FUNCTION saveRecipe
		VAR_INPUT
			nr 	: UDINT;
			recipe 	: strToolRecipe;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION loadRecipe
		VAR_INPUT
			nr 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION saveChanges
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION saveToUsb;
	
	FUNCTION loadFromUsb;
	
	FUNCTION VIRTUAL GLOBAL RecipeId::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strDescription::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strReserveText::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL strReserveText::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Id_::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL diameter::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL length::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL speedRPM::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reserve1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reserve2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reserve3::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reserve4::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiSaveRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiReloadRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiDeleteRecipe::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiSaveRecipeToUsb::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HmiLoadRecipeFromUsb::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL stsUnsafeChanges::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using EditString
#pragma usingLtd _FileSys
#pragma usingLtd FileBase
#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ToolsDb::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_TOOLSDB
0$UINT, 0$UINT, (SIZEOF(::ToolsDb))$UINT, 
19$UINT, 5$UINT, 0$UINT, 
TO_UDINT(3718559786), "ToolsDb", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::ToolsDb.RecipeId.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1433076410), "RecipeId", 
(::ToolsDb.strDescription.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(415395287), "strDescription", 
(::ToolsDb.strReserveText.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(865421036), "strReserveText", 
(::ToolsDb.Id_.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4023101753), "Id_", 
(::ToolsDb.diameter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2987770654), "diameter", 
(::ToolsDb.length.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4052048180), "length", 
(::ToolsDb.speedRPM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2604719056), "speedRPM", 
(::ToolsDb.reserve1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2885612093), "reserve1", 
(::ToolsDb.reserve2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(855090055), "reserve2", 
(::ToolsDb.reserve3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1173394193), "reserve3", 
(::ToolsDb.reserve4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3683911346), "reserve4", 
(::ToolsDb.HmiSaveRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1848756402), "HmiSaveRecipe", 
(::ToolsDb.HmiReloadRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(583644729), "HmiReloadRecipe", 
(::ToolsDb.HmiDeleteRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3337502784), "HmiDeleteRecipe", 
(::ToolsDb.HmiSaveRecipeToUsb.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2900115486), "HmiSaveRecipeToUsb", 
(::ToolsDb.HmiLoadRecipeFromUsb.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2513126847), "HmiLoadRecipeFromUsb", 
(::ToolsDb.HmiFileNrRecipe.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1875755963), "HmiFileNrRecipe", 
(::ToolsDb.stsUnsafeChanges.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1099579582), "stsUnsafeChanges", 
(::ToolsDb.sparAutoSave.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4270006197), "sparAutoSave", 
//Clients:
(::ToolsDb.RamEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(933570811), "RamEx", TO_UDINT(933570811), "RAMex", 1$UINT, 17$UINT, 
(::ToolsDb.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::ToolsDb.FB.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2133383872), "FB", TO_UDINT(1689253198), "FileBase", 0$UINT, 5$UINT, 
(::ToolsDb.str_Description.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3670666575), "str_Description", TO_UDINT(648754807), "EditString", 0$UINT, 0$UINT, 
(::ToolsDb.str_ReserveText.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4053714548), "str_ReserveText", TO_UDINT(648754807), "EditString", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_ToolsDb 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ToolsDb] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ToolsDb::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ToolsDb;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RecipeId.pMeth			:= StoreMethod( #M_RD_DIRECT(), #RecipeId::Write() );
	IF RecipeId.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, strDescription.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #strDescription::Read();
	vmt.CmdTable.Write		:= #strDescription::Write();
	strDescription.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF strDescription.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, strReserveText.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #strReserveText::Read();
	vmt.CmdTable.Write		:= #strReserveText::Write();
	strReserveText.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF strReserveText.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Id_.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Id_::Write() );
	IF Id_.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	diameter.pMeth			:= StoreMethod( #M_RD_DIRECT(), #diameter::Write() );
	IF diameter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	length.pMeth			:= StoreMethod( #M_RD_DIRECT(), #length::Write() );
	IF length.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	speedRPM.pMeth			:= StoreMethod( #M_RD_DIRECT(), #speedRPM::Write() );
	IF speedRPM.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reserve1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reserve1::Write() );
	IF reserve1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reserve2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reserve2::Write() );
	IF reserve2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reserve3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reserve3::Write() );
	IF reserve3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reserve4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reserve4::Write() );
	IF reserve4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiSaveRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiSaveRecipe::Write() );
	IF HmiSaveRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiReloadRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiReloadRecipe::Write() );
	IF HmiReloadRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiDeleteRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiDeleteRecipe::Write() );
	IF HmiDeleteRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiSaveRecipeToUsb.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiSaveRecipeToUsb::Write() );
	IF HmiSaveRecipeToUsb.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiLoadRecipeFromUsb.pMeth			:= StoreMethod( #M_RD_DIRECT(), #HmiLoadRecipeFromUsb::Write() );
	IF HmiLoadRecipeFromUsb.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HmiFileNrRecipe.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF HmiFileNrRecipe.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsUnsafeChanges.pMeth			:= StoreMethod( #stsUnsafeChanges::Read(), #M_NO_F() );
	IF stsUnsafeChanges.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sparAutoSave.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sparAutoSave.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 12-10-2020 profile db v2 changed to toolsDb
// JdK 8-1-2020 profiles db v2, created from productsDBV2
// JdK 29-11-2019 productsDBV2 created to handle 'recipes' like products, assembly's etc.
// functions like autosave, save, save as, reload (undo changes) are available
// storage to usb and load from usb are not yet functional, will be added later

// 
//ErrorNr 1 no file present
//ErrorNr 2 USB not present
//ErrorNr 3 cannot open file
//ErrorNr 4 error reading file
//ErrorNr 5 wrong format
//ErrorNr 6 too many lines
//ErrorNr 7 too little chars in data string

FUNCTION VIRTUAL ToolsDb::Init1

  IF initDone= 0 THEN
  
    dbAmountOfRecipes:= cProfileDbMaxProgs; //read in amounts
//    dbAmountOfLinesInRecipe:= CPRODDBMAXOPERATIONLINES;
    sizeRecipedata := to_udint(sizeof(tRecipeData)); //put size of product data in var
    _memset(dest:=#emptyRecipe, usByte:=0, cntr:=sizeRecipedata); //set empty product
    
    IF RamEx.GetSize() <> (sizeRecipedata*dbAmountOfRecipes) THEN //check if ram size isn't set yet
      IF RamEx.SetSize(udsize:= (sizeRecipedata*dbAmountOfRecipes)) = C_OK THEN //only if setting is done, say init is done
        initDone:= 1;
        
        loadRecipe(nr:=RecipeId); //after setting size of db try to load the recipe

      END_IF;
    ELSE
      initDone:= 1;
      loadRecipe(nr:=RecipeId); //also if size is ok, load recipe
    END_IF;
    
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
  //check if we need to update the strings
  if str_Description.NewData.Read() <> 0 then//description
    _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
    str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
    str_Description.NewData.Write(input:=0);
  end_if;

  if str_ReserveText.NewData.Read() <> 0 then//productCode
    _memset(dest:=#ActRecipeData.reserveText[0], usByte:=0, cntr:=sizeof(ActRecipeData.reserveText));
    str_ReserveText.ReadDataOff(udOff:=0, pData:=#ActRecipeData.reserveText[0], udMax:=sizeof(ActRecipeData.reserveText));
    str_ReserveText.NewData.Write(input:=0);
  end_if;

  //if autosave is active, check every ten seconds if we should save
  IF sparAutoSave & ops.tAbsolute-tmrAutoSave> 10000 THEN
    saveChanges();
    tmrAutoSave:= ops.tAbsolute;
  END_IF;
  
  IF HmiDeleteRecipe= -10 THEN //means delete complete db
    IF tmpNrDelete > 0 & tmpNrDelete < dbAmountOfRecipes THEN
      IF saveRecipe(nr:=tmpNrDelete, recipe:=emptyRecipe)= 1 THEN
        tmpNrDelete+=1;
        IF tmpNrDelete = dbAmountOfRecipes THEN
          HmiDeleteRecipe:= 0; //all recipes are deleted now
          loadRecipe(nr:=RecipeId);//load active recipe to show it's empty
        END_IF;
      END_IF;
    END_IF;
  END_IF;

  stsUnsafeChanges.Read();

  //run usb load/save stuff
  IF HmiSaveRecipeToUsb <> 0 THEN
    SaveToUsb(); 
    IF sswSaveUsb= 0 THEN //stopped for some reason
      HmiSaveRecipeToUsb:=0;
    ELSIF sswSaveUsb= 21 THEN //done 
      IF HmiSaveRecipeToUsb= -10 & cntrUsb < TO_DINT(dbAmountOfRecipes) THEN
        cntrUsb+=1;
        tmpNrUsbStored:= cntrUsb; 
        tmpRecipeNrUsb:= cntrUsb;        
        sswSaveUsb:=1;
      ELSE
        sswSaveUsb:=0;
        HmiSaveRecipeToUsb:=0;
      END_IF;
    END_IF;
  ELSIF HmiLoadRecipeFromUsb <> 0 THEN
    loadFromUsb();
    IF sswLoadUsb= 0 THEN //stopped for some reason
      IF HmiLoadRecipeFromUsb<> -10 & fileToLoadNotFound= 1 THEN
        giveAlarm(errorNr:=3);
      END_IF;    
      HmiLoadRecipeFromUsb:= 0;
    ELSIF sswLoadUsb= 21 THEN //done
      IF HmiLoadRecipeFromUsb= -10 & cntrUsb < TO_DINT(dbAmountOfRecipes) THEN
        cntrUsb+=1;
        tmpNrUsbStored:= cntrUsb;
        tmpRecipeNrUsb:= cntrUsb;
        sswLoadUsb:= 1;
      ELSE
        IF HmiLoadRecipeFromUsb<> -10 & fileToLoadNotFound= 1 THEN
          giveAlarm(errorNr:=3);
        END_IF;
        sswLoadUsb:=0;
        HmiLoadRecipeFromUsb:= 0;
      END_IF;
    END_IF;
  END_IF;


  state:= 0;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL ToolsDb::stsUnsafeChanges::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  IF ActRecipeData <> checkForStorageProductData THEN
    stsUnsafeChanges:= 1;
  ELSE
    stsUnsafeChanges:= 0;
  END_IF;

	output := stsUnsafeChanges;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::RecipeId::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR
  
  IF input > 0 & input < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    IF sparAutoSave= 0 | saveChanges()= 1 THEN //only if autosave is active, else in screen project choose to save or not should be made before writing a new product ID
      RecipeId:= input; //keep input in memory
      loadRecipe(nr:=RecipeId);
    END_IF;
   
  ELSE
    Result := Access_Denied;
  End_If;

END_FUNCTION

FUNCTION ToolsDb::saveRecipe
	VAR_INPUT
		nr 	: UDINT;
		recipe 	: tRecipeData;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  //function save recipe in input nr in ram db
  IF nr > 0 & nr < dbAmountOfRecipes THEN //we don't use nr 0, so we have one less
    tempRecipe:= recipe;
    stsRamResult:= RamEx.SetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:=nr * sizeRecipedata);
    IF stsRamResult= 5 THEN
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION ToolsDb::loadRecipe
	VAR_INPUT
		nr 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  //function loads recipe from nr into act recipe, also changes check saving recipe, used to control if saving is required
  IF nr>0 & nr<dbAmountOfRecipes THEN
    stsRamResult:= RamEx.GetDataAt(pData:=#ActRecipeData$USINT, udSize:=sizeRecipedata, udAt:=nr* sizeRecipedata);
    IF stsRamResult= 5 THEN
      checkForStorageProductData:= ActRecipeData; //no changes yet
      UpdateServers();
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 0;
  END_IF;

END_FUNCTION


FUNCTION ToolsDb::saveChanges
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  IF checkForStorageProductData <> ActRecipeData THEN //only do saving if there is a difference
    IF saveRecipe(nr:=RecipeId, recipe:=ActRecipeData) THEN
      checkForStorageProductData:= ActRecipeData;
      ok:= 1;
    ELSE
      ok:= 0;
    END_IF;
  ELSE
    ok:= 1; //no changes, means no storage needed
  END_IF;

END_FUNCTION

FUNCTION ToolsDb::UpdateServers

//put data of new recipe into data servers
  Id_ := ActRecipeData.Id;
  diameter := ActRecipeData.diameter;
  length := ActRecipeData.length;
  speedRPM := ActRecipeData.speedRPM;
  reserve1 := ActRecipeData.reserve1;
  reserve2 := ActRecipeData.reserve2;
  reserve3     := ActRecipeData.reserve3;
  reserve4 := ActRecipeData.reserve4;

  
  
  str_Description.WriteDataOff(udLen:=sizeof(ActRecipeData.description), udOff:=0, pData:=#ActRecipeData.description[0]);
  str_ReserveText.WriteDataOff(udLen:=sizeof(ActRecipeData.reserveText), udOff:=0, pData:=#ActRecipeData.reserveText[0]);

END_FUNCTION

////////////////////////////////////////////////////////////////////
// some functions for controlling recipe from HMI

FUNCTION VIRTUAL GLOBAL ToolsDb::HmiSaveRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //function to save actual recipe into given nr
  //if used as regular save, write product id into this Server to save,
  //else write nr. where you want to save it
  tmpInputNr:=to_udint(input);
  IF input> 0 & tmpInputNr < dbAmountOfRecipes THEN
    IF saveRecipe(nr:=tmpInputNr, recipe:=ActRecipeData) = 1 THEN
	    HmiSaveRecipe := 0; //saving done
    ELSE
      HmiSaveRecipe:= -1;
    END_IF;
  ELSE
    HmiSaveRecipe := -1; //saving not ok
  END_IF;
	result := HmiSaveRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::HmiReloadRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //means throw away all made changes
  IF loadRecipe(nr:=RecipeId)= 1 THEN
  	HmiReloadRecipe := 0; //done
  ELSE
    HmiReloadRecipe := -1; //not ok
  END_IF;
  
	result := HmiReloadRecipe;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::HmiDeleteRecipe::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //delete all recipes (if value = -10), or one (if value is between min and max recipes)
  tmpInputNr:=to_udint(input);
  IF input = -10 THEN
    HmiDeleteRecipe := input;
    tmpNrDelete:= 1;
  ELSIF input>0 & tmpInputNr < dbAmountOfRecipes THEN
    IF saveRecipe(nr:=tmpInputNr, recipe:=emptyRecipe) = 1 THEN
      IF tmpInputNr = RecipeId THEN //if actual recipe is deleted, reload it
        loadRecipe(nr:=RecipeId);
      END_IF;
      HmiDeleteRecipe:= 0;
    ELSE
      HmiDeleteRecipe:= -1;
    END_IF;
  END_IF;
	result := HmiDeleteRecipe;

END_FUNCTION


/////////////////////////////////////////////////////////////////
// USB functions
//////////////////////////////////////////////////////////////////
// function to get prog from other class

FUNCTION GLOBAL ToolsDb::GetRecipe
	VAR_INPUT
		id 	: DINT;
	END_VAR
	VAR_OUTPUT
		oRecipe 	: tRecipeData;
	END_VAR
  
  if id >= 0 & id < to_dint(dbAmountOfRecipes) then
    if id = to_dint(RecipeId) then //JdK if product is active, just give it back, else db isn't written in right way
      tempRecipe:=ActRecipeData;
    else
      RamEx.GetDataAt(pdata:=#tempRecipe$usint, udsize:=sizeRecipedata, udat:= to_udint(id) * sizeRecipedata);
    end_if;
    oRecipe := tempRecipe;
  else
    oRecipe := emptyRecipe;
  end_if;


END_FUNCTION

//////////////////////////////////////////////////////////////
// functions to write data

FUNCTION VIRTUAL GLOBAL ToolsDb::strDescription::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	strDescription := str_Description.Data.Read();
	output := strDescription;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::strDescription::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	strDescription := input;
	result := (str_Description.Data.Write(strDescription))$UDINT;
  _memset(dest:=#ActRecipeData.description[0], usByte:=0, cntr:=sizeof(ActRecipeData.description));
  str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.description[0], udMax:=sizeof(ActRecipeData.description));
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::strReserveText::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	strReserveText := str_ReserveText.Data.Read();
	output := strReserveText;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::strReserveText::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	strReserveText := input;
	result := (str_ReserveText.Data.Write(strReserveText))$UDINT;
  _memset(dest:=#ActRecipeData.reserveText[0], usByte:=0, cntr:=sizeof(ActRecipeData.reserveText));
  str_Description.ReadDataOff(udOff:=0, pData:=#ActRecipeData.reserveText[0], udMax:=sizeof(ActRecipeData.reserveText));


END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::Id_::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	Id_ := input;
  ActRecipeData.Id := Id_;
	result := Id_;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::speedRPM::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	speedRPM := input;
  ActRecipeData.speedRPM := speedRPM;
	result := speedRPM;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::reserve1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	reserve1 := input;
  ActRecipeData.reserve1 := reserve1;
	result := reserve1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::reserve2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	reserve2 := input;
  ActRecipeData.reserve2 := reserve2;
	result := reserve2;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL ToolsDb::diameter::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	diameter := input;
  ActRecipeData.diameter := diameter;
	result := diameter;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::length::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	length := input;
  ActRecipeData.length := length;
	result := length;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::reserve3::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  reserve3 := input;
  ActRecipeData.reserve3:= reserve3;
	result := reserve3;

END_FUNCTION  


FUNCTION VIRTUAL GLOBAL ToolsDb::reserve4::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	reserve4 := input;
  ActRecipeData.reserve4:= reserve4;
	result := reserve4;

END_FUNCTION



FUNCTION ToolsDb::saveToUsb
//method to save one recipe to usb stick, nr of recipe to save is in tmpRecipeNrUsb
//nr of recipe name on usb is in tmpNrUsbStored, same vars are used for loading and saving from/to usb, so we have to make sure only one of them is used

  case sswSaveUsb of

  0://idle
            
  1:// create file name, load data to sve

    FileSys.GetDriveListShort(drivelist:=#CheckDisk[0]);//get active drive names
    
    if CheckDisk[4] <> 0 then// check if drive e is available

      fb.BuildValue2Ascii(Value:=to_dint(tmpNrUsbStored), Dest:=#tmpString[0], Offset:=0);
      _strcpy(dest:=#strname[0], src:="e:\ProfileProg");                             // make localfilename
      _strcat(dest:=#strname[0], src:=#tmpString[0]);                             // recipe nummer
      _strcat(dest:=#strname[0], src:=".csv");                                    // data type
    
      tmpRecipeUsb:= GetRecipe(id:=tmpRecipeNrUsb);
      IF tmpRecipeUsb.diameter <> 0 | tmpRecipeUsb.length <> 0 | tmpRecipeUsb.speedRPM <> 0 THEN
        sswSaveUsb +=1;
      ELSE
        sswSaveUsb:= 21; //just don't save, because there is no data
      END_IF;

    else
      sswSaveUsb:= 0;
      giveAlarm(errorNr:=2);// USB not present
    end_if;
    
  2://empty a few things and open file
    _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString)); 
    fb.OpenFile(FileName:=#strname[0], Attribute:=ATT_READ_WRITE or ATT_CREATE_ALWAYS);
    sswSaveUsb +=1;

  3: // write general stuff

    _strcat(dest:=#tmpString[0], src:=#tmpRecipeUsb.description[0]);  
    _strcat(dest:=#tmpString[0], src:=",");  
    
    _strcat(dest:=#tmpString[0], src:=#tmpRecipeUsb.reserveText[0]);   
    _strcat(dest:=#tmpString[0], src:=",");  
    
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.Id , Dest:=#tmpString[0], Offset:=actStrLen); //
    _strcat(dest:=#tmpString[0], src:=",");
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.diameter , Dest:=#tmpString[0], Offset:=actStrLen); // 
    _strcat(dest:=#tmpString[0], src:=",");   
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.length , Dest:=#tmpString[0], Offset:=actStrLen); // 
    _strcat(dest:=#tmpString[0], src:=",");   
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.speedRPM , Dest:=#tmpString[0], Offset:=actStrLen); // 
    _strcat(dest:=#tmpString[0], src:=",");   
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.reserve1 , Dest:=#tmpString[0], Offset:=actStrLen); //
    _strcat(dest:=#tmpString[0], src:=",");  
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));    
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.reserve2 , Dest:=#tmpString[0], Offset:=actStrLen); //
    _strcat(dest:=#tmpString[0], src:=",");  
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.reserve3 , Dest:=#tmpString[0], Offset:=actStrLen); //
    _strcat(dest:=#tmpString[0], src:=",");   
    
    actStrLen:=to_dint(_strlen(src:=#tmpString[0]));
    fb.BuildValue2Ascii(Value:=tmpRecipeUsb.reserve4 , Dest:=#tmpString[0], Offset:=actStrLen); //
    _strcat(dest:=#tmpString[0], src:=",");   
    
         
    sswSaveUsb +=1;
        
       
  4: //write line stuff, no line stuf for profile data
    sswSaveUsb:= 20;


      
  20: // save file
    fb.CloseFile();
    sswSaveUsb+=1;              
    
  21: //wait until stopped from other part of program
      
end_case;

END_FUNCTION


FUNCTION ToolsDb::loadFromUsb
//method to load one recipe from usb stick, nr of recipe to load is in tmpNrUsbStored
//nr where to store tmpRecipeNrUsb, same vars are used for loading and saving from/to usb, so we have to make sure only one of them is used

  case sswLoadUsb of
  
  0://idle
         
  1:// create file name
    FileSys.GetDriveListShort(drivelist:=#CheckDisk[0]);//get active drive names
    fileToLoadNotFound:= 0;
    if CheckDisk[4] <> 0 then// check if drive e is available
      _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString));
      fb.BuildValue2Ascii(Value:=tmpNrUsbStored, Dest:=#tmpString[0], Offset:=0);
      _strcpy(dest:=#strname[0], src:="e:\ProfileProg");                             // make localfilename
      _strcat(dest:=#strname[0], src:=#tmpString[0]);                             // recipe number
      _strcat(dest:=#strname[0], src:=".csv");                                    // data type
      fileHandle := FileSys.FindFirst(path:="", file:=#strname[0], infostruct:=#FileInfo, atts_inkl:=0, atts_exkl:=0);
      if fileHandle > 0 then
        sswLoadUsb +=1;
      else
        fileToLoadNotFound:= 0;
        sswLoadUsb := 21;
      end_if;
    else
      giveAlarm(errorNr:=2);   //USB not present
      sswLoadUsb:=0;
    end_if;
    
  2://open file
    fb.OpenFile(FileName:=#strName[0], Attribute:=ATTR_READ_ONLY);
    sswLoadUsb +=1;
  
  3://read in first line
    actBufferLength:= fb.ReadFileSkipLineFeeds(Dest:=#buffer[0], Offset:=0);
    offsetBuffer:= 0;
    if actBufferLength > sizeof(buffer) | actBufferLength= 0 then
      giveAlarm(errorNr:=4); //error reading file
      sswLoadUsb := 21;
    else
      sswLoadUsb := 4;
    end_if;
  
  4: //close file, data in buffer
    fb.CloseFile();
    _memset(dest:=#tmpRecipeUsb, usByte:=0, cntr:=sizeof(tmpRecipeUsb));
    sswLoadUsb +=1;
    
  5:// read assembly
    _memset(dest:=#tmpString[0], usByte:=0, cntr:=sizeof(tmpString));
    offsetBuffer := FB.Read2Cr(Source:=#Buffer[0], Dest:=#tmpString[0], Offset:=0); //R1
    offsetBuffer+= 1;
    if  offsetBuffer > actBufferLength+1 then
      giveAlarm(errorNr:=5);   //wrong format
      sswLoadUsb :=0;
    else
      actStrLen := fb.Read2Seperator(Source:=#tmpString[0], Dest:=#tmpRecipeUsb.description[0], Offset:=0); //
      actStrLen+= 1; //ignore seperator
      actStrLen += fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpRecipeUsb.reserveText[0], Offset:=0); //
      actStrLen+= 1; //ignore seperator
      
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.Id:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
      
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.diameter:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.length:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.speedRPM:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.reserve1:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.reserve2:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.reserve3:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      _memset(dest:=#tmpString2[0], usByte:=0, cntr:=sizeof(tmpString2));
      actStrLen+= fb.Read2Seperator(Source:=#tmpString[actStrLen], Dest:=#tmpString2[0], Offset:=0); //
      tmpRecipeUsb.reserve4:= fb.ConvAscii2Value(Source:=#tmpString2[0]);
      actStrLen+= 1; //ignore seperator
            
      
      sswLoadUsb +=1;
    end_if;
    
  6: // read recipe lines, no lines for profile data
    sswLoadUsb:= 20;

    
  20: //save recipe
    IF saveRecipe(nr:=TO_UDINT(tmpRecipeNrUsb), recipe:=tmpRecipeUsb)= 1 THEN
      IF tmpRecipeNrUsb= TO_DINT(RecipeId) THEN //act loaded recipe is same as loaded from usb
        ActRecipeData:= tmpRecipeUsb;
        loadRecipe(nr:=TO_UDINT(RecipeId));
      END_IF;
      sswLoadUsb+= 1;
    END_IF;
    
  21: //wait until stopped from somewhere else in the program
    cntrTje+=1;
    
  end_case;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::HmiSaveRecipeToUsb::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	HmiSaveRecipeToUsb := input;
  IF HmiLoadRecipeFromUsb = 0 & sswLoadUsb= 0 & sswSaveUsb = 0 THEN
	  
    IF HmiSaveRecipeToUsb <> -10 & (HmiSaveRecipeToUsb <= 0 | HmiSaveRecipeToUsb > TO_DINT(dbAmountOfRecipes)) THEN
      HmiSaveRecipeToUsb:= 0; //only activate if nr is right, -10 means save them all, other numbers mean save this nr
    ELSIF HmiSaveRecipeToUsb > 0 & HmiSaveRecipeToUsb <= TO_DINT(dbAmountOfRecipes) THEN
      IF HmiFileNrRecipe> 0 & HmiFileNrRecipe <= TO_DINT(dbAmountOfRecipes) THEN
        tmpNrUsbStored:= HmiFileNrRecipe; //save on specified nr
      ELSE
        tmpNrUsbStored:= HmiSaveRecipeToUsb; //save on used nr
        tmpRecipeNrUsb:= HmiSaveRecipeToUsb;
      END_IF;
    ELSE
      tmpNrUsbStored:= 1; //store them all, start with 1
      tmpRecipeNrUsb:= 1;
      cntrUsb:= 1;
    END_IF;
    sswSaveUsb:=1;
  ELSE
    HmiSaveRecipeToUsb:= 0;
  END_IF;  
	result := HmiSaveRecipeToUsb;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ToolsDb::HmiLoadRecipeFromUsb::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	HmiLoadRecipeFromUsb := input;
  IF HmiSaveRecipeToUsb = 0 & sswLoadUsb= 0 & sswSaveUsb = 0 THEN
      
    IF HmiLoadRecipeFromUsb <> -10 & (HmiLoadRecipeFromUsb <= 0 | HmiLoadRecipeFromUsb > TO_DINT(dbAmountOfRecipes)) THEN
      HmiLoadRecipeFromUsb:= 0; //only activate if nr is right, -10 means save them all, other numbers mean save this nr
    ELSIF HmiLoadRecipeFromUsb > 0 & HmiLoadRecipeFromUsb <= TO_DINT(dbAmountOfRecipes) THEN
      IF HmiFileNrRecipe> 0 & HmiFileNrRecipe <= TO_DINT(dbAmountOfRecipes) THEN
        tmpNrUsbStored:= HmiFileNrRecipe; //save on specified nr
      ELSE
        tmpNrUsbStored:= HmiLoadRecipeFromUsb; //save on used nr
        tmpRecipeNrUsb:= HmiLoadRecipeFromUsb;
      END_IF;
    ELSE
      tmpNrUsbStored:= 1; //load them all, start with 1
      tmpRecipeNrUsb:= 1;
      cntrUsb:= 1;      
    END_IF;
    sswLoadUsb:=1;
  ELSE
    HmiLoadRecipeFromUsb:= 0;
  END_IF;  
	result := HmiLoadRecipeFromUsb;

END_FUNCTION
