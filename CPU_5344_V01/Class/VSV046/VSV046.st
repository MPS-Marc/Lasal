//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define VSV_TXCONFIGREG_OFFSET         16#1000

#define VSV_TX_STATUSREG_OFFSET      16#1801
#define VSV_TX_FRAMELENGTH_OFFSET    16#1008
#define VSV_TX_DATA_OFFSET           16#100A
#define VSV_RX_STATUSREG_OFFSET      16#1800
#define VSV_RX_FRAMELENGTH_OFFSET    16#1802
#define VSV_RX_DATA_OFFSET           16#1804

#define VSV_TX_MAX_DATA_LENGTH        1472  
#define VSV_TX_WRITE_HEADERSIZE         0
#define VSV_RX_MAX_DATA_LENGTH        1472
#define VSV_RX_READ_HEADERSIZE          4
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Source\interfaces\lsl_st_pci.h"

(*!
<Class
	Name               = "VSV046"
	Revision           = "1.33"
	GUID               = "{388A6F83-F268-4477-A344-5E4F69A13385}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\Varan_16x16.ico"
	SharedCommandTable = "true"
	Objectsize         = "(682,120)"
	Comment            = "VARAN splitter (5 VARAN Out ports), switchable supply for VARAN Out ports and Realtime Ethernet on a specified Port">
	<Channels>
		<Server Name="DeviceMACAddress" GUID="{CD88EC43-15CC-480D-B830-537AA663F65F}" Class="VirtualBaseInit" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="The MAC-Address of the device is shown here"/>
		<Server Name="RealtimeIP_Link" GUID="{307BB0F2-68A8-4CAD-BD90-1DC7B8AE8071}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="1 .. Realtime Ethernet is connected&#13;&#10;0 .. Realtime Ethernet is not connected"/>
		<Server Name="SyncOffset" GUID="{CF1448F3-1928-4B7F-9E66-D53CC2D634EA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Offset between VARAN-Sync and transmission of Realtime Ethernet Data"/>
		<Server Name="VaranOut_0" GUID="{4C791E01-676A-4D25-90B0-D7F7FF9F5A8E}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Server Name="VaranOut_1" GUID="{0C6E157C-16B9-40B4-A13C-620A0BFE84A2}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Server Name="VaranOut_2" GUID="{655D90B5-0896-45ED-BFD5-B8AFFA06117E}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Server Name="VaranOut_3" GUID="{BBF006FD-06B5-4F88-A4D4-A8D71333EF8D}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Server Name="VaranOut_4" GUID="{BE3516AE-DF42-4B35-B22E-6D121EC4D14A}" Class="Hub_Base" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="connect a varan client class"/>
		<Client Name="DontCheckRxDestMAC" Required="false" Internal="false" DefValue="0" Comment="Filter settings for destination MAC address of incoming frames&#13;&#10;&#13;&#10;0..application gets only frames with a correct destinaction MAC address&#13;&#10;1..application gets all received frames"/>
		<Client Name="Hub_Base0" Required="true" Internal="true"/>
		<Client Name="Hub_Base1" Required="true" Internal="true"/>
		<Client Name="Hub_Base2" Required="true" Internal="true"/>
		<Client Name="Hub_Base3" Required="true" Internal="true"/>
		<Client Name="Hub_Base4" Required="true" Internal="true"/>
		<Client Name="MacAddress" Required="true" Internal="true"/>
		<Client Name="RealtimeIP_Mode" Required="false" Internal="false" DefValue="0" Comment="Mode of Realtime IP functionality&#13;&#10;&#13;&#10;0...Disabled&#13;&#10;1...Enabled: Start transfer with Sync&#13;&#10;2...Enabled: Start transfer when last TX Byte has been written"/>
		<Client Name="RealtimeIP_PortNr" Required="false" Internal="false" DefValue="-1" Comment="Number of downlinkport for realtime IP&#13;&#10;( 0 till 4 ) -1 = disabled"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\interfaces\lsl_st_pci.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.33" Date="09.12.2019" Author="LanSte" Company="Sigmatek" Description="Added Server ProtocolVersion. InterframeGap is included in the resource calculation."/>
		<Dokumentation Revision="1.32" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.31" Date="06.03.2018" Author="EisMic" Company="Sigmatek" Description="Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="1.30" Date="12.01.2018" Author="LanSte" Company="Sigmatek" Description="Added PostInit Support. Added Call to base class for disable device in interrupt."/>
		<Dokumentation Revision="1.29" Date="07.12.2016" Author="HaeTho" Company="Sigmatek" Description="Changed &quot;Online&quot; server behavior to set online first if cyclic data is valid due to SA35740."/>
		<Dokumentation Revision="1.28" Date="30.08.2016" Author="ZoePat" Company="Sigmatek" Description="Added function CheckRTEthernetAvaliable() to change required FPGA version for derived classes."/>
		<Dokumentation Revision="1.27" Date="10.05.2016" Author="RamAnd" Company="Sigmatek" Description="Suppressed warning that would occur with target ARM on compiler version 30 or higher."/>
		<Dokumentation Revision="1.26" Date="17.02.2016" Author="EisMic" Company="Sigmatek" Description="Prescalersettings were not set correctly when Payload is active."/>
		<Dokumentation Revision="1.25" Date="16.04.2015" Author="PieSte&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.24" Date="24.03.2015" Author="EisMic" Company="Sigmatek" Description="Check pointer p_NodeInfo for validity in method GetRetryTimeout due to access exception error if method Varan_HWDisconnect is called and no hardware was available."/>
		<Dokumentation Revision="1.23" Date="25.07.2014" Author="LanSte" Company="Sigmatek" Description="Added Support for reading hardware diagnose and hardwaretree entry."/>
		<Dokumentation Revision="1.22" Date="06.05.2014" Author="LanSte" Company="Sigmatek" Description="Improved Transparent property description in HW-Tree and activated greying out of the object in the HW-Tree.&#13;&#10;Minimized the interface request via CILGET by useing private pointers to reduce time in init."/>
		<Dokumentation Revision="1.21" Date="07.04.2014" Author="EisMic" Company="Sigmatek" Description="Disabled all DOs which are installed, in the methods Varan_HWInterrupt and Varan_HwDisconnect."/>
		<Dokumentation Revision="1.20" Date="05.12.2013" Author="LanSte" Company="Sigmatek" Description="Added Payload Support"/>
		<Dokumentation Revision="1.14" Date="18.07.2012" Author="ObeChr" Company="Sigmatek" Description="Implemented time measurement for internal tests in methods UpdateRt, UpdateRtPostScan and UpdateCy"/>
		<Dokumentation Revision="1.13" Date="31.10.2011" Author="RamAnd" Company="Sigmatek" Description="Write supply settings at startup did only work when the realtime ethernet functionality was in use."/>
		<Dokumentation Revision="1.12" Date="14.10.2011" Author="RamAnd" Company="Sigmatek" Description="RetryCounter functionality has been added"/>
		<Dokumentation Revision="1.11" Date="22.09.2011" Author="RamAnd" Company="Sigmatek" Description="Realtime ethernet is now also possible with frames smaller than 129 Byte."/>
		<Dokumentation Revision="1.10" Date="04.01.2011" Author="BleErn" Company="Sigmatek" Description="Added Client Transparent that allows to disable a VARAN-HW-Class"/>
		<Dokumentation Revision="1.9" Date="21.03.2011" Author="BleErn" Company="Sigmatek" Description="Changed t_longDOSettings to a local type (t_VSV_logDOSettings)"/>
		<Dokumentation Revision="1.8" Date="17.03.2011" Author="BleErn" Company="Sigmatek" Description="Corrected Handling of Ethernet-Header"/>
		<Dokumentation Revision="1.7" Date="15.03.2011" Author="BleErn" Company="Sigmatek" Description="Reworked realtime ethernet implementation"/>
		<Dokumentation Revision="1.6" Date="13.02.2011" Author="BleErn" Company="Sigmatek" Description="Added support for realtime ethernet"/>
		<Dokumentation Revision="1.5" Date="15.10.2010" Author="BleErn" Company="Sigmatek" Description="Removed Client UseRtPostScan"/>
		<Dokumentation Revision="1.4" Date="13.07.2010" Author="BleErn" Company="Sigmatek" Description="Content of corresponding LASAL Hardware Description file (.lhd) which is necessary for the hardware editor has been corrected"/>
		<Dokumentation Revision="1.3" Date="30.06.2010" Author="RamAnd" Company="Sigmatek" Description="Connect clients/servers for serial number validation to topmost derivation"/>
		<Dokumentation Revision="1.2" Date="11.03.2010" Author="RamAnd" Company="Sigmatek" Description="Added serial number validation"/>
		<Dokumentation Revision="1.1" Date="13.07.2009" Author="armluk" Company="Sigmatek" Description="Added and improved Server/Client comments"/>
		<Dokumentation Revision="1.0" Date="15.04.2009" Author="RamAnd" Company="Sigmatek" Description="Initial Version"/>
		<Dokumentation Revision="1.29" Date="07.12.2016" Author="HaeTho" Company="Sigmatek" Description=". All Operations which where done until now on Online-Server are now done on Variable bOnline.&#13;&#10;. Server Online is now set an begin of state &apos;Operational&apos; in function UpdateRT()."/>
	</RevDoku>
	<Network Name="VSV046">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{4256A7B6-99BB-4BD8-A671-DA0FB99D0617}"
				Class      = "VSV_Base"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="DeviceAddress"/>
					<Server Name="DeviceID"/>
					<Server Name="Online"/>
					<Server Name="ProtocolVersion"/>
					<Server Name="Release"/>
					<Server Name="RetryCounter"/>
					<Server Name="SerialNo"/>
					<Server Name="State"/>
					<Server Name="SupplyVaranOut_0"/>
					<Server Name="SupplyVaranOut_1"/>
					<Server Name="SupplyVaranOut_2"/>
					<Server Name="SupplyVaranOut_3"/>
					<Server Name="SupplyVaranOut_4"/>
					<Server Name="ValidateSerNo"/>
					<Server Name="VendorID"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SerNoValidation"/>
					<Client Name="Transparent"/>
					<Client Name="UserAction"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base0"
				GUID       = "{18757703-E7E2-414D-B677-25027DD46412}"
				Class      = "Hub_Base"
				Position   = "(360,1260)"
				Visualized = "false">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="0"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base1"
				GUID       = "{60E0BC57-87A9-42B5-8D11-8406780E259D}"
				Class      = "Hub_Base"
				Position   = "(360,1470)"
				Visualized = "false">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="1"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base2"
				GUID       = "{373BAECE-AC27-4163-A5EE-A9C96F384B18}"
				Class      = "Hub_Base"
				Position   = "(360,1680)"
				Visualized = "false">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="2"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base3"
				GUID       = "{72E20E7D-BDAD-4B62-A5C1-4A2FC6F60DD5}"
				Class      = "Hub_Base"
				Position   = "(360,1890)"
				Visualized = "false">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="3"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "Hub_Base4"
				GUID       = "{9453BBA8-150E-4CBE-82E4-69CFC9EE9B5F}"
				Class      = "Hub_Base"
				Position   = "(360,2100)"
				Visualized = "false">
				<Channels>
					<Server Name="Control"/>
					<Client Name="Splitter_Place" Value="4"/>
					<Client Name="VaranIn"/>
				</Channels>
			</Object>
			<Object
				Name       = "MacAddress"
				GUID       = "{2FA465AE-5C01-408A-8FBD-3064DECA1FEA}"
				Class      = "String"
				Position   = "(480,1080)"
				Visualized = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.State" Destination="_base.State" Vertices="(1418,210),(790,210),"/>
			<Connection Source="this.Online" Destination="_base.Online" Vertices="(1418,270),(790,270),"/>
			<Connection Source="this.Release" Destination="_base.Release" Vertices="(1418,330),(790,330),"/>
			<Connection Source="this.DeviceAddress" Destination="_base.DeviceAddress" Vertices="(1418,390),(790,390),"/>
			<Connection Source="this.VendorID" Destination="_base.VendorID" Vertices="(1418,450),(790,450),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(1418,510),(790,510),"/>
			<Connection Source="this.SupplyVaranOut_0" Destination="_base.SupplyVaranOut_0" Vertices="(1418,810),(790,810),"/>
			<Connection Source="this.SupplyVaranOut_1" Destination="_base.SupplyVaranOut_1" Vertices="(1418,870),(790,870),"/>
			<Connection Source="this.SupplyVaranOut_2" Destination="_base.SupplyVaranOut_2" Vertices="(1418,930),(790,930),"/>
			<Connection Source="this.SupplyVaranOut_3" Destination="_base.SupplyVaranOut_3" Vertices="(1418,990),(790,990),"/>
			<Connection Source="this.SupplyVaranOut_4" Destination="_base.SupplyVaranOut_4" Vertices="(1418,1050),(790,1050),"/>
			<Connection Source="_base.VaranIn" Destination="this.VaranIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.UserAction" Destination="this.UserAction" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.Hub_Base0" Destination="Hub_Base0.Control"/>
			<Connection Source="this.Hub_Base1" Destination="Hub_Base1.Control"/>
			<Connection Source="this.Hub_Base2" Destination="Hub_Base2.Control"/>
			<Connection Source="this.Hub_Base3" Destination="Hub_Base3.Control"/>
			<Connection Source="this.Hub_Base4" Destination="Hub_Base4.Control"/>
			<Connection Source="Hub_Base4.VaranIn" Destination="_base.State" Vertices="(360,2190),(790,210),"/>
			<Connection Source="Hub_Base0.VaranIn" Destination="_base.State" Vertices="(360,1350),(790,210),"/>
			<Connection Source="Hub_Base1.VaranIn" Destination="_base.State" Vertices="(360,1560),(790,210),"/>
			<Connection Source="Hub_Base2.VaranIn" Destination="_base.State" Vertices="(360,1770),(790,210),"/>
			<Connection Source="Hub_Base3.VaranIn" Destination="_base.State" Vertices="(360,1980),(790,210),"/>
			<Connection Source="this.VaranOut_0" Destination="Hub_Base0.Control" Vertices="(1418,1290),(786,1350),"/>
			<Connection Source="this.VaranOut_1" Destination="Hub_Base1.Control" Vertices="(1418,1350),(786,1560),"/>
			<Connection Source="this.VaranOut_2" Destination="Hub_Base2.Control" Vertices="(1418,1410),(786,1770),"/>
			<Connection Source="this.VaranOut_3" Destination="Hub_Base3.Control" Vertices="(1418,1470),(786,1980),"/>
			<Connection Source="this.VaranOut_4" Destination="Hub_Base4.Control" Vertices="(1418,1530),(786,2190),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(1418,570),(790,570),"/>
			<Connection Source="_base.SerNoValidation" Destination="this.SerNoValidation" Vertices="(218,390),(38,390),"/>
			<Connection Source="this.ValidateSerNo" Destination="_base.ValidateSerNo" Vertices="(1418,690),(790,690),"/>
			<Connection Source="this.MacAddress" Destination="MacAddress.Data"/>
			<Connection Source="this.DeviceMACAddress" Destination="MacAddress.Data" Vertices="(1418,1230),(1246,1170),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(1418,630),(790,630),"/>
			<Connection Source="_base.Transparent" Destination="this.Transparent" Vertices="(218,450),(38,450),"/>
			<Connection Source="this.ProtocolVersion" Destination="_base.ProtocolVersion" Vertices="(1418,750),(790,750),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using VSV_Base

VSV046 : CLASS
: VSV_Base
	TYPE
	  t_MACAddr : ARRAY [0..5] OF HSINT;  //! <Type Public="true" Name="t_MACAddr"/>
#pragma pack(push, 1)
	  t_ConfigStruct : STRUCT
	    TxConfig : BSINT
	    [
	      1 EnableStartBySync,
	      2 StartTXWrite,
	    ];
	    FilterConfig : BSINT
	    [
	      1 RXDestinationMacFilterEnable,
	      2 RXWithoutAlternatingBuffer,
	    ];
	    RxDestMACAddr : t_MACAddr;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_VSV_longDOSettings : STRUCT
	    us_Command : HSINT;
	    ud_Address : HDINT;
	    ui_ByteCount0 : UINT;
	    us_ByteCount1 : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ETHFrameHeader : STRUCT  //! <Type Public="true" Name="t_ETHFrameHeader"/>
	    DestAddr : t_MACAddr;
	    SrcAddr : t_MACAddr;
	    ProtocolType : HINT;  //! <Type Comment="16#0806 =&gt; ARP&#13;&#10;16#0800 =&gt; IP&#13;&#10;16#88A4 =&gt; EtherCAT Special Protokol" Name="t_ETHFrameHeader.ProtocolType"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_ETHFrame : STRUCT  //! <Type Public="true" Name="t_ETHFrame"/>
	    Header : t_ETHFrameHeader;
	    Data : ARRAY [0..VSV_TX_MAX_DATA_LENGTH-14-1] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_VSV_DataReceive : STRUCT
	    RXStatusReg : BSINT
	    [
	      1 LinkEstablished,
	      2 FrameReceived,
	      3 CRCError,
	      4 TimesliceError,
	      5 LengthError,
	    ];
	    TXStatusRegister : BSINT
	    [
	      1 FrameSend,
	      2 LengthError,
	    ];
	    RXFrameLength : UINT;
	    ETHFrame : t_ETHFrame;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_VSV_FrameReceive : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_LongDOSettings : ^t_VSV_longDOSettings;
	    p_Settings : ^t_VaranDOSettingsRd;
	    p_DataRead : ^t_VSV_DataReceive;
	    us_OldRetryCounter : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_VSV_FrameSend : STRUCT
	    TXFrameLength : UINT;
	    ETHFrame : t_ETHFrame;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_DO_VSV_FrameSend : STRUCT
	    p_Handle : ^LSL_VARANFRAME;
	    p_LongDOSettings : ^t_VSV_longDOSettings;
	    p_Settings : ^t_VaranDOSettingsWr;
	    p_DataWrite : ^t_VSV_FrameSend;
	    us_OldRetryCounter : USINT;
	    b_DOIsRunning : t_SingleRunState;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_MACConfiguration : STRUCT
	    MACDeviceNumber : USINT;
	    TypeOfEntry : BSINT
	    [
	      1 MACAdress,
	      2 IPAddressSubnetGateway,
	      3 IPv6,
	    ];
	    MACAddress : t_MACAddr;
	    IPAddress : DINT;
	    SubnetMask : DINT;
	    Gateway : DINT;
	    Reserved : ARRAY [0..35] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_VSVStatus : BSINT
	  [
	    1 IsLinked,
	    2 NewSendData,
	  ];
	END_TYPE
  //Servers:
	RealtimeIP_Link 	: SvrCh_DINT;
	SyncOffset 	: SvrCh_UDINT;
	DeviceMACAddress 	: SvrChCmd_UDINT;
	VaranOut_0 	: SvrChCmd_DINT;
	VaranOut_1 	: SvrChCmd_DINT;
	VaranOut_2 	: SvrChCmd_DINT;
	VaranOut_3 	: SvrChCmd_DINT;
	VaranOut_4 	: SvrChCmd_DINT;
  //Clients:
	Hub_Base0 	: CltChCmd_Hub_Base;
	Hub_Base1 	: CltChCmd_Hub_Base;
	Hub_Base2 	: CltChCmd_Hub_Base;
	Hub_Base3 	: CltChCmd_Hub_Base;
	Hub_Base4 	: CltChCmd_Hub_Base;
	RealtimeIP_Mode 	: CltCh_DINT;
	RealtimeIP_PortNr 	: CltCh_DINT;
	DontCheckRxDestMAC 	: CltCh_DINT;
	MacAddress 	: CltChCmd_String;
  //Variables:
		us_Initrun 	: USINT;
		ud_VaranTime 	: UDINT;
		sd_SyncOffset 	: DINT;
		ud_IsoStartPoint 	: UDINT;
		MaxFrameLength 	: UINT;
		MaxSendLength 	: UINT;
		s_DO_VSV_FrameSend 	: t_DO_VSV_FrameSend;
		s_DO_VSV_FrameReceive 	: t_DO_VSV_FrameReceive;
		VSVStatus 	: t_VSVStatus;
		p_SendBuffer 	: ^t_ETHFrame;
		SendLength 	: UINT;
		p_RXFunktion 	: ^void;
		p_RXThis 	: ^void;
		VSVConfig 	: t_ConfigStruct;
		p_ReceiveBuffer 	: ^t_ETHFrame;
		b_FirstFrameReceived 	: BOOL;
		ui_EtherNetProtocolType 	: UINT;
		b_RealtimeEthernetActive 	: BOOL;
		DestMacAddr 	: t_MACAddr;
		MACFilter 	: t_MACAddr;
		b_FilterEnabled 	: BOOL;
		b_UseSenderMACasDestination 	: BOOL;
		pSPCIInfo 	: ^LSL_SPCIINFO;
		b_LongDO 	: BOOL;
		MaxIPPortNr 	: DINT;
  //Functions:
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Init for Varan Client&#13;&#10;=================================================================================================&#13;&#10;[server] State    :W  :state of class&#13;&#10;[client] Required   :R  :is class required for varan or not&#13;&#10;[members] p_VaranPosition  :R/W :node string of varan module&#13;&#10;   ud_VaranManagerNr :W  :number of varan manager&#13;&#10;   p_Varan    :W  :pointer to varan OS - Functions&#13;&#10;[locals] sd_retval   :W/R :return value of called functions&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Rt - Funktion of Varan class ( called bei VaranMaster )" Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Function is called by VaranRtPostScan if used" Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="[#ENGLISH]&#13;&#10;=================================================================================================&#13;&#10;Function is called if a varan module is connected&#13;&#10;=================================================================================================&#13;&#10;[server] Online  :W  :set if class is ok and all data is valid&#13;&#10;   State  :W  :state of class&#13;&#10;" Name="Varan_HwConnect"/>
	FUNCTION AWL VIRTUAL GLOBAL Varan_HwConnect
		VAR_INPUT
			ud_data 	: UDINT;			//! <Variable Comment="data of callback function" Name="Varan_HwConnect.ud_data"/>
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;			//! <Variable Comment="return value of OS" Name="Varan_HwConnect.sd_retval"/>
		END_VAR;
				//! <Function Comment="Function is called if a varan interrupt occures" Name="Varan_HwInterrupt"/>
	FUNCTION VIRTUAL GLOBAL Varan_HwInterrupt
		VAR_INPUT
			ud_reason 	: UDINT;
			ud_data 	: ^t_CallBackInterrupt;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="Function is called if a varan module is disconnected&#13;&#10;" Name="Varan_HwDisconnect"/>
	FUNCTION AWL VIRTUAL GLOBAL Varan_HwDisconnect
		VAR_INPUT
			ud_data 	: UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
				//! <Function Comment="Function to set all Data Objects off" Name="SetDOsOff"/>
	FUNCTION VIRTUAL GLOBAL SetDOsOff;
				//! <Function Comment="Function to update module retry counter" Name="UpdateRetryCounter"/>
	FUNCTION VIRTUAL GLOBAL UpdateRetryCounter;
				//! <Function Comment="Check if DeviceID is supported by class" Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			ID2Check 	: UDINT;			//! <Variable Comment="VARAN DeviceID, which should be checked" Name="CheckDeviceID.ID2Check"/>
		END_VAR
		VAR_OUTPUT
			IsOK 	: BOOL;			//! <Variable Comment="TRUE...DeviceID is ok with this class&#13;&#10;FALSE..DeviceID is not ok with this class" Name="CheckDeviceID.IsOK"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
				//! <Function Comment="Returns true if this class needs the postinitphase. &#13;&#10;Default in the base is false." Name="CheckPostInitNeeded"/>
	FUNCTION VIRTUAL GLOBAL CheckPostInitNeeded
		VAR_INPUT
			pbPostInitSettings 	: ^t_VM_CMD_NEED_POST_INIT_CALL_SETTINGS;
		END_VAR
		VAR_OUTPUT
			PostInitNeeded 	: BOOL;
		END_VAR;
	
	FUNCTION DataReceivedDummy
		VAR_INPUT
			pBuf 	: ^t_ETHFrame;
			Len 	: UINT;
		END_VAR;
	
	FUNCTION VIRTUAL WriteConfig
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION CheckReceivedFrame;
				//! <Function Comment="function for cyclically setting send data" Name="SetSendData"/>
	FUNCTION GLOBAL SetSendData
		VAR_INPUT
			p_Data 	: ^void;			//! <Variable Comment="Pointer on data" Name="SetSendData.p_Data"/>
			ui_length 	: UINT;			//! <Variable Comment="length of data" Name="SetSendData.ui_length"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="READY .. function was successful&#13;&#10;ERROR .. no datapointer given, no length given, length too big" Name="SetSendData.ret_code"/>
		END_VAR;
				//! <Function Comment="method for configuring receive-data;&#13;&#10;has to be called until 6th init-run" Name="ConfigReceiveData"/>
	FUNCTION GLOBAL ConfigReceiveData
		VAR_INPUT
			p_ReceiveFunktion 	: ^void;			//! <Variable Comment="method pointer for receive-function" Name="ConfigReceiveData.p_ReceiveFunktion"/>
			p_this 	: ^void;			//! <Variable Comment="this-pointer for calling receive-function" Name="ConfigReceiveData.p_this"/>
			p_FilterMacAddress 	: ^t_MACAddr := NIL;			//! <Variable Comment="pointer on mac-adress for receive-filter" Name="ConfigReceiveData.p_FilterMacAddress"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="READY .. function successful&#13;&#10;ERROR .. invalid receive function pointer / this pointer&#13;&#10;ERROR_BUSY .. function called after 6th init-run" Name="ConfigReceiveData.ret_code"/>
		END_VAR;
				//! <Function Comment="method for configuring send-data;&#13;&#10;has to be called until 6th init-run" Name="ConfigSendData"/>
	FUNCTION GLOBAL ConfigSendData
		VAR_INPUT
			ui_MaxLength 	: UINT;			//! <Variable Comment="maximum send length" Name="ConfigSendData.ui_MaxLength"/>
			ui_ProtocolType 	: HINT;			//! <Variable Comment="ethertype for ethernet-frames" Name="ConfigSendData.ui_ProtocolType"/>
			p_DestinationMacAddress 	: ^t_MACAddr := NIL;			//! <Variable Comment="pointer on destination mac adress for sending" Name="ConfigSendData.p_DestinationMacAddress"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="READY .. function successful&#13;&#10;ERROR .. invalid length&#13;&#10;ERROR_BUSY .. function called after 6th init-run" Name="ConfigSendData.ret_code"/>
		END_VAR;
	
	FUNCTION SearchSPIList
		VAR_INPUT
			p_us_position_info 	: ^USINT;
			SearchID 	: UDINT;
			p_BaseListAddress 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION ReadSPIDataComfort
		VAR_INPUT
			p_us_position_info 	: ^USINT;
			ud_offset 	: UDINT;
			ud_length 	: UDINT;
			p_data 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			sd_retval 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetMaxIP_PortNr;
	
	FUNCTION VIRTUAL UpdateTxConfig;
	
	FUNCTION VIRTUAL CheckRTEthernetAvaliable
		VAR_OUTPUT
			bIsAvaliable 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SyncOffset::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Hub_Base
#pragma using String


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB VSV046::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_VSV046
1$UINT, 33$UINT, (SIZEOF(::VSV046))$UINT, 
8$UINT, 9$UINT, 0$UINT, 
TO_UDINT(2856004818), "VSV046", //Class
TO_UDINT(1403496763), "VSV_Base", 1$UINT, 18$UINT, //Baseclass
//Servers:
(::VSV046.RealtimeIP_Link.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3287227532), "RealtimeIP_Link", 
(::VSV046.SyncOffset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1050456542), "SyncOffset", 
(::VSV046.DeviceMACAddress.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1080291236), "DeviceMACAddress", 
(::VSV046.VaranOut_0.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(142323460), "VaranOut_0", 
(::VSV046.VaranOut_1.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2138873746), "VaranOut_1", 
(::VSV046.VaranOut_2.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3866480168), "VaranOut_2", 
(::VSV046.VaranOut_3.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2440232638), "VaranOut_3", 
(::VSV046.VaranOut_4.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(253127453), "VaranOut_4", 
//Clients:
(::VSV046.Hub_Base0.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1954527509), "Hub_Base0", TO_UDINT(3238133653), "Hub_Base", 1$UINT, 21$UINT, 
(::VSV046.Hub_Base1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(58231171), "Hub_Base1", TO_UDINT(3238133653), "Hub_Base", 1$UINT, 21$UINT, 
(::VSV046.Hub_Base2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2591152185), "Hub_Base2", TO_UDINT(3238133653), "Hub_Base", 1$UINT, 21$UINT, 
(::VSV046.Hub_Base3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3983993007), "Hub_Base3", TO_UDINT(3238133653), "Hub_Base", 1$UINT, 21$UINT, 
(::VSV046.Hub_Base4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1930591500), "Hub_Base4", TO_UDINT(3238133653), "Hub_Base", 1$UINT, 21$UINT, 
(::VSV046.RealtimeIP_Mode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1653195478), "RealtimeIP_Mode", 
(::VSV046.RealtimeIP_PortNr.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3750769505), "RealtimeIP_PortNr", 
(::VSV046.DontCheckRxDestMAC.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1813674650), "DontCheckRxDestMAC", 
(::VSV046.MacAddress.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1230141641), "MacAddress", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
END_FUNCTION


#define USER_CNT_VSV046 52

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_VSV046] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION VSV046::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= VSV_Base::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= Varan_Base::State.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, Varan_Base::State.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_VSV046;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #Varan_HwConnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #Varan_HwInterrupt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #Varan_HwDisconnect();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #SetDOsOff();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #UpdateRetryCounter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[43]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[45]		:= #CheckPostInitNeeded();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[48]		:= #WriteConfig();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[49]		:= #GetMaxIP_PortNr();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[50]		:= #UpdateTxConfig();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[51]		:= #CheckRTEthernetAvaliable();

#pragma warning (default : 74)
	Varan_Base::State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Varan_Base::State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SyncOffset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SyncOffset::Write() );
	IF SyncOffset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, DeviceMACAddress.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Write		:= #DeviceMACAddress::M_WR_DIRECT();
	DeviceMACAddress.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF DeviceMACAddress.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_0.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_1.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_1.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_2.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_2.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_3.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_3.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, VaranOut_4.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	VaranOut_4.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF VaranOut_4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL VSV046::Init
  VAR
    sd_retval         : DINT;
    p_sigmatek_devinfo  : ^PCICONFDATA;
    
    p_ManagerStructure : ^LSL_CONTROLBLOCK;
    p_ManagerPll : ^LSL_VARANPLL;    
    
    pManagerProtocolVersion : ^HINT;
    ud_ProtocolVersion  : UDINT;
  END_VAR

#ifdef IsTransparent_IS_AVAILABLE
  IF IsTransparent() THEN
    return;
  END_IF;
#endif

  //in first Initphase
  if ( us_Initrun = 0 ) then
    b_useSwitchableSupply := TRUE;
  
    GetMaxIP_PortNr();
  
    //---------------------------------------------------------------------------------------------------------
    //init the base class
    VSV_Base::Init();

    //if an error occurs in base class return
    if ( State <> _NotInitialized ) then
      return;
    end_if;

    RealtimeIP_Mode := RealtimeIP_Mode.Read();

    //get IP Portnumber
    sd_RealtimeIP_PortNr := RealtimeIP_PortNr := RealtimeIP_PortNr.Read();
    if (sd_RealtimeIP_PortNr > MaxIPPortNr) | (sd_RealtimeIP_PortNr < 0) then
      sd_RealtimeIP_PortNr := -1;
      RealtimeIP_Mode := 0;
    end_if; 

    //---------------------------------------------------------------------------------------------------------
    //install RT - Varantask

// class has to work on library versions without postscan also
#ifdef CALL_OPTION_RT_POSTSCAN
      VaranIn.AddVaranTask( ud_dol_type := VARAN_DOL_ISO
                          , p_this      := this
                          , callOptions := CALL_OPTION_RT_PRESCAN OR CALL_OPTION_RT_POSTSCAN
                          );
#else
      VaranIn.AddVaranTask( ud_dol_type := VARAN_DOL_ISO
                          , p_this      := this
                          );
#endif

    //get varan time and calculate offset for sync
    ud_VaranTime := VaranIn.GetVaranTime( #ud_IsoStartPoint );

    sd_SyncOffset := ( ud_VaranTime - ud_IsoStartPoint )$DINT;
    
    Syncoffset := ud_IsoStartPoint / (ud_VaranTime / 100);
    
  end_if;
  
  //in 7th Initphase we add our DOs
  if ( us_Initrun = 6 ) then

    if (MaxSendLength > 0) & RealtimeIP_Mode then
    
      // check if long DOs are supported by VARAN Manager Protocol Version before we use it (must be 1.2.5 or greater)
      if OS_CILGET( "PCICONFIG", #pSPCIInfo ) =  SYS_ERR_NONE then
        p_sigmatek_devinfo  := SPCIINFO_FINDDEVICE( 0x0707,0 );
        
        if p_sigmatek_devinfo <> NIL then
          pManagerProtocolVersion := SPCIINFO_GETADDRESS( p_sigmatek_devinfo ) + 16#34;

        elsif b_PayloadSupport & 
              _RTOSVersion >= VM_FULL_PAYLOAD_AVAILABLE then
          pManagerProtocolVersion := (#ud_ProtocolVersion)$^UINT;
          sd_retval := MULTI_VARAN_iGetNodeProperty(  hNodeHandle       := ud_HandleModule
                                                    , udPropertyId      := VM_PROP_VARAN_PROTOCOL_VERSION
                                                    , pudPropertyValue  := #ud_ProtocolVersion);
                                                    
        else
          //-----------------------------------------------------------------------------------------------
          //get Manager structure
          sd_retval := VARAN_iGetManagerControl ( uiManager := ud_VaranManagerNr
                                                , pvCB    := ( #p_ManagerStructure )$^PLSL_CONTROLBLOCK
                                                , pvPLL   := ( #p_ManagerPll )$^PLSL_VARANPLL
                                                );

          // if we can't find the PCI device we recalculate the address via the varan manager structure
          pManagerProtocolVersion := (p_ManagerStructure - 16#800 + 16#A34)$^UINT;
        end_if;

        // check if the Manager supports LongDOs
        if pManagerProtocolVersion^ < 16#125 then
          State := _ComponentNotExists;
          return;
        end_if;
      end_if;
     
      //add read DO
      if b_PayloadSupport then
          
          sd_retval := AddRdPayloadDO(  ud_dol_type         := VARAN_DOL_ISO
                                      , p_ud_handle         := ( #s_DO_VSV_FrameReceive.p_Handle)$^UDINT
                                      , ud_offset_read      := VSV_RX_STATUSREG_OFFSET                                
                                      , ud_length_read      := MaxFrameLength
                                      , p_ud_data_read      := ( #s_DO_VSV_FrameReceive.p_DataRead)$^UDINT
                                      , ud_type             := VM_MEMORY_ACCESS
                                     );
          

          
          //look if an error occurs
          if ( sd_retval <> VARANMANAGER_OK ) then
            State := _CreateDOFailed;
            return;
          end_if; 
          //-----------------------------------------------------------------------------------------------
          // add write DO
          sd_retval := AddWrPayloadDO(  ud_dol_type         := VARAN_DOL_ISO
                                      , p_ud_handle         := ( #s_DO_VSV_FrameSend.p_Handle)$^UDINT
                                      , ud_offset_write     := VSV_TX_FRAMELENGTH_OFFSET                                
                                      , ud_length_write     := MaxFrameLength
                                      , p_ud_data_write     := ( #s_DO_VSV_FrameSend.p_DataWrite)$^UDINT
                                      , ud_type             := VM_MEMORY_ACCESS
                                      );
          

          
          //look if an error occurs
          if ( sd_retval <> VARANMANAGER_OK ) then
            State := _CreateDOFailed;
            return;
          end_if; 
  
      else  
        //add read DO
        sd_retval := VaranIn.AddRdDO( p_us_position_info := p_VaranPosition
                                    , ud_dol_type        := VARAN_DOL_ISO
                                    , p_ud_handle        := ( #s_DO_VSV_FrameReceive.p_Handle )$^UDINT
                                    , ud_address         := 0
                                    , ud_length          := MaxFrameLength
                                    , p_ud_data          := ( #s_DO_VSV_FrameReceive.p_DataRead )$^UDINT
                                    , ud_type            := VM_MEMORY_ACCESS
                                    );
                           
        //look if an error occurs
          if ( sd_retval <> VARANMANAGER_OK ) then        
          State := _CreateDOFailed;
            return;         
        end_if;     
       
        //-----------------------------------------------------------------------------------------------
        // add write DO
        sd_retval := VaranIn.AddWrDO( p_us_position_info := p_VaranPosition
                                    , ud_dol_type        := VARAN_DOL_ISO
                                    , p_ud_handle        := ( #s_DO_VSV_FrameSend.p_Handle )$^UDINT
                                    , ud_address         := 0
                                    , ud_length          := MaxFrameLength
                                    , p_ud_data          := ( #s_DO_VSV_FrameSend.p_DataWrite )$^UDINT
                                    , ud_type            := VM_MEMORY_ACCESS
                                    );
          
          //look if an error occurs
        if ( sd_retval <> VARANMANAGER_OK ) then        
          State := _CreateDOFailed;
          return;
        end_if;
          if b_LongDO then          
          s_DO_VSV_FrameReceive.p_LongDOSettings:= s_DO_VSV_FrameReceive.p_Handle + sizeof(LSL_VARANFRAME);
          s_DO_VSV_FrameReceive.p_DataRead      := s_DO_VSV_FrameReceive.p_LongDOSettings + sizeof(t_VSV_longDOSettings);

          s_DO_VSV_FrameSend.p_LongDOSettings   := s_DO_VSV_FrameSend.p_Handle + sizeof(LSL_VARANFRAME);
          s_DO_VSV_FrameSend.p_DataWrite        := s_DO_VSV_FrameSend.p_LongDOSettings + sizeof(t_VSV_longDOSettings);
        else
            
          s_DO_VSV_FrameReceive.p_Settings      := s_DO_VSV_FrameReceive.p_DataRead - VM_DO_OFFSET_RD;
          s_DO_VSV_FrameSend.p_Settings         := s_DO_VSV_FrameSend.p_DataWrite - VM_DO_OFFSET_WR;
          
        end_if;
      end_if; // if b_PayloadSupport then
    end_if;
     
    //-----------------------------------------------------------------------------------------------
    //call connect hardware function
    sd_retval := Varan_CallBack ( ud_reason := VARANMANAGER_CB_CONNECT
                                , ud_data   := 1
                                );

    //produce Varan Error if module not ok
    if ( sd_retval <> VARANMANAGER_OK ) then    
      VaranIn.SetVaranError( p_Node := p_VaranPosition );      
    end_if;
    //-----------------------------------------------------------------------------------------------    
  end_if;
  
  us_Initrun += 1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::Varan_HwConnect
  VAR_INPUT
    ud_data   : UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR
  VAR
    helpval : UINT;
    spi_macPointer    : UDINT;
    a_spiInfo : ARRAY [0..2] OF UDINT;
    spi_MacConfiguration : t_MACConfiguration;
    sz_buffer : ARRAY [0..12] OF CHAR;
    i : USINT;
    us_nibble : USINT;
    sz_nibble : ARRAY [0..2] OF CHAR;    
  END_VAR
  
  //------------------------------------------------------------------------------------------------
  //get node information
  sd_retval := GetNodeInfo();
  
  //if an error occurs in base class return
  if ( sd_retval <> VARANMANAGER_OK ) then
    return;
  end_if;

  To_MultiTask.TASKDELAY( timeout0 := 15ms ); 

  if b_useSwitchableSupply 
    & b_PayloadSupport = false then    
    s_DO_SwitchableOutput.p_DOSettings^.ud_Address := DeviceAddress + 1;    
  end_if;
    
  if CheckRTEthernetAvaliable() & RealtimeIP_Mode & (MaxSendLength > 0) & (RealtimeIP_PortNr >= 0) & (RealtimeIP_PortNr <= MaxIPPortNr) then

    b_RealtimeEthernetActive := TRUE;
  
    //*****************************************************************************
    //** read mac address from spi-flash                                         **
    //*****************************************************************************
    IF SearchSPIList(p_us_position_info:=p_VaranPosition, SearchID:=16#0B00_0000, p_BaseListAddress:=#spi_macPointer) = VARANMANAGER_OK THEN
      IF ReadSPIDataComfort(p_us_position_info := p_VaranPosition, ud_offset := spi_macPointer, ud_length := 12, p_data := ( #a_spiInfo[0] )$^USINT) = VARANMANAGER_OK THEN
        //** check if at least one entry is available in mac-address list *************
        IF a_spiInfo[2] >= 56 THEN
          IF ReadSPIDataComfort(p_us_position_info := p_VaranPosition, ud_offset := (spi_macPointer + 12) , ud_length := 56 , p_data := ( #spi_MacConfiguration )$^USINT ) = VARANMANAGER_OK THEN
            s_DO_VSV_FrameSend.p_DataWrite^.ETHFrame.Header.SrcAddr := spi_MacConfiguration.MACAddress;

            // filter setting
            if b_FilterEnabled then
              // filter set by user
              VSVConfig.RxDestMACAddr := MACFilter;
            else
              // mac address of VSV
              VSVConfig.RxDestMACAddr[0] := spi_MacConfiguration.MACAddress[5];
              VSVConfig.RxDestMACAddr[1] := spi_MacConfiguration.MACAddress[4];
              VSVConfig.RxDestMACAddr[2] := spi_MacConfiguration.MACAddress[3];
              VSVConfig.RxDestMACAddr[3] := spi_MacConfiguration.MACAddress[2];
              VSVConfig.RxDestMACAddr[4] := spi_MacConfiguration.MACAddress[1];
              VSVConfig.RxDestMACAddr[5] := spi_MacConfiguration.MACAddress[0];
            end_if;
            
            _memset(dest:=#sz_buffer[0], usByte:=0, cntr:=SIZEOF(sz_buffer));
            _memset(dest:=#sz_nibble[0], usByte:=0, cntr:=SIZEOF(sz_nibble));
            
            FOR i := 0 TO 5 DO
              
              us_nibble := (spi_MacConfiguration.MACAddress[i] SHR 4) AND 16#F;
              CASE us_nibble OF
                0..9:
                  sz_nibble[0] := '0' + us_nibble;
                10..15:
                  sz_nibble[0] := 'A' - 10 + us_nibble;
              END_CASE;
              
              us_nibble := spi_MacConfiguration.MACAddress[i] AND 16#F;
              CASE us_nibble OF
                0..9:
                  sz_nibble[1] := '0' + us_nibble;
                10..15:
                  sz_nibble[1] := 'A' - 10 + us_nibble;
              END_CASE;
              
              _strcat(dest:=#sz_buffer[0], src:=#sz_nibble[0]);        
              
            END_FOR;

            MacAddress.WriteDataOff(udLen:=_strlen(src:=#sz_buffer[0]), udOff:=0, pData:=#sz_buffer[0]);
          ELSE
            b_RealtimeEthernetActive := FALSE;
          END_IF;
        ELSE
          b_RealtimeEthernetActive := FALSE;
        END_IF;
      ELSE
        b_RealtimeEthernetActive := FALSE;
      END_IF;
    ELSE
      b_RealtimeEthernetActive := FALSE;
    END_IF;
  
    WriteConfig();//port und TX Config setzen

    //------------------------------------------------------------------------------------------------
    //correct address for data objects
    if b_LongDO then    
      if b_PayloadSupport = FALSE then
        s_DO_VSV_FrameSend.p_LongDOSettings^.ud_Address         := DeviceAddress + VSV_TX_FRAMELENGTH_OFFSET;
        s_DO_VSV_FrameSend.p_LongDOSettings^.ui_ByteCount0      := MaxFrameLength;
        s_DO_VSV_FrameSend.p_LongDOSettings^.us_ByteCount1      := 0;
        s_DO_VSV_FrameSend.p_Handle^.usSendBufferLength         := 16#FFFF;
        s_DO_VSV_FrameSend.p_Handle^.usLengthofExpAnswer        := 16#FFFF;
        
        s_DO_VSV_FrameReceive.p_LongDOSettings^.ud_Address      := DeviceAddress + VSV_RX_STATUSREG_OFFSET; 
        s_DO_VSV_FrameReceive.p_LongDOSettings^.ui_ByteCount0   := MaxFrameLength;
        s_DO_VSV_FrameReceive.p_LongDOSettings^.us_ByteCount1   := 0;
        s_DO_VSV_FrameReceive.p_Handle^.usSendBufferLength      := 16#FFFF;
        s_DO_VSV_FrameReceive.p_Handle^.usLengthofExpAnswer     := 16#FFFF;                      
      end_if;      
    else
      if b_PayloadSupport = FALSE then
        s_DO_VSV_FrameSend.p_Settings^.ud_Address     := DeviceAddress + VSV_TX_FRAMELENGTH_OFFSET;
        s_DO_VSV_FrameReceive.p_Settings^.ud_Address  := DeviceAddress + VSV_RX_STATUSREG_OFFSET;
      end_if;
    end_if;
  
    // write length register with direct access (must be set before first run of DOs)
    helpval := 0;
    if b_PayloadSupport then
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := VSV_TX_FRAMELENGTH_OFFSET
                                                    , udLength    := 2
                                                    , pusData     := ( #helpval )$^USINT
                                                    , pudErrorInfo:= NIL); 
                                                    
                                                          //look if an error occures
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        b_RealtimeEthernetActive := FALSE;
        return;
      end_if;
                                                  
    else
      sd_retval := VARAN_iWriteMemoryDA(  uiManager     := ud_VaranManagerNr
                                        , uiAddress     := DeviceAddress + VSV_TX_FRAMELENGTH_OFFSET
                                        , uiLen         := 2
                                        , uiRetryTimeout:= GetRetryTimeout( ud_bytes := 2 )
                                        , pvData        := #helpval
                                        , puiError      := NIL
                                        );

      //look if an error occures
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        b_RealtimeEthernetActive := FALSE;
        return;
      end_if;
    end_if;
    
    //Build SendFrame
    s_DO_VSV_FrameSend.p_DataWrite^.TXFrameLength                 := MaxSendLength;
    s_DO_VSV_FrameSend.p_DataWrite^.ETHFrame.Header.DestAddr      := DestMacAddr;
    s_DO_VSV_FrameSend.p_DataWrite^.ETHFrame.Header.ProtocolType  := ui_EtherNetProtocolType;
    
    
    //------------------------------------------------------------------------------------------------
    //set Pll data
    sd_retval := SetPllData();

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      b_RealtimeEthernetActive := FALSE;
      return;
    end_if;

    //set sync out counter 0 for isochron communication
    sd_retval := EnableSyncOut  ( us_sync_nr              := 0
                                , sd_offset               := sd_SyncOffset / 10
                                , us_period_multiplier    := 0
                                , us_frame_count_treshold := 0
                                , us_enable_frame_count   := 0
                                );

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      b_RealtimeEthernetActive := FALSE;
      return;
    end_if;

    //set sync out counter 1 for triple buffer switching
    sd_retval := EnableSyncOut  ( us_sync_nr              := 1
                                , sd_offset               := 0
                                , us_period_multiplier    := 0
                                , us_frame_count_treshold := 0
                                , us_enable_frame_count   := 0
                                );

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      b_RealtimeEthernetActive := FALSE;
      return;
    end_if;
    
    // start initializing the DOs
    eCycleWork  := _CycleStartIsoDO;
      
  else
    WriteSupplySettings();
    // do NOT initialize the ethernet DOs but go Online as well
    eCycleWork  := _CyclePreOperational;
    b_RealtimeEthernetActive := FALSE;    
  end_if;
  
  //------------------------------------------------------------------------------------------------
  //class ok
  State       := _ClassOk;
  bOnline     := TRUE;
  sd_retval   := VARANMANAGER_OK;

  if b_UseSenderMACasDestination = TRUE then
    b_FirstFrameReceived := FALSE;
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::CheckDeviceID
  VAR_INPUT
    ID2Check  : UDINT;
  END_VAR
  VAR_OUTPUT
    IsOK  : BOOL;
  END_VAR

  //look if it is right hardware
  if ( ID2Check <> VSV046_DEVICE_ID ) then
    IsOK := FALSE;
  else
    IsOK := TRUE;
  end_if;

END_FUNCTION

#pragma warning(disable:73 )
FUNCTION VSV046::DataReceivedDummy
  VAR_INPUT
    pBuf  : ^t_ETHFrame;
    Len   : UINT;
  END_VAR

END_FUNCTION
#pragma warning(default:73 )


FUNCTION GLOBAL VSV046::ConfigSendData
  VAR_INPUT
    ui_MaxLength  : UINT;
    ui_ProtocolType   : HINT;
    p_DestinationMacAddress   : ^t_MACAddr;
  END_VAR
  VAR_OUTPUT
    ret_code  : iprStates;
  END_VAR
  
  if (us_Initrun < 6) 
#ifdef IsTransparent_IS_AVAILABLE
  & ( IsTransparent() = FALSE ) 
#endif
  then
    
    if (ui_MaxLength > 0) & (ui_MaxLength <= VSV_TX_MAX_DATA_LENGTH ) then
      
      MaxSendLength := ui_MaxLength;  
      
      if (MaxSendLength + sizeof(t_VSV_DataReceive.RXStatusReg) + sizeof(t_VSV_DataReceive.TXStatusRegister) + sizeof(t_VSV_DataReceive.RXFrameLength) + sizeof(t_ETHFrameHeader)) > 128 then
        //*****************************************************************************************************************************************************************
        //**  Long-DO's mssen lt. Silberer mit einer Gre von einem vielfachen von 128 angelegt werden, sonst knnte mit Protocol version 1.2.5 ein Problem entstehen  **
        //**  welches behoben ist wenn PCI Device 0x212 eine Version >= 0x25 aufweist (auf dieses Device kann aber am C-IPC noch nicht sauber zugegriffen werden!!       **
        //*****************************************************************************************************************************************************************
        MaxFrameLength := ((MaxSendLength + sizeof(t_VSV_DataReceive.RXStatusReg) + sizeof(t_VSV_DataReceive.TXStatusRegister) + sizeof(t_VSV_DataReceive.RXFrameLength) + sizeof(t_ETHFrameHeader) + 127) / 128) * 128;
        
        b_LongDO := TRUE;
      else
        MaxFrameLength := MaxSendLength + sizeof(t_VSV_DataReceive.RXStatusReg) + sizeof(t_VSV_DataReceive.TXStatusRegister) + sizeof(t_VSV_DataReceive.RXFrameLength) + sizeof(t_ETHFrameHeader);       
        
        b_LongDO := FALSE;
      end_if;
      
      if p_DestinationMacAddress then
        DestMacAddr := p_DestinationMacAddress^;
        //--- MAC Addresse wurde bergeben, wir mssen nicht warten bis etwas empfangen wurde
        b_FirstFrameReceived := TRUE;
      else
        b_UseSenderMACasDestination := TRUE;
        b_FirstFrameReceived := FALSE;
      end_if;

      ui_EtherNetProtocolType := ui_ProtocolType;

      p_ReceiveBuffer$^void := To_StdLib.Malloc(size:=MaxSendLength + SIZEOF(t_ETHFrameHeader));
      p_SendBuffer$^void := To_StdLib.Malloc(size:=MaxSendLength + SIZEOF(t_ETHFrameHeader));

      ret_code := READY;
      
    else
    
      ret_code := ERROR;
      
    end_if;
    
  else
    
    ret_code := ERROR_BUSY;
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL VSV046::ConfigReceiveData
  VAR_INPUT
    p_ReceiveFunktion   : ^void;
    p_this  : ^void;
    p_FilterMacAddress  : ^t_MACAddr;
  END_VAR
  VAR_OUTPUT
    ret_code  : iprStates;
  END_VAR

  if (us_Initrun < 6)
#ifdef IsTransparent_IS_AVAILABLE
  & ( IsTransparent() = FALSE ) 
#endif
  then

    if ((p_ReceiveFunktion <> NIL) & (p_this <> NIL)) then
      
      if p_FilterMacAddress then
        MACFilter := p_FilterMacAddress^;
        b_FilterEnabled := TRUE;
      end_if;
      p_RXFunktion := p_ReceiveFunktion;
      p_RXThis     := p_this;
                
      ret_code := READY;
      
    else
    
      ret_code := ERROR;
      
    end_if;
    
  else
    
    ret_code := ERROR_BUSY;
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL VSV046::SetSendData
  VAR_INPUT
    p_Data  : ^void;
    ui_length   : UINT;
  END_VAR
  VAR_OUTPUT
    ret_code  : iprStates;
  END_VAR

  if (p_data <> NIL) & (ui_length > 0) & (ui_length <= MaxSendLength) (*& VSVStatus.IsLinked*) 
#ifdef IsTransparent_IS_AVAILABLE
  & ( IsTransparent() = FALSE ) 
#endif
  then
    
    Sendlength := ui_length;    

    _memcpy(ptr1:=#p_SendBuffer^.data[0], ptr2:=p_Data, cntr:=ui_length);
    
    VSVStatus.NewSendData := true;
    
    ret_code := READY;
    
  else
  
    ret_code := ERROR;
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL VSV046::WriteConfig
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR

  VSVConfig.TXConfig := 0;

  if RealtimeIP_Mode then
    
    if RealtimeIP_Mode = 1 then
    
      VSVConfig.TXConfig.StartTXWrite       := false;
      VSVConfig.TXConfig.EnableStartBySync  := true;
//      RealtimeIP_Mode                       := 1;
      
    else
    
      VSVConfig.TXConfig.EnableStartBySync  := false;
      VSVConfig.TXConfig.StartTXWrite       := true;
      RealtimeIP_Mode                       := 2;
      
    end_if;
    
    if DontCheckRxDestMAC.Read() then
      VSVConfig.FilterConfig.RXDestinationMacFilterEnable := FALSE;
      DontCheckRxDestMAC                                  := 1;
    else
      VSVConfig.FilterConfig.RXDestinationMacFilterEnable := TRUE;
//      DontCheckRxDestMAC                                  := 0;
    end_if;

    
    case sd_RealtimeIP_PortNr of
    
      0: 
          VSVConfig.TXConfig := VSVConfig.TXConfig or (1 SHL 2);
          SupplyVaranOut_0.Write(0);
      1: 
          VSVConfig.TXConfig := VSVConfig.TXConfig or (2 SHL 2);
          SupplyVaranOut_1.Write(0);
      2: 
          VSVConfig.TXConfig := VSVConfig.TXConfig or (3 SHL 2);
          SupplyVaranOut_2.Write(0);
      3: 
          VSVConfig.TXConfig := VSVConfig.TXConfig or (4 SHL 2);
          SupplyVaranOut_3.Write(0);
      4: 
          VSVConfig.TXConfig := VSVConfig.TXConfig or (5 SHL 2);
          SupplyVaranOut_4.Write(0);
    else
      UpdateTxConfig();
    end_case;

    // write config register with direct access
    if b_PayloadSupport then
      sd_retval := MULTI_VARAN_iExecuteDirectAccess(  hNodeHandle := ud_HandleModule
                                                    , udCommand   := VARAN_CMD_MEMORY_WRITE
                                                    , udOffset    := VSV_TXCONFIGREG_OFFSET
                                                    , udLength    := sizeof(VSVConfig)
                                                    , pusData     := ( #VSVConfig )$^USINT
                                                    , pudErrorInfo:= NIL); 
                                                    
      //look if an error occures
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        b_RealtimeEthernetActive := FALSE;
        return;
      end_if;
                                                  
    else
      sd_retval := VARAN_iWriteMemoryDA(  uiManager     := ud_VaranManagerNr
                                        , uiAddress     := DeviceAddress + VSV_TXCONFIGREG_OFFSET
                                        , uiLen         := sizeof(VSVConfig)
                                        , uiRetryTimeout:= GetRetryTimeout( ud_bytes := sizeof(VSVConfig) )
                                        , pvData        := #VSVConfig
                                        , puiError      := NIL
                                        );
      //look if an error occures
      if ( sd_retval <> VARANMANAGER_OK ) then
        State := _DirectAccessFailed;
        b_RealtimeEthernetActive := FALSE;
        return;
      end_if;
    end_if;
  end_if;
  
  WriteSupplySettings();
  
END_FUNCTION


FUNCTION VSV046::CheckReceivedFrame  
  VAR
    p_Funktion     : ^void;
    Len : UINT;
    pBuf : ^t_ETHFrame;
    p_Tx : ^t_VSV_FrameSend;
  END_VAR  
  
  if s_DO_VSV_FrameReceive.p_DataRead^.RXFrameLength < MaxSendLength then
    Len := s_DO_VSV_FrameReceive.p_DataRead^.RXFrameLength;
  else
    Len := MaxSendLength;
  end_if;
  
  _memcpy(ptr1:=p_ReceiveBuffer, ptr2:=#s_DO_VSV_FrameReceive.p_DataRead^.ETHFrame, cntr:=Len + SIZEOF(t_ETHFrameHeader));

  if b_FirstFrameReceived = FALSE then
  
    b_FirstFrameReceived := TRUE;
    
    p_Tx := s_DO_VSV_FrameSend.p_DataWrite;
    
    // copy received source MAC address to send destination MAC address
    if b_UseSenderMACasDestination then
      _memcpy(ptr1:=#p_Tx^.ETHFrame.Header.DestAddr[0], ptr2:=p_ReceiveBuffer + 6, cntr:= 6);  
    end_if;
    
    // we accept no MAC address with only zeros
    if (p_Tx^.ETHFrame.Header.DestAddr[0]$UDINT = 0) & (p_Tx^.ETHFrame.Header.DestAddr[4]$UINT = 0) then
    
      b_FirstFrameReceived := FALSE;
      
    end_if;
    
  end_if;
  
  pBuf := p_ReceiveBuffer; // attention: we change the this-pointer so we can no longer access p_ReceiveBuffer!
  
  p_Funktion := p_RXFunktion;
  THIS := p_RXThis $ ^VSV046;
  p_Funktion $ DataReceivedDummy( pBuf, Len );

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::UpdateRt

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StartTimeMeasurement(VARANTIME_RT);
#endif
//=================================================================================================
  
  // Call base class for disable Device, Cyclic call in VSV_Base is optional
  VSV_Base::UpdateRt();
  
  if bOnline <> FALSE then
  
    // state machine for initializing the DOs
    case eCycleWork of
      //**************************************************************************************
      _CycleInitIdle:

      //**************************************************************************************
      _CycleStartIsoDO: //_CycleStartAsyDO not used: UpdateRt is called in UpdateCy
        // init the DOs
        //------------------------------------------------------------------------------------------------
        if b_LongDO then
          DisableDO(ud_DOHandle:=s_DO_VSV_FrameSend.p_Handle$UDINT);
          EnableDO(ud_DOHandle:=s_DO_VSV_FrameReceive.p_Handle$UDINT, ud_bytes := 128);
        else
          DisableDO(ud_DOHandle:=s_DO_VSV_FrameSend.p_Handle$UDINT);
          EnableDO(ud_DOHandle:=s_DO_VSV_FrameReceive.p_Handle$UDINT, ud_bytes := MaxFrameLength);
        end_if;
        //------------------------------------------------------------------------------------------------
        eCycleWork := _CyclePreOperational; // wait 1 cycle till Online->1

        //**************************************************************************************
      _CyclePreOperational, _CycleOperational:
        //rt is passed through => data is valid
        if eCycleWork = _CyclePreOperational then
          // set class online
          Online     := 1;
          eCycleWork := _CycleOperational;
        end_if;
        
        if ( State = _ClassOk ) & MaxSendLength & b_RealtimeEthernetActive then

          if VSVStatus.IsLinked then
          
            if not s_DO_VSV_FrameReceive.p_DataRead^.RXStatusReg.LinkEstablished then
            
              Trace("Link Fast Ethernet lost");
              VSVStatus.IsLinked  := false;
              RealtimeIP_Link     := 0;
              
            end_if;
          
            //Frame Received??
            if s_DO_VSV_FrameReceive.p_DataRead^.RXStatusReg.FrameReceived then

              //Frame Auswerten         
              CheckReceivedFrame();

            end_if; 
          
          else //aktual no Link
            //Link
            if s_DO_VSV_FrameReceive.p_DataRead^.RXStatusReg.LinkEstablished then
            
              VSVStatus.IsLinked  := true;
              RealtimeIP_Link     := 1;
              
            end_if;   
            
          end_if; 
        
        end_if;

    end_case;
    
  end_if;
  
 
#ifndef CALL_OPTION_RT_POSTSCAN
  UpdateRtPostScan();
#endif
 
//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StopTimeMeasurement(VARANTIME_RT);
#endif
//================================================================================================= 
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::UpdateRtPostScan

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StartTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================

  if ( State = _ClassOk ) & MaxSendLength & b_RealtimeEthernetActive then

    if VSVStatus.IsLinked then

      if VSVStatus.NewSendData & b_FirstFrameReceived then
        VSVStatus.NewSendData := false;
        
        s_DO_VSV_FrameSend.p_DataWrite^.TXFrameLength := Sendlength + SIZEOF(t_ETHFrameHeader);

        _memcpy(ptr1:=#s_DO_VSV_FrameSend.p_DataWrite^.ETHFrame.Data, ptr2:=#p_SendBuffer^.Data, cntr:=SendLength);
        if b_PayloadSupport then
            s_DO_VSV_FrameSend.b_DOIsRunning.StartRequest :=TRUE;
        else
          if b_LongDO then
            //reset data object
            ResetDataObject ( p_handleDO  := s_DO_VSV_FrameSend.p_Handle                    
                            , us_state    := VARAN_DO_SINGLE_RUN
                            , ud_bytes    := 128
                            );
          else
            //reset data object
            ResetDataObject ( p_handleDO  := s_DO_VSV_FrameSend.p_Handle                    
                            , us_state    := VARAN_DO_SINGLE_RUN
                            , ud_bytes    := MaxFrameLength
                            );        
          end_if;
        end_if;
      end_if;

    end_if;

  end_if; 
  
  if b_PayloadSupport then
      
    case s_DO_VSV_FrameSend.b_DOIsRunning of
    
      SR_STATE_ENABLE_ME :  // DO is not running and start request is set ----------------------------------------
        EnableDO(ud_DOHandle := s_DO_VSV_FrameSend.p_Handle$UDINT);        
        s_DO_VSV_FrameSend.b_DOIsRunning  := SR_STATE_DISABLE_ME;
        
      SR_STATE_DISABLE_ME : // DO is running and start request is not set ----------------------------------------
        DisableDO(ud_DOHandle:= s_DO_VSV_FrameSend.p_Handle$UDINT);
        s_DO_VSV_FrameSend.b_DOIsRunning := SR_STATE_NOTHING;
        
      SR_STATE_LEAVE_ME_ENABLED : // DO is running and another start request is set ------------------------------
        s_DO_VSV_FrameSend.b_DOIsRunning := SR_STATE_DISABLE_ME;
        
    end_case;
  end_if;

//=================================================================================================
#ifdef VM_CLASS_TIME_MEASUREMENT
  StopTimeMeasurement(VARANTIME_RTPOSTSCAN);
#endif
//=================================================================================================
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::SyncOffset::Write
  VAR_INPUT
    input (EAX)   : UDINT;
  END_VAR
  VAR_OUTPUT
    result (EAX)  : UDINT;
  END_VAR
  VAR
    sd_retval : DINT;
  END_VAR

  if input <= 100  then
  
    sd_SyncOffset := ( ud_VaranTime - ((ud_VaranTime/100) * input))$DINT ;

    //set sync out counter 0 for isochron communication
    sd_retval := EnableSyncOut  ( us_sync_nr        := 0
                                , sd_offset         := sd_SyncOffset / 10
                                , us_period_multiplier    := 0
                                , us_frame_count_treshold := 0
                                , us_enable_frame_count   := 0
                                );

    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
    
      return;
      
    end_if;
    
    Syncoffset := input;

  end_if;

  result := Syncoffset;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::Varan_HwDisconnect
  VAR_INPUT
    ud_data   : UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR

  SetDOsOff();  

  b_RealtimeEthernetActive := FALSE;

  sd_retval   := VSV_Base::Varan_HwDisconnect( ud_data );
  
END_FUNCTION


FUNCTION VSV046::SearchSPIList
  VAR_INPUT
    p_us_position_info  : ^USINT;
    SearchID            : UDINT;
    p_BaseListAddress   : ^UDINT;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR
  VAR
    i       : UDINT;
    a_data  : ARRAY[0..31] OF UDINT;
  END_VAR

  if p_BaseListAddress = NIL then
    // invalid parameters
    sd_retval := -101;
    return;
  end_if;

  //read SPI data
  sd_retval := VaranIn.ReadSPIData( p_us_position_info  := p_us_position_info
                                  , ud_offset           := 0
                                  , ud_length           := 128 or VM_SPI_IDENT_LIST 
                                  , p_data              := ( #a_data )$^USINT
                                  );

  //look for an error
  if ( sd_retval <> VARANMANAGER_OK ) then
    State := _SPIError;
    return;
  end_if;

  //look for right Identifier
  if ( a_data[ 0 ] <> 16#12345678 ) then
    State := _SPIError;
    return;
  end_if;

  //look for valid length (we only read 128 Byte at the moment [16Byte are header])
  if( a_data[ 3 ] > (128 - 16 ) ) then
    State := _SPIError;
    return;
  end_if;

  //search for SPI Flash Configuration
  for i := 0 to a_data[ 3 ] / sizeof( UDINT ) do

    //look for configuration id in 3rd byte
    if ( ( a_data[ i + 4 ] and 16#FF00_0000 ) = SearchID ) then
      p_BaseListAddress^ := a_data[ i + 4 ] and 16#00FF_FFFF;
      sd_retval := 0;
      return;
    end_if;
    
  end_for;

  //if no entry is found
  sd_retval := -100;

END_FUNCTION


FUNCTION VSV046::ReadSPIDataComfort
  VAR_INPUT
    p_us_position_info  : ^USINT;
    ud_offset   : UDINT;
    ud_length   : UDINT;
    p_data  : ^USINT;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR
  VAR
    ud_read_length  : UDINT;
  END_VAR

  //look if we have a length
  if ( ud_length = 0 ) then
    sd_retval := -100;
    return;
  end_if;

  //look if data is in one page
  while ( ud_length <> 0 ) do
    
    //if length is above page size
    if ( ( ud_offset and 16#FF ) + ud_length > 16#FF ) then
      //how many bytes are in this page available
      ud_read_length := 16#100 - ( ud_offset and 16#FF );
      //not more than 128 Bytes
      if ( ud_read_length > 128 ) then
        ud_read_length := 128;
      end_if;
    else
      //not more than 128 Bytes
      if ( ud_length > 128 ) then
        ud_read_length := 128;
      else
        ud_read_length := ud_length;
      end_if;
    end_if;

    //read data
    sd_retval := VaranIn.ReadSPIData( p_us_position_info  := p_us_position_info,
                                      ud_offset       := ud_offset,
                                      ud_length       := ud_read_length,
                                      p_data        := p_data
                                    );
    //look for an error
    if ( sd_retval <> VARANMANAGER_OK ) then
      State := _SPIError;
      return;
    end_if;

    //correct length
    ud_length -= ud_read_length;
    ud_offset += ud_read_length;
    p_data += ud_read_length;
  end_while;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::SetDOsOff

  //stop data objects
  if s_DO_VSV_FrameSend.p_Handle & s_DO_VSV_FrameReceive.p_Handle then
    DisableDO(ud_DOHandle:=s_DO_VSV_FrameSend.p_Handle$UDINT);
    DisableDO(ud_DOHandle:=s_DO_VSV_FrameReceive.p_Handle$UDINT);
   
    s_DO_VSV_FrameSend.b_DOIsRunning := 0;
        
  end_if;
  
  if s_DO_SwitchableOutput.p_Handle then
    DisableDO(ud_DOHandle:=s_DO_SwitchableOutput.p_Handle$UDINT);
    s_DO_SwitchableOutput.b_DOIsRunning := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::Varan_HwInterrupt
  VAR_INPUT
    ud_reason   : UDINT;
    ud_data   : ^t_CallBackInterrupt;
  END_VAR
  VAR_OUTPUT
    sd_retval   : DINT;
  END_VAR

  SetDOsOff();  

  b_RealtimeEthernetActive := FALSE;

  sd_retval   := VSV_Base::Varan_HwInterrupt( ud_reason, ud_data );

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::UpdateRetryCounter
  VAR
    TempRetryCounter : USINT;
  END_VAR

  if s_DO_VSV_FrameSend.p_Handle then
    tempRetryCounter := GetRetryCounter(ud_DOHandle := s_DO_VSV_FrameSend.p_Handle$UDINT);
    if ( tempRetryCounter <> s_DO_VSV_FrameSend.us_OldRetryCounter ) then
      RetryCounter += TO_USINT( tempRetryCounter - s_DO_VSV_FrameSend.us_OldRetryCounter );
      s_DO_VSV_FrameSend.us_OldRetryCounter := tempRetryCounter;
  end_if;
  end_if;

  if s_DO_VSV_FrameReceive.p_Handle then   
    TempRetryCounter := GetRetryCounter(ud_DOHandle := s_DO_VSV_FrameReceive.p_Handle$UDINT);
    if ( tempRetryCounter <> s_DO_VSV_FrameReceive.us_OldRetryCounter ) then
      RetryCounter += TO_USINT( tempRetryCounter - s_DO_VSV_FrameReceive.us_OldRetryCounter );
      s_DO_VSV_FrameReceive.us_OldRetryCounter := tempRetryCounter;
  end_if;
  end_if;
  
  // check also the base
  VSV_Base::UpdateRetryCounter();

END_FUNCTION


FUNCTION VIRTUAL VSV046::GetMaxIP_PortNr
  
  // if a derivation has more ports, it needs to overwrite this method
  MaxIPPortNr := 4;

END_FUNCTION


FUNCTION VIRTUAL VSV046::UpdateTxConfig

  // if a derivation has more ports, it needs to overwrite this method and handle all ports > 4
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::GetDeviceID
  VAR_OUTPUT
    output  : UDINT;
  END_VAR

  output := VSV046_DEVICE_ID;
  
END_FUNCTION


FUNCTION VIRTUAL VSV046::CheckRTEthernetAvaliable
  VAR_OUTPUT
    bIsAvaliable  : BOOL;
  END_VAR

  bIsAvaliable := FALSE;
  
  // realtime ethernet is available since FPGA v1.3
  if (Release >= 16#13) then
    bIsAvaliable := TRUE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL VSV046::CheckPostInitNeeded
	VAR_INPUT
		pbPostInitSettings 	: ^t_VM_CMD_NEED_POST_INIT_CALL_SETTINGS;
	END_VAR
	VAR_OUTPUT
		PostInitNeeded 	: BOOL;
	END_VAR

  if pbPostInitSettings <> NIL then
    pbPostInitSettings^ := 0;
  end_if;
  
  PostInitNeeded := TRUE;
  
END_FUNCTION
