//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "sLineHandler"
	Revision           = "1.0"
	GUID               = "{1E929842-EB37-40CC-82CF-C02C1A8B0E0B}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(1140,1440)">
	<Channels>
		<Server Name="actLengthInInput" GUID="{C1D6378D-0389-4CDC-9242-5ABF2A89A12C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="actMathHeigth" GUID="{7C6AD9A7-93C8-4C99-8380-C4D3171A61A8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="actMathWidth" GUID="{F7D11805-B589-4415-8CEE-C682999862F5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="amountDone" GUID="{3F1BBB91-89A9-4F78-8007-DAFC8A82E302}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="amountToDo" GUID="{B1282BF2-6018-4E78-94F5-CCAE9C791D27}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="BackOffMaterial" GUID="{7044BB86-323A-484C-8F5A-FD0CC5D5BDB4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ClassSvr" GUID="{13FD1948-647C-4524-B678-DE9E66FD2E76}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="FrontOffMaterial" GUID="{2355CC97-3A74-4C64-A63B-775A157C82BE}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="lineNrInput" GUID="{A4D278DA-DE7A-423B-8CC5-5D7402A5DB7B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="lineNrOutput" GUID="{074DB6FE-401F-44C9-879B-8A229FCEA757}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="reReadAmountToDo" GUID="{0E4DF8EF-9373-466F-8F98-36F2692ED823}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ResetBackOffMaterial" GUID="{4772EF9E-4A38-43EF-8E1F-C74C232C5042}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ResetFrontOffMaterialToTakeIn" GUID="{28B89FEC-EBD7-4AB6-87F7-B91C6107D6B8}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="rnrInput" GUID="{188C8393-0F87-4CCB-9F2E-6999B3093F73}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="rnrOutput" GUID="{DCDE6D2E-9A19-4555-997C-6DC776E325B5}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sSetBackOffMaterialAfterSawing" GUID="{AD7655C7-D05E-4E28-B260-9294A7CF8784}" Visualized="false" Initialize="true" DefValue="1" WriteProtected="true" Retentive="false"/>
		<Server Name="stopAfterLength" GUID="{CF12F82E-F4F3-4680-A448-B92F1FDAC889}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprInputSide" GUID="{FE0C5BF5-BEC3-4FB2-A214-1C89163BE094}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprOutputSide" GUID="{EFEB5C7D-AA12-404B-A8A3-8B751AF9B522}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsCompleted" GUID="{1542ACC4-9DC2-48B2-A7A9-D0E8EC83188C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsStartedFromPC" GUID="{41371939-2022-4412-9720-35A46003D6A4}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="thisUnitIsSaw" GUID="{5C876D9A-95EF-4169-B271-209A8DD15003}" Visualized="false" Initialize="true" DefValue="1" WriteProtected="true" Retentive="false"/>
		<Client Name="ctrlMain" Required="true" Internal="false"/>
		<Client Name="ctrlReadIn" Required="true" Internal="false"/>
		<Client Name="iActMathHeigth" Required="true" Internal="false"/>
		<Client Name="iActMathWidth" Required="true" Internal="false"/>
		<Client Name="iAmountToDo" Required="true" Internal="false"/>
		<Client Name="iInputLength" Required="true" Internal="false"/>
		<Client Name="iLiveXPos" Required="true" Internal="false"/>
		<Client Name="iOffsetInputMaterial" Required="true" Internal="false"/>
		<Client Name="listSLines" Required="true" Internal="false"/>
		<Client Name="oAmountDone" Required="true" Internal="false"/>
		<Client Name="oAmountDoneOutput" Required="false" Internal="false"/>
		<Client Name="oLineNrInput" Required="true" Internal="false"/>
		<Client Name="oLineNrOutput" Required="true" Internal="false"/>
	</Channels>
</Class>
*)
sLineHandler : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	stsCompleted 	: SvrCh_DINT;
	stsStartedFromPC 	: SvrCh_DINT;
	stprInputSide 	: SvrCh_DINT;
	stprOutputSide 	: SvrCh_DINT;
	FrontOffMaterial 	: SvrCh_DINT;
	BackOffMaterial 	: SvrCh_DINT;
	ResetBackOffMaterial 	: SvrCh_DINT;
	ResetFrontOffMaterialToTakeIn 	: SvrCh_DINT;
	actLengthInInput 	: SvrCh_DINT;
	actMathHeigth 	: SvrCh_DINT;
	actMathWidth 	: SvrCh_DINT;
	lineNrInput 	: SvrCh_DINT;
	lineNrOutput 	: SvrCh_DINT;
	stopAfterLength 	: SvrCh_DINT;
	amountToDo 	: SvrCh_DINT;
	amountDone 	: SvrCh_DINT;
	reReadAmountToDo 	: SvrCh_DINT;
	thisUnitIsSaw 	: SvrCh_Units;
	sSetBackOffMaterialAfterSawing 	: SvrCh_DINT;
	rnrInput 	: SvrCh_DINT;
	rnrOutput 	: SvrCh_DINT;
  //Clients:
	listSLines 	: CltChCmd_GlobalList;
	ctrlMain 	: CltChCmd_mainControl;
	iInputLength 	: CltCh_DINT;
	iAmountToDo 	: CltCh_DINT;
	iOffsetInputMaterial 	: CltCh_DINT;
	iLiveXPos 	: CltCh_DINT;
	iActMathWidth 	: CltCh_DINT;
	iActMathHeigth 	: CltCh_DINT;
	oAmountDone 	: CltCh_DINT;
	oAmountDoneOutput 	: CltCh_DINT;
	oLineNrInput 	: CltCh_DINT;
	oLineNrOutput 	: CltCh_DINT;
	ctrlReadIn 	: CltChCmd_readInGlobalList;
  //Variables:
		actInputLine 	: SRegelInfo;
		actOutputLine 	: SRegelInfo;
		firstStart 	: DINT;
		lastFrontPosDuringSawing 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION GLOBAL startProgram
		VAR_INPUT
			LineNrInput2 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL stopProgram;
	
	FUNCTION stepperInput;
	
	FUNCTION stepperOutput;
	
	FUNCTION VIRTUAL GLOBAL ResetBackOffMaterial::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ResetFrontOffMaterialToTakeIn::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL actMathHeigth::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL reReadAmountToDo::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rnrInput::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL rnrOutput::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd GlobalList
#pragma usingLtd mainControl
#pragma usingLtd readInGlobalList


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB sLineHandler::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_SLINEHANDLER
1$UINT, 0$UINT, (SIZEOF(::sLineHandler))$UINT, 
22$UINT, 13$UINT, 0$UINT, 
TO_UDINT(3361655140), "sLineHandler", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::sLineHandler.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::sLineHandler.stsCompleted.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(843549521), "stsCompleted", 
(::sLineHandler.stsStartedFromPC.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4172353927), "stsStartedFromPC", 
(::sLineHandler.stprInputSide.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2305139321), "stprInputSide", 
(::sLineHandler.stprOutputSide.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1594253634), "stprOutputSide", 
(::sLineHandler.FrontOffMaterial.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2084825204), "FrontOffMaterial", 
(::sLineHandler.BackOffMaterial.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2359158756), "BackOffMaterial", 
(::sLineHandler.ResetBackOffMaterial.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4089552674), "ResetBackOffMaterial", 
(::sLineHandler.ResetFrontOffMaterialToTakeIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2043206199), "ResetFrontOffMaterialToTakeIn", 
(::sLineHandler.actLengthInInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(645540562), "actLengthInInput", 
(::sLineHandler.actMathHeigth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2731612740), "actMathHeigth", 
(::sLineHandler.actMathWidth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1817278248), "actMathWidth", 
(::sLineHandler.lineNrInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(511418896), "lineNrInput", 
(::sLineHandler.lineNrOutput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4067832021), "lineNrOutput", 
(::sLineHandler.stopAfterLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4005214858), "stopAfterLength", 
(::sLineHandler.amountToDo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2304864502), "amountToDo", 
(::sLineHandler.amountDone.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3275892477), "amountDone", 
(::sLineHandler.reReadAmountToDo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2605041502), "reReadAmountToDo", 
(::sLineHandler.thisUnitIsSaw.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3013402217), "thisUnitIsSaw", 
(::sLineHandler.sSetBackOffMaterialAfterSawing.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(154433938), "sSetBackOffMaterialAfterSawing", 
(::sLineHandler.rnrInput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3456994160), "rnrInput", 
(::sLineHandler.rnrOutput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3205769124), "rnrOutput", 
//Clients:
(::sLineHandler.listSLines.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3982737639), "listSLines", TO_UDINT(2390595228), "GlobalList", 0$UINT, 0$UINT, 
(::sLineHandler.ctrlMain.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1628845243), "ctrlMain", TO_UDINT(116908342), "mainControl", 2$UINT, 1$UINT, 
(::sLineHandler.iInputLength.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(52482704), "iInputLength", 
(::sLineHandler.iAmountToDo.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2892598790), "iAmountToDo", 
(::sLineHandler.iOffsetInputMaterial.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2417428025), "iOffsetInputMaterial", 
(::sLineHandler.iLiveXPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2530943056), "iLiveXPos", 
(::sLineHandler.iActMathWidth.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(585657478), "iActMathWidth", 
(::sLineHandler.iActMathHeigth.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2482056624), "iActMathHeigth", 
(::sLineHandler.oAmountDone.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(251597390), "oAmountDone", 
(::sLineHandler.oAmountDoneOutput.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3352254237), "oAmountDoneOutput", 
(::sLineHandler.oLineNrInput.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1289682194), "oLineNrInput", 
(::sLineHandler.oLineNrOutput.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(472577190), "oLineNrOutput", 
(::sLineHandler.ctrlReadIn.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(413193027), "ctrlReadIn", TO_UDINT(3217018748), "readInGlobalList", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_sLineHandler 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_sLineHandler] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION sLineHandler::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_sLineHandler, pCmd := #vmt.CmdTable);
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsStartedFromPC.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stsStartedFromPC.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprInputSide.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprInputSide.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprOutputSide.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprOutputSide.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FrontOffMaterial.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF FrontOffMaterial.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BackOffMaterial.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF BackOffMaterial.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ResetBackOffMaterial.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ResetBackOffMaterial::Write() );
	IF ResetBackOffMaterial.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ResetFrontOffMaterialToTakeIn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ResetFrontOffMaterialToTakeIn::Write() );
	IF ResetFrontOffMaterialToTakeIn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	actLengthInInput.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF actLengthInInput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	actMathHeigth.pMeth			:= StoreMethod( #actMathHeigth::Read(), #M_WR_DIRECT() );
	IF actMathHeigth.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	actMathWidth.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF actMathWidth.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	lineNrInput.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF lineNrInput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	lineNrOutput.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF lineNrOutput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stopAfterLength.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stopAfterLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	amountToDo.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF amountToDo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	amountDone.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF amountDone.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	reReadAmountToDo.pMeth			:= StoreMethod( #M_RD_DIRECT(), #reReadAmountToDo::Write() );
	IF reReadAmountToDo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	rnrInput.pMeth			:= StoreMethod( #M_RD_DIRECT(), #rnrInput::Write() );
	IF rnrInput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	rnrOutput.pMeth			:= StoreMethod( #M_RD_DIRECT(), #rnrOutput::Write() );
	IF rnrOutput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 20-6-2019: sLineHandler created for 4284 TraffiRoad. Goal is to handle the s lines for the units
// just run all the sLinerules from begin to end

FUNCTION VIRTUAL GLOBAL sLineHandler::reReadAmountToDo::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	reReadAmountToDo := input;
  iAmountToDo:=iAmountToDo.Read();
  amountToDo:=iAmountToDo;
	result := reReadAmountToDo;

END_FUNCTION


FUNCTION GLOBAL sLineHandler::startProgram
	VAR_INPUT
		LineNrInput2 	: DINT;
	END_VAR

  //set everything right for starting
  IF stprInputSide= 0 THEN
    stsCompleted:=0;
    lineNrInput:=LineNrInput2;//0;
    lineNrOutput:=0;
    iInputLength:=iInputLength.Read();
    FrontOffMaterial:=FAULTVALUE; //on start there should be no material, so set values on fault value else we can't possible not start (doesn't fit then)
    BackOffMaterial:=-1*FAULTVALUE;
    oAmountDone:=oAmountDone.Read(); //at start, read in amount already done
    oAmountDoneOutput:=oAmountDone;
    IF stsStartedFromPC= 0 THEN
      amountDone:=oAmountDone;
    ELSE
      amountDone:=0;
    END_IF;
    firstStart:=1;
    stprInputSide:=1;
  END_IF;

END_FUNCTION


FUNCTION GLOBAL sLineHandler::stopProgram

  //just stop it
  stprInputSide:=0;
  stprOutputSide:=0;
  stsCompleted:= 0;


END_FUNCTION


FUNCTION sLineHandler::stepperInput

  CASE stprInputSide OF
  
  0: //wait
    stsCompleted:= 0;  
  
  1: //take next sLine
    actInputLine:=listSLines.readLine(Nr:=lineNrInput);
    IF actInputLine.Units.DoWithOutput= 0 THEN //check if we have to do this line with the input
      oLineNrInput:=actInputLine.Rnr;
      oLineNrInput.Write(input:=oLineNrInput);
      rnrInput:=oLineNrInput;      
      stprInputSide+= 1;
    ELSE
      IF actInputLine.Command= STARTOUTPUT THEN //start working with output, but only if outputstepper is 0
        IF stprOutputSide= 0 THEN
          BackOffMaterial:=0; //for 4255 taking away material with output is always from sawing pos 
          lineNrOutput:=lineNrInput+1;
          lineNrInput+= 1;
          stprOutputSide:=1;
        END_IF;
      ELSE
        lineNrInput+=1; //just ignore this rule, because it's for the output      
      END_IF;
    END_IF;
  
  2: //do line action
    CASE actInputLine.Command OF
    
    STARTCOM: //reset act length input, if first start, read in to do and from line
      IF stsStartedFromPC= 0 THEN
        actLengthInInput:=iInputLength;
        iActMathHeigth:= iActMathHeigth.Read(); //JdK 29-9-2020: should go through sline list, but isn't ready yet
        iActMathWidth:= iActMathWidth.Read();
        actMathHeigth:= iActMathHeigth;
        actMathWidth:= iActMathWidth;
      ELSE
        actLengthInInput:= ctrlReadIn.stsActInputLength;
        actMathHeigth:= ctrlReadIn.stsActInputHeigth;
        actMathWidth:= ctrlReadIn.stsActInputWidth;
      END_IF;
      
      IF firstStart=1 THEN
        amountToDo:=actInputLine.Amount;
        firstStart:=0;
      END_IF;
      stprInputSide:=5;
      
    STOPCOM:
      amountDone+=1;
      IF stsStartedFromPC= 0 THEN
        oAmountDone+=1; //one extra ready
        oAmountDone.Write(input:=oAmountDone);
      END_IF;
      FrontOffMaterial:= FAULTVALUE; //ready with production on input, so reset front off material
      lineNrInput:=-1; //because in stpr 5 value 1 is added
      IF stopAfterLength= 1 THEN
        stprInputSide:= 10; //wait there until output is ready, but after restart we can go on
        stopAfterLength:= 0;
      ELSIF amountDone >= amountToDo THEN //amount reached
        IF stsStartedFromPC= 0 THEN
          stprInputSide:= 20; //JdK 7-10-2020 only do one assembly 15; //check if we can produce next assembly
        ELSE
          stprInputSide:= 12; //check if we have to do next profile
        END_IF;
      ELSE
        stprInputSide:=5;
      END_IF;
      
    WAITOPERATIONCOM, WAITFOROUTPUT:
      stprInputSide+= 1;
      
    UNITMOVECOM, UNITSTARTCOM, CHANGETOOL: 
      IF ctrlMain.startSLine(sLine:=actInputLine)= 1 THEN //just start it until we get a 1 back
        IF (actInputLine.Units AND thisUnitIsSaw)>0 & actInputLine.Command= UNITSTARTCOM THEN //means sawing is started
          lastFrontPosDuringSawing:= FrontOffMaterial;
          FrontOffMaterial:=0; //because sawing is done
          IF sSetBackOffMaterialAfterSawing= 1 & stprOutputSide= 0 THEN //for machines without outputrules, set back of material right after sawing
            BackOffMaterial:= 0;
          END_IF;
          iLiveXPos:=iLiveXPos.Read();
          actLengthInInput:= iLiveXPos;
        END_IF;
        stprInputSide:=5;
      ELSE
        //give alarm? started action at wrong time or started not existed unit
      END_IF;
      
    ELSE
      //give alarm for not possible command
    
    END_CASE;
    
  3: //wait actions
    IF actInputLine.Command= WAITOPERATIONCOM THEN
      IF ctrlMain.askReadySLine(sLine:=actInputLine)= 1 THEN //wait until we get back a ready
        stprInputSide:=5;
      END_IF;
    ELSIF actInputLine.Command= WAITFOROUTPUT THEN
      IF stprOutputSide= 0 THEN //just wait until output is done
        stprInputSide:=5;
      END_IF;
    END_IF;
  
  5: //prepare for next line
    lineNrInput+=1;
    stprInputSide:= 1;
    
  10: //stop after length place, wait until output done
    IF stprOutputSide= 0 THEN
      stprInputSide+=1;
    END_IF;
    
  11: //after main puts machine in hold (also in and output), main also sets stpr input to 5

  12: //check if we have to do next program in list (started from pc)
  
  13: //just wait
  
  14: //restart with next line
    lineNrInput:= 0;
    stprInputSide:= 1;
 
  15: //wait until output is done
    IF stprOutputSide= 0 THEN
      stprInputSide+= 1;
    END_IF; 
    
  16: //write next recipeid to assembly
    //ctrlAssembly.RecipeId.Write(input:=ctrlAssembly.RecipeId+1);
    iAmountToDo:= iAmountToDo.Read();
    oAmountDone:= oAmountDone.Read();
    iInputLength:= iInputLength.Read();
    IF iAmountToDo > oAmountDone & iInputLength > 0 THEN
      ctrlMain.calcNext();
      stprInputSide:= 0;
    ELSE
      stprInputSide:= 20; //next is also empty, so stop it
    END_IF;
    
  17: //step after stopped after length
    IF amountDone >= amountToDo THEN //amount reached
      IF stsStartedFromPC= 0 THEN
        stprInputSide:= 15; //check if we can produce next assembly
      ELSE
        stprInputSide:= 12; //check if we have to do next profile
      END_IF;
    ELSE
      stprInputSide:=5;
    END_IF;  
  
  20: //wait until output is done
    IF stprOutputSide= 0 THEN
      stprInputSide+= 1;
    END_IF;
    
  21: //give ready signal, stop is done by main
    stsCompleted:=1;
  
  
  END_CASE;


END_FUNCTION


FUNCTION sLineHandler::stepperOutput

  CASE stprOutputSide OF
  
  0: //just wait
  
  1: //get new line
    actOutputLine:= listSLines.readLine(Nr:=lineNrOutput);
    IF actOutputLine.Units.DoWithOutput= 1 THEN
      oLineNrOutput:= lineNrOutput;
      oLineNrOutput.Write(input:=oLineNrOutput);
      rnrOutput:=oLineNrOutput;      
      stprOutputSide+=1;
    ELSE
      lineNrOutput+= 1;
    END_IF;
    
  2: //do line action
    CASE actOutputLine.Command OF
    
    STARTCOM: //should not happen for output
      stprOutputSide:=5; //just ignore
      
    STOPCOM: //do counting and ready, counting is discussion, is it the only stopcom for this product?
      oAmountDoneOutput+=1;
      oAmountDoneOutput.Write(input:=oAmountDoneOutput);
      //dont reset backside, because material can still be somewehere on the outputlane
      lineNrOutput:=0;
      stprOutputSide:=0; //after stopcom, just stop
      
    WAITOPERATIONCOM:
      stprOutputSide+= 1;
      
    UNITMOVECOM, UNITSTARTCOM, CHANGETOOL: 
      IF ctrlMain.startSLine(sLine:=actOutputLine)= 1 THEN //just start it until we get a 1 back
        stprOutputSide:=5;
      ELSE
        //give alarm? started action at wrong time or started not existed unit
      END_IF;
      
    ELSE
      //give alarm for not possible command   
      
    END_CASE;

  3: //waiting action, for output should only be wait operation
    IF actOutputLine.Command= WAITOPERATIONCOM THEN
      IF ctrlMain.askReadySLine(sLine:=actOutputLine)= 1 THEN //wait until we get back a ready
        stprOutputSide:=5;
      END_IF;
    END_IF;
  
  5: //prepare for next line
    lineNrOutput+=1;
    stprOutputSide:= 1;  
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL sLineHandler::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR


  stepperInput();
  stepperOutput();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL sLineHandler::ResetFrontOffMaterialToTakeIn::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  //after take in new material, we have to reset front to offset of input
	ResetFrontOffMaterialToTakeIn := input;
  iOffsetInputMaterial:=iOffsetInputMaterial.Read();
  FrontOffMaterial:=iOffsetInputMaterial;
	result := ResetFrontOffMaterialToTakeIn;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL sLineHandler::ResetBackOffMaterial::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ResetBackOffMaterial := input;
  BackOffMaterial:=ResetBackOffMaterial;
	result := ResetBackOffMaterial;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL sLineHandler::actMathHeigth::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  iActMathHeigth:= iActMathHeigth.Read(); //temp solution, should come from calclist
  //actMathHeigth:= iActMathHeigth;
	output := actMathHeigth;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL sLineHandler::rnrInput::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	rnrInput := input;
  oLineNrInput:=rnrInput;
  oLineNrInput.Write(input:=oLineNrInput);
	result := rnrInput;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL sLineHandler::rnrOutput::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	rnrOutput := input;
  oLineNrOutput:=rnrOutput;
  oLineNrOutput.Write(input:=oLineNrOutput);
	result := rnrOutput;

END_FUNCTION
