//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "switchesAxis"
	Revision           = "0.0"
	GUID               = "{2A0FCD44-E98D-4646-AE89-B385FACE8C0D}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{0E84F852-8DEF-4324-9E25-8C08EF466591}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="maxSwitch" GUID="{2FB513A8-D2D3-4B30-B4CD-762B6488D8A1}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="minSwitch" GUID="{0052E06F-752F-499A-AF37-2BFEC8D7A518}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="overRuleMax" GUID="{1D8440F6-1D85-4DC0-A7B8-348F5F2A65F7}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="overRuleMin" GUID="{FF8E6716-F9B6-4CA6-AEA1-066E819DAFE9}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="overRuleRef" GUID="{403AD4A1-8F9C-41C2-ADC0-09B67FC3EEDA}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="refSwitch" GUID="{22C363AB-CCF0-49B2-9911-8B8EED4FD279}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="switchMaxIsNormallyOpen" GUID="{F7459E06-708A-41EF-AE76-6C291617BBFD}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="switchMinIsNormallyOpen" GUID="{24021799-8174-4948-B140-3F05DC0CBBD3}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Client Name="ctrlServo" Required="true" Internal="false"/>
		<Client Name="iEsMaxSwitch" Required="false" Internal="false"/>
		<Client Name="iEsMinSwitch" Required="false" Internal="false"/>
		<Client Name="iEsRefSwitch" Required="false" Internal="false"/>
	</Channels>
</Class>
*)
switchesAxis : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	minSwitch 	: SvrCh_DINT;
	maxSwitch 	: SvrCh_DINT;
	refSwitch 	: SvrCh_DINT;
	switchMinIsNormallyOpen 	: SvrCh_DINT;
	switchMaxIsNormallyOpen 	: SvrCh_DINT;
	overRuleMin 	: SvrCh_DINT;
	overRuleMax 	: SvrCh_DINT;
	overRuleRef 	: SvrCh_DINT;
  //Clients:
	iEsMinSwitch 	: CltCh_DINT;
	iEsMaxSwitch 	: CltCh_DINT;
	iEsRefSwitch 	: CltCh_DINT;
	ctrlServo 	: CltChCmd_cmServo;
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL minSwitch::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL maxSwitch::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL refSwitch::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd cmServo


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB switchesAxis::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_SWITCHESAXIS
0$UINT, 0$UINT, (SIZEOF(::switchesAxis))$UINT, 
9$UINT, 4$UINT, 0$UINT, 
TO_UDINT(1319820962), "switchesAxis", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::switchesAxis.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::switchesAxis.minSwitch.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3319859745), "minSwitch", 
(::switchesAxis.maxSwitch.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(302692448), "maxSwitch", 
(::switchesAxis.refSwitch.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3537427625), "refSwitch", 
(::switchesAxis.switchMinIsNormallyOpen.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3332733092), "switchMinIsNormallyOpen", 
(::switchesAxis.switchMaxIsNormallyOpen.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3543051350), "switchMaxIsNormallyOpen", 
(::switchesAxis.overRuleMin.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(140960492), "overRuleMin", 
(::switchesAxis.overRuleMax.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(879484341), "overRuleMax", 
(::switchesAxis.overRuleRef.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3178414495), "overRuleRef", 
//Clients:
(::switchesAxis.iEsMinSwitch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(13360487), "iEsMinSwitch", 
(::switchesAxis.iEsMaxSwitch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3609227046), "iEsMaxSwitch", 
(::switchesAxis.iEsRefSwitch.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(401738735), "iEsRefSwitch", 
(::switchesAxis.ctrlServo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2859050432), "ctrlServo", TO_UDINT(3985303601), "cmServo", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_switchesAxis 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_switchesAxis] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION switchesAxis::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_switchesAxis, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	minSwitch.pMeth			:= StoreMethod( #minSwitch::Read(), #M_NO_F() );
	IF minSwitch.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	maxSwitch.pMeth			:= StoreMethod( #maxSwitch::Read(), #M_NO_F() );
	IF maxSwitch.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	refSwitch.pMeth			:= StoreMethod( #refSwitch::Read(), #M_NO_F() );
	IF refSwitch.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	switchMinIsNormallyOpen.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF switchMinIsNormallyOpen.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	switchMaxIsNormallyOpen.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF switchMaxIsNormallyOpen.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	overRuleMin.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF overRuleMin.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	overRuleMax.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF overRuleMax.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	overRuleRef.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF overRuleRef.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 22-3-2022: switchesAxis, connect the endswitches to the axis, also handles the simulation states, goal is to make it less work to go to and from simulation

FUNCTION VIRTUAL GLOBAL switchesAxis::minSwitch::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  iEsMinSwitch:= iEsMinSwitch.Read();
  IF overRuleMin<> 0 THEN
   minSwitch:= overRuleMin>0;
  ELSIF ctrlServo.stsAllSimuActive THEN
    IF ctrlServo.parRefDirPositive= 0 THEN
      minSwitch:= ctrlServo.stsSimRef; //homing negative
    ELSE
      minSwitch:= 0;
    END_IF;
  ELSE
    IF switchMinIsNormallyOpen THEN
      minSwitch:= iEsMinSwitch;
    ELSE
      minSwitch:= iEsMinSwitch= 0; //invert signal
    END_IF;
  END_IF;

	output := minSwitch;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL switchesAxis::maxSwitch::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  iEsMaxSwitch:= iEsMaxSwitch.Read();
  IF overRuleMax<> 0 THEN
    maxSwitch:= overRuleMax>0;
  ELSIF ctrlServo.stsAllSimuActive THEN
    IF ctrlServo.parRefDirPositive= 1 THEN
      maxSwitch:= ctrlServo.stsSimRef; //homing positive
    ELSE
      MaxSwitch:= 0;
    END_IF;
  ELSE
    IF switchMaxIsNormallyOpen THEN
      maxSwitch:= iEsMaxSwitch;
    ELSE
      maxSwitch:= iEsMaxSwitch= 0; //invert signal
    END_IF;
  END_IF;
	output := maxSwitch;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL switchesAxis::refSwitch::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

  iEsRefSwitch:= iEsRefSwitch.Read();
  IF overRuleRef<> 0 THEN
    refSwitch:= overRuleRef>0;
  ELSIF ctrlServo.stsAllSimuActive & ctrlServo.parNoRefSwitch= 0 THEN
    refSwitch:= ctrlServo.stsSimRef;
  ELSE
    refSwitch:= iEsRefSwitch;
  END_IF;

	output := refSwitch;

END_FUNCTION
