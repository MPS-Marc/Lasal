//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\_DriveMngBase\SDDDefinitions.h"

(*!
<Class
	Name               = "_DriveAxisSet"
	Revision           = "1.21"
	GUID               = "{EDF12091-F02E-45AF-90DB-21527D7AAE51}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\_DriveMngBase\Drive.ico"
	SharedCommandTable = "true"
	Objectsize         = "(586,120)"
	Comment            = "internal class for the Drive&#13;&#10;(does the file- and parameterhandling)">
	<Channels>
		<Server Name="Server0" GUID="{818AD4D9-9CEC-4FC6-BD25-D4B3C1BBDE46}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="coLinker" Required="false" Internal="false" Comment="object channel to the class _Linker"/>
		<Client Name="coMerkerEx" Required="true" Internal="false" Comment="object channel to the class MerkerEx (local drive parameter)"/>
		<Client Name="coRamEx" Required="true" Internal="false" Comment="object channel to the class RamEx(drive parameter in the SRAM)"/>
		<Client Name="FileHandle" Required="false" Internal="false" Comment="command client to the class _DriveFileHandling&#13;&#10;The client has to be connected to use the RAMFILE for the drive parameters&#13;&#10;or to export the drive parameter into an excel formated file."/>
		<Client Name="OverwriteMotorPara" Required="false" Internal="false" DefValue="0" Comment="This client is just important for EnDat or Hiperface:&#13;&#10;&#13;&#10;0  .. no M-Parameter will be overwritten&#13;&#10;1  .. all M-Parameter except M-ROFF will be overwritten&#13;&#10;99 .. all M-Parameter will be overwritten"/>
		<Client Name="ParaSaveType" Required="false" Internal="false" Comment="Save/Use Type of the drive parameter handling :&#13;&#10;&#13;&#10;0.. User table &#13;&#10;The client ParaTab have to connected to an object of the class _DriveParaTab.&#13;&#10;Is no connection available, the default settings of the drive will be send.&#13;&#10;No parameter changes by an user will be saved.&#13;&#10;&#13;&#10;1.. Lasal2 table&#13;&#10;A Lasal2 table must be connected to a _DriveAxis Object, by selecting the _DriveAxis Object &#13;&#10;in the properties of the xml-File. (see _DriveAxis Documentation).&#13;&#10;Is the Lasal2 drive table not available, the system looks if an user table for the axis exists.(See ParaSaveType = 0)&#13;&#10;No parameter changes by an user will be saved.&#13;&#10;&#13;&#10;2.. drive parameter saved in the SRAM&#13;&#10;In this case the parameter will be saved in the SRAM. The first time of the system start-up, we get the drive parameters of the Lasal2 table.&#13;&#10;(See ParaSaveType = 1). At the second time of the system start-up,the parameters are loaded from the SRAM into the drive&#13;&#10;Any parameter changes by an user will be saved in the SRAM.&#13;&#10;&#13;&#10;3.. drive parameter saved in the RAMFILE&#13;&#10;In this case the parameter will be saved in a RAMFILE if the client cFileHandle is connected to the class _DriveFileHandling.&#13;&#10;This type can only used if a file system is available.&#13;&#10;The first time of the system start-up, we get the drive parameters of the Lasal2 table and save the parameter into the file.&#13;&#10;(See ParaSaveType = 1). At the second time of the system start-up,the parameters are loaded from the file into the drive&#13;&#10;Any parameter changes by an user will be saved in the file.&#13;&#10;&#13;&#10;"/>
		<Client Name="ParaTab" Required="false" Internal="false" Comment="client for connecting a _DriveParaTab"/>
		<Client Name="TableIndex" Required="false" Internal="false" Comment="With the value from this client, the specific Lasal2 Table is used for parameterizing the axis.&#13;&#10;(Only available for ParaSaveType = 1)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_DriveMngBase\SDDDefinitions.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="HasHan"/>
		<Dokumentation Revision="1.21" Date="25.05.2020" Author="LanSte" Company="Sigmatek" Description="Added support for ex/importing drive parameters to xml file."/>
		<Dokumentation Revision="1.20" Date="06.03.2013" Author="RamAnd" Company="Sigmatek" Description="If a _DriveAxis has been placed in a complex network, the table name could not be generated since the last correction in the _DriveAxisSet class."/>
		<Dokumentation Revision="1.10" Date="05.11.2012" Author="ObeChr" Company="Sigmatek" Description="The Paramterfile for the axis can now be selected by index"/>
		<Dokumentation Revision="1.2" Date="10.02.2012" Author="ZoePat" Company="Sigmatek" Description="Added headerfile SDDDefinitions.h to prevent errors with projectversion V5"/>
		<Dokumentation Revision="1.1" Date="22.11.2010" Author="RamAnd" Company="Sigmatek" Description="Removed restriction for user tables. Now it&apos;s possible to use a table from user memory."/>
		<Dokumentation Revision="1.0" Date="05.08.2009" Author="HasHan" Company="Sigmatek" Description="Creation"/>
	</RevDoku>
</Class>
*)
_DriveAxisSet : CLASS
  //Servers:
	Server0 	: SvrChCmd_DINT;
  //Clients:
	ParaSaveType 	: CltCh_DINT;
	coMerkerEx 	: CltChCmd_MerkerEx;
	coRamEx 	: CltChCmd_RAMex;
	coLinker 	: CltChCmd__Linker;
	OverwriteMotorPara 	: CltCh_DINT;
	ParaTab 	: CltCh_DINT;
	FileHandle 	: CltChCmd_DINT;
	TableIndex 	: CltCh_UDINT;
  //Variables:
  //Functions:
	
	FUNCTION GLOBAL GetInitType
		VAR_OUTPUT
			InitType 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetUserTab
		VAR_INPUT
			bMotorPara 	: BOOL;
			pTabLength 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			TabAddress 	: ^DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetL2Tab
		VAR_INPUT
			pThis 	: ^void;
			bMotorPara 	: BOOL;
			pTabLength 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			TabAddress 	: ^DINT;
		END_VAR;
	
	FUNCTION GetFnctName
		VAR_INPUT
			pFnctName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			pFct 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL GetMemPtr
		VAR_OUTPUT
			pData 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL GetRamExLength
		VAR_OUTPUT
			udLength 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SaveRamExData
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CpyRamExMem
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION ChkL2TabVersion;
	
	FUNCTION GLOBAL ChkFileHandle
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL GetRamFileLen
		VAR_OUTPUT
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SaveRamFileData
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CpyRamFileMem
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION RamFileSetSize
		VAR_INPUT
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION RamFileSetDataAt
		VAR_INPUT
			pData 	: ^USINT;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR;
	
	FUNCTION RamFileGetDataAt
		VAR_INPUT
			pData 	: ^USINT;
			udLen 	: UDINT;
			udOffset 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetUserSSDCmd
		VAR_INPUT
			UserCmd 	: _SDDUSERCMD;
			pData 	: ^_DriveAxisBase::_SDDMEMHEADER;
		END_VAR;
	
	FUNCTION GLOBAL GetUserSSDCmd
		VAR_OUTPUT
			UserCmd 	: _SDDUSERCMD;
		END_VAR;
	
	FUNCTION GLOBAL GetFeedBackInfo
		VAR_OUTPUT
			GetFB 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL CalcCRC32
		VAR_INPUT
			pData 	: ^UDINT;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UDINT;
		END_VAR;
				//! <Function Comment="Set Drivetpy for xml export" Name="SetDriveType"/>
	FUNCTION GLOBAL SetDriveType
		VAR_INPUT
			eDriveType 	: _DRIVETYPE;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _Linker
#pragma usingLtd MerkerEx
#pragma usingLtd RAMex


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _DriveAxisSet::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__DRIVEAXISSET
1$UINT, 21$UINT, (SIZEOF(::_DriveAxisSet))$UINT, 
1$UINT, 8$UINT, 0$UINT, 
TO_UDINT(833307860), "_DriveAxisSet", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_DriveAxisSet.Server0.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2759080719), "Server0", 
//Clients:
(::_DriveAxisSet.ParaSaveType.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3430860999), "ParaSaveType", 
(::_DriveAxisSet.coMerkerEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1991140626), "coMerkerEx", TO_UDINT(2225119864), "MerkerEx", 1$UINT, 22$UINT, 
(::_DriveAxisSet.coRamEx.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3875985349), "coRamEx", TO_UDINT(933570811), "RAMex", 1$UINT, 17$UINT, 
(::_DriveAxisSet.coLinker.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1382361455), "coLinker", TO_UDINT(1793552568), "_Linker", 0$UINT, 4$UINT, 
(::_DriveAxisSet.OverwriteMotorPara.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(100162029), "OverwriteMotorPara", 
(::_DriveAxisSet.ParaTab.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(29594727), "ParaTab", 
(::_DriveAxisSet.FileHandle.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3131334989), "FileHandle", 
(::_DriveAxisSet.TableIndex.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2619296494), "TableIndex", 
END_FUNCTION


#define USER_CNT__DriveAxisSet 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__DriveAxisSet] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _DriveAxisSet::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL _DriveAxisSet::GetInitType
	VAR_OUTPUT
		InitType 	: DINT;
	END_VAR
	
	InitType := ParaSaveType := ParaSaveType.read();

END_FUNCTION 


FUNCTION GLOBAL _DriveAxisSet::GetUserTab
	VAR_INPUT
		bMotorPara 	: BOOL;
		pTabLength 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		TabAddress 	: ^DINT;
	END_VAR
  VAR
    NewOffset   : DINT;
    hTabAddress : ^DINT;
  END_VAR

	TabAddress := NIL;
	
		if IsClientConnected(#ParaTab) then
			TabAddress$DINT := ParaTab.read();
      if TabAddress <> NIL then
        if bMotorPara = TRUE then
          TabAddress += sizeof(UDINT) + sizeof(UDINT); // um die tatsächliche Länge der Daten zu bekommen
          pTabLength^ := TabAddress^;
          TabAddress += sizeof(UDINT);  // um die eigentlichen Daten zu bekommen
        else
          // get the address without the motorparameter
          NewOffset := (TabAddress + sizeof(UDINT) + sizeof(UDINT))^;
          hTabAddress := TabAddress + sizeof(UDINT) + SizeOf(UDINT) + SizeOf(UDINT) + NewOffset;
          hTabAddress += sizeof(UDINT); // die 4 Byte für die nächste Längenberechnung müssen dazuaddiert werden
          hTabAddress += sizeof(USINT) + sizeof(UDINT); // der nächste Eintrag ist der Offset für die Motorparameter
          hTabAddress += sizeof(USINT); // Länge für die Gruppennummer dazuaddieren
          NewOffset := hTabAddress^;
          
          // calculate the new length
          hTabAddress := TabAddress + sizeof(UDINT) + sizeof(UDINT);
          pTabLength^:= hTabAddress^ - (NewOffset - 3* sizeof(UDINT));
          // set the new address
          TabAddress += NewOffset;
        end_if;        
      end_if; 
		end_if;

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetL2Tab
	VAR_INPUT
		pThis 	: ^void;
		bMotorPara 	: BOOL;
		pTabLength 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		TabAddress 	: ^DINT;
	END_VAR
  VAR
    szTabName		: ARRAY[0..99] of CHAR;
    retcode     : BOOL;
    szObjName   : ARRAY[0..99] of CHAR;
    udStrLen    : UDINT;
    NewOffset   : DINT;
    hTabAddress : ^DINT;
    tmpDigits   : USINT;
    tmpLoop     : UDINT;
    x           : UDINT;
  END_VAR
  
  TabAddress := NIL;
  retcode := FALSE;
  
  if pThis <> NIL then
    
    // get the object name of the this pointer
    udStrLen := _GetObjName(pThis$^VirtualBase, #szObjName[0]);
    
    // convert the sign '/' to '_' in the object name (complex)
    if udStrLen > 0 then
    
      for x := 0 to (udStrLen - 1) do
        if szObjName[x] = '\' then
          szObjName[x] := '_';
        end_if;
      end_for;
    
      TableIndex := TableIndex.Read();

      //If only one Parameterfile is available, we don't need the extension for the index
      //****************************************************************************************************
      _strcpy(#szTabName[0], STDL2TABLENAME);
      _strcat(#szTabName[0], "_");
      _strcat(#szTabName[0], #szObjName[0]);
      
      //Get Pointer to Lasal2 Table
      TabAddress$pVoid := GetFnctName(#szTabName[0]);
      
      //Get table by selected index
      //****************************************************************************************************      
      if TabAddress = NIL then
      
        _strcpy(#szTabName[0], STDL2TABLENAME);
        _strcat(#szTabName[0], "_");
        _strcat(#szTabName[0], #szObjName[0]);
        _strcat(#szTabName[0], "_");
        
        //Get Digits of TableIndex
        tmpLoop   := TableIndex;
        tmpDigits := 0;
        
        //TableIndex <> 0
        if tmpLoop then
        
          while tmpLoop do
            tmpLoop  /= 10;
            tmpDigits     += 1;
          end_while;
          
          //Convert Number to String
          tmpLoop := TableIndex;
          
          szObjName[tmpDigits] := 0;
          tmpDigits -= 1;
          
          while tmpLoop do
            szObjName[tmpDigits] := ('0' + tmpLoop mod 10)$CHAR;
            tmpLoop   /= 10;
            tmpDigits -= 1;
          end_while;
          
          _strcat(#szTabName[0], #szObjName[0]);
        
        else
          _strcat(#szTabName[0], "0");
        end_if;
        
        //Get Pointer to Lasal2 Table
        TabAddress$pVoid := GetFnctName(#szTabName[0]);
      
      end_if;

      if TabAddress <> NIL then
        // *****************************
        // now get the parameter data
        // *****************************
        // add the whole length of the table and the version number of the table to the address
        //check the version
        ChkL2TabVersion();
        if bMotorPara = TRUE then
          TabAddress += sizeof(UDINT) + sizeof(UDINT); // um die tatsächliche Länge der Daten zu bekommen
          pTabLength^ := TabAddress^;
          TabAddress += sizeof(UDINT);  // um die eigentlichen Daten zu bekommen
        else
          // get the address without the motorparameter
          NewOffset := (TabAddress + sizeof(UDINT) + sizeof(UDINT))^;
          hTabAddress := TabAddress + sizeof(UDINT) + SizeOf(UDINT) + SizeOf(UDINT) + NewOffset;
          hTabAddress += sizeof(UDINT); // die 4 Byte für die nächste Längenberechnung müssen dazuaddiert werden
          hTabAddress += sizeof(USINT) + sizeof(UDINT); // der nächste Eintrag ist der Offset für die Motorparameter
          hTabAddress += sizeof(USINT); // Länge für die Gruppennummer dazuaddieren
          NewOffset := hTabAddress^;
          
          // calculate the new length
          hTabAddress := TabAddress + sizeof(UDINT) + sizeof(UDINT);
          pTabLength^:= hTabAddress^ - (NewOffset - 3* sizeof(UDINT));
          // set the new address
          TabAddress += NewOffset;
        end_if;
      end_if;

    end_if; 
    
  end_if;

END_FUNCTION //GLOBAL SDDSettings::GetL2Tab

FUNCTION _DriveAxisSet::GetFnctName
	VAR_INPUT
		pFnctName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		pFct 	: ^void;
	END_VAR
VAR	
	isExe			: Char;
END_VAR
	
	pFct$UDINT := coLinker.GetAddressFunction(pFnctName, (#IsExe)$^CHAR);

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetMemPtr
	VAR_OUTPUT
		pData 	: ^void;
	END_VAR
	
	if coMerkerEx.GetSize() <> SDDMAXMEM then
		coMerkerEx.SetSize(SDDMAXMEM);
	end_if;

	pData := coMerkerEx.GetDataPtr();

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetRamExLength
	VAR_OUTPUT
		udLength 	: UDINT;
	END_VAR
	
	udLength := coRamEx.read();

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::SaveRamExData
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
VAR
	udActLen		: UDINT;
  ret_code    : ConfStates;
END_VAR

	udActLen := coRamEx.Read();
  retcode := TRUE;
  
  if udActLen < (udLen + udOffset) then
    if udLen + udOffset > SDDMAXMEM then
      // ERROR
      Trace("SDDManager :: maximal memory for the parameters reached!!");
      retcode := FALSE;
      return;
    end_if;
    ret_code := coRamEx.SetSize(udLen + udOffset);
    if ret_code <> C_OK then
      retcode := FALSE;
    end_if;
	end_if;
  
  if retcode = TRUE then
  		coRamEx.SetDataAt(pData$^USINT, udLen, udOffset);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::CpyRamExMem
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR	
VAR
	udLen	 : UDINT;
	pData		: ^USINT;
END_VAR
	retcode := FALSE;

	// copy data from RAMEX to MEMORY
	udLen := GetRamExLength();
	if udLen > SDDMAXMEM then
		coMerkerEx.SetSize(udLen);
	end_if;
	pData := coRamEx.GetDataPtr();
	if pData <> NIL then
		coMerkerEx.SetDataAt(pData, udLen, 0);
		retcode := TRUE;
	end_if;

END_FUNCTION


FUNCTION _DriveAxisSet::ChkL2TabVersion
   
   // not used at the  moment
   
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::ChkFileHandle
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    ret_code      : iprStates;
    UserCmdStruct : CmdStruct;
    UserResult    : Results;
  END_VAR
  
  retcode := FALSE;
  
  if IsClientConnected(#FileHandle) then
    // check if the right class is connected
    UserCmdStruct.uiCmd := 199;
    
    ret_code := FileHandle.NewInst(#UserCmdStruct, #UserResult);
    if (ret_code = READY) & (UserResult.aData[2] = 16#FE) then
      retcode := TRUE;
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetRamFileLen
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  VAR
    ret_code        : iprStates;
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  // get the actual length of the ramfile
  UserCmdStruct.uiCmd := 0;
  
  ret_code := FileHandle.NewInst(#UserCmdStruct, #UserResults);
  udLen := 0;
  if ret_code = READY then
    udLen := UserResults.aData[0]$UDINT;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::SaveRamFileData
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    udActLen		: UDINT;
    ret_code    : ConfStates;
  END_VAR

	udActLen := GetRamFileLen();
  retcode := TRUE;
  
  if udActLen < (udLen + udOffset) then
    if udLen + udOffset > SDDMAXMEM then
      // ERROR
      Trace("SDDManager :: maximal memory for the parameters reached!!");
      retcode := FALSE;
      return;
    end_if;
    ret_code := RamFileSetSize(udLen + udOffset);
    if ret_code <> C_OK then
      retcode := FALSE;
    end_if;
	end_if;
  
  if retcode = TRUE then
    RamFileSetDataAt(pData$^USINT, udLen, udOffset);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::CpyRamFileMem
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR	
  VAR
    udLen	 : UDINT;
    pData		: ^USINT;
  END_VAR

	retcode := FALSE;

	// copy data from RAMFILE to MEMORY
	udLen := GetRamFileLen();
	if udLen > SDDMAXMEM then
		coMerkerEx.SetSize(udLen);
	end_if;
	
  pData := coMerkerEx.GetDataPtr();
	if pData <> NIL then
    RamfileGetDataAt(pData, udLen, 0);
		retcode := TRUE;
	end_if;

END_FUNCTION


FUNCTION _DriveAxisSet::RamFileSetSize
	VAR_INPUT
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  VAR
    myret_code      : iprStates;
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  // set the size of the ramfile
  UserCmdStruct.uiCmd := 1;
  UserCmdStruct.aPara[0] := udLen$DINT;
  
  myret_code := FileHandle.NewInst(#UserCmdStruct, #UserResults);
  ret_code   := C_SYSTEM_ERROR;
  if myret_code = READY then
    ret_code := UserResults.aData[0]$ConfStates;
  end_if;
  
END_FUNCTION


FUNCTION _DriveAxisSet::RamFileSetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  // set the data into the ramfile
  UserCmdStruct.uiCmd := 2;
  UserCmdStruct.aPara[0] := pData$DINT;
  UserCmdStruct.aPara[1] := udLen$DINT;
  UserCmdStruct.aPara[2] := udOffset$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);
  
END_FUNCTION


FUNCTION _DriveAxisSet::RamFileGetDataAt
	VAR_INPUT
		pData 	: ^USINT;
		udLen 	: UDINT;
		udOffset 	: UDINT;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  // get the data into the ramfile
  UserCmdStruct.uiCmd := 3;
  UserCmdStruct.aPara[0] := pData$DINT;
  UserCmdStruct.aPara[1] := udLen$DINT;
  UserCmdStruct.aPara[2] := udOffset$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);
  
END_FUNCTION



FUNCTION GLOBAL _DriveAxisSet::SetUserSSDCmd
	VAR_INPUT
		UserCmd 	: _SDDUSERCMD;
		pData 	: ^_DriveAxisBase::_SDDMEMHEADER;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  // Set the user command to the file handler
  UserCmdStruct.uiCmd := 4;
  UserCmdStruct.aPara[0] := UserCmd$DINT;
  UserCmdStruct.aPara[1] := pData$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetUserSSDCmd
	VAR_OUTPUT
		UserCmd 	: _SDDUSERCMD;
	END_VAR
  VAR
    ret_code        : iprStates;
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  // Set the user command to the file handler
  UserCmdStruct.uiCmd := 5;
  
  ret_code := FileHandle.NewInst(#UserCmdStruct, #UserResults);
  UserCmd  := _SDDERROR;
  if ret_code = READY then
    UserCmd := UserResults.aData[0]$_SDDUSERCMD;
  end_if; 

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::GetFeedBackInfo
	VAR_OUTPUT
		GetFB 	: DINT;
	END_VAR
  
  GetFB := OverwriteMotorPara := OverwriteMotorPara.read();

END_FUNCTION


FUNCTION GLOBAL _DriveAxisSet::CalcCRC32
	VAR_INPUT
		pData 	: ^UDINT;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UDINT;
	END_VAR
  
  retcode := coLinker.CRC32(crc:=0, buf:=pData$^void, length:=udLen);

END_FUNCTION

FUNCTION GLOBAL _DriveAxisSet::SetDriveType
	VAR_INPUT
		eDriveType 	: _DRIVETYPE;
	END_VAR
  VAR
    UserCmdStruct   : CmdStruct;
    UserResults     : Results;
  END_VAR
  
  // Set the user command to the file handler
  UserCmdStruct.uiCmd := 6;
  UserCmdStruct.aPara[0] := eDriveType$DINT;
  
  FileHandle.NewInst(#UserCmdStruct, #UserResults);

END_FUNCTION
