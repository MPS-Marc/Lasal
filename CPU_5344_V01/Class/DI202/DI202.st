//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_DI202 1019    

#define DI202_COUNTER_MODE          16#0003         
#define DI202_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "DI202"
	Revision           = "1.33"
	GUID               = "{5A9EA05E-1769-4425-AA8F-BBE80C700292}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(440,120)"
	Comment            = "This hardware class is used to control the DI202 hardware module with 20 digital inputs and two counter modes&#13;&#10;It is possible to reset count servers with write methode.">
	<Channels>
		<Server Name="Counter1" GUID="{C9818E07-6306-41D2-9460-7AA709086BCE}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="CounterMode1 = 0 ... disabled&#13;&#10;CounterMode1 = 1 ... normal counter of input 1&#13;&#10;CounterMode1 = 2 ... incremental encoder input 1 and 2&#13;&#10;Counter can be reset with the write method of the server.&#13;&#10;"/>
		<Server Name="Counter2" GUID="{9C29FBB1-7C16-44BC-80B2-63536F54C56E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="CounterMode1 = 0 ... disabled&#13;&#10;CounterMode1 = 1 ... normal counter of input 2&#13;&#10;CounterMode1 = 2 ... disabled.&#13;&#10;Counter can be reset with the write method of the server.&#13;&#10;"/>
		<Server Name="Counter3" GUID="{48E38DB2-ADD2-4CF6-902C-0B123077FA44}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="CounterMode1 = 0 ... disabled&#13;&#10;CounterMode1 = 1 ... normal counter of input 3&#13;&#10;CounterMode1 = 2 ... incremental encoder input 3 and 4&#13;&#10;Counter can be reset with the write method of the server.&#13;&#10;"/>
		<Server Name="Counter4" GUID="{D1A2F82A-289A-4D52-B958-73149CF185EB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="CounterMode2 = 0 ...  disabled&#13;&#10;CounterMode2 = 1 ...  normal counter input 4&#13;&#10;CounterMode2 = 2 ...  disabled &#13;&#10;Counter can be reset with the write method of the server.&#13;&#10;"/>
		<Server Name="Input1" GUID="{05B67F63-7C4B-4505-9717-B670454FDE98}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 1 value"/>
		<Server Name="Input10" GUID="{5F3EC81D-756C-4C9B-A49C-04EFC0BA7D31}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 10 value"/>
		<Server Name="Input11" GUID="{16C3AE96-49AB-4E6E-9A02-A25D9A2D4A9D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 11 value"/>
		<Server Name="Input12" GUID="{CFE11D4D-30D8-4F0E-801F-126C109F25CA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 12 value"/>
		<Server Name="Input13" GUID="{9E91DB84-B810-41D6-A18D-AA5BD21C4F48}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 13 value"/>
		<Server Name="Input14" GUID="{1E589FA4-C506-4387-813C-326AC5550C25}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 14 value"/>
		<Server Name="Input15" GUID="{4B5573DA-1DA7-4623-9AD8-47FF6C6FCC1E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 15 value"/>
		<Server Name="Input16" GUID="{13463A26-1E23-4F54-8D6A-7637CBB3487D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 16 value"/>
		<Server Name="Input17" GUID="{F0B3F951-1FB5-4EDD-8F76-1CAFFF0E6E0D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 17 value"/>
		<Server Name="Input18" GUID="{615E3212-8E0B-4F05-915A-891FC8B25A50}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 18 value"/>
		<Server Name="Input19" GUID="{D91FDDEC-E443-4F69-A89F-645E1BFCB268}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 19 value"/>
		<Server Name="Input2" GUID="{468E69D1-A840-4707-BEF6-15DF3DDAD84E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 2 value"/>
		<Server Name="Input20" GUID="{5E78C15D-09A1-422C-B5E2-F0633D34A861}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 20 value"/>
		<Server Name="Input3" GUID="{07FB3871-2BB5-4DA7-ADE6-6D45E0D1AB9F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 3 value"/>
		<Server Name="Input4" GUID="{F22C6057-2DEB-476A-A1D2-61A634403E31}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 4 value"/>
		<Server Name="Input5" GUID="{A98B29C7-8663-4D7D-B032-CA0B9039FFAF}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 5 value"/>
		<Server Name="Input6" GUID="{7C74E84C-CFBE-4B13-949B-5F6DF73901AC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 6 value"/>
		<Server Name="Input7" GUID="{BAE3495A-D4BA-4227-91E1-069D2EDA94C7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 7 value"/>
		<Server Name="Input8" GUID="{EE9C92CF-55B8-4416-A188-029FF9256630}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 8 value"/>
		<Server Name="Input9" GUID="{8977A973-0F7A-4437-A1B0-F5E460F58BB7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Input 9 value"/>
		<Server Name="InputDouble" GUID="{B80AE5C7-6F30-4EAD-8356-C5E8F7D5DF6B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Bit 0 to 19 ... Input 1 to 20"/>
		<Client Name="CounterMode1" Required="false" Internal="false" Comment="Input 1+2&#13;&#10;0=no counter, 1=normal counter, 2=incremental encoder"/>
		<Client Name="CounterMode2" Required="false" Internal="false" Comment="Input 3+4&#13;&#10;0=no counter, 1=normal counter, 2=incremental encoder"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="PieSte"/>
		<Dokumentation Revision="1.33" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.32" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.31" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.30" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.29" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.28" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.27" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED.&#13;&#10;Added comments for servers Counter1-4."/>
		<Dokumentation Revision="1.26" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.25" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.24" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.23" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.22" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.21" Date="09.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.20" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.10" Date="05.12.2013" Author="RamAnd" Company="Sigmatek" Description="Changed login mechanism to sdias manager class to be independent of bus accesses."/>
		<Dokumentation Revision="1.0" Date="27.09.2013" Author="PieSte" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="DI202">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{4CE3BAD3-6A95-4AF0-828B-B4AA434EC629}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

DI202 : CLASS
: SdiasBase
	TYPE
#pragma pack(push, 1)
	  _Counter : STRUCT
	    CounterA : USINT;
	    CounterB : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_InitSSW :
	  (
	    _InitVariables,
	    _ConfigModule,
	    _Finish,
	    _InitError
	  )$UDINT;
#pragma pack(push, 1)
	  t_ReadData : STRUCT
	    DigIn : DINT;
	    Counter1 : _Counter;
	    Counter2 : _Counter;
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle,
	    _wait,
	    _valid
	  )$UDINT;
	END_TYPE
  //Servers:
	Input1 	: SvrCh_DINT;
	Input2 	: SvrCh_DINT;
	Input3 	: SvrCh_DINT;
	Input4 	: SvrCh_DINT;
	Input5 	: SvrCh_DINT;
	Input6 	: SvrCh_DINT;
	Input7 	: SvrCh_DINT;
	Input8 	: SvrCh_DINT;
	Input9 	: SvrCh_DINT;
	Input10 	: SvrCh_DINT;
	Input11 	: SvrCh_DINT;
	Input12 	: SvrCh_DINT;
	Input13 	: SvrCh_DINT;
	Input14 	: SvrCh_DINT;
	Input15 	: SvrCh_DINT;
	Input16 	: SvrCh_DINT;
	Input17 	: SvrCh_DINT;
	Input18 	: SvrCh_DINT;
	Input19 	: SvrCh_DINT;
	Input20 	: SvrCh_DINT;
	InputDouble 	: SvrCh_BDINT;
	Counter1 	: SvrCh_DINT;
	Counter2 	: SvrCh_DINT;
	Counter3 	: SvrCh_DINT;
	Counter4 	: SvrCh_DINT;
  //Clients:
	CounterMode1 	: CltCh_DINT;
	CounterMode2 	: CltCh_DINT;
  //Variables:
		pReadData 	: ^t_ReadData;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		bCounterMode : BSINT
		[
		  1 Counter_Inkrement1,
		  2 Counter_Inkrement2,
		  3 reserve,
		];

		usCounter1Old 	: USINT;
		usCounter2Old 	: USINT;
		usCounter3Old 	: USINT;
		usCounter4Old 	: USINT;
		uCounter1Old 	: INT;
		uCounter3Old 	: INT;
		eInitSSW 	: t_InitSSW;
		eResponseState 	: t_ResponseState;
		udSDOTimeout 	: UDINT;
		eInitSSWErrorStep 	: t_InitSSW;
		Variable 	: DINT;
		Counter1Actuell 	: _Counter;
		Counter3Actuell 	: _Counter;
		TEMP 	: DINT;
  //Functions:
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB DI202::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_DI202
1$UINT, 33$UINT, (SIZEOF(::DI202))$UINT, 
25$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3174254766), "DI202", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::DI202.Input1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1344628668), "Input1", 
(::DI202.Input2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3375117830), "Input2", 
(::DI202.Input3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3190490768), "Input3", 
(::DI202.Input4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(542085939), "Input4", 
(::DI202.Input5.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1464378277), "Input5", 
(::DI202.Input6.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3460428319), "Input6", 
(::DI202.Input7.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3108422281), "Input7", 
(::DI202.Input8.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(704241432), "Input8", 
(::DI202.Input9.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1593765774), "Input9", 
(::DI202.Input10.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(912000481), "Input10", 
(::DI202.Input11.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1096496503), "Input11", 
(::DI202.Input12.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3629278413), "Input12", 
(::DI202.Input13.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2941604955), "Input13", 
(::DI202.Input14.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(825344504), "Input14", 
(::DI202.Input15.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1178005870), "Input15", 
(::DI202.Input16.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3745489108), "Input16", 
(::DI202.Input17.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2822279234), "Input17", 
(::DI202.Input18.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(948407763), "Input18", 
(::DI202.Input19.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1333837125), "Input19", 
(::DI202.Input20.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(493966882), "Input20", 
(::DI202.InputDouble.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1696744495), "InputDouble", 
(::DI202.Counter1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(547260585), "Counter1", 
(::DI202.Counter2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3113736467), "Counter2", 
(::DI202.Counter3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3465603461), "Counter3", 
(::DI202.Counter4.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1358199846), "Counter4", 
//Clients:
(::DI202.CounterMode1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2126225204), "CounterMode1", 
(::DI202.CounterMode2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3887255182), "CounterMode2", 
END_FUNCTION


#define USER_CNT_DI202 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_DI202] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION DI202::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_DI202;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Counter1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Counter1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Counter2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Counter2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Counter3.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Counter3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Counter4.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Counter4.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL DI202::UpdateRt
  VAR
    inputMask             : DINT;
    newInputs             : DINT;
    pInputSrv             : ^DINT;
    usCounter1Difference  : USINT;
    usCounter2Difference  : USINT;
    usCounter3Difference  : USINT;
    usCounter4Difference  : USINT;
    uCounter1Difference   : INT;
    uCounter3Difference   : INT;       
  END_VAR  

  newInputs         := pReadData^.DigIn and 16#00FFFFFF;     // read only 3 bytes
  InputMask         := InputDouble$DINT xor newInputs; //old Input xor new Input (to see changes)  
  
  if InputMask <> 0 then    
    InputDouble$DINT  := newInputs;
    pInputSrv         :=#Input1.Ddata;
    repeat
      if InputMask and 1 then
        pInputSrv^ := newInputs and 1;
      end_if;
      inputMask := inputMask shr 1;
      newInputs := newInputs shr 1;
      pInputSrv += sizeof(SvrCh);
    until inputMask = 0 end_repeat;
  end_if;   

  if CounterMode1 <> 0 then  
    Counter1Actuell := pReadData^.Counter1;      
  // Mode selection Input 1 + 2 (0 normal counter 1 incremential encoder)
    if bCounterMode.Counter_Inkrement1 = 0 then
    // normal counter input 1 + 2
      usCounter1Difference := (Counter1Actuell.CounterA - usCounter1Old);
      usCounter2Difference := (Counter1Actuell.CounterB - usCounter2Old);
      usCounter1Old        := Counter1Actuell.CounterA;
      usCounter2Old        := Counter1Actuell.CounterB;
      Counter1             := Counter1 + usCounter1Difference;
      Counter2             := Counter2 + usCounter2Difference;
    else
      //inkremental encoder input 1 + 2 
      uCounter1Difference := (Counter1Actuell$INT - uCounter1Old);
      uCounter1Old        :=  Counter1Actuell$INT;   
      Counter1            :=  Counter1 + uCounter1Difference;     
    end_if; 
  end_if;


  if CounterMode2 <> 0 then  
    Counter3Actuell := pReadData^.Counter2;
   // Mode selection Input 3 + 4 (0 normal counter 1 incremental encoder)    
    if bCounterMode.Counter_Inkrement2 = 0 then
    // normal counter input 3 + 4 
      usCounter3Difference := (Counter3Actuell.CounterA - usCounter3Old);
      usCounter4Difference := (Counter3Actuell.CounterB - usCounter4Old);
      usCounter3Old        := Counter3Actuell.CounterA;
      usCounter4Old        := Counter3Actuell.CounterB;
      Counter3             := Counter3 + usCounter3Difference;
      Counter4             := Counter4 + usCounter4Difference;      
    else
      //inkremental encoder input 3 + 4 
      uCounter3Difference  := (Counter3Actuell$INT - uCounter3Old);
      uCounter3Old         :=  Counter3Actuell$INT;
      Counter3             :=  Counter3 + uCounter3Difference;  
    end_if;
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DI202::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
  //look if it is right hardware
	if ( udID2Check <> DEVICE_ID_DI202 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DI202::ConnectEvent

  // start the accesses on the SDIAS (initialize the control byte in the DPRAM)
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_ReadData;

    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;

  CounterMode1 := CounterMode1.Read();
  CounterMode2 := CounterMode2.Read();

  eInitSSW := _InitVariables;
  eResponseState := _idle;
  eInitState := _NotInitialized;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL DI202::DisconnectEvent

  // reset general module information shown on servers
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL DI202::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode        : iprStates;
  END_VAR

  eModuleInitState := BUSY;
  
 case eInitSSW of
//**************************************************************************************************************************************** 
    _InitVariables:   
    
      //reset Counters  
      Counter1 := 0;
      Counter2 := 0;
      Counter3 := 0;
      Counter4 := 0;
         
      //define counter mode input 1 + 2 on hardware 
      if CounterMode1 = 1 then 
        bCounterMode.Counter_Inkrement1 := 0;
      end_if;
      if CounterMode1 = 2 then
        bCounterMode.Counter_Inkrement1 := 1;
      end_if; 
     
     //define counter mode input 3 + 4 on hardware   
      if CounterMode2 = 1 then
        bCounterMode.Counter_Inkrement2 := 0;
      end_if;
      if CounterMode2 = 2 then
        bCounterMode.Counter_Inkrement2 := 1;
      end_if; 
      eInitSSW := _ConfigModule;
      
//****************************************************************************************************************************************
      
    _ConfigModule:
      case eResponseState of
         _idle:
          TmpRetcode  := StartWriteSDO(hOffset:=DI202_COUNTER_MODE, usLength:=sizeof(USINT), pWriteBuffer:=(#bCounterMode)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= _wait; 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (DI202::InitModule) Failed to add write SDO for counter mode configuration");
            eInitState := _NoMem;
          end_if;
          //*****************************************************
        _wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > DI202_SDO_RESPONSE_TIMEOUT) then
            LogError("@ZZZZ (DI202::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        _valid:
          eInitSSW        := _Finish;
          eResponseState  := _idle;
        //*****************************************************
      end_case;     
      
//****************************************************************************************************************************************
     _Finish:
      eInitSSW         := _InitVariables;
      eModuleInitState := READY;
      eInitState       := _ClassOk;    
 
//****************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
  
//****************************************************************************************************************************************
 end_case;  

END_FUNCTION

FUNCTION VIRTUAL DI202::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	  : USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR

  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);

  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;  
  
  if eResult = READY then
    
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
          DI202_COUNTER_MODE:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;           
        end_case;        
    end_case;
    
    if eResponseState <> _valid then
      LogError("@ZZZZ (DI202::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := _InitError;      
    end_if;
  else
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (DI202::ReceiveSDOResponse) Error while writing the counter mode");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (DI202::ReceiveSDOResponse) Error while waiting for the counter mode state");
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL DI202::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE;

END_FUNCTION



FUNCTION VIRTUAL DI202::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_DI202;

END_FUNCTION
