//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emMiterSawingUnitV5286"
	Revision           = "0.0"
	GUID               = "{8D4D9317-77AD-4245-83AB-01758247AC2C}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(600,1800)">
	<Channels>
		<Server Name="hmiExtractionOn" GUID="{EF55A7D6-DA61-45BC-B8D0-438167711941}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="iEndMillingActive" Required="true" Internal="false"/>
		<Client Name="oStartMilling" Required="true" Internal="false"/>
	</Channels>
	<Network Name="emMiterSawingUnitV5286">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{76EF3686-D4FA-4F35-897A-94C1BFAC8ED1}"
				Class      = "emMiterSawingUnit"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="csStartRPM"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="lastXY1Angle"/>
					<Server Name="mode"/>
					<Server Name="oEnableLubrication"/>
					<Server Name="paclosewinTime"/>
					<Server Name="parMaxHeightForSensor1"/>
					<Server Name="parMinPulseTime"/>
					<Server Name="parTimeBeforeMotorOff"/>
					<Server Name="parTimeOutTime"/>
					<Server Name="parTimeWaitForClamp"/>
					<Server Name="ParWaitTimer"/>
					<Server Name="resetSoftCounter"/>
					<Server Name="softCounter"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsNrInAssembly"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit"/>
					<Server Name="totalCounter"/>
					<Client Name="ctrlBlower"/>
					<Client Name="ctrlClamp"/>
					<Client Name="ctrlMotor"/>
					<Client Name="ctrlScreen"/>
					<Client Name="ctrlYAngleServo"/>
					<Client Name="fileBase"/>
					<Client Name="iActHeigthMaterial"/>
					<Client Name="iActHeigthSaw"/>
					<Client Name="iActPosWagon"/>
					<Client Name="id"/>
					<Client Name="iHydroPumpOn"/>
					<Client Name="iMinPosForSawOperation"/>
					<Client Name="iOperationAllowed"/>
					<Client Name="iPusherWagonInPos"/>
					<Client Name="iSawInAutomode"/>
					<Client Name="iSawMotorOn"/>
					<Client Name="iSawReady"/>
					<Client Name="iSensor1"/>
					<Client Name="iSensor2"/>
					<Client Name="nrOffWindowTry"/>
					<Client Name="nwEmOrUnit"/>
					<Client Name="oEnableExtraction"/>
					<Client Name="oMpsAutoMode"/>
					<Client Name="oPulseSawClamp"/>
					<Client Name="oStartSawCycle"/>
					<Client Name="windowNr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1126,210),(954,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1126,270),(954,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1126,330),(954,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1126,390),(954,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1126,450),(954,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1126,510),(954,510),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1126,570),(954,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1126,630),(954,630),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1126,690),(954,690),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1126,750),(954,750),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1126,810),(954,810),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1126,870),(954,870),"/>
			<Connection Source="this.cmdWaitReset" Destination="_base.cmdWaitReset" Vertices="(1126,930),(954,930),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1126,990),(954,990),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1126,1050),(954,1050),"/>
			<Connection Source="this.csStartRPM" Destination="_base.csStartRPM" Vertices="(1126,1110),(954,1170),"/>
			<Connection Source="this.parTimeBeforeMotorOff" Destination="_base.parTimeBeforeMotorOff" Vertices="(1126,1170),(954,1230),"/>
			<Connection Source="this.parTimeWaitForClamp" Destination="_base.parTimeWaitForClamp" Vertices="(1126,1230),(954,1290),"/>
			<Connection Source="this.oEnableLubrication" Destination="_base.oEnableLubrication" Vertices="(1126,1290),(954,1350),"/>
			<Connection Source="this.parTimeOutTime" Destination="_base.parTimeOutTime" Vertices="(1126,1350),(954,1410),"/>
			<Connection Source="this.parMinPulseTime" Destination="_base.parMinPulseTime" Vertices="(1126,1410),(954,1470),"/>
			<Connection Source="this.paclosewinTime" Destination="_base.paclosewinTime" Vertices="(1126,1470),(954,1530),"/>
			<Connection Source="this.ParWaitTimer" Destination="_base.ParWaitTimer" Vertices="(1126,1530),(954,1590),"/>
			<Connection Source="this.softCounter" Destination="_base.softCounter" Vertices="(1126,1590),(954,1650),"/>
			<Connection Source="this.totalCounter" Destination="_base.totalCounter" Vertices="(1126,1650),(954,1710),"/>
			<Connection Source="this.resetSoftCounter" Destination="_base.resetSoftCounter" Vertices="(1126,1710),(954,1770),"/>
			<Connection Source="this.stsNrInAssembly" Destination="_base.stsNrInAssembly" Vertices="(1126,1770),(954,1830),"/>
			<Connection Source="this.lastXY1Angle" Destination="_base.lastXY1Angle" Vertices="(1126,1830),(954,1890),"/>
			<Connection Source="this.parMaxHeightForSensor1" Destination="_base.parMaxHeightForSensor1" Vertices="(1126,1890),(954,1950),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.ctrlClamp" Destination="this.ctrlClamp" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.ctrlMotor" Destination="this.ctrlMotor" Vertices="(218,390),(38,390),"/>
			<Connection Source="_base.ctrlYAngleServo" Destination="this.ctrlYAngleServo" Vertices="(218,450),(38,450),"/>
			<Connection Source="_base.ctrlBlower" Destination="this.ctrlBlower" Vertices="(218,510),(38,510),"/>
			<Connection Source="_base.iOperationAllowed" Destination="this.iOperationAllowed" Vertices="(218,570),(38,570),"/>
			<Connection Source="_base.iSawMotorOn" Destination="this.iSawMotorOn" Vertices="(218,630),(38,630),"/>
			<Connection Source="_base.iHydroPumpOn" Destination="this.iHydroPumpOn" Vertices="(218,690),(38,690),"/>
			<Connection Source="_base.iSawInAutomode" Destination="this.iSawInAutomode" Vertices="(218,750),(38,750),"/>
			<Connection Source="_base.iSensor1" Destination="this.iSensor1" Vertices="(218,810),(38,810),"/>
			<Connection Source="_base.iSensor2" Destination="this.iSensor2" Vertices="(218,870),(38,870),"/>
			<Connection Source="_base.iSawReady" Destination="this.iSawReady" Vertices="(218,930),(38,930),"/>
			<Connection Source="_base.iActPosWagon" Destination="this.iActPosWagon" Vertices="(218,990),(38,990),"/>
			<Connection Source="_base.iMinPosForSawOperation" Destination="this.iMinPosForSawOperation" Vertices="(218,1050),(38,1050),"/>
			<Connection Source="_base.iActHeigthSaw" Destination="this.iActHeigthSaw" Vertices="(218,1110),(38,1110),"/>
			<Connection Source="_base.iActHeigthMaterial" Destination="this.iActHeigthMaterial" Vertices="(218,1170),(38,1170),"/>
			<Connection Source="_base.oMpsAutoMode" Destination="this.oMpsAutoMode" Vertices="(218,1230),(38,1230),"/>
			<Connection Source="_base.oStartSawCycle" Destination="this.oStartSawCycle" Vertices="(218,1290),(38,1290),"/>
			<Connection Source="_base.oPulseSawClamp" Destination="this.oPulseSawClamp" Vertices="(218,1350),(38,1350),"/>
			<Connection Source="_base.oEnableExtraction" Destination="this.oEnableExtraction" Vertices="(218,1410),(38,1410),"/>
			<Connection Source="_base.iPusherWagonInPos" Destination="this.iPusherWagonInPos" Vertices="(218,1470),(38,1470),"/>
			<Connection Source="_base.ctrlScreen" Destination="this.ctrlScreen" Vertices="(218,1590),(38,1530),"/>
			<Connection Source="_base.windowNr" Destination="this.windowNr" Vertices="(218,1650),(38,1590),"/>
			<Connection Source="_base.nrOffWindowTry" Destination="this.nrOffWindowTry" Vertices="(218,1710),(38,1650),"/>
			<Connection Source="_base.fileBase" Destination="this.fileBase" Vertices="(218,1770),(38,1710),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emMiterSawingUnit

emMiterSawingUnitV5286 : CLASS
: emMiterSawingUnit
  //Servers:
	hmiExtractionOn 	: SvrCh_DINT;
  //Clients:
	iEndMillingActive 	: CltCh_DINT;
	oStartMilling 	: CltCh_DINT;
  //Variables:
		timerExtraction 	: strTimer;
  //Functions:
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL runAction;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emMiterSawingUnitV5286::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMMITERSAWINGUNITV5286
0$UINT, 0$UINT, (SIZEOF(::emMiterSawingUnitV5286))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(3013632119), "emMiterSawingUnitV5286", //Class
TO_UDINT(3730376064), "emMiterSawingUnit", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emMiterSawingUnitV5286.hmiExtractionOn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2512523525), "hmiExtractionOn", 
//Clients:
(::emMiterSawingUnitV5286.iEndMillingActive.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(347374715), "iEndMillingActive", 
(::emMiterSawingUnitV5286.oStartMilling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1392034099), "oStartMilling", 
END_FUNCTION


#define USER_CNT_emMiterSawingUnitV5286 41

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emMiterSawingUnitV5286] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emMiterSawingUnitV5286::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emMiterSawingUnit::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emMiterSawingUnitV5286;
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #runAction();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	hmiExtractionOn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF hmiExtractionOn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 16-8-2022: emMiterSawingUnitV5286 derived from emMiterSawingUnit, only difference is, here we start milling after sawing (if this function is activated)


FUNCTION VIRTUAL emMiterSawingUnitV5286::runAction


  IF stprAction >= 11 & stprAction <= 13 THEN //during going into material enable lubrication
    oEnableLubrication:= 1;
  END_IF;
  
  //check if motor isn't switched off during drilling
  IF stprAction>= 6 & stprAction<= 20 & stsStateMotor<>moRunning & motorConnected= 1 THEN
    tmpMotorNotRunningDuringOperation:= 1;
  END_IF;  

  oMpsAutoMode:= 1; //write automode always if in run action

  CASE stprAction OF
  
  0: //wait for start
  
  1: //control automatic stuff, if there is
    IF angleServoConnected= 1 &  ctrlYAngleServo.checkInPos(checkPos:=actionLine.xy1Angle)= 0 THEN //give alarm if not in right position, but only if servo isconnected
      giveAlarm(errorNr:=4);
    ELSE
      stprAction+=1;
    END_IF; 
    
  2: //switch automode on, check if saw is in automode, and if wagon has right position
    IF iSawInAutomode= 1 & iSawReady= 1 & iActPosWagon >= iMinPosForSawOperation & iHydroPumpOn= 1 THEN //RVDL 19-12-2019   changed hydropomp to =1
      stprAction+=1;
    ELSIF iSawInAutomode= 0 THEN
      giveAlarm(errorNr:=2);
    ELSIF iSawReady= 0 THEN
      giveAlarm(errorNr:=5);
    ELSIF iActPosWagon < iMinPosForSawOperation THEN
      giveAlarm(errorNr:=10);
    ELSIF iHydroPumpOn= 0 THEN
      giveAlarm(errorNr:=8);
    END_IF;
    
  3: //check if we need long sawing or short sawing
    IF iActHeigthMaterial <= parMaxHeightForSensor1 THEN
      tmpDoShortSawing:= 1;
    ELSE
      tmpDoShortSawing:= 0;
    END_IF;
    stprAction+=1;
    
  4: //start motor and wait for it
    IF motorConnected= 0 | stsStateMotor= moRunning THEN
      stprAction+=1;
    ELSIF motorConnected= 1 THEN
      ctrlMotor.csStartFwd(speed:=1000);
    END_IF;
     
  5: //check if movement is allowed
    IF iOperationAllowed= 1 THEN
      stprAction+=1;
    ELSIF iOperationAllowed=0 THEN
      giveAlarm(errorNr:=3);
    END_IF;
    
  6: //close clamps
    oPulseSawClamp:=1; //extra output for pulse controlled clamps on JIH saws  
    IF stsPosClamps=cilNotConnected | stsPosClamps=cilOut THEN
      stprAction+=1;
    ELSIF clampsConnected=1 THEN
      ctrlClamp.csMoveOut();
    END_IF;
    
  7: //wait for clamps to open/close
    oPulseSawClamp:= 1;
    IF TimerWaitForClamp.done THEN //wait for clamps  until its closed, only needed if clamp is closed by a pulse
      stprAction+=1;
    END_IF;      
    
  8: //start sawing
    oStartSawCycle:=1;
    IF iSawReady=0 THEN
      stprAction+=1;
    END_IF;
    
 9: //wait minimum time for sawpulse
    oStartSawCycle:=1;
    if (tmpDoShortSawing & iSensor1 ) |  iSensor2 | iSawReady | (iActHeigthSaw > iActHeigthMaterial & sawHeightConnected) | pmlCom.cmd.simulation = allSimu then //JdK 15-8-2022, it's ok if sensor 1 is active for small material, or sensor 2 is active, or cycle is done and saw ready is active again, or if analog sensor is used
      stprAction+=1;
      oStartSawCycle:=0;
    end_if;
    
  10: //wait until ready again
    IF iSawReady=1 | pmlCom.cmd.simulation = allSimu THEN
      stprAction+=1;
    END_IF;  
     
  11: //reserve
    stprAction+=1;
    
  12: //start blowing
    IF blowerConnected= 1 THEN
      ctrlBlower.cmdBlow.Write(input:=1);
    END_IF;
    stprAction+=1;
    
  13: //open clamps
    IF stsPosClamps=cilNotConnected | stsPosClamps=cilin THEN
      stprAction+=1;
    // Jdk 14-10-2021 dont give signal to open clamp, this goes automatically, we have to wait until clamp is opened, so just wait for the timer in the next step oPulseSawClamp:=1;
    ELSIF clampsConnected=1 THEN
      ctrlClamp.csMoveIn();
    END_IF;
    
  14: //wait for clamps to be open again
    IF TimerWaitForClamp.done THEN 
      stprAction+=1;
    END_IF;      
    
  15: //if in manual or half auto, switch off motor
    IF (motorConnected=0 | (pmlCom.sts.mode=auto | pmlCom.sts.mode=service) | stsStateMotor=moOff) & timerWaitTime.done THEN
      stprAction+=1;
    ELSE
      ctrlMotor.csStop();
    END_IF;  

  16: //start milling only after sawing endpiece
    iEndMillingActive:= iEndMillingActive.Read();
    IF iEndMillingActive & actionLine.actione<>1 & pmlCom.sts.mode= auto THEN
      oStartMilling.Write(input:=1);
    END_IF;
    stprAction+=1;  
   
  17: // done
    stprAction:=0;
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnitV5286::work

  IF stsHMI_RunsAllowed & stprAction<> 0 & (pmlCom.sts.mode=manual | pmlCom.sts.mode= halfAuto | pmlCom.sts.mode= service) THEN //if hmi run is allowed, run action (if one was started)
    runAction();
  END_IF;
  IF ((pmlCom.sts.mode = auto & (oldMode = manual | oldMode = halfAuto)) | //stop movement if mode changes, but keep old auto stepper
    ((pmlCom.sts.mode = manual | pmlCom.sts.mode = halfAuto) & oldMode = auto)) & stprAction<> 0 THEN
    IF oldMode = auto | oldMode = service THEN
      oldAutoStprAction:=stprAction;
    END_IF;
    stprAction:=0;
  END_IF;

  oldMode:=pmlCom.sts.mode;  
  
   
  timerExtraction:=runTimer(Active:=iOperationAllowed, iMem:=timerExtraction, TimerTime:=2000, Pause:=0);
  
  //control extraction unit
  IF (iOperationAllowed & timerExtraction.done) | (hmiExtractionOn= 1 & (pmlCom.sts.mode= manual | pmlCom.sts.mode= halfAuto)) THEN
    oEnableExtraction:=1;
  ELSE
    oEnableExtraction:=0;
  END_IF;  
    
    
    
END_FUNCTION
