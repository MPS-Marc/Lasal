//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_ISE021                            1036
#define ISE021_OFFSET_DIGOUT_REGISTER               16#0380
#define ISE021_OFFSET_DIGOUT_REGISTER_SECOND_RS232  16#037D

#define ISE021_SDO_RESPONSE_TIMEOUT                 (SDIAS_SDO_TIMEOUT * 2)
//Other Defines
#define ISE021_UART_FPGA_VER_MORE_BAUDRATES_9BIT_MODE_AVAILABLE 16#00000012
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "ISE021"
	Revision           = "1.23"
	GUID               = "{CB74BF38-AFCD-46E7-80E3-4738D2B6E50F}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(628,120)"
	Comment            = "SDIAS serial interface module with 3 UARTs:&#13;&#10; - RS232 1&#13;&#10; - RS485&#13;&#10; - RS232 2">
	<Channels>
		<Server Name="ClassState">
		</Server>
		<Server Name="InvalidDataErrorCnt1" GUID="{691AB241-8C3C-4CE6-B6CC-D9C7899D6464}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if a framing or parity error occurs"/>
		<Server Name="InvalidDataErrorCnt2" GUID="{71B5E631-7729-462D-AFAE-2DC0B87323FD}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if a framing or parity error occurs"/>
		<Server Name="InvalidDataErrorCnt3" GUID="{240BC3B4-25F0-4806-8FC1-CEBDDD3579AB}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if a framing or parity error occurs."/>
		<Server Name="RecBufOverflowErrorCnt1" GUID="{183B830B-0FB7-4EC4-B62A-8DE50C84E821}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if the receive buffer is overflowed."/>
		<Server Name="RecBufOverflowErrorCnt2" GUID="{7D52E4FA-393B-47F2-89B9-CDB7C29FE5E6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if the receive buffer is overflowed."/>
		<Server Name="RecBufOverflowErrorCnt3" GUID="{45354C59-C8FC-4B36-8CFE-59B66402F031}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server counts up if the receive buffer is overflowed."/>
		<Server Name="SerInterface1" GUID="{118D1C3C-0DEF-4F2B-8CFF-C88AC64BD4E3}" Class="SdiasUartHandler" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="RS232 Interface for calling global methods"/>
		<Server Name="SerInterface2" GUID="{D7D11C8F-26E7-4A6A-8E44-0EF4FA82D82E}" Class="SdiasUartHandler" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="RS485 Interface for calling global methods"/>
		<Server Name="SerInterface3" GUID="{5494F270-383F-4BDB-8281-EA08FE0FBFEA}" Class="SdiasUartHandler" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Second RS232 Interface for calling global methods if function is available and activated with &quot;ActivateIF3&quot;.&#13;&#10;"/>
		<Client Name="ActivateIF3" Required="true" Internal="false" DefValue="0" Comment="Can be activate to use second RS232 interface if it is supported by hardware (FPGA &gt;= v2.0).&#13;&#10;Must be set as initial value.&#13;&#10;0 .. deactivated&#13;&#10;1 .. activated&#13;&#10;&#13;&#10;-1 .. not supported or deactivated"/>
		<Client Name="MaxRdLenIF1" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to receive via SDIAS per cycle (the rest of the receive data is stored in the ringbuffer of the module).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="MaxRdLenIF2" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to receive via SDIAS per cycle (the rest of the receive data is stored in the ringbuffer of the module).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="MaxRdLenIF3" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to receive via SDIAS per cycle (the rest of the receive data is stored in the ringbuffer of the module).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="MaxWrLenIF1" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to transmit via SDIAS per cycle (the rest of the send data is stored in the ringbuffer of the class).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="MaxWrLenIF2" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to transmit via SDIAS per cycle (the rest of the send data is stored in the ringbuffer of the class).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="MaxWrLenIF3" Required="true" Internal="false" DefValue="16" Comment="Maximum byte to transmit via SDIAS per cycle (the rest of the send data is stored in the ringbuffer of the class).&#13;&#10;Must be set as initial value.&#13;&#10;0: Off (interface disabled)&#13;&#10;...&#13;&#10;16: Default&#13;&#10;...&#13;&#10;120: Maximum"/>
		<Client Name="RS485_Spread" Required="true" Internal="false" DefValue="0" Comment="Use this client to activate the internal spread of the RS485 interface.&#13;&#10;This feature is available at hw-version 3.0&#13;&#10;As initialisation value.&#13;&#10;&#13;&#10;0 .. spread inactive&#13;&#10;1 .. spread active&#13;&#10;-1 .. This feature is not available at this hw"/>
		<Client Name="RS485_Term" Required="true" Internal="false" DefValue="0" Comment="Use this client to activate the internal termination of the RS485 interface.&#13;&#10;This feature is available at hw-version 3.0&#13;&#10;As initialisation value.&#13;&#10;&#13;&#10;0 .. termination inactive&#13;&#10;1 .. termination active&#13;&#10;-1 .. This feature is not available at this hw"/>
		<Client Name="SdiasUartHandler1" Required="true" Internal="true"/>
		<Client Name="SdiasUartHandler2" Required="true" Internal="true"/>
		<Client Name="SdiasUartHandler3" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.23" Date="16.09.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.22" Date="03.07.2019" Author="PieSte" Company="Sigmatek" Description="Add support for second RS232 interface.&#13;&#10;Numbers have been added to the log messages so that they can be assigned."/>
		<Dokumentation Revision="1.21" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.20" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.19" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.18" Date="14.12.2017" Author="PieSte" Company="Sigmatek" Description="Save act transmit data length to calculate the correct used transmit buffer length at GetSendState() function (SA37717).&#13;&#10;Added &quot;RecBufOverflowErrorCnt&quot; to indicate that the receive buffer has overflowed.&#13;&#10;Now it is possible to call &quot;SetBaudrate&quot; at Init(). &#13;&#10;If hardware support the extended hw buffer it is used."/>
		<Dokumentation Revision="1.17" Date="29.06.2017" Author="PieSte" Company="Sigmatek" Description="Add transmit buffer used length of module (max 120byte) to return value at GetSendState() function.&#13;&#10;Removed message log for RecvChar() and RecvBlock() if there is no data in receive buffer."/>
		<Dokumentation Revision="1.16" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.15" Date="31.08.2016" Author="PieSte" Company="Sigmatek" Description="Add RSMode setting for TTY interface to enable or disable echo. Concerns only ISE031 hardware."/>
		<Dokumentation Revision="1.14" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.13" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.12" Date="16.11.2015" Author="PieSte" Company="Sigmatek" Description="Add cyclic task for logging to prevent rt-runtime error."/>
		<Dokumentation Revision="1.11" Date="15.10.2015" Author="PieSte" Company="Sigmatek" Description="Disable EchoOff for RS232 interface to enable receiving during transmit."/>
		<Dokumentation Revision="1.10" Date="22.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.9" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.8" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.7" Date="26.02.2015" Author="EisMic" Company="Sigmatek" Description="Added clients RS485_Term and RS485_Spread which can set the internal termination resistor and spread resistor of the module if HW Version is 3.0 or higher."/>
		<Dokumentation Revision="1.6" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.5" Date="30.01.2015" Author="RamAnd" Company="Sigmatek" Description="The parameters for creating DOs were not correctly initialized if SdiasManager class v1.63 or higher has been used."/>
		<Dokumentation Revision="1.4" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.3" Date="07.11.2014" Author="EisMic" Company="Sigmatek" Description="Implemented 9Bit Mode and more baudrates"/>
		<Dokumentation Revision="1.2" Date="10.07.2014" Author="ZoePat" Company="Sigmatek" Description="Corrected value of GetInterfaceType()."/>
		<Dokumentation Revision="1.1" Date="09.07.2014" Author="EisMic" Company="Sigmatek" Description="Added support for reading hardware diagnosis and hardwaretree entry."/>
		<Dokumentation Revision="1.0" Date="28.04.2014" Author="PieSte" Company="Sigmatek" Description="Initial library version."/>
	</RevDoku>
	<Network Name="ISE021">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{3495CC5D-2E0A-43B2-A5EA-C54A02DFDE5B}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "SdiasUartHandler1"
				GUID       = "{B12EA042-4AA4-4584-9AF7-258D377709B4}"
				Class      = "SdiasUartHandler"
				Position   = "(210,720)"
				Visualized = "true">
				<Channels>
					<Server Name="Com" Value="1"/>
					<Server Name="Command"/>
					<Server Name="HwOptionBits"/>
					<Server Name="InvalidDataErrorCnt"/>
					<Server Name="RecBufOverflowErrorCnt"/>
					<Client Name="AddressOffset" Value="0x0100"/>
					<Client Name="MaxRdLen" Value="16"/>
					<Client Name="MaxWrLen" Value="16"/>
					<Client Name="ToSdiasBase"/>
					<Client Name="ToStdLib"/>
					<Client Name="UartType" Value="0"/>
				</Channels>
			</Object>
			<Object
				Name       = "SdiasUartHandler2"
				GUID       = "{58994894-8A1C-4285-B46F-D4A393935B23}"
				Class      = "SdiasUartHandler"
				Position   = "(210,1200)"
				Visualized = "true">
				<Channels>
					<Server Name="Com" Value="2"/>
					<Server Name="Command"/>
					<Server Name="HwOptionBits"/>
					<Server Name="InvalidDataErrorCnt"/>
					<Server Name="RecBufOverflowErrorCnt"/>
					<Client Name="AddressOffset" Value="0x0200"/>
					<Client Name="MaxRdLen" Value="16"/>
					<Client Name="MaxWrLen" Value="16"/>
					<Client Name="ToSdiasBase"/>
					<Client Name="ToStdLib"/>
					<Client Name="UartType" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "SdiasUartHandler3"
				GUID       = "{3DB6548C-E190-47C4-810F-BCD1FE92D544}"
				Class      = "SdiasUartHandler"
				Position   = "(210,1680)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Com" Value="3"/>
					<Server Name="Command"/>
					<Server Name="HwOptionBits"/>
					<Server Name="InvalidDataErrorCnt"/>
					<Server Name="RecBufOverflowErrorCnt"/>
					<Client Name="AddressOffset" Value="0x0300"/>
					<Client Name="MaxRdLen" Value="16"/>
					<Client Name="MaxWrLen" Value="16"/>
					<Client Name="ToSdiasBase"/>
					<Client Name="ToStdLib"/>
					<Client Name="UartType" Value="0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(824,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(824,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(824,330),(632,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(824,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(824,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(824,570),(632,570),"/>
			<Connection Source="this.SdiasUartHandler1" Destination="SdiasUartHandler1.Command"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.SdiasUartHandler2" Destination="SdiasUartHandler2.Command"/>
			<Connection Source="SdiasUartHandler1.ToSdiasBase" Destination="_base.ClassState" Vertices="(210,810),(180,810),(180,690),(750,690),(750,210),(632,210),"/>
			<Connection Source="SdiasUartHandler2.ToSdiasBase" Destination="_base.ClassState" Vertices="(210,1290),(180,1290),(180,690),(750,690),(750,210),(632,210),"/>
			<Connection Source="this.SerInterface1" Destination="SdiasUartHandler1.Command" Vertices="(824,630),(652,810),"/>
			<Connection Source="this.SerInterface2" Destination="SdiasUartHandler2.Command" Vertices="(824,810),(652,1290),"/>
			<Connection Source="SdiasUartHandler1.MaxRdLen" Destination="this.MaxRdLenIF1" Vertices="(210,1050),(180,1050),(180,630),(38,630),"/>
			<Connection Source="SdiasUartHandler1.MaxWrLen" Destination="this.MaxWrLenIF1" Vertices="(210,1110),(180,1110),(180,690),(38,690),"/>
			<Connection Source="SdiasUartHandler2.MaxRdLen" Destination="this.MaxRdLenIF2" Vertices="(210,1530),(180,1530),(180,750),(38,750),"/>
			<Connection Source="SdiasUartHandler2.MaxWrLen" Destination="this.MaxWrLenIF2" Vertices="(210,1590),(180,1590),(180,810),(38,810),"/>
			<Connection Source="this.InvalidDataErrorCnt1" Destination="SdiasUartHandler1.InvalidDataErrorCnt" Vertices="(824,690),(652,930),"/>
			<Connection Source="this.InvalidDataErrorCnt2" Destination="SdiasUartHandler2.InvalidDataErrorCnt" Vertices="(824,870),(652,1410),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(824,390),(632,390),"/>
			<Connection Source="this.RecBufOverflowErrorCnt1" Destination="SdiasUartHandler1.RecBufOverflowErrorCnt" Vertices="(824,750),(652,990),"/>
			<Connection Source="this.RecBufOverflowErrorCnt2" Destination="SdiasUartHandler2.RecBufOverflowErrorCnt" Vertices="(824,930),(652,1470),"/>
			<Connection Source="this.SdiasUartHandler3" Destination="SdiasUartHandler3.Command"/>
			<Connection Source="SdiasUartHandler3.ToSdiasBase" Destination="_base.ClassState" Vertices="(210,1770),(180,1770),(180,690),(750,690),(750,210),(632,210),"/>
			<Connection Source="this.SerInterface3" Destination="SdiasUartHandler3.Command" Vertices="(824,990),(652,1770),"/>
			<Connection Source="this.InvalidDataErrorCnt3" Destination="SdiasUartHandler3.InvalidDataErrorCnt" Vertices="(824,1050),(652,1890),"/>
			<Connection Source="this.RecBufOverflowErrorCnt3" Destination="SdiasUartHandler3.RecBufOverflowErrorCnt" Vertices="(824,1110),(652,1950),"/>
			<Connection Source="SdiasUartHandler3.MaxRdLen" Destination="this.MaxRdLenIF3" Vertices="(210,2010),(180,2010),(180,870),(38,870),"/>
			<Connection Source="SdiasUartHandler3.MaxWrLen" Destination="this.MaxWrLenIF3" Vertices="(210,2070),(180,2070),(180,930),(38,930),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

ISE021 : CLASS
: SdiasBase
	TYPE
	  t_e_InitSSW :
	  (
	    _GetHWID,
	    _InitModule1,
	    _InitModule2,
	    _CheckInitModule3,
	    _InitModule3,
	    _CheckConfigNeeded,
	    _ConfigModule,
	    _SetOptionBits,
	    _Finish,
	    _InitError
	  )$UDINT;
	  t_ReadData : BSINT
	  [
	    1 HwIDBit0,
	    2 HwIDBit1,
	    3 HwIDBit2,
	    4 HwIDBit3,
	    5 DCOK,
	    6 OverVoltage,
	  ];
#pragma pack(push, 1)
	  t_SecondRS232 : STRUCT
	    bSecondRS232Activated : BOOL;
	    pReadData : ^t_ReadData;
	    pReadControlByte : ^t_SDIAS_ControlByte;
	    pReadStateByte : t_SDIAS_StateByte;
	    ReadAccessHandle : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_WriteData : BSINT
	  [
	    1 RS485_Term,
	    2 RS485_Spread,
	    3 RS485_Term2,
	    4 RS485_Spread2,
	    5 RS232_SecondIF,
	    6 ResistorActive,
	  ];
	END_TYPE
  //Servers:
	SerInterface1 	: SvrChCmd_DINT;
	InvalidDataErrorCnt1 	: SvrCh_DINT;
	RecBufOverflowErrorCnt1 	: SvrCh_DINT;
	SerInterface2 	: SvrChCmd_DINT;
	InvalidDataErrorCnt2 	: SvrCh_DINT;
	RecBufOverflowErrorCnt2 	: SvrCh_DINT;
	SerInterface3 	: SvrChCmd_DINT;
	InvalidDataErrorCnt3 	: SvrCh_DINT;
	RecBufOverflowErrorCnt3 	: SvrCh_DINT;
  //Clients:
	SdiasUartHandler1 	: CltChCmd_SdiasUartHandler;
	SdiasUartHandler2 	: CltChCmd_SdiasUartHandler;
	MaxRdLenIF1 	: CltCh_UDINT;
	MaxWrLenIF1 	: CltCh_UDINT;
	MaxRdLenIF2 	: CltCh_UDINT;
	MaxWrLenIF2 	: CltCh_UDINT;
	MaxRdLenIF3 	: CltCh_UDINT;
	MaxWrLenIF3 	: CltCh_UDINT;
	ActivateIF3 	: CltCh_DINT;
	RS485_Spread 	: CltCh_DINT;
	RS485_Term 	: CltCh_DINT;
	SdiasUartHandler3 	: CltChCmd_SdiasUartHandler;
  //Variables:
		pReadData 	: ^t_ReadData;
		eInitSSW 	: t_e_InitSSW;
		eResponseState 	: t_ResponseInfo;
		udSDOTimeOut 	: UDINT;
		DigIOReadData 	: t_ReadData;
		ConfigWriteData 	: t_WriteData;
		sSecondRS232IF 	: t_SecondRS232;
  //Functions:
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit0..Realtime PreScan&#13;&#10;Bit1..Realtime PostScan&#13;&#10;Bit2..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClassState::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InvalidDataErrorCnt1::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RecBufOverflowErrorCnt1::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InvalidDataErrorCnt2::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RecBufOverflowErrorCnt2::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SerInterface3::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InvalidDataErrorCnt3::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL RecBufOverflowErrorCnt3::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using SdiasUartHandler


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB ISE021::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_ISE021
1$UINT, 23$UINT, (SIZEOF(::ISE021))$UINT, 
9$UINT, 12$UINT, 0$UINT, 
TO_UDINT(3525924552), "ISE021", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::ISE021.SerInterface1.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2614581643), "SerInterface1", 
(::ISE021.InvalidDataErrorCnt1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2923839687), "InvalidDataErrorCnt1", 
(::ISE021.RecBufOverflowErrorCnt1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1088449367), "RecBufOverflowErrorCnt1", 
(::ISE021.SerInterface2.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(48105521), "SerInterface2", 
(::ISE021.InvalidDataErrorCnt2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(927928701), "InvalidDataErrorCnt2", 
(::ISE021.RecBufOverflowErrorCnt2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3655940845), "RecBufOverflowErrorCnt2", 
(::ISE021.SerInterface3.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1977170087), "SerInterface3", 
(::ISE021.InvalidDataErrorCnt3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1078469099), "InvalidDataErrorCnt3", 
(::ISE021.RecBufOverflowErrorCnt3.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2934835835), "RecBufOverflowErrorCnt3", 
//Clients:
(::ISE021.SdiasUartHandler1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(569820569), "SdiasUartHandler1", TO_UDINT(1297832995), "SdiasUartHandler", 1$UINT, 12$UINT, 
(::ISE021.SdiasUartHandler2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3103757347), "SdiasUartHandler2", TO_UDINT(1297832995), "SdiasUartHandler", 1$UINT, 12$UINT, 
(::ISE021.MaxRdLenIF1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(1914348531), "MaxRdLenIF1", 
(::ISE021.MaxWrLenIF1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(1056179299), "MaxWrLenIF1", 
(::ISE021.MaxRdLenIF2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(3943952969), "MaxRdLenIF2", 
(::ISE021.MaxWrLenIF2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(2818397657), "MaxWrLenIF2", 
(::ISE021.MaxRdLenIF3.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(2618606303), "MaxRdLenIF3", 
(::ISE021.MaxWrLenIF3.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(3506070863), "MaxWrLenIF3", 
(::ISE021.ActivateIF3.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2470508870), "ActivateIF3", 
(::ISE021.RS485_Spread.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2600991563), "RS485_Spread", 
(::ISE021.RS485_Term.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3549818403), "RS485_Term", 
(::ISE021.SdiasUartHandler3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3489178805), "SdiasUartHandler3", TO_UDINT(1297832995), "SdiasUartHandler", 1$UINT, 12$UINT, 
END_FUNCTION


#define USER_CNT_ISE021 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_ISE021] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION ISE021::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_ISE021;
	vmt.CmdTable.NewInstr		:= #ClassState::NewInst();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SerInterface1.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	SerInterface1.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SerInterface1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	InvalidDataErrorCnt1.pMeth			:= StoreMethod( #InvalidDataErrorCnt1::Read(), #M_NO_F() );
	IF InvalidDataErrorCnt1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RecBufOverflowErrorCnt1.pMeth			:= StoreMethod( #RecBufOverflowErrorCnt1::Read(), #M_NO_F() );
	IF RecBufOverflowErrorCnt1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SerInterface2.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	SerInterface2.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SerInterface2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	InvalidDataErrorCnt2.pMeth			:= StoreMethod( #InvalidDataErrorCnt2::Read(), #M_NO_F() );
	IF InvalidDataErrorCnt2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RecBufOverflowErrorCnt2.pMeth			:= StoreMethod( #RecBufOverflowErrorCnt2::Read(), #M_NO_F() );
	IF RecBufOverflowErrorCnt2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, SerInterface3.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #SerInterface3::Read();
	SerInterface3.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SerInterface3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	InvalidDataErrorCnt3.pMeth			:= StoreMethod( #InvalidDataErrorCnt3::Read(), #M_NO_F() );
	IF InvalidDataErrorCnt3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RecBufOverflowErrorCnt3.pMeth			:= StoreMethod( #RecBufOverflowErrorCnt3::Read(), #M_NO_F() );
	IF RecBufOverflowErrorCnt3.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL ISE021::ClassState::NewInst
  VAR_INPUT
    pPara   : ^CmdStruct;
    pResult   : ^results;
  END_VAR
  VAR_OUTPUT
    ret_code   : iprStates;
  END_VAR

  ret_code := READY;
  
  CASE pPara^.uiCmd OF
    //**********************************************************************************************************************************************************
    SDIAS_CLT_CMD_ADD_DYN_READ:
      // complete the parameters for adding the access to sdias manager
      pPara^.aPara[0] := this$DINT;
      pPara^.aPara[1] := Place$DINT;
      pPara^.aPara[2] := Required;
      pPara^.uiCmd := SDIAS_CMD_ADD_DYN_RD_ACCESS;
      ret_code := SdiasIn.NewInst(pPara, pResult);

    //**********************************************************************************************************************************************************
    SDIAS_CLT_CMD_ADD_DYN_WRITE:
      // complete the parameters for adding the access to sdias manager
      pPara^.aPara[0] := this$DINT;
      pPara^.aPara[1] := Place$DINT;
      pPara^.aPara[2] := Required;
      pPara^.uiCmd := SDIAS_CMD_ADD_DYN_WR_ACCESS;
      ret_code := SdiasIn.NewInst(pPara, pResult);

    //**********************************************************************************************************************************************************
    SDIAS_CLT_CMD_CHG_DYN_ACCESS:
      pPara^.uiCmd := SDIAS_CMD_CHANGE_DYN_ACCESS;
      ret_code := SdiasIn.NewInst(pPara, pResult);
      
    //**********************************************************************************************************************************************************
    SDIAS_CLT_SDO_CMD_MEM_READ:
      ret_code := StartReadSDO(hOffset:=pPara^.aPara[0]$HINT, usLength:=pPara^.aPara[1]$USINT, eCommand:=pPara^.aPara[2]$t_SDIAS_SDO_Cmd);
      
  //**********************************************************************************************************************************************************
  ELSE
    ret_code := SdiasBase::ClassState.NewInst(pPara, pResult);
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::CheckDeviceID
  VAR_INPUT
    udID2Check   : UDINT;
  END_VAR
  VAR_OUTPUT
    bIsOK   : BOOL;
  END_VAR

    //look if it is right hardware
  if ( udID2Check <> DEVICE_ID_ISE021 ) then
    bIsOK := FALSE;
  else
    bIsOK := TRUE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL ISE021::GetTaskCfg
  VAR_OUTPUT
    TaskCfg   : BDINT;
  END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST OR SDIAS_TASK_MASK_CY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::UpdateRt

  // call the UART Handler objects
  SdiasUartHandler1.UpdateRt();
  SdiasUartHandler2.UpdateRt();  
  SdiasUartHandler3.UpdateRt();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::UpdateRtPostScan

  // call the UART Handler objects
  SdiasUartHandler1.UpdateRtPostScan();
  SdiasUartHandler2.UpdateRtPostScan();  
  SdiasUartHandler3.UpdateRtPostScan();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::UpdateCy

  // call the UART Handler objects for logging
  SdiasUartHandler1.UpdateCy();
  SdiasUartHandler2.UpdateCy();
  SdiasUartHandler3.UpdateCy();
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::AddAccesses
  VAR_OUTPUT
    eModuleInitState   : iprStates;
  END_VAR
  VAR
    TempModuleState : iprStates;
  END_VAR
  
  //If an error occurs, the return value of the error is used for eModuleInitState.
  eModuleInitState := READY;
  
  // call the UART Handler objects  
  TempModuleState := SdiasUartHandler1.AddAccesses();
  
  if TempModuleState <> READY then
    eModuleInitState := TempModuleState;
    return;
  end_if;
  
  TempModuleState := SdiasUartHandler2.AddAccesses();

  if TempModuleState <> READY then
    eModuleInitState := TempModuleState;
    return;
  end_if;
  
  ActivateIF3 := ActivateIF3.Read();
  //Accesses must be added if IF is activated
  if ActivateIF3 then
  
    TempModuleState := SdiasUartHandler3.AddAccesses();
    
    if TempModuleState <> READY then
      eModuleInitState := TempModuleState;
      return;
    end_if;
      
    TempModuleState :=AddRdAccess(hOffset:= ISE021_OFFSET_DIGOUT_REGISTER_SECOND_RS232
                                , uLength:= 1          
                                , ppData:= #pReadData
                                , ppStateByte:= #sSecondRS232IF.pReadStateByte
                                , ppControlByte:= #sSecondRS232IF.pReadControlByte
                                , pAccessHandle:= #sSecondRS232IF.ReadAccessHandle);
  
    if TempModuleState <> READY then
      eModuleInitState := TempModuleState;
      return;
    end_if;
    //second interface should be used
    sSecondRS232IF.bSecondRS232Activated := TRUE;    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::ConnectEvent

  // call the UART Handler objects
  SdiasUartHandler1.ConnectEvent();
  SdiasUartHandler2.ConnectEvent();
  //SdiasUartHandler3.ConnectEvent() is called at initmodule if needed.  
    
  eInitSSW       := _GetHWID;
  eResponseState := idle;
  eInitState     := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::InvalidDataErrorCnt1::Read
  VAR_OUTPUT
    output (EAX)   : DINT;
  END_VAR

  InvalidDataErrorCnt1 := SdiasUartHandler1.InvalidDataErrorCnt.Read();
  output := InvalidDataErrorCnt1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::InvalidDataErrorCnt2::Read
  VAR_OUTPUT
    output (EAX)   : DINT;
  END_VAR

  InvalidDataErrorCnt2 := SdiasUartHandler2.InvalidDataErrorCnt.Read();
  output := InvalidDataErrorCnt2;

END_FUNCTION


FUNCTION VIRTUAL ISE021::GetDeviceID
  VAR_OUTPUT
    output   : UDINT;
  END_VAR
  
  output := DEVICE_ID_ISE021;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::InitModule
  VAR_OUTPUT
    eModuleInitState   : iprStates;
  END_VAR
  VAR
    TmpRetcode   : iprStates;
    TmpHwOptionBits : SdiasUartHandler::t_bdOptionBits;
    bInterfaceActive : BOOL;
  END_VAR  
  
  eModuleInitState := BUSY;
  
  case eInitSSW of 
    //****************************************************************************************************************************************
    _GetHWID: 
      case eResponseState of
        idle:
          TmpRetcode  := StartReadSDO(hOffset:=ISE021_OFFSET_DIGOUT_REGISTER, usLength:=sizeof(t_ReadData), eCommand:=SDIAS_SDO_CMD_MEM_READ);
          if TmpRetcode = READY then
            udSDOTimeout   := ops.tAbsolute;
            eResponseState := wait; 
          elsif TmpRetcode = ERROR then
            LogError("@0536 (ISE021::InitModule) Failed to add read SDO for HW ID.");
            eInitState       := _NoMem;
            eModuleInitState := ERROR;
          end_if; 
          //*****************************************************
        wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ISE021_SDO_RESPONSE_TIMEOUT) then
            LogError("@0118 (ISE021::InitModule) SDO Response timeout read HW ID.");
            eInitSSW  :=   _InitError;
          end_if;
        //*****************************************************
        valid:        
          eInitSSW       := _InitModule1;
          eResponseState := idle;
          
      end_case;    
            
    //****************************************************************************************************************************************
    _InitModule1:     
      TmpRetcode := SdiasUartHandler1.InitModule();  
      if TmpRetcode = READY then
        eInitSSW := _InitModule2;
      elsif TmpRetcode = ERROR then
        LogError("@0537 (ISE021::InitModule) Failed to init serial interface 1.");
        eInitSSW := _InitError;
      end_if;
      
    //****************************************************************************************************************************************
    _InitModule2:          
      TmpRetcode := SdiasUartHandler2.InitModule();
      if TmpRetcode = READY then        
        eInitSSW := _CheckInitModule3;
      elsif TmpRetcode = ERROR then
        LogError("@0537 (ISE021::InitModule) Failed to init serial interface 2.");
        eInitSSW := _InitError;
      end_if;      
      
    //****************************************************************************************************************************************
    _CheckInitModule3:
      //check if interface is activated
      SdiasUartHandler3.GetIFState(pbInterfaceActive:=#bInterfaceActive);
      //must only be called if it is activated and supported by interface 1
      if sSecondRS232IF.bSecondRS232Activated & SdiasUartHandler1.HwOptionBits.SecondUARTAvailable & bInterfaceActive then 
        //call uart handler for second RS232 interface
        SdiasUartHandler3.ConnectEvent();
        if sSecondRS232IF.pReadControlByte then
          sSecondRS232IF.pReadControlByte^.EnableDO := TRUE;
        end_if;    
        
        //Disable default access if second RS232 is used
        if DefaultAccesses.ReadAccess.pControlByte then
          DefaultAccesses.ReadAccess.pControlByte^.EnableDO := FALSE;
        end_if;
        
        eInitSSW := _InitModule3;
      else
        if sSecondRS232IF.bSecondRS232Activated = TRUE then
          sSecondRS232IF.bSecondRS232Activated := FALSE;
          ActivateIF3      := -1;
          LogError("@0538 (ISE021::InitModule) Second RS232 Interface is not supported, update fpga version.");
        end_if;
        //deactivate additional Interface calls
        bInterfaceActive := FALSE;
        SdiasUartHandler3.SetIFState(pbInterfaceActive:=#bInterfaceActive);
        eInitSSW := _CheckConfigNeeded;
      end_if;
      //set state of additional interface at SdiasUartHandler
      SdiasUartHandler1.SetIFState(pbAdditionalIFActive:=#sSecondRS232IF.bSecondRS232Activated);
    
    //****************************************************************************************************************************************
    _InitModule3:         
      TmpRetcode := SdiasUartHandler3.InitModule();
      if TmpRetcode = READY then
        eInitSSW := _CheckConfigNeeded;
      elsif TmpRetcode = ERROR then
        LogError("@0537 (ISE021::InitModule) Failed to init serial interface 3.");
        eInitSSW := _InitError;
      end_if; 
      
    //****************************************************************************************************************************************
    _CheckConfigNeeded:    
      if DigIOReadData.HwIDBit2 = 1 | sSecondRS232IF.bSecondRS232Activated = TRUE then
        //We have a new hardware version of the ise
        eInitSSW       := _ConfigModule;
        eResponseState := idle;
      else
        eInitSSW       := _SetOptionBits;
        eResponseState := idle;
        RS485_Term     := -1;
        RS485_Spread   := -1;
      end_if;
      
    //****************************************************************************************************************************************
    _ConfigModule:    
      case eResponseState of
        idle:          
          //Get Client data
          RS485_Spread := RS485_Spread.Read();
          RS485_Term := RS485_Term.Read();
          
          ConfigWriteData.RS485_Term     := RS485_Term$BOOL;
          ConfigWriteData.RS485_Spread   := RS485_Spread$BOOL;
          ConfigWriteData.RS232_SecondIF := sSecondRS232IF.bSecondRS232Activated;

          TmpRetcode  := StartWriteSDO(hOffset:=ISE021_OFFSET_DIGOUT_REGISTER, usLength:=sizeof(ConfigWriteData), pWriteBuffer:=(#ConfigWriteData)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= wait; 
          elsif TmpRetcode = ERROR then
            LogError("@0539 (ISE021::InitModule) Failed to add write SDO for rs485 termination/spread configuration");
            eInitState       := _NoMem;
            eModuleInitState := ERROR;
          end_if;
          //*****************************************************
        wait:
          // wait for response
          if ((ops.tAbsolute - udSDOTimeout) > ISE021_SDO_RESPONSE_TIMEOUT) then
            LogError("@0118 (ISE021::InitModule) SDO Response timeout config module.");
            eInitSSW := _InitError;
          end_if;
        //*****************************************************
        valid:
          eInitSSW        := _SetOptionBits;
          eResponseState  := idle;
        //*****************************************************
      end_case;     
      
    //****************************************************************************************************************************************
    _SetOptionBits:          
      if FPGAVersion >= ISE021_UART_FPGA_VER_MORE_BAUDRATES_9BIT_MODE_AVAILABLE then
        TmpHwOptionBits := 0;
        TmpHwOptionBits._9BitMode := TRUE;
        TmpHwOptionBits.FlexibleBaudrate := TRUE;
        SdiasUartHandler1.SetHwOptionBits(TmpHwOptionBits);
        SdiasUartHandler2.SetHwOptionBits(TmpHwOptionBits);
      end_if;
      eInitSSW := _Finish;
      
    //****************************************************************************************************************************************
    _Finish:
      eInitSSW         := _GetHWID;
      eInitState       := _ClassOk;    
      eModuleInitState := READY;  
 
    //****************************************************************************************************************************************
    _InitError:
      eModuleInitState := ERROR; 
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
  
  //****************************************************************************************************************************************
  end_case;

END_FUNCTION


FUNCTION VIRTUAL ISE021::ReceiveSDOResponse
  VAR_INPUT
    eCommand   : t_SDIAS_SDO_Cmd;
    hOffset   : HINT;
    usLength   : USINT;
    eResult   : iprStates;
    pResponseBuffer   : ^USINT;
    ResponseLength   : USINT;
  END_VAR
  VAR_OUTPUT
    ret_code   : iprStates;
  END_VAR

  ret_code := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);

  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;  
  
  if eResult = READY then
    //****************************************************************************************************************************************    
    case eCommand of
      //****************************************************************************************************************************************
      SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
          ISE021_OFFSET_DIGOUT_REGISTER:
            if eResponseState = wait then
              eResponseState := valid;
            end_if;
            
        end_case;
        
      //****************************************************************************************************************************************
      SDIAS_SDO_CMD_MEM_READ:
        case hOffset of
          ISE021_OFFSET_DIGOUT_REGISTER:
            if eResponseState = wait then
              eResponseState := valid;
              DigIOReadData := pResponseBuffer^$t_ReadData;  
            end_if;
        
        else    
          //call internal classes for sdo response
          if SdiasUartHandler1.ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength) = READY then
            eResponseState := valid;
          elsif SdiasUartHandler2.ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength) = READY then
            eResponseState := valid;
          elsif SdiasUartHandler3.ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength) = READY then
            eResponseState := valid;
          end_if;
        end_case;
        
    end_case;
    
    if eResponseState <> valid then
      LogError("@00E7 (ISE021::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := _InitError;      
    end_if;
    
  else // Result not ready
    //****************************************************************************************************************************************
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogValue("@01C0 (ISE021::ReceiveSDOResponse) SDO Error while writing SDO with length 0x{0} to control offset 0x{1}", usLength, hOffset);
      SDIAS_SDO_CMD_MEM_READ:
        LogValue("@01C1 (ISE021::ReceiveSDOResponse) SDO Error while reading SDO with length 0x{0} from control offset 0x{1}", usLength, hOffset);
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL ISE021::RecBufOverflowErrorCnt1::Read
  VAR_OUTPUT
    output (EAX)   : DINT;
  END_VAR

  RecBufOverflowErrorCnt1 := SdiasUartHandler1.RecBufOverflowErrorCnt.Read();
  output := RecBufOverflowErrorCnt1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::RecBufOverflowErrorCnt2::Read
  VAR_OUTPUT
    output (EAX)   : DINT;
  END_VAR

  RecBufOverflowErrorCnt2 := SdiasUartHandler2.RecBufOverflowErrorCnt.Read();
  output := RecBufOverflowErrorCnt2;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL ISE021::SerInterface3::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  if sSecondRS232IF.bSecondRS232Activated then
    SerInterface3 := SdiasUartHandler3.Command.Read();
    output := SerInterface3;  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::InvalidDataErrorCnt3::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	InvalidDataErrorCnt3 := SdiasUartHandler3.InvalidDataErrorCnt.Read();
	output := InvalidDataErrorCnt3;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL ISE021::RecBufOverflowErrorCnt3::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	RecBufOverflowErrorCnt3 := SdiasUartHandler3.RecBufOverflowErrorCnt.Read();
	output := RecBufOverflowErrorCnt3;

END_FUNCTION
