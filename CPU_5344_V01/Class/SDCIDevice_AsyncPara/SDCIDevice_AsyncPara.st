//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "SDCIDevice_AsyncPara"
	Revision           = "1.3"
	GUID               = "{359E306C-F10F-4028-B87A-56DE26455329}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\SDCI.ico"
	SharedCommandTable = "true"
	Objectsize         = "(720,540)"
	Comment            = "Class for easy parameter exchange with SDCI Devices">
	<Channels>
		<Server Name="CmdState" GUID="{C8A49DE1-9D53-4809-AA1B-DFD4935C316E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the current class state:&#13;&#10;&#13;&#10;READY .. Ready for a new task / Successfully finished the previous task&#13;&#10;BUSY.. Busy with a task&#13;&#10;ERROR .. An error happend when executing the last task&#13;&#10;ERROR_BUSY .. The device did not respond within ten seconds"/>
		<Server Name="ErrorCode" GUID="{CD9F1BB7-0F2B-4808-9D82-3475ECE07A3A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="If the parameter transmission fails between the SDCI Master and the SDCI Device (when SDCIRetcode shows SDCI_MicroCtrl_ApplicationError), this server will show the reason.&#13;&#10;&#13;&#10;0x0080 .. Device application error&#13;&#10;0x1180 .. Index not available&#13;&#10;0x1280 .. Subindex not available&#13;&#10;0x2080 .. Service temporarily not available&#13;&#10;0x2180 .. Service temporarily not available - local control&#13;&#10;0x2280 .. Service temporarily not available - device control&#13;&#10;0x2380 .. Index not writeable&#13;&#10;0x3080 .. Parameter out of range&#13;&#10;0x3180 .. Parameter value above limit&#13;&#10;0x3280 .. Parameter value below limit&#13;&#10;0x3380 .. Parameter length overrun&#13;&#10;0x3480 .. Parameter length underrun&#13;&#10;0x3580 .. Function not available&#13;&#10;0x3680 .. Function temporarily unavailable&#13;&#10;0x4080 .. Invalid parameter set&#13;&#10;0x4180 .. Inconsistent parameter set&#13;&#10;0x8280 .. Application not ready&#13;&#10;0x??81 .. Vendor specific&#13;&#10;"/>
		<Server Name="ParaIndex" GUID="{0EB5D546-9ACC-4647-8E1F-7528966B0BF7}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Index of parameter that should be accessed (2 Byte range)"/>
		<Server Name="ParaRdWr" GUID="{CF24CD8C-18C1-4F90-AA85-2C5BD0F1213F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Choose the operation. The write-method also starts the command. &#13;&#10;0..read&#13;&#10;1..write&#13;&#10;&#13;&#10;The Server shows an error if starting the command is not possible:&#13;&#10;-1..the class is already busy or received an invalid input value for the command&#13;&#10;-2..invalid write length (only shown at the write command)&#13;&#10;"/>
		<Server Name="ParaSize" GUID="{CDD3AF24-26F5-4F6B-82CC-7BF6DACC32B0}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Set the size for writing (1-4 Bytes), for reading the size is returned (if the read data contain more than 4 bytes, only the first 4 bytes are copied to the ParaValue Server)"/>
		<Server Name="ParaSubIndex" GUID="{B7428093-BFBB-48FB-8754-E69FEDBD1021}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="SubIndex of parameter that should be accessed (1 Byte range)"/>
		<Server Name="ParaValue" GUID="{D17393AA-AB5F-48BA-9A8F-32D09AD1778A}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="When reading, this server will contain the read value after successful execution&#13;&#10;When writing, this servers value will be written to the device&#13;&#10;"/>
		<Server Name="SDCIRetcode" GUID="{CE99EB00-685C-48DE-9181-E26FEDE38F5D}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Returncode from device when sending a new command or checking the state of a command"/>
		<Client Name="TimeoutAsyCmd" Required="true" Internal="false" DefValue="10000" Comment="Timeout for asynchrone access. &#13;&#10;When using buffered asynchrone accesses (useBufferedAsyCmds = 1), the time processing of the buffer must be taken into account."/>
		<Client Name="ToDevice" Required="true" Internal="false" Comment="Connect to ClassState Server of SDCIDevice"/>
		<Client Name="useBufferedAsyCmds" Required="true" Internal="false" DefValue="0" Comment="0 .. This class will use the unbuffered methods to access the asychrone channel.&#13;&#10;1 .. This class will use the buffered methods to access the asychrone channel.&#13;&#10;(Buffered and unbuffered methods should not be combined for one SDCIMaster (IIO041)."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="RamAnd"/>
		<Dokumentation Revision="1.3" Date="16.12.2019" Author="PieSte" Company="Sigmatek" Description="Corrected wrong cast from usint to udint variable at CallBack() methode."/>
		<Dokumentation Revision="1.2" Date="19.06.2019" Author="LanSte" Company="Sigmatek" Description="Added support to use buffered commands."/>
		<Dokumentation Revision="1.1" Date="27.02.2017" Author="RamAnd" Company="Sigmatek" Description="It is now possible to initialize servers ParaIndex, ParaSubIndex, ParaSize and ParaValue."/>
		<Dokumentation Revision="1.0" Date="14.02.2017" Author="ZoePat" Company="Sigmatek" Description="first release version."/>
	</RevDoku>
</Class>
*)
SDCIDevice_AsyncPara : CLASS
	TYPE
	  t_SSW :
	  (
	    _WaitForCommand,
	    _SendCommand,
	    _WaitForAnswer
	  )$UDINT;
	END_TYPE
  //Servers:
	CmdState 	: SvrChCmd_iprStates;
	ParaRdWr 	: SvrCh_DINT;
	ParaIndex 	: SvrCh_UDINT;
	ParaSubIndex 	: SvrCh_UDINT;
	ParaSize 	: SvrCh_UDINT;
	ParaValue 	: SvrCh_DINT;
	SDCIRetcode 	: SvrCh_t_SDCIRetCode_PTofCls_SdiasSDCIMaster;
	ErrorCode 	: SvrCh_HDINT;
  //Clients:
	ToDevice 	: CltChCmd_SDCIDevice;
	useBufferedAsyCmds 	: CltCh_DINT;
	TimeoutAsyCmd 	: CltCh_UDINT;
  //Variables:
		SSW 	: t_SSW;
		StartTime 	: UDINT;
		pReadData 	: pVoid;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION CallBack
		VAR_INPUT
			pThis 	: pVoid;
			AsyState 	: SdiasSDCIMaster::t_SDCIRetCode;
			LengthOfData 	: USINT;
			pData 	: ^USINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ParaRdWr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd SDCIDevice


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SDCIDevice_AsyncPara::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_SDCIDEVICE_ASYNCPARA
1$UINT, 3$UINT, (SIZEOF(::SDCIDevice_AsyncPara))$UINT, 
8$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1321842971), "SDCIDevice_AsyncPara", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SDCIDevice_AsyncPara.CmdState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3787497970), "CmdState", 
(::SDCIDevice_AsyncPara.ParaRdWr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2426770201), "ParaRdWr", 
(::SDCIDevice_AsyncPara.ParaIndex.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2955404368), "ParaIndex", 
(::SDCIDevice_AsyncPara.ParaSubIndex.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2108805251), "ParaSubIndex", 
(::SDCIDevice_AsyncPara.ParaSize.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(381459621), "ParaSize", 
(::SDCIDevice_AsyncPara.ParaValue.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(757324645), "ParaValue", 
(::SDCIDevice_AsyncPara.SDCIRetcode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2328839021), "SDCIRetcode", 
(::SDCIDevice_AsyncPara.ErrorCode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(224164065), "ErrorCode", 
//Clients:
(::SDCIDevice_AsyncPara.ToDevice.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1310259054), "ToDevice", TO_UDINT(205726265), "SDCIDevice", 1$UINT, 4$UINT, 
(::SDCIDevice_AsyncPara.useBufferedAsyCmds.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2958794479), "useBufferedAsyCmds", 
(::SDCIDevice_AsyncPara.TimeoutAsyCmd.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2394773882), "TimeoutAsyCmd", 
END_FUNCTION


#define USER_CNT_SDCIDevice_AsyncPara 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SDCIDevice_AsyncPara] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SDCIDevice_AsyncPara::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_SDCIDevice_AsyncPara, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	CmdState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CmdState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaRdWr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ParaRdWr::Write() );
	IF ParaRdWr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaIndex.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParaIndex.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaSubIndex.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParaSubIndex.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaSize.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParaSize.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParaValue.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParaValue.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL SDCIDevice_AsyncPara::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	retcode : SdiasSDCIMaster::t_SDCIRetCode;
    ReadDataLength : USINT;
  END_VAR

  case SSW of
//**********************************************************************************************************************************************************
    _WaitForCommand: // wait for command
    
//**********************************************************************************************************************************************************
    _SendCommand: // send command
      
      if useBufferedAsyCmds then
        if ParaRdWr then              
          // write
          retcode := ToDevice.SetAsyParaBuffered( ParaIndex         := ParaIndex$UINT
                                                , ParaSubIndex      := ParaSubIndex$USINT
                                                , WriteDataLength   := ParaSize$USINT
                                                , pWriteData        := #ParaValue
                                                , pThis             := this
                                                , pCallBackFunction := #CallBack());
          
        else
          // read
          retcode := ToDevice.GetAsyParaBuffered( ParaIndex         := ParaIndex$UINT
                                                , ParaSubIndex      := ParaSubIndex$USINT
                                                , pThis             := this
                                                , pCallBackFunction := #CallBack());
        end_if;
      else
        if ParaRdWr then              
          // write
          retcode := ToDevice.SetAsyPara( ParaIndex         := ParaIndex$UINT
                                        , ParaSubIndex      := ParaSubIndex$USINT
                                        , WriteDataLength   := ParaSize$USINT
                                        , pWriteData        := #ParaValue);
        else
          // read
          retcode := ToDevice.GetAsyPara( ParaIndex         := ParaIndex$UINT
                                        , ParaSubIndex      := ParaSubIndex$USINT);
        end_if;      
      end_if;
      
      // if it succeeded => go to next step to wait for the answer
      if retcode = SdiasSDCIMaster::t_SDCIRetCode::SDCI_Ready_Ok then
        StartTime := ops.tAbsolute;
        SDCIRetcode := retcode;
        
        // CmdState := BUSY; // Busy already set in ParaRdWr::Write
        SSW := _WaitForAnswer;
      
      elsif retcode <> SdiasSDCIMaster::t_SDCIRetCode::SDCI_Busy then
        
        // Return <> busy => cancel _SendCommand
        SDCIRetcode := retcode;
        
        SSW := _WaitForCommand;        
        CmdState := ERROR;
      end_if;
    
//**********************************************************************************************************************************************************
    _WaitForAnswer: // wait for answer of command
      
      // Answer is handled in NewInst
      if useBufferedAsyCmds = 0 then
      
        // if the command was writing
        if ParaRdWr then
          // only get the return and errorcode
          retcode := ToDevice.GetAsyState(pErrorCode:=(#ErrorCode)$^HINT);
        else
          // if the command was reading, also get the readlength and readdata if available
          retcode := ToDevice.GetAsyState(pErrorCode:=(#ErrorCode)$^HINT, pReadDataLength:=#ReadDataLength, ppReadData:=#pReadData);
          
          // if successful and there are data to store
          if (retcode = SdiasSDCIMaster::t_SDCIRetCode::SDCI_Ready_Ok) & ReadDataLength & pReadData then
            
            ParaSize := ReadDataLength;
            
            // check if the parameter data completely fits on the server
            if ParaSize <= 4 then
              // reset the server (delete high bytes in case of reading a smaller parameter than before)
              ParaValue := 0;
            
              // copy the read data
              _memcpy(ptr1:=#ParaValue, ptr2:=pReadData, cntr:=ParaSize);
            else
              // copy the read data (only the first 4 bytes)
              _memcpy(ptr1:=#ParaValue, ptr2:=pReadData, cntr:=4);
            end_if;
          end_if;
        end_if;
        
        // if not busy => take the returncode as transferstate and go back to idle
        if retcode <> SdiasSDCIMaster::t_SDCIRetCode::SDCI_Busy then
          if retcode = SdiasSDCIMaster::t_SDCIRetCode::SDCI_Ready_Ok then
            CmdState := READY;
          else
            CmdState := ERROR;
          end_if;

          SDCIRetcode := retcode;

          SSW := _WaitForCommand;
          
        // timeout
        elsif (ops.tAbsolute - StartTime) > TimeoutAsyCmd then
          // timeout
          CmdState := ERROR_BUSY;

          SSW := _WaitForCommand;
        end_if;      
      
      // timeout
      elsif (ops.tAbsolute - StartTime) > TimeoutAsyCmd then
        // timeout
        CmdState := ERROR_BUSY;

        SSW := _WaitForCommand;
      end_if;

//**********************************************************************************************************************************************************
  end_case;

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice_AsyncPara::ParaRdWr::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // only when not busy and a valid command has been passed
  if (CmdState <> BUSY) & (input$UDINT < 2) then
  
    if (input = 1) & ((ParaSize = 0) | (ParaSize > 4)) then
      // a write command should be started, but the size is invalid
      ParaRdWr := -2;
      return;
    end_if;
  
    CmdState := BUSY;
    
  	ParaRdWr := input;
    SSW := _SendCommand;
  else
    // already busy or invalid input
    ParaRdWr := -1;
  end_if;

	result := input;

END_FUNCTION


FUNCTION SDCIDevice_AsyncPara::CallBack
	VAR_INPUT
    pThis         : pVoid;
    AsyState      : SdiasSDCIMaster::t_SDCIRetCode;
    LengthOfData  : USINT;
    pData         : ^USINT;
	END_VAR
  
  THIS := pThis$^SDCIDevice_AsyncPara;
  
  ErrorCode := 0;
  
  if AsyState = SdiasSDCIMaster::t_SDCIRetCode::SDCI_Ready_Ok then

    if ParaRdWr = 0 & LengthOfData > 0 & pData then
            
      if LengthOfData <= 4 then
        // reset the server (delete high bytes in case of reading a smaller parameter than before)
        ParaValue := 0;
      
        // copy the read data
        _memcpy(ptr1:=#ParaValue, ptr2:=pData, cntr:=LengthOfData);
      else
        // copy the read data (only the first 4 bytes)
        _memcpy(ptr1:=#ParaValue, ptr2:=pData, cntr:=4);
      end_if;
      
      ParaSize := LengthOfData;
    
    end_if;
  
    CmdState := READY;
  else
    CmdState := ERROR;
    
    if (( AsyState = SdiasSDCIMaster::t_SDCIRetCode::SDCI_MicroCtrl_ApplicationError) & (LengthOfData)) then
      
      if LengthOfData <= 4 then
        // reset the server (delete high bytes in case of reading a smaller parameter than before)
        ErrorCode := 0;
      
        // copy the read data
        _memcpy(ptr1:=#ErrorCode, ptr2:=pData, cntr:=LengthOfData);
      else
        // copy the read data (only the first 4 bytes)
        _memcpy(ptr1:=#ErrorCode, ptr2:=pData, cntr:=4);
      end_if;
      
    end_if;

  end_if;

  SDCIRetcode := AsyState;

  SSW := _WaitForCommand;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL SDCIDevice_AsyncPara::Init
  
  if _FirstScan then
    useBufferedAsyCmds := useBufferedAsyCmds.Read();
    if useBufferedAsyCmds then
      useBufferedAsyCmds := 1;
    end_if;

    TimeoutAsyCmd      := TimeoutAsyCmd.Read();
  end_if;

END_FUNCTION