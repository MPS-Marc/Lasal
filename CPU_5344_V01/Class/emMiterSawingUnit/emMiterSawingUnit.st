//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emMiterSawingUnit"
	Revision           = "1.0"
	GUID               = "{3659F611-6F3A-4E99-909B-2883D17B5796}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,1080)">
	<Channels>
		<Server Name="csStartRPM" GUID="{7F737949-0473-4BA2-BC85-4C8D44688F12}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="lastXY1Angle" GUID="{FD6DE0F2-9C83-4318-B504-4C8B82159AC9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="oEnableLubrication" GUID="{F08F4D5E-58A5-4CB7-83E4-8F59AD0067AC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="paclosewinTime" GUID="{D19880EC-C767-4DC0-BCF1-1FCF13A372E3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parMaxHeightForSensor1" GUID="{950E1C83-DD65-4E1D-98D1-C8964BD8296A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parMinPulseTime" GUID="{611618CA-FBFF-45A2-8B38-0010EEC90852}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeBeforeMotorOff" GUID="{29CCE55D-E864-4878-A749-0710B5475303}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeOutTime" GUID="{A6F61BBF-AC63-4F7A-9537-50655804EE45}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeWaitForClamp" GUID="{F4625AB3-9EE8-4924-B041-F92D5FFE0DA5}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="ParWaitTimer" GUID="{3802FE99-C00F-4336-80BB-4BB51C7FCC0B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="resetSoftCounter" GUID="{3BE859E4-70D5-46B6-98A7-8692D379C8F4}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="softCounter" GUID="{6FD8347D-E9C1-425C-97B6-259BBCC3B57F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsNrInAssembly" GUID="{2E737403-FD03-4630-95DE-C16A055487FA}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="totalCounter" GUID="{1AD8F0C8-EC2D-4EF0-B083-31671CC5481E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="cntrAmount1" Required="true" Internal="true"/>
		<Client Name="ctrlBlower" Required="false" Internal="false"/>
		<Client Name="ctrlClamp" Required="false" Internal="false"/>
		<Client Name="ctrlMotor" Required="false" Internal="false"/>
		<Client Name="ctrlScreen" Required="true" Internal="false"/>
		<Client Name="ctrlYAngleServo" Required="false" Internal="false"/>
		<Client Name="fileBase" Required="true" Internal="false"/>
		<Client Name="iActHeigthMaterial" Required="false" Internal="false"/>
		<Client Name="iActHeigthSaw" Required="true" Internal="false"/>
		<Client Name="iActPosWagon" Required="true" Internal="false"/>
		<Client Name="iHydroPumpOn" Required="true" Internal="false"/>
		<Client Name="iMinPosForSawOperation" Required="true" Internal="false"/>
		<Client Name="iOperationAllowed" Required="true" Internal="false"/>
		<Client Name="iPusherWagonInPos" Required="true" Internal="false"/>
		<Client Name="iSawInAutomode" Required="true" Internal="false"/>
		<Client Name="iSawMotorOn" Required="true" Internal="false"/>
		<Client Name="iSawReady" Required="true" Internal="false"/>
		<Client Name="iSensor1" Required="true" Internal="false" Comment="sensor used for small material"/>
		<Client Name="iSensor2" Required="true" Internal="false" Comment="sensor used if there is only one, or for big material"/>
		<Client Name="nrOffWindowTry" Required="true" Internal="false"/>
		<Client Name="oEnableExtraction" Required="true" Internal="false"/>
		<Client Name="oMpsAutoMode" Required="true" Internal="false"/>
		<Client Name="oPulseSawClamp" Required="true" Internal="false"/>
		<Client Name="oStartSawCycle" Required="true" Internal="false"/>
		<Client Name="windowNr" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
		</Servers>
		<Clients>
			<SepChn Position="20"/>
		</Clients>
	</Separators>
	<Network Name="emMiterSawingUnit">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{51623C70-8CD3-4303-8E1E-4ACE16CB1374}"
				Class      = "emBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name           = "cntrAmount1"
				GUID           = "{E2A71D86-3AD8-43A4-96D8-7CE931B6D8C1}"
				Class          = "cntrAmount"
				Position       = "(450,1800)"
				Visualized     = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="count"/>
					<Server Name="resetSoftCounter"/>
					<Server Name="softCounter"/>
					<Server Name="totalCounter"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1156,210),(984,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1156,270),(984,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1156,330),(984,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1156,390),(984,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1156,450),(984,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1156,510),(984,510),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1156,570),(984,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1156,630),(984,630),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1156,690),(984,750),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1156,750),(984,810),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1156,810),(984,870),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1156,870),(984,930),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1156,990),(984,1170),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1156,1050),(984,1230),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.cmdWaitReset" Destination="_base.cmdWaitReset" Vertices="(1156,930),(984,1050),"/>
			<Connection Source="this.cntrAmount1" Destination="cntrAmount1.ClassSvr"/>
			<Connection Source="this.softCounter" Destination="cntrAmount1.softCounter" Vertices="(1156,1590),(750,1950),"/>
			<Connection Source="this.totalCounter" Destination="cntrAmount1.totalCounter" Vertices="(1156,1650),(750,2010),"/>
			<Connection Source="this.resetSoftCounter" Destination="cntrAmount1.resetSoftCounter" Vertices="(1156,1710),(750,2070),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emBase

emMiterSawingUnit : CLASS
: emBase
  //Servers:
	csStartRPM 	: SvrCh_DINT;
	parTimeBeforeMotorOff 	: SvrCh_UDINT;
	parTimeWaitForClamp 	: SvrCh_UDINT;
	oEnableLubrication 	: SvrCh_DINT;
	parTimeOutTime 	: SvrCh_UDINT;
	parMinPulseTime 	: SvrCh_UDINT;
	paclosewinTime 	: SvrCh_UDINT;
	ParWaitTimer 	: SvrCh_UDINT;
	softCounter 	: SvrCh_DINT;
	totalCounter 	: SvrCh_DINT;
	resetSoftCounter 	: SvrCh_DINT;
	stsNrInAssembly 	: SvrCh_DINT;
	lastXY1Angle 	: SvrCh_DINT;
	parMaxHeightForSensor1 	: SvrCh_DINT;
  //Clients:
	ctrlClamp 	: CltChCmd_cmMultipleCil;
	ctrlMotor 	: CltChCmd_cmMotor;
	ctrlYAngleServo 	: CltChCmd_cmServo;
	ctrlBlower 	: CltChCmd_cmBlower;
	iOperationAllowed 	: CltCh_DINT;
	iSawMotorOn 	: CltCh_DINT;
	iHydroPumpOn 	: CltCh_DINT;
	iSawInAutomode 	: CltCh_DINT;
	iSensor1 	: CltCh_DINT;
	iSensor2 	: CltCh_DINT;
	iSawReady 	: CltCh_DINT;
	iActPosWagon 	: CltCh_DINT;
	iMinPosForSawOperation 	: CltCh_DINT;
	iActHeigthSaw 	: CltCh_DINT;
	iActHeigthMaterial 	: CltCh_DINT;
	oMpsAutoMode 	: CltCh_DINT;
	oStartSawCycle 	: CltCh_DINT;
	oPulseSawClamp 	: CltCh_DINT;
	oEnableExtraction 	: CltCh_DINT;
	iPusherWagonInPos 	: CltCh_DINT;
	ctrlScreen 	: CltChCmd_ScreenCtrl;
	windowNr 	: CltCh_DINT;
	nrOffWindowTry 	: CltCh_DINT;
	fileBase 	: CltChCmd_FileBase;
	cntrAmount1 	: CltChCmd_cntrAmount;
  //Variables:
		motorConnected 	: DINT;
		clampsConnected 	: DINT;
		blowerConnected 	: DINT;
		sawHeightConnected 	: DINT;
		angleServoConnected 	: DINT;
		mpsControlMessageConnected 	: DINT;
		stsPosClamps 	: cilPos;
		stsStateMotor 	: motorPos;
		tmpMotorNotRunningDuringOperation 	: DINT;
		oldMode 	: eModePML;
		oldAutoStprAction 	: DINT;
		timerLastRun 	: strTimer;
		timeOutTimer 	: strTimer;
		TimerWaitForClamp 	: strTimer;
		timerPulseStartSaw 	: strTimer;
		timerCloseWindow 	: strTimer;
		stprOperationStillBusy 	: DINT;
		oldStprAction 	: DINT;
		WindowTry 	: DINT;
		timerWaitTime 	: strTimer;
		stsPosCil 	: cilPos;
		tmpDoShortSawing 	: DINT;
		len 	: UDINT;
		tmpText 	: longText;
  //Functions:
	
	FUNCTION VIRTUAL interlock;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL execStart;
	
	FUNCTION VIRTUAL execStop;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION VIRTUAL execResetting;
	
	FUNCTION VIRTUAL execStarting;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION VIRTUAL execCompleting;
	
	FUNCTION VIRTUAL execHolding;
	
	FUNCTION VIRTUAL execUnHolding;
	
	FUNCTION VIRTUAL execStopping;
	
	FUNCTION VIRTUAL execSuspending;
	
	FUNCTION VIRTUAL execUnSuspending;
	
	FUNCTION VIRTUAL runAction;
	
	FUNCTION runMoving;
	
	FUNCTION VIRTUAL GLOBAL softCounter::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL softCounter::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL totalCounter::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL totalCounter::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL resetSoftCounter::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL resetSoftCounter::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using cntrAmount
#pragma usingLtd cmBlower
#pragma usingLtd cmMotor
#pragma usingLtd cmMultipleCil
#pragma usingLtd cmServo
#pragma usingLtd FileBase
#pragma usingLtd ScreenCtrl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emMiterSawingUnit::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMMITERSAWINGUNIT
1$UINT, 0$UINT, (SIZEOF(::emMiterSawingUnit))$UINT, 
14$UINT, 25$UINT, 0$UINT, 
TO_UDINT(3730376064), "emMiterSawingUnit", //Class
TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emMiterSawingUnit.csStartRPM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3468548055), "csStartRPM", 
(::emMiterSawingUnit.parTimeBeforeMotorOff.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(605557712), "parTimeBeforeMotorOff", 
(::emMiterSawingUnit.parTimeWaitForClamp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(637572492), "parTimeWaitForClamp", 
(::emMiterSawingUnit.oEnableLubrication.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1421400189), "oEnableLubrication", 
(::emMiterSawingUnit.parTimeOutTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4183149504), "parTimeOutTime", 
(::emMiterSawingUnit.parMinPulseTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3789779291), "parMinPulseTime", 
(::emMiterSawingUnit.paclosewinTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(431241491), "paclosewinTime", 
(::emMiterSawingUnit.ParWaitTimer.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(61305609), "ParWaitTimer", 
(::emMiterSawingUnit.softCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4203045961), "softCounter", 
(::emMiterSawingUnit.totalCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1698109949), "totalCounter", 
(::emMiterSawingUnit.resetSoftCounter.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(260643724), "resetSoftCounter", 
(::emMiterSawingUnit.stsNrInAssembly.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4139240015), "stsNrInAssembly", 
(::emMiterSawingUnit.lastXY1Angle.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3937941435), "lastXY1Angle", 
(::emMiterSawingUnit.parMaxHeightForSensor1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(493005460), "parMaxHeightForSensor1", 
//Clients:
(::emMiterSawingUnit.ctrlClamp.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2380244622), "ctrlClamp", TO_UDINT(3389912646), "cmMultipleCil", 0$UINT, 0$UINT, 
(::emMiterSawingUnit.ctrlMotor.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3868185908), "ctrlMotor", TO_UDINT(2708248773), "cmMotor", 1$UINT, 0$UINT, 
(::emMiterSawingUnit.ctrlYAngleServo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1127446459), "ctrlYAngleServo", TO_UDINT(3985303601), "cmServo", 1$UINT, 0$UINT, 
(::emMiterSawingUnit.ctrlBlower.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1349372656), "ctrlBlower", TO_UDINT(2593188663), "cmBlower", 0$UINT, 0$UINT, 
(::emMiterSawingUnit.iOperationAllowed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(439506079), "iOperationAllowed", 
(::emMiterSawingUnit.iSawMotorOn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1579159221), "iSawMotorOn", 
(::emMiterSawingUnit.iHydroPumpOn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3331417159), "iHydroPumpOn", 
(::emMiterSawingUnit.iSawInAutomode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1574246679), "iSawInAutomode", 
(::emMiterSawingUnit.iSensor1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2193022255), "iSensor1", 
(::emMiterSawingUnit.iSensor2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(465538197), "iSensor2", 
(::emMiterSawingUnit.iSawReady.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2776998743), "iSawReady", 
(::emMiterSawingUnit.iActPosWagon.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3428722028), "iActPosWagon", 
(::emMiterSawingUnit.iMinPosForSawOperation.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1076736938), "iMinPosForSawOperation", 
(::emMiterSawingUnit.iActHeigthSaw.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1201810249), "iActHeigthSaw", 
(::emMiterSawingUnit.iActHeigthMaterial.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1992765889), "iActHeigthMaterial", 
(::emMiterSawingUnit.oMpsAutoMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2403907044), "oMpsAutoMode", 
(::emMiterSawingUnit.oStartSawCycle.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1637668533), "oStartSawCycle", 
(::emMiterSawingUnit.oPulseSawClamp.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3365609590), "oPulseSawClamp", 
(::emMiterSawingUnit.oEnableExtraction.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1616663132), "oEnableExtraction", 
(::emMiterSawingUnit.iPusherWagonInPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1171377603), "iPusherWagonInPos", 
(::emMiterSawingUnit.ctrlScreen.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3009882124), "ctrlScreen", TO_UDINT(4196661951), "ScreenCtrl", 0$UINT, 0$UINT, 
(::emMiterSawingUnit.windowNr.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(845718148), "windowNr", 
(::emMiterSawingUnit.nrOffWindowTry.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(773640), "nrOffWindowTry", 
(::emMiterSawingUnit.fileBase.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1689253198), "fileBase", TO_UDINT(1689253198), "FileBase", 0$UINT, 5$UINT, 
(::emMiterSawingUnit.cntrAmount1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(505704967), "cntrAmount1", TO_UDINT(719986565), "cntrAmount", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_emMiterSawingUnit 41

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emMiterSawingUnit] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emMiterSawingUnit::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emMiterSawingUnit;
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #interlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #execStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #execStop();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #execResetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #execStarting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[24]		:= #execCompleting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[26]		:= #execHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #execUnHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[32]		:= #execStopping();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[33]		:= #execSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #execUnSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #runAction();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	csStartRPM.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF csStartRPM.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeBeforeMotorOff.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeBeforeMotorOff.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeWaitForClamp.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeWaitForClamp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeOutTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeOutTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMinPulseTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parMinPulseTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	paclosewinTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF paclosewinTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParWaitTimer.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParWaitTimer.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	softCounter.pMeth			:= StoreMethod( #softCounter::Read(), #softCounter::Write() );
	IF softCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	totalCounter.pMeth			:= StoreMethod( #totalCounter::Read(), #totalCounter::Write() );
	IF totalCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	resetSoftCounter.pMeth			:= StoreMethod( #resetSoftCounter::Read(), #resetSoftCounter::Write() );
	IF resetSoftCounter.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMaxHeightForSensor1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parMaxHeightForSensor1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 15-8-2022: added as much versions as possible in one program, should be used for both manual and automatic angle movement, for analog height, 2 or 1 sensor heigth, for JIH, FG and other sawing machines
// but only to be used for interface saw, for other sawing machines use operation unit or something like that
// TP 12-03-2020 changed it so that it will give a popup if saw need to change position
// JdK 6-12-2019 changed emMiterSawingUnit to fritz gross version
// means sawing is done by interfacing, y-axe for angle is controlled from here
// no clamping, no motor, nothing, only check if hydropump is on, and if saw is in auto mode



// errors: 1: motor stopped during movement
//         2: saw not in automode during starting
//         3: operation not allowed
//         4: saw angle not in right position
//         5: saw not ready during starting
//         6: time out 
//         7: hydropump not active while required for moving
//         8: hydropump not active while required for sawing
//         9: hydropump not active while required for resetting
//        10: wagon too close to saw
//        11: angle servo didn't reach position, and becomes idle
//        12: saw not ready during reset
//        13: Can not connect with the screen

// in manual we can run the manual sawing, it's runned by start, of course only in half automatic mode, only possible if clamps are manually put in the right position


//RVDL 10-1-2020 added stsFirstInAssembly to use for pressureroll control via unitmachine
FUNCTION VIRTUAL emMiterSawingUnit::Init1

  IF initDone=0 THEN
    motorConnected:=IsClientConnected(#ctrlMotor);
    clampsConnected:=IsClientConnected(#ctrlClamp);
    blowerConnected:=IsClientConnected(#ctrlBlower);
    sawHeightConnected:=IsClientConnected(input:=#iActHeigthSaw);
    angleServoConnected:=IsClientConnected(input:=#ctrlYAngleServo);
    stprOperationStillBusy:= 11;
    initDone:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::work

 
  IF stsHMI_RunsAllowed & stprAction<> 0 & (pmlCom.sts.mode=manual | pmlCom.sts.mode= halfAuto | pmlCom.sts.mode= service) THEN //if hmi run is allowed, run action (if one was started)
    runAction();
  END_IF;
  IF ((pmlCom.sts.mode = auto & (oldMode = manual | oldMode = halfAuto)) | //stop movement if mode changes, but keep old auto stepper
    ((pmlCom.sts.mode = manual | pmlCom.sts.mode = halfAuto) & oldMode = auto)) & stprAction<> 0 THEN
    IF oldMode = auto | oldMode = service THEN
      oldAutoStprAction:=stprAction;
    END_IF;
    stprAction:=0;
  END_IF;

  oldMode:=pmlCom.sts.mode;  
  

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::runAction

  IF stprAction >= 11 & stprAction <= 13 THEN //during going into material enable lubrication
    oEnableLubrication:= 1;
  END_IF;
  
  //check if motor isn't switched off during drilling
  IF stprAction>= 6 & stprAction<= 20 & stsStateMotor<>moRunning & motorConnected= 1 THEN
    tmpMotorNotRunningDuringOperation:= 1;
  END_IF;  

  oMpsAutoMode:= 1; //write automode always if in run action

  CASE stprAction OF
  
  0: //wait for start
  
  1: //control automatic stuff, if there is
    IF angleServoConnected= 1 &  ctrlYAngleServo.checkInPos(checkPos:=actionLine.xy1Angle)= 0 THEN //give alarm if not in right position, but only if servo isconnected
      giveAlarm(errorNr:=4);
    ELSE
      stprAction+=1;
    END_IF; 
    
  2: //switch automode on, check if saw is in automode, and if wagon has right position
    IF iSawInAutomode= 1 & iSawReady= 1 & iActPosWagon >= iMinPosForSawOperation & iHydroPumpOn= 1 THEN //RVDL 19-12-2019   changed hydropomp to =1
      stprAction+=1;
    ELSIF iSawInAutomode= 0 THEN
      giveAlarm(errorNr:=2);
    ELSIF iSawReady= 0 THEN
      giveAlarm(errorNr:=5);
    ELSIF iActPosWagon < iMinPosForSawOperation THEN
      giveAlarm(errorNr:=10);
    ELSIF iHydroPumpOn= 0 THEN
      giveAlarm(errorNr:=8);
    END_IF;
    
  3: //check if we need long sawing or short sawing
    IF iActHeigthMaterial <= parMaxHeightForSensor1 THEN
      tmpDoShortSawing:= 1;
    ELSE
      tmpDoShortSawing:= 0;
    END_IF;
    stprAction+=1;
    
  4: //start motor and wait for it
    IF motorConnected= 0 | stsStateMotor= moRunning THEN
      stprAction+=1;
    ELSIF motorConnected= 1 THEN
      ctrlMotor.csStartFwd(speed:=1000);
    END_IF;
    
  5: //check if movement is allowed
    IF iOperationAllowed= 1 THEN
      stprAction+=1;
    ELSIF iOperationAllowed=0 THEN
      giveAlarm(errorNr:=3);
    END_IF;
    
  6: //close clamps
    oPulseSawClamp:=1; //extra output for pulse controlled clamps on JIH saws  
    IF stsPosClamps=cilNotConnected | stsPosClamps=cilOut THEN
      stprAction+=1;
    ELSIF clampsConnected=1 THEN
      ctrlClamp.csMoveOut();
    END_IF;
    
  7: //wait for clamps to open/close
    oPulseSawClamp:= 1;
    IF TimerWaitForClamp.done THEN //wait for clamps  until its closed, only needed if clamp is closed by a pulse
      stprAction+=1;
    END_IF;      
    
  8: //start sawing
    oStartSawCycle:=1;
    IF iSawReady=0 THEN
      stprAction+=1;
    END_IF;
    
 9: //wait minimum time for sawpulse
    oStartSawCycle:=1;
    if (tmpDoShortSawing & iSensor1 ) |  iSensor2 | iSawReady | (iActHeigthSaw > iActHeigthMaterial & sawHeightConnected) | pmlCom.cmd.simulation = allSimu then //JdK 15-8-2022, it's ok if sensor 1 is active for small material, or sensor 2 is active, or cycle is done and saw ready is active again, or if analog sensor is used
      stprAction+=1;
      oStartSawCycle:=0;
    end_if;
    
  10: //wait until ready again
    IF iSawReady=1 | pmlCom.cmd.simulation = allSimu THEN
      stprAction+=1;
    END_IF;  
     
  11: //reserve
    stprAction+=1;
    
  12: //start blowing
    IF blowerConnected= 1 THEN
      ctrlBlower.cmdBlow.Write(input:=1);
    END_IF;
    stprAction+=1;
    
  13: //open clamps
    IF stsPosClamps=cilNotConnected | stsPosClamps=cilOut THEN
      stprAction+=1;
    // Jdk 14-10-2021 dont give signal to open clamp, this goes automatically, we have to wait until clamp is opened, so just wait for the timer in the next step oPulseSawClamp:=1;
    ELSIF clampsConnected=1 THEN
      ctrlClamp.csMoveIn();
    END_IF;
    
  14: //wait for clamps to be open again
    IF TimerWaitForClamp.done THEN 
      stprAction+=1;
    END_IF;      
    
  15: //if in manual or half auto, switch off motor
    IF (motorConnected=0 | (pmlCom.sts.mode=auto | pmlCom.sts.mode=service) | stsStateMotor=moOff) & timerWaitTime.done THEN
      stprAction+=1;
    ELSE
      ctrlMotor.csStop();
    END_IF;  
   
  16: // done
    stprAction:=0;
  
  END_CASE;


END_FUNCTION


FUNCTION emMiterSawingUnit::runMoving

  CASE stprMoving OF
  
  0: //idle
  
  1: //check if we have to move automaticly or manually
    IF angleServoConnected THEN
      stprMoving+= 1;
    ELSE
      stprMoving:= 50; //just give message
    END_IF;
  
  2: //send angle to right position, can be done during sending underplates to right position
    ctrlYAngleServo.csStartMoveAbs(iReqPos:=moveLine.xy1angle, iReqSpeed:=1000);
    stprMoving+= 1;
    
  3: //wait until at position
    IF ctrlYAngleServo.stsState= seIdle & ctrlYAngleServo.checkInPos(checkPos:=moveLine.xy1angle) THEN
      stprMoving+= 1;
    ELSIF ctrlYAngleServo.stsState= seIdle THEN
      stprMoving-= 1;
    END_IF;
  
  50: //give message, only if position differs from last position
    IF moveLine.xy1Angle <> FAULTVALUE THEN
      IF lastXY1Angle <> moveLine.xy1Angle then
        lastXY1Angle:= moveLine.xy1Angle;  
        IF mpsControlMessageConnected = 1 THEN
          stprMoving:= 60; //give message through mps control
        ELSE
          stprMoving+=1;
        END_IF;
      ELSE
        stprMoving:= 0;
      END_IF;
    ELSE
      stprMoving:= 0;
    END_IF;
    
  51: //posible it's better to wait if the pusherwagon will get in position before giving the popup
    if iPusherWagonInPos = 1 then//tp 25-08-2020 wait for wagon in pos for give popup
       if ctrlScreen.ActWindow <> windowNr & ctrlScreen.ActWindow = 0 | ctrlScreen.ActWindow = -1 then
            ctrlScreen.ReqWindow := windowNr;
            stprMoving+=1;
       elsif ctrlScreen.ActWindow = windowNr then
           stprMoving+=1;
       end_if;
     end_if;
    
  52: //check if hydropump is enabled
    IF iHydroPumpOn=1 THEN
      stprMoving+=1;
    ELSE
      giveAlarm(errorNr:=7);
    END_IF;
    
  53: //give the message, and set machine to suspended
    IF iHydroPumpOn=0 THEN
      giveAlarm(errorNr:=7);
    END_IF;    
    IF ctrlScreen.ActWindow = windowNr & pmlCom.cmd.state= Execute then        
      pmlCom.sts.stateReq.ID:=id;
      pmlCom.sts.stateReq.state:=Suspending;
      WindowTry:=0;
      stprMoving+=1;
    elsif ctrlScreen.ActWindow <> windowNr & pmlCom.cmd.state= Execute & nrOffWindowTry>= WindowTry & timerCloseWindow.done then
      lastXY1Angle:= FAULTVALUE;
      WindowTry+=1;
      stprMoving:=1;
    elsif nrOffWindowTry <= WindowTry & pmlCom.cmd.state= Execute then
      giveAlarm(errorNr:=13);//don't get connected with screen
    elsif pmlCom.cmd.state<> Execute then
      stprMoving:=0;    
    end_if;
  
  54:
    if ctrlScreen.ActWindow = windowNr & pmlCom.cmd.state <> Execute then
      if ctrlScreen.CloseWindow=-1 then
        ctrlScreen.CloseWindow.Write(input:=1);
        stprMoving+=1;
      elsif ctrlScreen.CloseWindow = 1 |ctrlScreen.CloseWindow = 0 then
        ctrlScreen.CloseWindow.Write(input:=-1);
        ctrlScreen.ActWindow.Write(input:=-1);
        stprMoving+=1;
      end_if;
    elsif ctrlScreen.ActWindow <> windowNr then
      stprMoving+=1;
    end_if;
    
   55:
   if timerCloseWindow.done then
      if ctrlScreen.ActWindow = -1 then
        ctrlScreen.CloseWindow.Write(input:=1);
      else
        stprMoving-=1;
      end_if;
    end_if;

    60: //give a message
      _memset(dest:=#tmpText[0], usByte:=0, cntr:=sizeof(longText));
      _strcpy(dest:=#tmpText[0], src:="Stel zaaghoek in op "); 
      len:= _strlen(src:=#tmpText[0]);
      fileBase.BuildValue2Ascii(Value:=moveLine.xy1Angle, Dest:=#tmpText[0], Offset:=to_dint(len));
      len:= _strlen(src:=#tmpText[0]);
      tmpText[len]:=tmpText[len-1];
      tmpText[len-1]:= ','; //add comma, because value is in 1/10 of a degree
      len:= _strlen(src:=#tmpText[0]);
      _strcpy(dest:=#tmpText[len], src:="°. Controleer positie zaagklemmen."); 
      pmlCom.sts.stateReq.state:=Suspending;
      stprMoving+=1; 
      
    61: //done
        stprMoving:= 0;

  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::interlock

  
  pmlCom.sts.isInterlocked:=pmlCom.cmd.interlock| tmpMotorNotRunningDuringOperation<>0 | iHydroPumpOn=0;  //also interlock if motor not running during movement, and if hydropump isn't running
  
  

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execResetting

  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //wait until saw is ok
    IF iSawReady= 1 THEN
      stprState+= 1;
    ELSE
      giveAlarm(errorNr:=12);
    END_IF;
    
  2: //check if y servo is homed
    IF pmlCom.cmd.reRun= 1 & angleServoConnected= 0 | ctrlYAngleServo.stsIsHomed= 1 THEN
      stprState:= 10;
    ELSE
      IF pmlCom.cmd.reRun= 0 THEN
        stprAction:= 0; //make sure actions don't start again
        stprMoving:= 0;
        oldAutoStprAction:= 0;
        stsNrInAssembly:=0;
      END_IF;
      IF iHydroPumpOn= 0 THEN
        giveAlarm(errorNr:=9);
      ELSIF angleServoConnected= 0 | ctrlYAngleServo.stsIsHomed THEN
        stprState+=2;
      ELSE
        ctrlYAngleServo.csStartHoming();
        stprState+=1;
      END_IF;
    END_IF;
    
  3: //wait until homing is done
    IF ctrlYAngleServo.stsState= seIdle THEN
      stprState-= 1;
    END_IF;
    
  4: //check if angle servo is connected
    IF angleServoConnected= 1 THEN
      stprState+= 1;
    ELSE
      stprState:= 11;
    END_IF;
    
  5: //send y angle to middle
    ctrlYAngleServo.csStartMoveAbs(iReqPos:=900, iReqSpeed:=250); //not to fast
    stprState+= 1;
    
  6: //wait until in position
    IF ctrlYAngleServo.stsState = seIdle & ctrlYAngleServo.checkInPos(checkPos:=900)= 1 THEN
      stprState:= 11;
    ELSIF ctrlYAngleServo.stsState = seIdle THEN
      stprState-= 1;
    END_IF;
    
  10: //check how to restart
    IF (stprAction>0  | oldAutoStprAction>0 ) & pmlCom.cmd.reRun=1 THEN //means sawing still in action
      stprMoving:= 0; //no way they both can be active in the same time
      IF (stprAction < stprOperationStillBusy & stprAction>0) | (oldAutoStprAction < stprOperationStillBusy & oldAutoStprAction>0) THEN
        stprAction:= 1; //start action again
      ELSIF stprAction = 0 THEN
        stprAction:= oldAutoStprAction;
      END_IF;  
      stprState+=1;
    ELSE
      stprAction:=0;
      oldAutoStprAction:=0;
      IF pmlCom.cmd.reRun=0 THEN
        stprMoving:=0;
      ELSIF stprMoving<> 0 THEN
        stprMoving:= 1; //just start moving again
      END_IF;
      oldAutoStprAction:=0;
      stprState+=1;
    END_IF;
    
  11: //done, start motor
    IF pmlCom.cmd.state= Starting & csStartRPM>0 & motorConnected=1 THEN //RVDL 19-12-2019 added check motor connected
      ctrlMotor.csStartFwd(speed:=csStartRPM);
    END_IF;    
    stprState:= 1000;
      
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execStarting

  IF pmlCom.cmd.reRun= 0 THEN
    execResetting(); //just run reset
  ELSE
    execUnHolding();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execExecute

  runAction();
  runMoving();
  IF stprAction=0 & stprMoving=0 THEN
    stprState:=1000; //only state completed if action is done
  ELSE
    stprState:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execSuspending

  CASE stprState OF
  
  0: //wait until action and movement are done, also go on if there is an problem in this em
    IF (stprAction=0 & (stprMoving=0 | stprMoving>=50)) | stsInAlarm=1 THEN
      stprState:=1000;
    ELSE
      runAction();
      runMoving();
    END_IF;
    
  1000: //ready
  
  END_CASE;
  

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execHolding

  execSuspending();

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execUnSuspending

  execUnHolding();

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execUnHolding


  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //check if moving was busy
    IF stprMoving<> 0 THEN
      runMoving();
    ELSE
      stprState+=1;
    END_IF;
    
  2: //check if old action nr. during was active, or action nr. still is active
    IF oldAutoStprAction> 0 THEN
      IF oldAutoStprAction<= stprOperationStillBusy THEN //operation not yet done, start it again
        stprAction:= 1;
      ELSE
        stprAction:=oldAutoStprAction; //operation already done, just do the things to make it complete
      END_IF;
      oldAutoStprAction:=0;
    ELSIF stprAction> 0 THEN
      IF stprAction<= stprOperationStillBusy THEN //operation not yet done, start it again
        stprAction:= 1;
      END_IF;
    END_IF;
    stprState+= 1;
    
  3: //all we have to do during unholding (and unsuspending and restarting) is to set the right nr. to de stprAction

    stprState:=1000;
    
  1000: //ready
  
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execCompleting

  CASE stprState OF
  
  0: //just go on
    stprState+=1;
    
  1: //switch off motor
    IF motorConnected=0 | stsStateMotor=moOff THEN
      stprState+=1;
    ELSIF motorConnected= 1 THEN
      ctrlMotor.csStop();
    END_IF;
    
  2: //that's it
    stprState:=1000;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execStopping
  
  CASE stprState OF
  
  0: //just go on
    stprState+= 1;
    
  1: //stop steppers
    stprAction:=0;
    stprMoving:=0;
    stprState+=1;
    
  2: //stop moment in servo's
    ctrlYAngleServo.csStop();
    stprState+= 1;
    
  3: //switch off motor
    IF motorConnected=0 | stsStateMotor=moOff THEN
      stprState+=1;
    ELSE
      ctrlMotor.csStop();
    END_IF;
    
  4: //open clamps
    IF  clampsConnected= 0 THEN
      stprState+= 1;
    ELSE
      IF stsPosClamps= cilIn THEN
        stprState+= 1;
      ELSIF clampsConnected= 1 THEN
        ctrlClamp.csMoveIn();
      END_IF;
    END_IF;
    
  5: //that's it
    stprState:=1000;
    
  1000: //ready
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execStart

  IF pmlCom.sts.mode = halfAuto THEN //cycle works only in half auto
    IF stprAction= 0 THEN
      stprAction:=2;
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::execStop

  stprAction:=0;

  IF iSawReady= 1 & motorConnected=1 & stsStateMotor<>moOff THEN
    ctrlMotor.csStop();
  END_IF;


END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::preScanOverride
  
  //get states/positions from connected stuff
  IF motorConnected THEN
    stsStateMotor:=ctrlMotor.stsStateRun;
  ELSE
    stsStateMotor:= moRunning; //if motor not connected, always say motor is running
  END_IF;
  
  IF clampsConnected THEN
    stsPosClamps:=ctrlClamp.stsPos;
  ELSE
    stsPosClamps:=cilNotConnected;
  END_IF;
  
  //read in digital inputs
  iOperationAllowed:=iOperationAllowed.Read();
  iActHeigthMaterial:=iActHeigthMaterial.Read();
  iSensor1:=iSensor1.Read();
  iSensor2:=iSensor2.Read();
  iSawMotorOn:=iSawMotorOn.Read();
  iPusherWagonInPos:= iPusherWagonInPos.Read();
  
  IF pmlCom.cmd.simulation= allSimu THEN
    iHydroPumpOn:= 1;
    iSawInAutomode:= 1;
    iSawReady:= oStartSawCycle=0;
  ELSE
    iHydroPumpOn:=iHydroPumpOn.Read();
    iSawInAutomode:=iSawInAutomode.Read();
    iSawReady:=iSawReady.Read();
  END_IF;
  iActPosWagon:=iActPosWagon.Read();
  iMinPosForSawOperation:=iMinPosForSawOperation.Read();
  iActHeigthSaw:= iActHeigthSaw.Read();

  IF stsInAlarm= 0 & tmpMotorNotRunningDuringOperation= 2 THEN
    tmpMotorNotRunningDuringOperation:= 0; //only reset after alarm is gone
  END_IF;    

  IF tmpMotorNotRunningDuringOperation= 1 THEN
    giveAlarm(errorNr:=1);
    tmpMotorNotRunningDuringOperation := 2; //means alarm is already given
  END_IF;


  //run timer to switch off motor, if not used for a while
  timerLastRun:= runTimer(Active:=stprAction=0, iMem:=timerLastRun, TimerTime:=parTimeBeforeMotorOff, Pause:=FALSE);
  timeOutTimer:= runTimer(Active:=stprAction>0 & stprAction=oldStprAction, iMem:=timeOutTimer, TimerTime:=parTimeOutTime, Pause:=pmlCom.cmd.state<>Holding & pmlCom.cmd.state<>Suspending & pmlCom.cmd.state<>Execute & stsHMI_RunsAllowed=0);
  TimerWaitForClamp:= runTimer(Active:=stprAction=7 | stprAction=14, iMem:=TimerWaitForClamp, TimerTime:=parTimeWaitForClamp, Pause:=FALSE);
  timerPulseStartSaw:= runTimer(Active:=oStartSawCycle=1, iMem:=timerPulseStartSaw, TimerTime:=parMinPulseTime, Pause:=FALSE);
  timerWaitTime:= runTimer(Active:=stprAction=15, iMem:=timerWaitTime, TimerTime:=ParWaitTimer, Pause:=FALSE);
  timerCloseWindow:= runTimer(Active:=stprMoving=53 | stprMoving=55 | stprMoving=61, iMem:=timerCloseWindow, TimerTime:=paclosewinTime, Pause:=FALSE);

  oldStprAction:= stprAction;

  //write outputs to 0
  oEnableLubrication:= 0;
  oMpsAutoMode:= 0;
  oStartSawCycle:= 0;
  oPulseSawClamp:= 0;
  
  //give alarm timeout
  IF timeOutTimer.done THEN
    giveAlarm(errorNr:=6);
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emMiterSawingUnit::postScanOverride

  //if in manual mode, stop action if there is a problem
  IF (stsInAlarm= 1 | stsIsInterlocked= 1) & (pmlCom.sts.mode= manual | pmlCom.sts.mode= halfAuto) & stprAction<> 0 THEN 
    stprAction:=0;
  END_IF;
  
  //check if we should switch of the motor
  IF motorConnected= 1 & stsStateMotor<> moOff & parTimeBeforeMotorOff> 0 & timerLastRun.done= 1 THEN
    ctrlMotor.csStop();
  END_IF;

  //write outputs
  oMpsAutoMode.Write(input:=oMpsAutoMode);
  oStartSawCycle.Write(input:=oStartSawCycle);
  oPulseSawClamp.Write(input:=oPulseSawClamp);
  oEnableExtraction.Write(input:=oEnableExtraction);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL emMiterSawingUnit::softCounter::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	softCounter := cntrAmount1.softCounter.Read();
	output := softCounter;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL emMiterSawingUnit::softCounter::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	softCounter := input;
	result := (cntrAmount1.softCounter.Write(softCounter))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL emMiterSawingUnit::totalCounter::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	totalCounter := cntrAmount1.totalCounter.Read();
	output := totalCounter;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL emMiterSawingUnit::totalCounter::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	totalCounter := input;
	result := (cntrAmount1.totalCounter.Write(totalCounter))$DINT;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL emMiterSawingUnit::resetSoftCounter::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	resetSoftCounter := cntrAmount1.resetSoftCounter.Read();
	output := resetSoftCounter;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL emMiterSawingUnit::resetSoftCounter::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	resetSoftCounter := input;
	result := (cntrAmount1.resetSoftCounter.Write(resetSoftCounter))$DINT;

END_FUNCTION
