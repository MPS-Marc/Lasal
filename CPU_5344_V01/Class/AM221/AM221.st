//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_AM221             1022

#define AM221_ADDR_CYC_WRITE        16#000
#define AM221_ADDR_CYC_READ         16#080
#define AM221_ADDR_CFG_FIRMWARE     16#100
#define AM221_ADDR_STATE_FIRMWARE   16#180

#define AM221_SDO_RESPONSE_TIMEOUT  SDIAS_SDO_TIMEOUT * 2

#define AM221_NUMBER_OF_ANALOG_IN   2
#define AM221_INVALID_VALUE         16#80000010$DINT

#define AM221_FIRMWARE_MIN          -10000
#define AM221_FIRMWARE_MAX          10000

//16 Bit Resolution Support
//**************************************************************
#define AM221_FIRMWARE_FULLRES_MIN  -30000
#define AM221_FIRMWARE_FULLRES_MAX  30000

//TimeOffsets Defines
//**************************************************************
#define AM221_FIRMWARE_VERSION_NEW_TIMING_AVAILABLE     16#200  //Firmware version since when new timing (TimeOffsets, message counter) are supported
#define AM221_TIME_OFFSET_AFTER_SYNC                    130     //Minimal offset that a time offset can be set after sync in 탎
#define AM221_TIME_OFFSET_BEFORE_SYNC                   160     //Maximal offset that a time offset can be before next sync in 탎

#define AM221_TIME_OFFSET_STATE_NOT_SUPPORTED           -1      //State of server which shows that feature is not supported by FW or class
#define AM221_TIME_OFFSET_STATE_INVALID_INPUT           -2      //Invalid input from write method

#define AM221_ERROR_BIT_MASK                            16#1E7F //Bitmask for all error bits expect the ones for the timeoffset feature
#define AM221_TIME_OFFSET_BIT_MASK                      16#03   //Bitmask for all time offset error/info bits

#define AM221_CABLE_BREAK_MASK                          16#0F   //Bitmask for the 4 cable break bits

#define AM221_OFFSET_TIME_OFFSET_BITS                   7
#define AM221_OFFSET_LOW_RANGE_BITS                     9

#define AM221_MODULE_VERSION                            0       //Detection for FW which module type it is (same FW for AM441 and AM221)
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "AM221"
	Revision           = "1.28"
	GUID               = "{F8376E31-BC7B-45F0-ADEE-C374C94DA205}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(600,120)"
	Comment            = "SDIAS Analog Mixed Module&#13;&#10;2 x Analog In +/- 10V&#13;&#10;2 x Analog Out +/- 10V">
	<Channels>
		<Server Name="AI1" GUID="{2D4D9359-CA45-4122-B3BD-5615621BB65F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input. Status query over read().&#13;&#10;The invalid value in case of cable break is 16#80000010."/>
		<Server Name="AI1TimeOffset" GUID="{4C5AE026-1191-4822-A4B1-3593D4B34DB9}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="The time offset of the respective analog input in 탎 can be set with this server.&#13;&#10;The value will be transmitted each cycle to the Firmware. &#13;&#10;e.g. time offset &quot;150&quot; means that the respective channel will be sampled exactly 150탎 after the SDIAS sync.&#13;&#10;Valid range: (130탎 to (CycleTime - 160탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 2.00 or feature not activated with client AI_TimeOffset&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AI2" GUID="{EBFA634E-858D-4B96-BB27-E224FE889C97}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Analog input. Status query over read().&#13;&#10;The invalid value in case of cable break is 16#80000010."/>
		<Server Name="AI2TimeOffset" GUID="{C7A05BB6-BF9C-4D4A-A470-72D7B96C000F}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="The time offset of the respective analog input in 탎 can be set with this server.&#13;&#10;The value will be transmitted each cycle to the Firmware. &#13;&#10;e.g. time offset &quot;150&quot; means that the respective channel will be sampled exactly 150탎 after the SDIAS sync.&#13;&#10;Valid range: (130탎 to (CycleTime - 160탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 2.00 or feature not activated with client AI_TimeOffset&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AO1" GUID="{A7AB97A8-B3DF-4723-8B26-A7F56A7D09B1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog output"/>
		<Server Name="AO1TimeOffset" GUID="{81345F99-B523-42A4-9DC0-C07453CED6AF}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="The time offset of the respective analog output in 탎 can be set with this server.&#13;&#10;The value will be transmitted each cycle to the Firmware. &#13;&#10;e.g. time offset &quot;150&quot; means that the respective channel will be written exactly 150탎 after the SDIAS sync.&#13;&#10;Valid range: (130탎 to (CycleTime - 160탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 2.00 or feature not activated with client AI_TimeOffset&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="AO2" GUID="{6B3053D3-4644-45C7-8CC1-7B3942C2A856}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Analog output"/>
		<Server Name="AO2TimeOffset" GUID="{DAE46FB5-90F8-44B0-920D-E3FB8A65C66B}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="The time offset of the respective analog output in 탎 can be set with this server.&#13;&#10;The value will be transmitted each cycle to the Firmware. &#13;&#10;e.g. time offset &quot;150&quot; means that the respective channel will be written exactly 150탎 after the SDIAS sync.&#13;&#10;Valid range: (130탎 to (CycleTime - 160탎))&#13;&#10;-1 .. Feature not available or inactive. FW Version must be higher than 2.00 or feature not activated with client AI_TimeOffset&#13;&#10;-2 .. Invalid input parameter. Value must be between valid range."/>
		<Server Name="ErrorBits" GUID="{0B68182A-FC1B-4377-9CA1-A48540F19C84}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Error Bits:&#13;&#10;Bit1 ... Reserved&#13;&#10;Bit2 ... No Sync&#13;&#10;Bit3 ... Flash data CRC error&#13;&#10;Bit4 ... Ram data CRC error&#13;&#10;Bit5 ... No valid EEPROM Version&#13;&#10;....&#13;&#10;Bit17 ... Cable break on AI1&#13;&#10;Bit18 ... Cable break on AI2&#13;&#10;...&#13;&#10;Bit22 ... Reference Supply Voltage too low&#13;&#10;Bit23 ... Current on analog input is too high&#13;&#10;Bit24 ... Voltage of sdias bus is too low.&#13;&#10;...&#13;&#10;Bit26 ... Under range AI1&#13;&#10;Bit27 ... Under range AI2&#13;&#10;"/>
		<Server Name="FirmwareVersion" GUID="{4F1F07F1-324C-49D0-BC6D-3954911809E7}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Version of the used firmware&#13;&#10;&#13;&#10;e.g. 16#100 means v1.0"/>
		<Server Name="Range" GUID="{568327CD-A57B-4263-BBE6-9AC7806F7560}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="high range detection (cablebreak):&#13;&#10;Bit 1 ... high range on AI1&#13;&#10;Bit 2 ... high range on AI2&#13;&#10;&#13;&#10;cable break is detected if value &gt;10,25 V.&#13;&#10;&#13;&#10;Low range detection (supported with FW Version 2.00 or higher):&#13;&#10;Bit 5 ... low range on AI1&#13;&#10;Bit 6 ... low range on AI2&#13;&#10;&#13;&#10;The low range is detected if the value &lt; -10,25 V. "/>
		<Server Name="RefVoltageOK" GUID="{5346B950-1BC9-48EF-A91A-66898258111A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Reference Supply Voltage status"/>
		<Server Name="TimeOffsetErrorBits" GUID="{1C2722D9-1F8F-4F36-8DED-6898CF44461B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the state of the timeoffset feature &#13;&#10;of the firmware. &#13;&#10;&#13;&#10;Bit1...Time offsets were corrected by &#13;&#10;firmware due to invalid settings &#13;&#10;(difference between two time offsets too &#13;&#10;small, 2 time offsets have the same value or &#13;&#10;at least one time offset is out of allowed range)&#13;&#10;&#13;&#10;Bit2...Time offsets could not be corrected by &#13;&#10;firmware."/>
		<Client Name="AI1_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI1_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI1_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI1Config" Required="false" Internal="false" Comment="0 = AIx used as analog in&#13;&#10;1 = AIx used as analog in with ground reference&#13;&#10;Range -10V...+10V&#13;&#10;"/>
		<Client Name="AI2_Freq" Required="false" Internal="false" Comment="Cut off frequency for low pass filter&#13;&#10;0... 1000 Hz&#13;&#10;1...  500 Hz&#13;&#10;2...  250 Hz&#13;&#10;3...  100 Hz&#13;&#10;4...   50 Hz&#13;&#10;5...   25 Hz&#13;&#10;6...   10 Hz&#13;&#10;&#13;&#10;"/>
		<Client Name="AI2_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI2_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of the analog input can be selected by this client (corresponds to +/-10V).&#13;&#10;As initvalue!"/>
		<Client Name="AI2Config" Required="false" Internal="false" Comment="0 = AIx used as analog in&#13;&#10;1 = AIx used as analog in with ground reference&#13;&#10;Range -10V...+10V&#13;&#10;"/>
		<Client Name="AI_TimeOffset" Required="false" Internal="false" DefValue="0" Comment="Use this client to activate the TimeOffset feature. (Needs FW Version 2.00 or higher)&#13;&#10;0 .. TimeOffset feature inactive&#13;&#10;1 .. TimeOffset feature active"/>
		<Client Name="AO1_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V). &#13;&#10;The min/max values for the respective analog output must not be the same.&#13;&#10;As initvalue!"/>
		<Client Name="AO1_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V). &#13;&#10;The min/max values for the respective analog output must not be the same.&#13;&#10;As initvalue!"/>
		<Client Name="AO2_Max" Required="false" Internal="false" DefValue="10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V). &#13;&#10;The min/max values for the respective analog output must not be the same.&#13;&#10;As initvalue!"/>
		<Client Name="AO2_Min" Required="false" Internal="false" DefValue="-10000" Comment="The scale of analog output can be selected by this client &#13;&#10;(corresponds +/- 10V). &#13;&#10;The min/max values for the respective analog output must not be the same.&#13;&#10;As initvalue!"/>
		<Client Name="AO_TimeOffset" Required="false" Internal="false" DefValue="0" Comment="Use this client to activate the TimeOffset feature. (Needs FW Version 2.00 or higher)&#13;&#10;0 .. TimeOffset feature inactive&#13;&#10;1 .. TimeOffset feature active"/>
		<Client Name="FullRes16Bit" Required="false" Internal="false" DefValue="0" Comment="The resolution of the analog input channel can be selected with this client.&#13;&#10;0: resolution analog voltage: -10/+10V 1mV LSB&#13;&#10;1: resolution analog voltage: -10/+10V 0.3mV LSB (real 16 bit resolution) (FW Version 2.00 or higher)"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="ZoePat"/>
		<Dokumentation Revision="1.28" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms."/>
		<Dokumentation Revision="1.27" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.26" Date="08.06.2018" Author="RamAnd" Company="Sigmatek" Description="LASAL Hardware Description (.lhd) file has been updated."/>
		<Dokumentation Revision="1.25" Date="23.01.2018" Author="RamAnd" Company="Sigmatek" Description="Log messages have been standardized for easier maintenance, easier use in any class and to allow spam filtering. Code for the logging functions is now only located in HwControl."/>
		<Dokumentation Revision="1.24" Date="11.10.2017" Author="FurDom" Company="Sigmatek" Description="Added Flag &quot;ScaleAIx&quot; for check if a new calculation is necessary for AI1-2 -&gt; Realtime optimization. &#13;&#10;New calculation if Client AI_Min or AI_Max is not default."/>
		<Dokumentation Revision="1.23" Date="18.05.2017" Author="EisMic" Company="Sigmatek" Description="Added support for FullRes16BitMode.&#13;&#10;Added support for TimeOffsets."/>
		<Dokumentation Revision="1.22" Date="16.05.2017" Author="RamAnd" Company="Sigmatek" Description="When adding an SDO (i.e. via ReadSPIData) from background priority it was possible that the adding process got interrupted by receiving the answer to this SDO which is handled in cyclic priority. In the error case the answer was unexpected and therefore ignored. Then the class signals a timeout while waiting for the answer, which already arrived before waiting for it. Added mutex and changed instruction order to prevent this error."/>
		<Dokumentation Revision="1.21" Date="08.11.2016" Author="PieSte" Company="Sigmatek" Description="Add description for &quot;ErrorBits.AM_Errors&quot; bit 7 = DC_NotOK."/>
		<Dokumentation Revision="1.20" Date="12.07.2016" Author="SeiChr" Company="Sigmatek" Description="Added Values for the total Current calculation. SA 31571"/>
		<Dokumentation Revision="1.19" Date="01.03.2016" Author="EisMic" Company="Sigmatek" Description="Corrected BoundExceed Error in base class at Write method of LEDControl Server when Place = LSL_DEACTIVATED."/>
		<Dokumentation Revision="1.18" Date="23.02.2016" Author="PieSte" Company="Sigmatek" Description="Add support for min range greater max range."/>
		<Dokumentation Revision="1.17" Date="17.06.2015" Author="EisMic" Company="Sigmatek" Description="The servers FPGAVersion, SerialNo, Device ID and status and input servers are now not reset anymore when the module is disconnected."/>
		<Dokumentation Revision="1.16" Date="16.04.2015" Author="EisMic&#13;&#10;LanSte" Company="Sigmatek" Description="Added support for visualisation in graphical hardware editor.&#13;&#10;Added support for calculating resources for graphical hardware editor."/>
		<Dokumentation Revision="1.15" Date="17.03.2015" Author="RamAnd" Company="Sigmatek" Description="Added HW Version for sdias clients."/>
		<Dokumentation Revision="1.14" Date="11.02.2015" Author="PieSte" Company="Sigmatek" Description="Corrected read spi data for hardwaretree in methode GetSPIDataFromID from baseclass."/>
		<Dokumentation Revision="1.13" Date="18.11.2014" Author="PieSte" Company="Sigmatek" Description="Added possibility  to read more data from spi flash then one sdo access.&#13;&#10;Set methode GetDeviceID to global.&#13;&#10;Add methode to calculate checksum of spi flash."/>
		<Dokumentation Revision="1.12" Date="09.07.2014" Author="EisMic" Company="Sigmatek" Description="Added Support for reading hardware diagnose and hardwaretree entry."/>
		<Dokumentation Revision="1.11" Date="07.03.2014" Author="EisMic" Company="Sigmatek" Description=" Corrected comment of server Firmwareversion"/>
		<Dokumentation Revision="1.10" Date="20.01.2014" Author="PieSte" Company="Sigmatek" Description="Read Client Required and Place in Init SdiasBase"/>
		<Dokumentation Revision="1.0" Date="10.12.2013" Author="ZoePat" Company="Sigmatek" Description="First library version"/>
	</RevDoku>
	<Network Name="AM221">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{B7238403-0565-4910-802B-8DA63C6AB2B0}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

AM221 : CLASS
: SdiasBase
	TYPE
	  t_AM_Errors : BINT  //! <Type Public="true" Comment="AM specific errors" Name="t_AM_Errors"/>
	  [
	    1 CableBreakAI1,  //! <Type Comment="Analog input cable break bit" Name="t_AM_Errors.CableBreakAI1"/>
	    2 CableBreakAI2,  //! <Type Comment="Analog input cable break bit" Name="t_AM_Errors.CableBreakAI2"/>
	    5 LowReference,  //! <Type Comment="Reference Supply Voltage is too low." Name="t_AM_Errors.LowReference"/>
	    6 AiOvercurrent,  //! <Type Comment="Analog input current is too high." Name="t_AM_Errors.AiOvercurrent"/>
	    7 DC_NotOK,  //! <Type Comment="Voltage of sdias bus is too low." Name="t_AM_Errors.DC_NotOK"/>
	    10 UnderRangeAI1,  //! <Type Comment="Low Range Analog Input Bit (since FW Version 2.00)&#13;&#10;&#13;&#10;Input &lt; - 10,25V" Name="t_AM_Errors.UnderRangeAI1"/>
	    11 UnderRangeAI2,  //! <Type Comment="Low Range Analog Input Bit (since FW Version 2.00)&#13;&#10;&#13;&#10;Input &lt; - 10,25V" Name="t_AM_Errors.UnderRangeAI2"/>
	  ];
	  t_AM_ErrorsAll : BINT  //! <Type Public="true" Comment="AM specific errors" Name="t_AM_ErrorsAll"/>
	  [
	    1 CableBreakAI1,  //! <Type Comment="Analog input cable break bit" Name="t_AM_ErrorsAll.CableBreakAI1"/>
	    2 CableBreakAI2,  //! <Type Comment="Analog input cable break bit" Name="t_AM_ErrorsAll.CableBreakAI2"/>
	    5 LowReference,  //! <Type Comment="Reference Supply Voltage is too low." Name="t_AM_ErrorsAll.LowReference"/>
	    6 AiOvercurrent,  //! <Type Comment="Analog input current is too high." Name="t_AM_ErrorsAll.AiOvercurrent"/>
	    7 DC_NotOK,  //! <Type Comment="Voltage of sdias bus is too low." Name="t_AM_ErrorsAll.DC_NotOK"/>
	    8 TimeOffsetsCorrectedByFW,  //! <Type Comment="Time offsets had to be corrected by FW&#13;&#10;" Name="t_AM_ErrorsAll.TimeOffsetsCorrectedByFW"/>
	    9 TimeOffsetsCouldNotBeCorrected,  //! <Type Comment="time offsets are out of allowed range" Name="t_AM_ErrorsAll.TimeOffsetsCouldNotBeCorrected"/>
	    10 UnderRangeAI1,  //! <Type Comment="Low Range Analog Input Bit (since FW Version 2.00)&#13;&#10;&#13;&#10;Input &lt; - 10,25V" Name="t_AM_ErrorsAll.UnderRangeAI1"/>
	    11 UnderRangeAI2,  //! <Type Comment="Low Range Analog Input Bit (since FW Version 2.00)&#13;&#10;&#13;&#10;Input &lt; - 10,25V" Name="t_AM_ErrorsAll.UnderRangeAI2"/>
	  ];
	  t_bi_Selection : BINT  //! <Type Comment="Analog in default or ground reference selection." Name="t_bi_Selection"/>
	  [
	    1 AI1_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI1_Def0_Ground1"/>
	    2 AI2_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI2_Def0_Ground1"/>
	    3 AI3_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI3_Def0_Ground1"/>
	    4 AI4_Def0_Ground1,  //! <Type Comment="Select bit for analog input&#13;&#10;0 = default input&#13;&#10;1 = ground reference input" Name="t_bi_Selection.AI4_Def0_Ground1"/>
	  ];
	  t_e_InitSSW :  //! <Type Comment="State definition for Initialization." Name="t_e_InitSSW"/>
	  (
	    Init_GetFWVersion,  //! <Type Comment="Get the FW version" Name="t_e_InitSSW.Init_GetFWVersion"/>
	    Init_Variables,  //! <Type Comment="Initialize default value." Name="t_e_InitSSW.Init_Variables"/>
	    Init_Firmware,  //! <Type Comment="SDO write access to firmware (writes config data)." Name="t_e_InitSSW.Init_Firmware"/>
	    Init_GetStateFW,  //! <Type Comment="SDO read access to firmware (read status data)." Name="t_e_InitSSW.Init_GetStateFW"/>
	    Init_Finish,  //! <Type Comment="Finish initialization." Name="t_e_InitSSW.Init_Finish"/>
	    Init_Error  //! <Type Comment="Error in initialization." Name="t_e_InitSSW.Init_Error"/>
	  )$UDINT;
	  t_e_SDOState :  //! <Type Comment="SDO Response states." Name="t_e_SDOState"/>
	  (
	    SDO_idle,  //! <Type Comment="No SDO transmission." Name="t_e_SDOState.SDO_idle"/>
	    SDO_wait,  //! <Type Comment="SDO transmission in progress." Name="t_e_SDOState.SDO_wait"/>
	    SDO_valid  //! <Type Comment="SDO transmission succeeded." Name="t_e_SDOState.SDO_valid"/>
	  )$UDINT;
#pragma pack(push, 1)
	  t_MinMaxRange : STRUCT
	    MinRangeValue : DINT;
	    MaxRangeValue : DINT;
	    Range : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_StandardModus : STRUCT  //! <Type Comment="Configuration data for module." Name="t_s_StandardModus"/>
	    Ai_mode : t_bi_Selection;  //! <Type Comment="Analog input settings" Name="t_s_StandardModus.Ai_mode"/>
	    uiAI1_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI1_Freq"/>
	    uiAI2_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI2_Freq"/>
	    uiAI3_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI3_Freq"/>
	    uiAI4_Freq : UINT;  //! <Type Comment="Cut off frequency for analog in low pass filter" Name="t_s_StandardModus.uiAI4_Freq"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FWConfiguration : STRUCT  //! <Type Comment="Configuration Data of from HW-Class to Firmware." Name="t_s_FWConfiguration"/>
	    hCRC : HINT;  //! <Type Comment="Checksum of data block." Name="t_s_FWConfiguration.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of data block." Name="t_s_FWConfiguration.uDataLength"/>
	    Info : BSINT  //! <Type Comment="Info (Special-Purpose / Statusbits)" Name="t_s_FWConfiguration.Info"/>
	    [
	      1 PMBModus,  //! <Type Comment="Mode for Firmware&#13;&#10;&#13;&#10;0 = standard Mode&#13;&#10;1 = PMB Mode" Name="t_s_FWConfiguration.Info.PMBModus"/>
	      2 BootLoaderUpdateReqest,  //! <Type Comment="Update request for bootloader." Name="t_s_FWConfiguration.Info.BootLoaderUpdateReqest"/>
	      3 EnableMessageCounter,
	      4 AI_TimeOffset,
	      5 AO_TimeOffset,
	      6 FullRes16Bit,
	      7 ModuleVersion,
	    ];
	    MessageCounter : USINT;  //! <Type Comment="Messagecounter if FW Version is higher or equal than 2.00.&#13;&#10;FW Version &lt; 2.00 ... reserved." Name="t_s_FWConfiguration.MessageCounter"/>
	    StandardModus : t_s_StandardModus;  //! <Type Comment="Module configuration" Name="t_s_FWConfiguration.StandardModus"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_FWState : STRUCT  //! <Type Comment="Configuration Data of from Firmware to HW-Class." Name="t_s_FWState"/>
	    hCRC : UINT;  //! <Type Comment="Checksum value for data block." Name="t_s_FWState.hCRC"/>
	    uDataLength : UINT;  //! <Type Comment="Length of data block." Name="t_s_FWState.uDataLength"/>
	    hFWVersion : HINT;  //! <Type Comment="Firmware version" Name="t_s_FWState.hFWVersion"/>
	    MessageCounter : USINT;
	    reserved : USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ReadData : STRUCT  //! <Type Comment="Cyclic read memory space." Name="t_s_ReadData"/>
	    Status : t_b_SdiasFWState;
	    iAnalogIn1 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn1"/>
	    iAnalogIn2 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn2"/>
	    iAnalogIn3 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn3"/>
	    iAnalogIn4 : INT;  //! <Type Comment="Analog in value." Name="t_s_ReadData.iAnalogIn4"/>
	    AM_ErrorsAll : t_AM_ErrorsAll;  //! <Type Comment="Module specific errors." Name="t_s_ReadData.AM_ErrorsAll"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_TwoOutputs : STRUCT  //! <Type Comment="Concatenate two Outputs." Name="t_s_TwoOutputs"/>
	    Output1 : INT;  //! <Type Comment="First output" Name="t_s_TwoOutputs.Output1"/>
	    Output2 : INT;  //! <Type Comment="Second output" Name="t_s_TwoOutputs.Output2"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteAccessTimeOffset : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteData : STRUCT  //! <Type Comment="Cyclic data for hardware." Name="t_s_WriteData"/>
	    AO1_2 : t_s_TwoOutputs;  //! <Type Comment="Output 1 and Output 2" Name="t_s_WriteData.AO1_2"/>
	    AO3_4 : t_s_TwoOutputs;  //! <Type Comment="Output 3 and Output 4" Name="t_s_WriteData.AO3_4"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_WriteDataTimeOffset : STRUCT  //! <Type Comment="Extended cyclic data with support of TimeOffsets." Name="t_s_WriteDataTimeOffset"/>
	    AO1_2 : t_s_TwoOutputs;
	    AO3_4 : t_s_TwoOutputs;
	    AI1_SP : UINT;
	    AI2_SP : UINT;
	    AI3_SP : UINT;
	    AI4_SP : UINT;
	    AO1_SP : UINT;
	    AO2_SP : UINT;
	    AO3_SP : UINT;
	    AO4_SP : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_SDIAS_ErrorBits_AM221 : STRUCT  //! <Type Public="true" Comment="Concatenation of error bits." Name="t_SDIAS_ErrorBits_AM221"/>
	    StandardErrors : t_b_SdiasFWState;  //! <Type Comment="Standard errors" Name="t_SDIAS_ErrorBits_AM221.StandardErrors"/>
	    AM_Errors : t_AM_Errors;  //! <Type Comment="Module specific errors." Name="t_SDIAS_ErrorBits_AM221.AM_Errors"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	FirmwareVersion 	: SvrCh_HDINT;
	ErrorBits 	: SvrCh_t_SDIAS_ErrorBits_AM221_PTofCls_AM221;
	AI1 	: SvrCh_DINT;
	AI2 	: SvrCh_DINT;
	AO1 	: SvrCh_DINT;
	AO2 	: SvrCh_DINT;
	RefVoltageOK 	: SvrCh_DINT;
	AI1TimeOffset 	: SvrCh_DINT;
	AI2TimeOffset 	: SvrCh_DINT;
	AO1TimeOffset 	: SvrCh_DINT;
	AO2TimeOffset 	: SvrCh_DINT;
	TimeOffsetErrorBits 	: SvrCh_BDINT;
	Range 	: SvrCh_BDINT;
  //Clients:
	AI1Config 	: CltCh_DINT;
	AI1_Freq 	: CltCh_UDINT;
	AI1_Min 	: CltCh_DINT;
	AI1_Max 	: CltCh_DINT;
	AI2Config 	: CltCh_DINT;
	AI2_Freq 	: CltCh_UDINT;
	AI2_Min 	: CltCh_DINT;
	AI2_Max 	: CltCh_DINT;
	AO1_Min 	: CltCh_DINT;
	AO1_Max 	: CltCh_DINT;
	AO2_Min 	: CltCh_DINT;
	AO2_Max 	: CltCh_DINT;
	FullRes16Bit 	: CltCh_UDINT;
	AI_TimeOffset 	: CltCh_DINT;
	AO_TimeOffset 	: CltCh_DINT;
  //Variables:
		aAIRange : ARRAY [0..AM221_NUMBER_OF_ANALOG_IN-1] OF DINT;
			//! <Variable Comment="RangeInformations for the Inputs." Name="aAIRange"/>
		eInitSSW 	: t_e_InitSSW;			//! <Variable Comment="Initialisation Statemachine." Name="eInitSSW"/>
		eInitSSWErrorStep 	: t_e_InitSSW;			//! <Variable Comment="Initialisation Statemachine in case of an Error." Name="eInitSSWErrorStep"/>
		eResponseState 	: t_e_SDOState;			//! <Variable Comment="Actual Response State of the SDO Communication." Name="eResponseState"/>
		pReadData 	: ^t_s_ReadData;			//! <Variable Comment="Read-Data from the Module." Name="pReadData"/>
		sFWConfiguration 	: t_s_FWConfiguration;			//! <Variable Comment="Configuration Data for the Firmware." Name="sFWConfiguration"/>
		sFWState 	: t_s_FWState;			//! <Variable Comment="FW Informations of the Module." Name="sFWState"/>
		udSDOTimeout 	: UDINT;			//! <Variable Comment="Timeout for SDO-Communication." Name="udSDOTimeout"/>
		pWriteData 	: ^t_s_WriteData;			//! <Variable Comment="WriteData of the Module." Name="pWriteData"/>
		pWriteDataTimeOffset 	: ^t_s_WriteDataTimeOffset;			//! <Variable Comment="Extended write data of module with support of time offsets." Name="pWriteDataTimeOffset"/>
		sWriteAccessTimeOffset 	: t_s_WriteAccessTimeOffset;
		sOutputValues 	: t_s_WriteDataTimeOffset;			//! <Variable Comment="Outputvalues for the Hardware." Name="sOutputValues"/>
		aMinMaxOutput : ARRAY [0..1] OF t_MinMaxRange;

		FirmwareMinValue 	: DINT;
		FirmwareRange 	: DINT;
		ScaleAI1 	: BOOL;
		ScaleAI2 	: BOOL;
  //Functions:
				//! <Function Comment="Constructor of Class." Name="AM221"/>
	FUNCTION AM221
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode is used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit1..Realtime PreScan&#13;&#10;Bit2..Realtime PostScan&#13;&#10;Bit3..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GetFWVersion
		VAR_INPUT
			pData 	: ^CHAR;
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Lookup-Methode to get the Frequency-Setting for the uC." Name="SetFrequency"/>
	FUNCTION SetFrequency
		VAR_INPUT
			pClientValue 	: ^UDINT;
			pErrorCode 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			Frequency 	: UINT;			//! <Variable Comment="Result for the uC." Name="SetFrequency.Frequency"/>
		END_VAR;
	
	FUNCTION CalcScaleInv
		VAR_INPUT
			ScaleVal 	: DINT;			//! <Variable Comment="Value to Scale into Binary Value." Name="CalcScaleInv.ScaleVal"/>
			MinVal 	: DINT;			//! <Variable Comment="Minimum Value." Name="CalcScaleInv.MinVal"/>
			MaxVal 	: DINT;			//! <Variable Comment="Maximum Value." Name="CalcScaleInv.MaxVal"/>
		END_VAR
		VAR_OUTPUT
			BinVal 	: INT;			//! <Variable Comment="Binary Value as Result." Name="CalcScaleInv.BinVal"/>
		END_VAR;
	
	FUNCTION GetMinMaxRange
		VAR_INPUT
			ClientMinRange 	: DINT;
			ClientMaxRange 	: DINT;
			pMinMaxValue 	: ^t_MinMaxRange;
		END_VAR
		VAR_OUTPUT
			bError 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI1TimeOffset::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AI2TimeOffset::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO1TimeOffset::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL AO2TimeOffset::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AM221::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_AM221
1$UINT, 28$UINT, (SIZEOF(::AM221))$UINT, 
13$UINT, 15$UINT, 0$UINT, 
TO_UDINT(1368286129), "AM221", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::AM221.FirmwareVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(389440282), "FirmwareVersion", 
(::AM221.ErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(259769398), "ErrorBits", 
(::AM221.AI1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4269591187), "AI1", 
(::AM221.AI2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1735760681), "AI2", 
(::AM221.AO1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2821090581), "AO1", 
(::AM221.AO2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(825179311), "AO2", 
(::AM221.RefVoltageOK.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4186040419), "RefVoltageOK", 
(::AM221.AI1TimeOffset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1427416424), "AI1TimeOffset", 
(::AM221.AI2TimeOffset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3438723945), "AI2TimeOffset", 
(::AM221.AO1TimeOffset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3123249288), "AO1TimeOffset", 
(::AM221.AO2TimeOffset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(600532617), "AO2TimeOffset", 
(::AM221.TimeOffsetErrorBits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3144423170), "TimeOffsetErrorBits", 
(::AM221.Range.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1691588857), "Range", 
//Clients:
(::AM221.AI1Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2190884243), "AI1Config", 
(::AM221.AI1_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1690732223), "AI1_Freq", 
(::AM221.AI1_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2432037533), "AI1_Min", 
(::AM221.AI1_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2901986756), "AI1_Max", 
(::AM221.AI2Config.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3011389198), "AI2Config", 
(::AM221.AI2_Freq.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3797087249), "AI2_Freq", 
(::AM221.AI2_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3612706893), "AI2_Min", 
(::AM221.AI2_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3948459796), "AI2_Max", 
(::AM221.AO1_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1185681792), "AO1_Min", 
(::AM221.AO1_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2057383641), "AO1_Max", 
(::AM221.AO2_Min.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(17591120), "AO2_Min", 
(::AM221.AO2_Max.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1023497225), "AO2_Max", 
(::AM221.FullRes16Bit.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3989465180), "FullRes16Bit", 
(::AM221.AI_TimeOffset.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1471551574), "AI_TimeOffset", 
(::AM221.AO_TimeOffset.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3096165814), "AO_TimeOffset", 
END_FUNCTION


#define USER_CNT_AM221 25

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AM221] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AM221::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AM221;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #GetFWVersion();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO1::Write() );
	IF AO1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO2::Write() );
	IF AO2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI1TimeOffset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI1TimeOffset::Write() );
	IF AI1TimeOffset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AI2TimeOffset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AI2TimeOffset::Write() );
	IF AI2TimeOffset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO1TimeOffset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO1TimeOffset::Write() );
	IF AO1TimeOffset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	AO2TimeOffset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #AO2TimeOffset::Write() );
	IF AO2TimeOffset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= AM221();

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL AM221::UpdateRt
  VAR
  	sTempReadData : t_s_ReadData;
    TmpLowRangeBits  : BDINT;
  END_VAR
  
  //Copy content of PDO Read Data to temp struct  
  sTempReadData := pReadData^;

  //Set Status
  ErrorBits.StandardErrors  := sTempReadData.Status;
  ErrorBits.AM_Errors       := sTempReadData.AM_ErrorsAll AND AM221_ERROR_BIT_MASK;
  TimeOffsetErrorBits       := ((sTempReadData.AM_ErrorsAll shr AM221_OFFSET_TIME_OFFSET_BITS) AND AM221_TIME_OFFSET_BIT_MASK);
  RefVoltageOK              := sTempReadData.AM_ErrorsAll.LowReference XOR 1;
  
  //Show all range bits on server (high range and low range)
  Range             := sTempReadData.AM_ErrorsAll AND AM221_CABLE_BREAK_MASK;
  TmpLowRangeBits   := ((sTempReadData.AM_ErrorsAll shr AM221_OFFSET_LOW_RANGE_BITS) AND AM221_CABLE_BREAK_MASK);
  Range             := Range OR (TmpLowRangeBits shl 4);  
  
  //Initialize servers in case of cable break
  AI1 := AM221_INVALID_VALUE;
  AI2 := AM221_INVALID_VALUE;
  
  //Check for cable break and scale value from fw
  if (sTempReadData.AM_ErrorsAll.CableBreakAI1 = FALSE) & (sTempReadData.AM_ErrorsAll.UnderRangeAI1 = FALSE) then
    if ScaleAI1 then
      AI1 := AI1_Min + (aAIRange[0] * (TO_DINT(sTempReadData.iAnalogIn1) - FirmwareMinValue)) / FirmwareRange;
    else
      AI1 := sTempReadData.iAnalogIn1;
    end_if;   
  end_if;
  
  if (sTempReadData.AM_ErrorsAll.CableBreakAI2 = FALSE) & (sTempReadData.AM_ErrorsAll.UnderRangeAI2 = FALSE) then
    if ScaleAI2 then
      AI2 := AI2_Min + (aAIRange[1] * (TO_DINT(sTempReadData.iAnalogIn2) - FirmwareMinValue)) / FirmwareRange;
    else
      AI2 := sTempReadData.iAnalogIn2;
    end_if;    
  end_if;
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::UpdateRtPostScan

  if (AI_TimeOffset = TRUE) | (AO_TimeOffset = TRUE) then
    pWriteDataTimeOffset^ := sOutputValues;    
    pWriteDataTimeOffset^.AO3_4 := sOutputValues.AO1_2; // at HW AO1/2 is AO3/4
  else
    pWriteData^.AO3_4 := sOutputValues.AO1_2; // at HW AO1/2 is AO3/4
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::ConnectEvent

  //Read Access
  if DefaultAccesses.ReadAccess.pControlByte then
    pReadData := DefaultAccesses.ReadAccess.pData$^t_s_ReadData;

    //Start Read-Access to Module (Set ControlWord in DPRam)
    DefaultAccesses.ReadAccess.pControlByte^.EnableDO := true;
  else
    //No ControlWord available
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  // Only enable extended DO if TimeOffsets config is used
  if (AI_TimeOffset = TRUE) | (AO_TimeOffset = TRUE) then
    
    //No Default access available, we use our own created write access
    if sWriteAccessTimeOffset.pControlByte then
      // Reset output memory area
      _memset(pWriteDataTimeOffset, 0, sizeof(t_s_WriteDataTimeOffset));
      
      sWriteAccessTimeOffset.pControlByte^.EnableDO := TRUE;
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;
        
        
  else
    //Write Access
    if DefaultAccesses.WriteAccess.pControlByte then
      pWriteData := DefaultAccesses.WriteAccess.pData$^t_s_WriteData;

      // Reset output memory area
      _memset(pWriteData, 0, sizeof(t_s_WriteData));

      //Start Write-Access to Module (Set ControlWord in DPRam)
      DefaultAccesses.WriteAccess.pControlByte^.EnableDO := true;
    else  
      //No ControlWord available
      eInitState := _DOHandleInvalid;
      return;
    end_if;
    
  end_if;

  //Reset Statemachines
  eInitSSW        := Init_GetFWVersion;
  eResponseState  := SDO_idle;
  eInitState      := _NotInitialized;

END_FUNCTION


FUNCTION VIRTUAL AM221::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  //Call Response of Base-Class
  ret_code := SdiasBase::ReceiveSDOResponse(eCommand        := eCommand, 
                                            hOffset         := hOffset, 
                                            usLength        := usLength, 
                                            eResult         := eResult, 
                                            pResponseBuffer := pResponseBuffer, 
                                            ResponseLength  := ResponseLength);
  
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;  

  //Evaluate Result of SDO
  //----------------------------------------------------------------------------
  if eResult = READY then
    
    //Check Type of SDO-Command
    case eCommand of
    
      //Memory Write
      SDIAS_SDO_CMD_MEM_WRITE:
      
        case hOffset of
          AM221_ADDR_CFG_FIRMWARE:
            if eResponseState = SDO_wait then
              eResponseState := SDO_valid;
            end_if;
        
        else
            LogError("@ZZZZ (AM221::ReceiveSDOResponse) Invalid Offset in Write-Response of SDO");
        end_case;
      
      //Memory Read
      SDIAS_SDO_CMD_MEM_READ:
      
        case hOffset of
        
          AM221_ADDR_STATE_FIRMWARE:
            if eResponseState = SDO_wait then
              eResponseState := SDO_valid;
            end_if;
            sFWState := pResponseBuffer^$t_s_FWState;
            
          else
            LogError("@ZZZZ (AM221::ReceiveSDOResponse) Invalid Offset in Read-Response of SDO");
        end_case;
    end_case;

    //Check if Class was in Valid State for SDO Response    
    if eResponseState <> SDO_valid then
      LogError("@ZZZZ (AM221::ReceiveSDOResponse) Error in response data of SDO");
      eInitSSW := Init_Error;      
    end_if;
    
  //Problem with Response
  //----------------------------------------------------------------------------    
  else
  
    //Check Type of SDO-Command to set correct Log-Message
    case eCommand of
      SDIAS_SDO_CMD_MEM_WRITE:
        LogError("@ZZZZ (AM221::ReceiveSDOResponse) Error while executing a sdo write-command");
      SDIAS_SDO_CMD_MEM_READ:
        LogError("@ZZZZ (AM221::ReceiveSDOResponse) Error while executing a sdo read-command");
    end_case;
    
    eInitSSW := Init_Error;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode      : iprStates;
    TmpErrorCode    : DINT;
  END_VAR
  
  eModuleInitState := BUSY;

  //*****************************************************************************
  //** STATEMACHINE FOR INITIALIZATION OF THE MODULE                           **
  //*****************************************************************************
  
  CASE eInitSSW OF
   
    //Get FW Version
    //***************************************************************************    
    Init_GetFWVersion:
    
      //Statemachine for SDO-Communication
      case eResponseState of

        //Idle
        //-------------------------------------------------------      
        SDO_idle:
        
          //Start SDO-Command
          TmpRetcode  := StartReadSDO(  hOffset   :=AM221_ADDR_STATE_FIRMWARE,
                                        usLength  :=sizeof(t_s_FWState),
                                        eCommand  :=SDIAS_SDO_CMD_MEM_READ);
                                        
          //Evaluate Returncode
          if TmpRetcode = READY then
            //Timestamp for TimeoutCheck
            udSDOTimeout      := ops.tAbsolute;
            eResponseState := SDO_wait;
          //Error occured 
          elsif TmpRetcode = ERROR then
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AM221::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
          end_if; 

        //Wait for Response
        //-------------------------------------------------------
        SDO_wait:
          
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > AM221_SDO_RESPONSE_TIMEOUT) then
          
            LogError("@ZZZZ (AM221::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
            
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_valid:
        
          // Check for correct length, allow old and new datalength
          if  (sFWState.uDataLength = sizeof(t_s_FWState) - sizeof(t_s_FWState.hCRC) - sizeof(t_s_FWState.uDataLength)) |
              (sFWState.uDataLength = sizeof(t_s_FWState) - sizeof(t_s_FWState.hCRC) - sizeof(t_s_FWState.uDataLength) - sizeof(t_s_FWState.MessageCounter) - sizeof(t_s_FWState.reserved)) then

            //Check CRC
            if (sFWState.hCRC = CheckSum_16(pData:= #sFWState.hFWVersion,
                                            uiDataLength:= sFWState.uDataLength,
                                            uiCrcStart:=16#FFFF)) then
              
              eInitSSW        := Init_Variables;
              eResponseState  := SDO_idle;   
              
              //Write Version of FW to Server
              FirmwareVersion := (sFWState.hFWVersion and 16#0000FFFF)$HDINT;
              
            else
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AM221::InitModule - Init_GetFWVersion) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
            end_if;
          else
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AM221::InitModule - Init_GetFWVersion) Invalid length at firmware info");
            eInitState := _ClientNotready;
          end_if;
        end_case;
    
    //Setting up Variables
    //***************************************************************************
    Init_Variables:
      AI1Config := AI1Config.Read();
      AI2Config := AI2Config.Read();
      
      AI1_Freq := AI1_Freq.Read();
      AI2_Freq := AI2_Freq.Read();

      //****************************************************************************   
      sFWConfiguration.StandardModus.uiAI1_Freq := SetFrequency(#AI1_Freq, #TmpErrorCode);
      if TmpErrorCode = -1 then
        eModuleInitState := ERROR;      
        LogError("@ZZZZ (AM221::InitModule) Invalid setting of client AI1_Freq. Client value must be between 0-6 or 10-1000");
        eInitState := _InvalidConfguration;
        return;        
      elsif TmpErrorCode = -2 then
        LogError("@ZZZZ (AM221::InitModule) The setting for client AI1_Freq is corrected to not violate the sampling theorem");
      end_if;
      
      //****************************************************************************         
      sFWConfiguration.StandardModus.uiAI2_Freq := SetFrequency(#AI2_Freq, #TmpErrorCode);
      if TmpErrorCode = -1 then
        eModuleInitState := ERROR;      
        LogError("@ZZZZ (AM221::InitModule) Invalid setting of client AI2_Freq. Client value must be between 0-6 or 10-1000");
        eInitState := _InvalidConfguration;
        return;        
      elsif TmpErrorCode = -2 then
        LogError("@ZZZZ (AM221::InitModule) The setting for client AI2_Freq is corrected to not violate the sampling theorem");
      end_if;

      AI1_Min := AI1_Min.Read();
      AI1_Max := AI1_Max.Read();
      AI2_Min := AI2_Min.Read();
      AI2_Max := AI2_Max.Read();
      
      //check if calculation is necessary
      if ((AI1_Max <> AM221_FIRMWARE_MAX) | (AI1_Min <> AM221_FIRMWARE_MIN)) then
        ScaleAI1 := TRUE;      
      end_if;
      if ((AI2_Max <> AM221_FIRMWARE_MAX) | (AI2_Min <> AM221_FIRMWARE_MIN)) then
        ScaleAI2 := TRUE;
      end_if;
      
      aAIRange[0] := AI1_Max - AI1_Min;
      aAIRange[1] := AI2_Max - AI2_Min;   
      
      AO1_Min := AO1_Min.Read();
      AO1_Max := AO1_Max.Read();
      AO2_Min := AO2_Min.Read();
      AO2_Max := AO2_Max.Read();
      AI_TimeOffset  := AI_TimeOffset.Read();
      AO_TimeOffset  := AO_TimeOffset.Read();
      FullRes16Bit   := FullRes16Bit.Read();
      
      if GetMinMaxRange(ClientMinRange:=AO1_Min, ClientMaxRange:=AO1_Max, pMinMaxValue:=#aMinMaxOutput[0]) then
        eModuleInitState := ERROR;
        LogError("@ZZZZ (AM221::InitModule) Invalid settings for AO1_Min and AO1_Max. Clients must not have the same value");
        eInitState := _InvalidConfguration;
        return;
      end_if;
      
      if GetMinMaxRange(ClientMinRange:=AO2_Min, ClientMaxRange:=AO2_Max, pMinMaxValue:=#aMinMaxOutput[1]) then
        eModuleInitState := ERROR;
        LogError("@ZZZZ (AM221::InitModule) Invalid settings for AO2_Min and AO2_Max. Clients must not have the same value");
        eInitState := _InvalidConfguration;
        return;
      end_if;
      
      // set analog input mode
      sFWConfiguration.StandardModus.Ai_mode := 0;
      
      sFWConfiguration.StandardModus.Ai_mode.AI1_Def0_Ground1     := AI1Config <> 0;
      sFWConfiguration.StandardModus.Ai_mode.AI2_Def0_Ground1     := AI2Config <> 0;
      
      // Set output to zero correspondig to min - max setting if value is out of range. 
      if (AO1 > aMinMaxOutput[0].MaxRangeValue) | (AO1 < aMinMaxOutput[0].MinRangeValue) then
        AO1 := aMinMaxOutput[0].MinRangeValue + (aMinMaxOutput[0].Range / 2);
      end_if;
      if (AO2 > aMinMaxOutput[1].MaxRangeValue) | (AO2 < aMinMaxOutput[1].MinRangeValue) then
        AO2 := aMinMaxOutput[1].MinRangeValue + (aMinMaxOutput[1].Range / 2);
      end_if;
      
      sOutputValues.AO1_2.Output1 := CalcScaleInv(AO1, AO1_Min, AO1_Max);
      sOutputValues.AO1_2.Output2 := CalcScaleInv(AO2, AO2_Min, AO2_Max);
      
      //AM221 Specific: Set unused TimeOffsets
      sOutputValues.AI3_SP := 0xFFFF;
      sOutputValues.AI4_SP := 0xFFFF;
      sOutputValues.AO1_SP := 0xFFFF;
      sOutputValues.AO2_SP := 0xFFFF;
       
      //Clear Info register
      sFWConfiguration.Info := 0;
      
      // rescale the min / max values for full res mode, set full res bit
      if FullRes16Bit then
        FirmwareMinValue  := (AM221_FIRMWARE_FULLRES_MIN);
        FirmwareRange     := (AM221_FIRMWARE_FULLRES_MAX - AM221_FIRMWARE_FULLRES_MIN);
      else
        FirmwareMinValue  := (AM221_FIRMWARE_MIN);
        FirmwareRange     := (AM221_FIRMWARE_MAX - AM221_FIRMWARE_MIN);
      end_if;
      
      //Show that feature is not supported/used
      if (AI_TimeOffset = FALSE) then
        AI1TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;
        AI2TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;
      end_if;
      if (AO_TimeOffset = FALSE) then
        AO1TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;
        AO2TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;
      end_if;
        
      //Check for feature support
      if FirmwareVersion < AM221_FIRMWARE_VERSION_NEW_TIMING_AVAILABLE then

        // Old FW Version -> TimeOffsets are not supported, show on servers
        AI1TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;
        AI2TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;
        AO1TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;
        AO2TimeOffset := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED;

        //Check if any new feature is enabled
        if AI_TimeOffset | AO_TimeOffset | FullRes16Bit then
          
          //Check for timeoffset feature
          if AI_TimeOffset | AO_TimeOffset then
            LogError("@ZZZZ (AM221::InitModule) TimeOffset feature is not supported by current FirmwareVersion. Please update to FirmwareVersion 2.00 or higher or set client value to 0");
          end_if;
          
          //Check for full res 16 bit feature
          if FullRes16Bit then
            LogError("@ZZZZ (AM221::InitModule) FullRes16Bit feature is not supported by current FirmwareVersion. Please update to FirmwareVersion 2.00 or higher or set client value to 0");        
      end_if;

          eModuleInitState := ERROR;
          eInitState := _InvalidConfguration;
          return;
        end_if;
                
      else  //Firmware version 2.00 or higher
        
        //Set Info Bits according to client settings
        sFWConfiguration.Info.EnableMessageCounter  := TRUE;
        sFWConfiguration.Info.FullRes16Bit          := FullRes16Bit  <> 0;
        sFWConfiguration.Info.AI_TimeOffset         := AI_TimeOffset <> 0;
        sFWConfiguration.Info.AO_TimeOffset         := AO_TimeOffset <> 0;
        sFWConfiguration.Info.ModuleVersion         := AM221_MODULE_VERSION;
        
        //Increment message counter and calculate data length
        sFWConfiguration.MessageCounter             += 1;
      end_if;
            
      sFWConfiguration.uDataLength    := sizeof(t_s_FWConfiguration) - sizeof(t_s_FWConfiguration.hCRC) - sizeof(t_s_FWConfiguration.uDataLength);
      sFWConfiguration.hCRC                           := CheckSum_16(pData:=(#sFWConfiguration.Info)$^UINT, uiDataLength:=sFWConfiguration.uDataLength, uiCrcStart:=16#FFFF);
      eInitSSW   := Init_Firmware;

    //Initialize Firmware
    //*****************************************************************************
    Init_Firmware:
    
      //Statemachine for SDO-Communication
      case eResponseState of
        //Idle
        //-------------------------------------------------------
        SDO_idle:
        
          //Start SDO-Command
          TmpRetcode  := StartWriteSDO(hOffset      :=AM221_ADDR_CFG_FIRMWARE,
                                      usLength      :=sizeof(t_s_FWConfiguration),
                                      pWriteBuffer  :=(#sFWConfiguration)$^USINT,
                                      eCommand      :=SDIAS_SDO_CMD_MEM_WRITE);
           
          //Evaluate Returncode
          if TmpRetcode = READY then
          
                    
            //Timestamp for TimeoutCheck
            udSDOTimeout  := ops.tAbsolute;
            eResponseState:= SDO_wait;
            
          //Error occured  
          elsif TmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AM221::InitModule) Failed to add write SDO for firmware configuration");
            eInitState := _NoMem;
            
          end_if;
          
          
        //Wait for Response
        //-------------------------------------------------------
        SDO_wait:
        
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > AM221_SDO_RESPONSE_TIMEOUT) then
          
            LogError("@ZZZZ (AM221::InitModule) SDO Response timeout config module");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
            
          end_if;

        //Response received
        //-------------------------------------------------------
        SDO_valid:
        
          eInitSSW        := Init_GetStateFW;
          eResponseState  := SDO_idle;

      end_case;
      
    //Get Firmware Informations
    //*****************************************************************************
    Init_GetStateFW:
    
      //Statemachine for SDO-Communication
      case eResponseState of

        //Idle
        //-------------------------------------------------------      
        SDO_idle:
        
          //Start SDO-Command
          TmpRetcode  := StartReadSDO(  hOffset   :=AM221_ADDR_STATE_FIRMWARE,
                                        usLength  :=sizeof(t_s_FWState),
                                        eCommand  :=SDIAS_SDO_CMD_MEM_READ);
                                        
          //Evaluate Returncode
          if TmpRetcode = READY then            
            //Timestamp for TimeoutCheck
            udSDOTimeout      := ops.tAbsolute;
            eResponseState := SDO_wait;
           
          //Error occured 
          elsif TmpRetcode = ERROR then
          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AM221::InitModule) Failed to add read SDO for firmware info");
            eInitState := _NoMem;
            
          end_if; 

        //Wait for Response
        //-------------------------------------------------------
        SDO_wait:
          
          //Timeout-Check
          if ((ops.tAbsolute - udSDOTimeout) > AM221_SDO_RESPONSE_TIMEOUT) then
          
            LogError("@ZZZZ (AM221::InitModule) SDO Response timeout read state");
            eInitSSWErrorStep := eInitSSW;
            eInitSSW := Init_Error;
            
          end_if;
          
        //Response received
        //-------------------------------------------------------
        SDO_valid:
        
          //Check Length of FirmwarePackage

          // Check for correct length, allow old and new datalength
          if  (sFWState.uDataLength = sizeof(t_s_FWState) - sizeof(t_s_FWState.hCRC) - sizeof(t_s_FWState.uDataLength)) |
              (sFWState.uDataLength = sizeof(t_s_FWState) - sizeof(t_s_FWState.hCRC) - sizeof(t_s_FWState.uDataLength) - sizeof(t_s_FWState.MessageCounter) - sizeof(t_s_FWState.reserved)) then
            //Check CRC
            if (sFWState.hCRC = CheckSum_16(pData:= #sFWState.hFWVersion,
                                            uiDataLength:= sFWState.uDataLength,
                                            uiCrcStart:=16#FFFF)) then
              
              //Write Version of FW to Server
              FirmwareVersion := (sFWState.hFWVersion and 16#0000FFFF)$HDINT;
                            
              //next step
              eInitSSW         := Init_Finish;
              eResponseState   := SDO_idle;
              
              if FirmwareVersion >= AM221_FIRMWARE_VERSION_NEW_TIMING_AVAILABLE then
              
//                Check for correct messagecounter
                if sFWState.MessageCounter = sFWConfiguration.MessageCounter then
              
                  //Set initvalues for TimeOffsets only when used
                  if AI_TimeOffset = TRUE then

                    //Now check if inital values from user are valid, Write values
                    if AI1TimeOffset.Write(input:=AI1TimeOffset) = AM221_TIME_OFFSET_STATE_INVALID_INPUT then
                  eModuleInitState := ERROR;
                      LogError("@ZZZZ (AM221::InitModule) TimeOffset setting of AI1 is invalid");
                  eInitState := _InvalidConfguration;
                end_if;
                                
                    if AI2TimeOffset.Write(input:=AI2TimeOffset) = AM221_TIME_OFFSET_STATE_INVALID_INPUT then
                  eModuleInitState := ERROR;
                      LogError("@ZZZZ (AM221::InitModule) TimeOffset setting of AI2 is invalid");
                  eInitState := _InvalidConfguration;
                end_if;
                
                  end_if;
                 
                  if AO_TimeOffset = TRUE then
                 
                    //Now check if inital values from user are valid, Write values
                    if AO1TimeOffset.Write(input:=AO1TimeOffset) = AM221_TIME_OFFSET_STATE_INVALID_INPUT then
                      eModuleInitState := ERROR;
                      LogError("@ZZZZ (AM221::InitModule) TimeOffset setting of AO1 is invalid");
                      eInitState := _InvalidConfguration;
                    end_if;

                    if AO2TimeOffset.Write(input:=AO2TimeOffset) = AM221_TIME_OFFSET_STATE_INVALID_INPUT then
                      eModuleInitState := ERROR;
                      LogError("@ZZZZ (AM221::InitModule) TimeOffset setting of AO2 is invalid");
                      eInitState := _InvalidConfguration;
                    end_if;
                              
                  end_if;                
                  
                //Wrong message counter    
                else
              
                  eModuleInitState := ERROR;
                  LogError("@ZZZZ (AM221::InitModule) Invalid message counter from Firmware");
                  eInitState := _ClientNotready;              
              
                end_if;
              end_if;             
              
            // Wrong CRC
            else
            
              eModuleInitState := ERROR;
              LogError("@ZZZZ (AM221::InitModule - Init_GetStateFW) Invalid checksum at firmware info");
              eInitState := _ClientNotready;
              
            end_if;
            
          //Wrong Data-Length
          else
          
            eModuleInitState := ERROR;
            LogError("@ZZZZ (AM221::InitModule - Init_GetStateFW) Invalid length at firmware info");
            eInitState := _ClientNotready;
              
          end_if;

      end_case;

    //Initialization of Module finished
    //*****************************************************************************
    Init_Finish:
    
      eInitSSW         := Init_GetFWVersion;
      eModuleInitState := READY;
      eInitState      := _ClassOk;
      
   //Error during Initialization
   //*****************************************************************************
    Init_Error:
    
      eModuleInitState := ERROR;
      
      // Keep _InvalidConfiguration for eInitState
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;  
      

  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
	//look if it is right hardware
	if ( udID2Check <> DEVICE_ID_AM221 ) then
		bIsOK := FALSE;
	else
    bIsOK := TRUE;
	end_if;
  
END_FUNCTION

FUNCTION AM221::SetFrequency
	VAR_INPUT
		pClientValue 	: ^UDINT;
		pErrorCode 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		Frequency 	: UINT;
	END_VAR
  VAR
  	dBusFreq : DINT;
  END_VAR
  
  //No error as default
  pErrorCode^ := 0;
  
  // lookup table for cut off frequency
  case pClientValue^ of
    6:  Frequency := 10;
    5:  Frequency := 25;
    4:  Frequency := 50;
    3:  Frequency := 100;
    2:  Frequency := 250;
    1:  Frequency := 500;
    0:  Frequency := 1000;
  else
    if pClientValue^ >= 10 & pClientValue^ <= 1000 then
      Frequency := TO_UINT(pClientValue^);
    else
      pErrorCode^ := -1;
      return;
    end_if;
  end_case;
  
  //Only if TimeOffsetmode is used, otherwise Fw is sampling more often
  if AI_TimeOffset then
  
    //Calculate bus frequency 
    dBusFreq := TO_DINT(( 1 / ( (TO_REAL(udBusTime) / 1000000000)))); //Convert udBustime from ns into s, 1/s = frequency
    
    //Check for violation of the shannon's sampling theorem
    if Frequency > (dBusFreq / 2) then
      Frequency := TO_UINT(dBusFreq / 2);
      pClientValue^ := Frequency;
      pErrorCode^   := -2;
      return;
    end_if;
  
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::DisconnectEvent
  
  //Reset DO-Data
  if pWriteData then
    _memset(dest := pWriteData, usByte := 0, cntr := sizeof(t_s_WriteData));
  end_if;
  
  //Reset DO-Data
  if pWriteDataTimeOffset then
    _memset(dest := pWriteDataTimeOffset, usByte := 0, cntr := sizeof(t_s_WriteDataTimeOffset));  
  end_if;  

  //Call Disconnect of Base-Class
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION AM221::AM221
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

	ret_code := C_OK;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::AO1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO1 <> input then  
    // Check input borders
    if input > aMinMaxOutput[0].MaxRangeValue then
      input := aMinMaxOutput[0].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[0].MinRangeValue then
      input := aMinMaxOutput[0].MinRangeValue;
    end_if;
  
    AO1 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO1_2.Output1 := CalcScaleInv(AO1, AO1_Min, AO1_Max);
    
    result := AO1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::AO2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  // Only react to changing Values
  if AO2 <> input then  
    // Check input borders
    if input > aMinMaxOutput[1].MaxRangeValue then
      input := aMinMaxOutput[1].MaxRangeValue;
    end_if;
    if input < aMinMaxOutput[1].MinRangeValue then
      input := aMinMaxOutput[1].MinRangeValue;
    end_if;
  
    AO2 := input;    
    
    // Convert Scaled Server Value to corresponding binary value (value sent to the module)
    sOutputValues.AO1_2.Output2 := CalcScaleInv(AO2, AO2_Min, AO2_Max);
    
    result := AO2;
  end_if;

END_FUNCTION


FUNCTION AM221::CalcScaleInv
	VAR_INPUT
		ScaleVal 	: DINT;
		MinVal 	: DINT;
		MaxVal 	: DINT;
	END_VAR
	VAR_OUTPUT
		BinVal 	: INT;
	END_VAR
  
  // Convert Scaled Value to corresponding binary value
  BinVal := (AM221_FIRMWARE_MIN + ((AM221_FIRMWARE_MAX - AM221_FIRMWARE_MIN) * (ScaleVal - MinVal)) / (MaxVal - MinVal))$INT;

END_FUNCTION


FUNCTION VIRTUAL AM221::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_RT_POST;

END_FUNCTION


FUNCTION VIRTUAL AM221::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR
  
  output := DEVICE_ID_AM221;

END_FUNCTION


FUNCTION VIRTUAL AM221::GetFWVersion
	VAR_INPUT
		pData 	: ^CHAR;
		Length 	: UDINT;
	END_VAR

  //Check pointer
  if pData then
    //Length of Firmwareversion (HDINT) -> 8Byte +1 byte zero termination
    if Length >= 9 then
      _itoa(udNumber:=FirmwareVersion, pString:=pData);  
    else
      pData^ := 0;
    end_if; 
  end_if;
  
END_FUNCTION


FUNCTION AM221::GetMinMaxRange
	VAR_INPUT
		ClientMinRange 	: DINT;
		ClientMaxRange 	: DINT;
		pMinMaxValue 	: ^t_MinMaxRange;
	END_VAR
	VAR_OUTPUT
		bError 	: BOOL;
	END_VAR
  
  bError := FALSE; //No Error as default
  
  if ClientMinRange < ClientMaxRange then
    pMinMaxValue^.MinRangeValue := ClientMinRange;
    pMinMaxValue^.MaxRangeValue := ClientMaxRange;
  elsif ClientMinRange > ClientMaxRange then    
    pMinMaxValue^.MinRangeValue := ClientMaxRange;
    pMinMaxValue^.MaxRangeValue := ClientMinRange;
  else
    //min and max value are equal => set class state to error
    bError := TRUE;
  end_if;
  
  //Calculate client range
  pMinMaxValue^.Range := pMinMaxValue^.MaxRangeValue - pMinMaxValue^.MinRangeValue;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL AM221::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR

  eModuleInitState := READY;
  
  AI_TimeOffset := AI_TimeOffset.Read();
  AO_TimeOffset := AO_TimeOffset.Read();
  
  // Only add accesss is TimeOffsets configuration is used
  if (AI_TimeOffset = TRUE) | (AO_TimeOffset = TRUE) then
    
    // No default access available, add write access here
    if AddWrAccess(hOffset              := AM221_ADDR_CYC_WRITE
                 , uLength              := sizeof(t_s_WriteDataTimeOffset)
                 , ppData               := #pWriteDataTimeOffset
                 , ppStateByte          := #sWriteAccessTimeOffset.pStateByte
                 , ppControlByte        := #sWriteAccessTimeOffset.pControlByte
                 , pAccessHandle        := #sWriteAccessTimeOffset.AccessHandle
                 ) <> READY then
      eModuleInitState := ERROR;
      LogError("@ZZZZ (AM221::AddAccesses) Adding write access for time offsets failed");
    end_if;
  end_if;
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::AI1TimeOffset::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if (FirmwareVersion >= AM221_FIRMWARE_VERSION_NEW_TIMING_AVAILABLE) & (AI_TimeOffset = TRUE) then
    if input >= AM221_TIME_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AM221_TIME_OFFSET_BEFORE_SYNC) then
      result := input;  
      AI1TimeOffset := result;
      sOutputValues.AI1_SP := AI1TimeOffset$UINT;      
    else
      result := AM221_TIME_OFFSET_STATE_INVALID_INPUT; // Invalid input parameter
    end_if;
  else
    result := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED; // Invalid firmwareversion, or feature inactive
  end_if;  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::AI2TimeOffset::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if (FirmwareVersion >= AM221_FIRMWARE_VERSION_NEW_TIMING_AVAILABLE) & (AI_TimeOffset = TRUE) then
    if input >= AM221_TIME_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AM221_TIME_OFFSET_BEFORE_SYNC) then
      result := input;  
      AI2TimeOffset := result;
      sOutputValues.AI2_SP := AI2TimeOffset$UINT;      
    else
      result := AM221_TIME_OFFSET_STATE_INVALID_INPUT; // Invalid input parameter
    end_if;
  else
    result := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED; // Invalid firmwareversion, or feature inactive
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::AO1TimeOffset::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if (FirmwareVersion >= AM221_FIRMWARE_VERSION_NEW_TIMING_AVAILABLE) & (AO_TimeOffset = TRUE) then
    if input >= AM221_TIME_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AM221_TIME_OFFSET_BEFORE_SYNC) then
      result := input;  
      AO1TimeOffset := result;
      sOutputValues.AO3_SP := AO1TimeOffset$UINT; // at HW AO1/2 is AO3/4    
    else
      result := AM221_TIME_OFFSET_STATE_INVALID_INPUT; // Invalid input parameter
    end_if;
  else
    result := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED; // Invalid firmwareversion, or feature inactive
  end_if;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL AM221::AO2TimeOffset::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  if (FirmwareVersion >= AM221_FIRMWARE_VERSION_NEW_TIMING_AVAILABLE) & (AO_TimeOffset = TRUE) then
    if input >= AM221_TIME_OFFSET_AFTER_SYNC & input <= ((udBusTime$DINT/1000) - AM221_TIME_OFFSET_BEFORE_SYNC) then
      result := input;  
      AO2TimeOffset := result;
      sOutputValues.AO4_SP := AO2TimeOffset$UINT; // at HW AO1/2 is AO3/4
    else
      result := AM221_TIME_OFFSET_STATE_INVALID_INPUT; // Invalid input parameter
    end_if;
  else
    result := AM221_TIME_OFFSET_STATE_NOT_SUPPORTED; // Invalid firmwareversion, or feature inactive
  end_if;  

END_FUNCTION

