//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "cmBase"
	Revision           = "1.0"
	GUID               = "{12988B22-1B65-4E1E-B270-CF3883724D4C}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(630,480)">
	<Channels>
		<Server Name="ClassSvr" GUID="{DD56CD04-CADE-4F40-BBBC-58A2FFB47B90}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="cmdHMI" GUID="{9D7C6750-3731-4185-B866-30987B8230C7}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ErrorNr" GUID="{E7C87617-9FD5-44DF-A4B1-6EF92A68837A}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="mode" GUID="{4920838A-DEAB-47EA-8730-C3298DBCBFFC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="state" GUID="{44673813-4751-40A2-9885-13C6399ADF84}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsHMI_RunsAllowed" GUID="{C111517C-3D8F-4AAE-8EAA-725259172902}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsInAlarm" GUID="{D88463AE-256F-4736-AE89-2B09B090FB02}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsIsInterlocked" GUID="{25CDDA60-5A5E-455E-8C0D-68DC17E12DA9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="_Alarm" Required="true" Internal="true"/>
		<Client Name="id" Required="false" Internal="false"/>
		<Client Name="nwEmOrUnit" Required="false" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="4"/>
		</Servers>
	</Separators>
	<RevDoku>
		<Owner Company="van Dulst" Author="JdK"/>
		<Dokumentation Revision="0.1" Date="2019-08-28" Author="JdK" Company="van Dulst" Description="always go to holding if in execute and errornr &gt; 0 and &lt; 100"/>
	</RevDoku>
	<Network Name="cmBase">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name           = "_Alarm"
				GUID           = "{28C9E53D-A6FB-4830-96BF-D8CA93851830}"
				Class          = "_AlarmX3ParaDer"
				Position       = "(90,630)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="AlarmActief"/>
					<Server Name="ClassSvr"/>
					<Server Name="ErrorNr"/>
					<Client Name="Acknow"/>
					<Client Name="Config" Value="0"/>
					<Client Name="Group"/>
					<Client Name="Para1"/>
					<Client Name="Para2"/>
					<Client Name="Para3"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this._Alarm" Destination="_Alarm.ClassSvr"/>
			<Connection Source="this.ErrorNr" Destination="_Alarm.ErrorNr" Vertices="(578,630),(406,840),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
cmBase : CLASS
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	state 	: SvrCh_eStatePML;
	mode 	: SvrCh_eModePML;
	cmdHMI 	: SvrCh_eHMI_CmdPML;
	stsInAlarm 	: SvrCh_DINT;
	stsIsInterlocked 	: SvrCh_DINT;
	stsHMI_RunsAllowed 	: SvrCh_DINT;
	ErrorNr 	: SvrCh_DINT;
  //Clients:
	nwEmOrUnit 	: CltChCmd_emBase;
	id 	: CltCh_DINT;
	_Alarm 	: CltChCmd__AlarmX3ParaDer;
  //Variables:
		pmlCom 	: strPmlCom;
		tmpReqMode 	: eModePML;
		tmpReqState 	: eStatePML;
		oldTmpReqState 	: eStatePML;
		tmpModeChange 	: DINT;
		oldCmdMode 	: eModePML;
		tmpResetAlarms 	: DINT;
		i 	: DINT;
		initDone 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL preScan;
	
	FUNCTION VIRTUAL postScan;
	
	FUNCTION VIRTUAL execHmiCmd1;
	
	FUNCTION VIRTUAL execHmiCmd2;
	
	FUNCTION VIRTUAL execHmiCmd3;
	
	FUNCTION VIRTUAL execHmiCmd4;
	
	FUNCTION giveAlarm
		VAR_INPUT
			errorNr 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL resetAlarm;
	
	FUNCTION VIRTUAL interlock;
	
	FUNCTION runTimer
		VAR_INPUT
			Active 	: DINT;
			iMem 	: strTimer;
			TimerTime 	: UDINT;
			Pause 	: DINT;
		END_VAR
		VAR_OUTPUT
			oMem 	: strTimer;
		END_VAR;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL execStart;
	
	FUNCTION VIRTUAL execStop;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL sendCommandsDown;
	
	FUNCTION VIRTUAL collectStatusUp;
	
	FUNCTION VIRTUAL stateControl;
	
	FUNCTION VIRTUAL setHMIAllowed;
	
	FUNCTION GLOBAL setPmlCmds
		VAR_INPUT
			setPmlCom 	: strPmlCom;
		END_VAR;
	
	FUNCTION GLOBAL cmdResetAlarm;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION VIRTUAL GLOBAL cmdHMI::Write
		VAR_INPUT
			input (EAX) 	: eHMI_CmdPML;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: eHMI_CmdPML;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorNr::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ErrorNr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _AlarmX3ParaDer
#pragma usingLtd emBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB cmBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CMBASE
1$UINT, 0$UINT, (SIZEOF(::cmBase))$UINT, 
8$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1325959504), "cmBase", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::cmBase.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::cmBase.state.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1422331979), "state", 
(::cmBase.mode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2707401247), "mode", 
(::cmBase.cmdHMI.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3091570423), "cmdHMI", 
(::cmBase.stsInAlarm.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3835074980), "stsInAlarm", 
(::cmBase.stsIsInterlocked.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1599066571), "stsIsInterlocked", 
(::cmBase.stsHMI_RunsAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2771631541), "stsHMI_RunsAllowed", 
(::cmBase.ErrorNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3474608145), "ErrorNr", 
//Clients:
(::cmBase.nwEmOrUnit.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1188868355), "nwEmOrUnit", TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, 
(::cmBase.id.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(299066170), "id", 
(::cmBase._Alarm.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(166947057), "_Alarm", TO_UDINT(763986700), "_AlarmX3ParaDer", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_cmBase 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_cmBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION cmBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_cmBase, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #preScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #postScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #execHmiCmd1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #execHmiCmd2();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #execHmiCmd3();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #execHmiCmd4();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #resetAlarm();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #interlock();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #execStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #execStop();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #sendCommandsDown();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #collectStatusUp();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #stateControl();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #setHMIAllowed();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	cmdHMI.pMeth			:= StoreMethod( #M_RD_DIRECT(), #cmdHMI::Write() );
	IF cmdHMI.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ErrorNr.pMeth			:= StoreMethod( #ErrorNr::Read(), #ErrorNr::Write() );
	IF ErrorNr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//JdK 28-8-2019: v1 if in execute and there is an alarm and errornr < 50 go to hold, if errornr >50 and <100 go to suspended

//JdK 17-5-2019: class cmBase created for MPS library and project Traffiroad 4284
// goal is to handle all basethings of a control module (last fb in row)
// cm just gets state information from above, mode can be changed here
// sts communication is given upwards, cmd communication is just taken
FUNCTION VIRTUAL GLOBAL cmBase::Init
  
  //on init tell software above you are alive, and give pointer to communication  
  IF pmlCom.Active=0 THEN //only if connection isn't working
    
    IF IsClientConnected(#nwEmOrUnit) THEN
      pmlCom.Active:=nwEmOrUnit.connectPtr(ptr:=#pmlCom, isEm:=0);
    END_IF;
    id:=id.Read();
   
  END_IF;
  Init1();
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL cmBase::cmdHMI::Write
	VAR_INPUT
		input (EAX) 	: eHMI_CmdPML;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: eHMI_CmdPML;
	END_VAR

	cmdHMI := input;
  IF pmlCom.sts.mode <> auto | cmdHMI = resetAlarms THEN
    CASE cmdHMI OF
    
    mdReqManual, mdReqAuto, mdReqHalfAuto, mdReqService, mdReqReserve:
      tmpReqMode:=(to_dint(cmdHMI)-1)$::eModePML; //mode in HMI command is one more then mode in enum, calculate and type cast to behind enum
      tmpModeChange:=1;
      
    start:
      IF stsHMI_RunsAllowed THEN
        execStart();
      END_IF;
      
    stop:
      IF stsHMI_RunsAllowed THEN
        execStop();
      END_IF;
      
    cmd1:
      IF stsHMI_RunsAllowed THEN
        execHmiCmd1();
      END_IF;
      
    cmd2:
      IF stsHMI_RunsAllowed THEN
        execHmiCmd2();
      END_IF;
      
    cmd3: 
      IF stsHMI_RunsAllowed THEN
        execHmiCmd3();
      END_IF;
      
    cmd4:
      IF stsHMI_RunsAllowed THEN
        execHmiCmd4();
      END_IF;
      
    resetAlarms:
      tmpResetAlarms:=1;
      
    stReqStart, stReqHold, stReqUnHold, stReqSuspend, stReqUnSuspend, stReqStop, stReqAbort, stReqClear, stReqReset:
      tmpReqState:= eHMI_CmdPML_TO_eStatePML(cmdHMI); //type cast to behind enum, this variable isn't used in the cm, but is in in the em's and units (they derive from here)

    END_CASE;

  END_IF;
  cmdHMI:=nul;
	result := cmdHMI;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmBase::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  preScan();
  stateControl();
  work();
  postScan();

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmBase::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

	state := READY;

END_FUNCTION


FUNCTION VIRTUAL cmBase::preScan

  //in prescan first change mode if required
  IF tmpModeChange=1 THEN   //means change mode from HMI 
    pmlCom.sts.mode:=tmpReqMode;
  ELSIF oldCmdMode<>pmlCom.cmd.mode THEN //means change mode from cmd
    pmlCom.sts.mode:=pmlCom.cmd.mode;
    oldCmdMode:=pmlCom.cmd.mode;
    tmpModeChange:=1; //save fact that mode did change, because we have to send it down then
  END_IF;
  
  //if required, reset alarms
  IF tmpResetAlarms | pmlCom.cmd.resetAlarms THEN
    resetAlarm();
  END_IF;
  
  //set interlock
  interlock();
  
  sendCommandsDown();
  
  setHMIAllowed();
  
  preScanOverride();
  

END_FUNCTION

FUNCTION VIRTUAL cmBase::postScan

  postScanOverride();

  //first set in alarm 
  pmlCom.sts.inAlarm:=_Alarm.AlarmActief;
  
  //set modesNotEqual to 0, for cm this is always 0
  pmlCom.sts.modesNotEqual:=0;
  
  collectStatusUp();
  

  //set data to servers to make it vissible
  state:=pmlCom.cmd.state;
  mode:=pmlCom.sts.mode;
  
  stsInAlarm:=pmlCom.sts.inAlarm;
  stsIsInterlocked:=pmlCom.sts.isInterlocked;

  //reset tmp's for prescan  
  tmpModeChange:=0; //only send change once  
  tmpResetAlarms:=0;
  pmlCom.cmd.resetAlarms:=0;  

END_FUNCTION

FUNCTION VIRTUAL cmBase::execHmiCmd1
//method to be derived if action is required
END_FUNCTION


FUNCTION VIRTUAL cmBase::execHmiCmd2
//method to be derived if action is required
END_FUNCTION


FUNCTION VIRTUAL cmBase::execHmiCmd3
//method to be derived if action is required
END_FUNCTION


FUNCTION VIRTUAL cmBase::execHmiCmd4
//method to be derived if action is required
END_FUNCTION


FUNCTION cmBase::giveAlarm
	VAR_INPUT
		errorNr 	: DINT;
	END_VAR

  IF _Alarm.AlarmActief=0 THEN
    _Alarm.ErrorNr.Write(input:=errorNr);
    _Alarm.AlarmActief.Write(input:=1);
  ELSIF errorNr < 50 & _Alarm.ErrorNr >= 50 | errorNr < 100 & _Alarm.ErrorNr >= 100 THEN //give new alarm if number is lower
    _Alarm.ErrorNr.Write(input:=0); //first reset
    _Alarm.AlarmActief.Write(input:=0);
    _Alarm.ErrorNr.Write(input:=errorNr);
    _Alarm.AlarmActief.Write(input:=1);
  END_IF;
  
  IF errorNr > 0 & errorNr < 50 & pmlCom.cmd.state= Execute THEN //means go to holding, but of course only from execute
    pmlCom.sts.stateReq.ID:= id;
    pmlCom.sts.stateReq.state:= Holding;  //holding because it's a machine failure
  ELSIF errorNr>= 50 & errorNr < 100 & pmlCom.cmd.state= Execute THEN //means go to suspending, because of alarms like magazin empty, belt full or other operator action required
    pmlCom.sts.stateReq.ID:= id;
    pmlCom.sts.stateReq.state:= Suspending; //suspending because something is expected from operators, or it's an external fault
  END_IF;    

END_FUNCTION


FUNCTION VIRTUAL cmBase::resetAlarm

  _Alarm.AlarmActief.Write(input:=0);
  _Alarm.ErrorNr.Write(input:=0);

END_FUNCTION


FUNCTION VIRTUAL cmBase::interlock
//see if interlock required, standard only take over interlock from above, else derive this method
pmlCom.sts.isInterlocked:=pmlCom.cmd.interlock;
END_FUNCTION


FUNCTION cmBase::runTimer
	VAR_INPUT
		Active 	: DINT;
		iMem 	: strTimer;
		TimerTime 	: UDINT;
		Pause 	: DINT;
	END_VAR
	VAR_OUTPUT
		oMem 	: strTimer;
	END_VAR
  VAR
  	Mem : strTimer;
  END_VAR

  Mem:=iMem;

  IF Active = 1 & Pause = 0 THEN
    Mem.tmpTime+=(ops.tAbsolute-Mem.lastTime); //if active and not paused, count difference act time and last time to it
    IF Mem.tmpTime >= TimerTime THEN
      Mem.Done:=1;
      Mem.tmpTime:=TimerTime;
    ELSE
      Mem.Done:=0;
    END_IF;
  ELSIF Active = 0 THEN
    Mem.tmpTime := 0; //if not active, reset
    Mem.Done:=0;
  END_IF;
  Mem.lastTime:=ops.tAbsolute;
 
  oMem := Mem; 
  
END_FUNCTION





FUNCTION VIRTUAL cmBase::work
//method to do the cyclic things in the real class
END_FUNCTION


FUNCTION VIRTUAL cmBase::execStart

END_FUNCTION


FUNCTION VIRTUAL cmBase::execStop

END_FUNCTION


FUNCTION VIRTUAL cmBase::Init1

END_FUNCTION


FUNCTION VIRTUAL cmBase::sendCommandsDown
//only neccesary for em's and units, but they use cmBase as a base
END_FUNCTION


FUNCTION VIRTUAL cmBase::stateControl
//only neccesary for em's and units, but they use cmBase as a base
END_FUNCTION


FUNCTION VIRTUAL cmBase::collectStatusUp
//only neccesary for em's and units, but they use cmBase as a base
END_FUNCTION


FUNCTION VIRTUAL cmBase::setHMIAllowed

//hmi movementcommands are only allowed if unit is in idle, or held or suspended, if other states should be allowed overwrite this method

  CASE pmlCom.cmd.state OF
  
    Idle, Held, Suspended:
      stsHMI_RunsAllowed:=1;
      
    else
      stsHMI_RunsAllowed:=0;
  
  END_CASE;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmBase::ErrorNr::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	ErrorNr := _Alarm.ErrorNr.Read();
	output := ErrorNr;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmBase::ErrorNr::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	ErrorNr := input;
	result := (_Alarm.ErrorNr.Write(ErrorNr))$DINT;

END_FUNCTION


FUNCTION GLOBAL cmBase::setPmlCmds
	VAR_INPUT
		setPmlCom 	: strPmlCom;
	END_VAR
  //for cm's under cm, only do something with commands
  pmlCom.cmd.interlock:=setPmlCom.cmd.interlock;
  pmlCom.cmd.mode:=setPmlCom.cmd.mode;
  pmlCom.cmd.state:=setPmlCom.cmd.state;
  pmlCom.cmd.simulation:=setPmlCom.cmd.simulation;
  pmlCom.cmd.reRun:=setPmlCom.cmd.reRun;
  pmlCom.cmd.resetAlarms:=setPmlCom.cmd.resetAlarms;
  
  
END_FUNCTION


FUNCTION GLOBAL cmBase::cmdResetAlarm

  tmpResetAlarms:=1;

END_FUNCTION


FUNCTION VIRTUAL cmBase::preScanOverride
//just to run pre and post scan in class above on behind moment
END_FUNCTION


FUNCTION VIRTUAL cmBase::postScanOverride
//just to run pre and post scan in class above on behind moment
END_FUNCTION
