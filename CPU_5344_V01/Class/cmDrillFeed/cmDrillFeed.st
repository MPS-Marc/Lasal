//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "cmDrillFeed"
	Revision           = "0.0"
	GUID               = "{037C5819-D97A-4F68-9049-D7C731C69BAA}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "500 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(480,840)">
	<Channels>
		<Server Name="parPosBack" GUID="{9093994F-01FB-48E9-8137-FDF2C4979A4E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="parTimeBetweenBackAndStop" GUID="{4E0D9AF6-A68A-4D39-B77F-578D8F122A09}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="parTimeBetweenFwdAndBackSkip" GUID="{E96015D4-1C04-4484-A805-C5F1C997AC14}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="parTimeOutTime" GUID="{EC3C0BBF-EC85-415F-9622-C7E74A20D0FB}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="stsBeenFwd" GUID="{4A1C921A-152A-4B37-A655-9AE73E51249F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsPos" GUID="{F6DDD1F8-2EDC-4C04-95E2-E51E28DF5F61}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="actual position of cilinder"/>
		<Server Name="stsStopBackAtHalf" GUID="{9AF98218-FF60-4B2B-86D8-3C5E07393A1B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="iFwdPos" Required="true" Internal="false"/>
		<Client Name="iLivePos" Required="true" Internal="false" Comment="optional actual pos to check with"/>
		<Client Name="iSafeBackPos" Required="true" Internal="false"/>
		<Client Name="iStartFeedPos" Required="true" Internal="false"/>
		<Client Name="iValuesOk" Required="true" Internal="false"/>
		<Client Name="oFeed" Required="true" Internal="false" Comment="optional output for position in"/>
		<Client Name="oSkipValve" Required="true" Internal="false" Comment="optional output for position out"/>
		<Client Name="oStopValve" Required="true" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
			<SepChn Position="4"/>
		</Servers>
	</Separators>
	<Network Name="cmDrillFeed">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{D9694212-6F6B-4D9C-BCC5-2F2AB28D6A7E}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

cmDrillFeed : CLASS
: cmBase
  //Servers:
	stsPos 	: SvrCh_feedPos;
	stsBeenFwd 	: SvrCh_DINT;
	stsStopBackAtHalf 	: SvrCh_DINT;
	parTimeOutTime 	: SvrCh_UDINT;
	parTimeBetweenFwdAndBackSkip 	: SvrCh_UDINT;
	parTimeBetweenBackAndStop 	: SvrCh_UDINT;
	parPosBack 	: SvrCh_DINT;
  //Clients:
	oFeed 	: CltCh_DINT;
	oSkipValve 	: CltCh_DINT;
	oStopValve 	: CltCh_DINT;
	iLivePos 	: CltCh_DINT;
	iStartFeedPos 	: CltCh_DINT;
	iFwdPos 	: CltCh_DINT;
	iSafeBackPos 	: CltCh_DINT;
	iValuesOk 	: CltCh_DINT;
  //Variables:
		timeOutTimer 	: strTimer;
		timerFwdAndSkip 	: strTimer;
		stopTimer 	: strTimer;
		oldStsPos 	: feedPos;
		oldMode 	: eModePML;
  //Functions:
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL execStart;
	
	FUNCTION VIRTUAL execStop;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION startMovement
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION stopMovement;
	
	FUNCTION GLOBAL csStartMovement
		VAR_INPUT
			goBackHalf 	: DINT;
		END_VAR
		VAR_OUTPUT
			ok 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL csStopMovement;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB cmDrillFeed::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CMDRILLFEED
0$UINT, 0$UINT, (SIZEOF(::cmDrillFeed))$UINT, 
7$UINT, 8$UINT, 0$UINT, 
TO_UDINT(3683638612), "cmDrillFeed", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::cmDrillFeed.stsPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3335286665), "stsPos", 
(::cmDrillFeed.stsBeenFwd.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3527084466), "stsBeenFwd", 
(::cmDrillFeed.stsStopBackAtHalf.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2891644163), "stsStopBackAtHalf", 
(::cmDrillFeed.parTimeOutTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(4183149504), "parTimeOutTime", 
(::cmDrillFeed.parTimeBetweenFwdAndBackSkip.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(264755214), "parTimeBetweenFwdAndBackSkip", 
(::cmDrillFeed.parTimeBetweenBackAndStop.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3726465980), "parTimeBetweenBackAndStop", 
(::cmDrillFeed.parPosBack.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1543707211), "parPosBack", 
//Clients:
(::cmDrillFeed.oFeed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(672157318), "oFeed", 
(::cmDrillFeed.oSkipValve.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1763873108), "oSkipValve", 
(::cmDrillFeed.oStopValve.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2942928873), "oStopValve", 
(::cmDrillFeed.iLivePos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(178957654), "iLivePos", 
(::cmDrillFeed.iStartFeedPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1598733618), "iStartFeedPos", 
(::cmDrillFeed.iFwdPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3800344352), "iFwdPos", 
(::cmDrillFeed.iSafeBackPos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(656873401), "iSafeBackPos", 
(::cmDrillFeed.iValuesOk.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(968580326), "iValuesOk", 
END_FUNCTION


#define USER_CNT_cmDrillFeed 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_cmDrillFeed] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION cmDrillFeed::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_cmDrillFeed;
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #execStart();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #execStop();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stsPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsStopBackAtHalf.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stsStopBackAtHalf.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeOutTime.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeOutTime.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeBetweenFwdAndBackSkip.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeBetweenFwdAndBackSkip.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeBetweenBackAndStop.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeBetweenBackAndStop.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parPosBack.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parPosBack.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 11-6-2019 class drillfeed, created for library icm project 4284 TraffiRoad 
// goal is to control a special drill movement, for this movement we have 3 outputs,
// we have a stopvalve, this one has to be active if we move forward,
// there is a feedvalve, this one is active if moving forward, but also if we have to hold the movement before it's complete back
// and there is a skipvalve, this one is active if we move fast forward, and also if we move back

// only possible movements we have are going forward, then go back complete and going forward and go back until certain value
// in manual mode we always go back complete

// during a interlock state is going back to unknown, this means no active outputs, after a certain time unkown state changes to back
// also if mode changes from auto to manual vice versa, stop movement by going to unkown

// alarms:  1: time-out
//          2: moved from complete back
//          3: no valid values during start

FUNCTION VIRTUAL cmDrillFeed::work

  IF pmlCom.sts.isInterlocked= 1 & stsPos<> fdUnKnown & stsPos<> fdCompleteBack THEN
    stsPos:= fdUnKnown;
  END_IF;
  IF ((pmlCom.sts.mode = auto & (oldMode = manual | oldMode = halfAuto)) | //stop movement if mode changes
      ((pmlCom.sts.mode = manual | pmlCom.sts.mode = halfAuto) & oldMode = auto)) & (stsPos<> fdUnKnown & stsPos<> fdCompleteBack) THEN
    stsPos:= fdUnKnown;
  END_IF;

  oldMode:= pmlCom.sts.mode;


  CASE stsPos OF
  
  fdUnKnown: //just wait for command, change to complete back if position tells we are complete back
    IF iLivePos >= parPosBack THEN
      stsPos:=fdCompleteBack;
    END_IF;
    
  fdCompleteBack: //just wait for command, change to unkown if position tells we are not complete back
    IF iLivePos < parPosBack THEN
      giveAlarm(errorNr:=2);
      stsPos:=fdUnKnown;
    END_IF;
    
  fdMovingFastFwd: //go fast until right pos
    IF iLivePos <= iStartFeedPos THEN
      stsPos:= fdMovingFwd;
    END_IF;
    oFeed:=1;
    oStopValve:=1;
    oSkipValve:=1;
    
  fdMovingFwd: //go fwd until arrived
    IF iLivePos <= iFwdPos THEN
      stsBeenFwd:= 1;
      stsPos:= fdMovingBack;
    END_IF;
    oFeed:=1;
    oStopValve:=1;
    
  fdMovingBack: //go back
    IF stsStopBackAtHalf= 1 & iLivePos >= iSafeBackPos THEN
      stsPos:= fdWaitStopBack;
    ELSIF stsStopBackAtHalf= 0 & iLivePos >= parPosBack THEN
      stsPos:= fdCompleteBack;
    END_IF;
    IF timerFwdAndSkip.done= 1 THEN
      oSkipValve:= 1;
    END_IF;
    
  fdWaitStopBack: //wait some time before we really can stop the movement
    IF stopTimer.done= 1 THEN
      stsPos:= fdStopBack;
    END_IF;
    
  fdStopBack: //stop in the middle of a movement, in this way the tool is close to the material
    oFeed:=1;
    IF iLivePos >= parPosBack THEN //if state changed in real, also change state in stsPos
      stsPos:=fdCompleteBack;
    END_IF;
  
  END_CASE;

END_FUNCTION


FUNCTION cmDrillFeed::startMovement
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR

  ok:=0;
  IF stsPos= fdStopBack & iLivePos < iStartFeedPos THEN //tool already close to material, start moving fwd slow
    stsBeenFwd:= 0;
    stsPos:= fdMovingFwd;
    ok:=1;
  ELSIF stsPos= fdCompleteBack | (stsPos= fdStopBack & iLivePos >= iStartFeedPos) THEN //only possible to start movement if drill at stop back, or at complete back
    stsBeenFwd:= 0;
    stsPos:= fdMovingFastFwd;
    ok:=1;
  END_IF;
  
END_FUNCTION


FUNCTION cmDrillFeed::stopMovement
  
  IF stsPos <> fdCompleteBack & stsPos <> fdUnKnown THEN
    stsStopBackAtHalf:=0;
    stsPos:=fdMovingBack;
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL cmDrillFeed::execStart

  IF (pmlCom.sts.mode= manual | pmlCom.sts.mode=service) & iValuesOk=1 THEN
    //JdK 26-7-2019 for test stsStopBackAtHalf:=0; //in manual mode always go back complete
    startMovement();
  ELSIF iValuesOk= 0 THEN
    giveAlarm(errorNr:=3);
  END_IF;
    

END_FUNCTION


FUNCTION VIRTUAL cmDrillFeed::execStop

  IF pmlCom.sts.mode= manual | pmlCom.sts.mode= service THEN
    stopMovement();
  END_IF;

END_FUNCTION


FUNCTION GLOBAL cmDrillFeed::csStartMovement
	VAR_INPUT
		goBackHalf 	: DINT;
	END_VAR
	VAR_OUTPUT
		ok 	: DINT;
	END_VAR
  
  ok:=0;
  IF pmlCom.sts.mode=auto | pmlCom.sts.mode=service THEN
    IF (stsPos = fdCompleteBack | stsPos = fdStopBack) & iValuesOk=1 THEN
      stsStopBackAtHalf:=goBackHalf;
      ok:=startMovement();
    ELSIF iValuesOk= 0 THEN
      giveAlarm(errorNr:=3);
    END_IF;
  END_IF;
  
END_FUNCTION


FUNCTION GLOBAL cmDrillFeed::csStopMovement

  IF pmlCom.sts.mode= auto | pmlCom.sts.mode=service THEN
    stopMovement();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmDrillFeed::preScanOverride
//preScan reads in al values before handling the actions

  //first read in all values
  iValuesOk := iValuesOk.Read();
  IF iValuesOk= 1 & stsPos <> fdMovingFwd & stsPos <> fdMovingFastFwd & stsPos <> fdMovingBack & stsPos <> fdWaitStopBack THEN //only reed in if nog drilling is active
    iStartFeedPos := iStartFeedPos.Read();
    iFwdPos := iFwdPos.Read();
    iSafeBackPos := iSafeBackPos.Read();
  END_IF;
  
  
  //then call timers
  timeOutTimer:=runTimer(Active:=(stsPos=oldStsPos & stsPos <> fdUnKnown & stsPos <> fdStopBack & stsPos <> fdCompleteBack), 
                                                                           iMem:=timeOutTimer, TimerTime:=parTimeOutTime, Pause:=FALSE);
  stopTimer:=runTimer(Active:=stsPos=fdWaitStopBack, iMem:=stopTimer, TimerTime:=parTimeBetweenBackAndStop, Pause:=FALSE);
  
  timerFwdAndSkip:=runTimer(Active:=stsPos=fdMovingBack, iMem:=timerFwdAndSkip, TimerTime:=parTimeBetweenFwdAndBackSkip, Pause:=FALSE);
  
  oldStsPos:=stsPos;
  
  //every cycle set outputs to 0, set them again if asked
  oFeed:=0;
  oSkipValve:=0;
  oStopValve:=0;
  
  IF pmlCom.cmd.simulation = allSimu THEN
    CASE stsPos OF
    
    fdMovingFastFwd:
      iLivePos:=iLivePos-10;
      
    fdMovingFwd:
      iLivePos:=iLivePos-1;
      
    fdMovingBack:
      iLivePos:=iLivePos+10;
    
    END_CASE;

    iLivePos.Write(input:=iLivePos);
  ELSE
    iLivePos:=iLivePos.Read();
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmDrillFeed::postScanOverride

  //write outputs
  oFeed.Write(input:=oFeed);
  oSkipValve.Write(input:=oSkipValve);
  oStopValve.Write(input:=oStopValve);
  
  //check alarmstatus
  IF _Alarm.AlarmActief THEN
    stsInAlarm:=1;
  ELSE
    stsInAlarm:=0;
  END_IF;

END_FUNCTION
