//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#ifndef _T_CSI022_H
#define _T_CSI022_H

#define CSIKennung                  16#14
#define CSI021Variante              16#01
#define CSI022Variante              16#02
#define CSI023Variante              16#03
#define CSI025Variante              16#04

#define	CSI022_APORT1	              16#00
#define	CSI022_APORT2	              16#08
#define	CSI022_APORT3	              16#10
#define	CSI022_APORT4	              16#18

//Register Offsets of Controller
#define ReceiverBufferOffset        16#00   //Read only; to access set DLAB = 0
#define TransmitterHoldingOffset    16#00   //Write only;  to access set DLAB = 0
#define IRQEnableOffset             16#01   //to access set DLAB = 0
#define IRQIdentOffset              16#02   //Read only
#define FIFOControlOffset           16#02   //Write only
#define LineControlOffset           16#03
#define ModemControlOffset          16#04
#define LineStatusOffset            16#05
#define ModemStatusOffset           16#06
#define ScratchOffset               16#07
#define DivisorLatchLSOffset        16#00   //to access set DLAB = 1
#define DivisorLatchMSOffset        16#01   //to access set DLAB = 1
#define AlternateFunctionOffset     16#02   //to access set DLAB = 1

//Register Offsets of Module
#define ModeSelectOffset            16#20
#define IRQModule                   16#F0

//Parameter
#define Parity_None                 2#00000000  
#define Parity_Odd                  2#00001000  
#define Parity_Even                 2#00011000 
#define Parity_Mark                 2#00101000 
#define Parity_Space                2#00111000

//Modes of Operation
#define RS232                       2#00
#define RS422                       2#01    
#define RS485                       2#11

//FifoIRQ Trigger Level
#define TriggerLevelHigh            2#11000111
#define TriggerLevelLow             2#00000111

//IRQIdentifier
#define IRQModemStatus                 2#000
#define IRQTransmitterHoldingEmpty     2#001
#define IRQReceivedDataAvailable       2#010
#define IRQReceiverLineStatus          2#011
#define IRQCharacterTimeoutIndication  2#110

#endif // _T_CSI022_H
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "CSI022_Base"
	Revision           = "2.46"
	GUID               = "{99BE2691-B100-4084-B8E7-C3CBB795A67C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\CSI022_Base\tool.ICO"
	SharedCommandTable = "true"
	Objectsize         = "(452,120)">
	<Channels>
		<Client Name="Com1_IRQ" Required="false" Internal="false" Comment="Client increments with every IRQ on Port.&#13;&#10;Write Methode of connected Client is called, when RX-Data is available. Input-Variable is Pointer to the RX-Buffer."/>
		<Client Name="Com2_IRQ" Required="false" Internal="false" Comment="Client increments with every IRQ on Port.&#13;&#10;Write Methode of connected Client is called, when RX-Data is available. Input-Variable is Pointer to the RX-Buffer."/>
		<Client Name="Com3_IRQ" Required="false" Internal="false" Comment="Client increments with every IRQ on Port.&#13;&#10;Write Methode of connected Client is called, when RX-Data is available. Input-Variable is Pointer to the RX-Buffer."/>
		<Client Name="Com4_IRQ" Required="false" Internal="false" Comment="Client increments with every IRQ on Port.&#13;&#10;Write Methode of connected Client is called, when RX-Data is available. Input-Variable is Pointer to the RX-Buffer."/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Source\interfaces\lsl_st_serial.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="ObeChr"/>
		<Dokumentation Revision="2.46" Date="06.03.2018" Author="EisMic" Company="Sigmatek" Description="Attached header files no longer point to the installation directory of LASAL but instead now point to the the source/interfaces folder."/>
		<Dokumentation Revision="2.45" Date="07.02.2017" Author="EisMic" Company="Sigmatek" Description="Corrected access exception if e.g. StartUser method is called and module is deactivated."/>
		<Dokumentation Revision="2.44" Date="11.05.2016" Author="RamAnd" Company="Sigmatek" Description="Suppressed warning that would occur with target ARM on compiler version 30 or higher."/>
		<Dokumentation Revision="2.43" Date="29.07.2014" Author="LanSte" Company="Sigmatek" Description="Added Support for reading hardware diagnose and hardwaretree entry."/>
		<Dokumentation Revision="2.42" Date="10.07.2014" Author="ZoePat" Company="Sigmatek" Description="The retcode of RTSOnOff(), DTROnOff(), ClearRecvBuffer(), SetRcvBuffer() and CloseCom() was not set, if the function was ok."/>
		<Dokumentation Revision="2.41" Date="08.05.2014&#13;&#10;14.05.2014" Author="EisMic" Company="Sigmatek" Description="Returned ErrorCode in Method SetMode for not supported modes.&#13;&#10;Corrected the calculation of how many bytes are in buffer in method GetSendStatus."/>
		<Dokumentation Revision="2.40" Date="06.12.2013" Author="LanSte" Company="Sigmatek" Description="CLI/STI deactivated for ARM"/>
		<Dokumentation Revision="2.30" Date="30.08.2013" Author="EisMic" Company="Sigmatek" Description="Added serial number display"/>
		<Dokumentation Revision="2.20" Date="18.07.2013" Author="ZoePat" Company="Sigmatek" Description="Corrected wrong data access at readout of receive data. (Could lead to loss of data on com2)"/>
		<Dokumentation Revision="2.10" Date="06.03.2013" Author="BeiWol" Company="Sigmatek" Description="Added functionality to use module optional via define DEACTIVATED_LSL as Place value."/>
		<Dokumentation Revision="2.7" Date="28.06.2012" Author="ObeChr" Company="Sigmatek" Description="rdDTR with Port 4 was not possible&#13;&#10;Returncode of Methode GetInfo() was incorrect if the method succeeded&#13;&#10;Avoid of Endlessloop in Methode SetMode() if the UART Chip was not responding"/>
		<Dokumentation Revision="2.6" Date="12.09.2011" Author="RamAnd" Company="Sigmatek" Description="A timeout surveillance has been added to send mechanism. If a timeout on sending has been detected GetError() returns -20 (SERERROR_SENDERROR). If a new sending process is started, the error will be quit by reinitializing the send buffer. This error appeared only, if at least 2 interfaces were used."/>
		<Dokumentation Revision="2.5" Date="22.07.2010" Author="WocPet" Company="Sigmatek" Description="Changes in base class: new client &quot;Required&quot; added"/>
		<Dokumentation Revision="2.4" Date="16.06.2010" Author="RamAnd / BleErn" Company="Sigmatek" Description="Corrected return value of method GetLastError.&#13;&#10;Fixed error in method RecvChar: wrong com-number was used."/>
		<Dokumentation Revision="2.3" Date="17.05.2010" Author="RamAnd" Company="Sigmatek" Description="Changed defines to avoid compiler warning &quot;Identical Redefinition&quot;"/>
		<Dokumentation Revision="2.2" Date="29.01.2010" Author="BleErn" Company="Sigmatek" Description="Fixed possible problem with initialisation of Com2 if Com3 or Com4 are used."/>
		<Dokumentation Revision="2.1" Date="26.01.2010" Author="BleErn" Company="Sigmatek" Description="Fixed problems with new RS485 Handling"/>
		<Dokumentation Revision="2.0" Date="02.12.2009" Author="ObeChr / BleErn" Company="Sigmatek" Description="Class has been completely reworked due to lack of transperancy.&#13;&#10;Problems with RS485Mode have been fixed"/>
	</RevDoku>
	<Network Name="CSI022_Base">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{4F01E40D-5A4E-40CC-B455-603E04545B37}"
				Class      = "HwBaseCDIAS"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="SerialNo"/>
					<Server Name="State"/>
					<Client Name="MasterConnect"/>
					<Client Name="Place"/>
					<Client Name="Required"/>
					<Client Name="TimeBase" Value="0"/>
					<Client Name="TimeBaseOffset" Value="0"/>
					<Client Name="To_StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.State" Destination="_base.State" Vertices="(690,210),(518,210),"/>
			<Connection Source="_base.MasterConnect" Destination="this.MasterConnect" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(690,270),(518,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using HwBaseCDIAS

CSI022_Base : CLASS
: HwBaseCDIAS
	TYPE
	  t_Register : BSINT
	  [
	    1 DataBit0,
	    2 DataBit1,
	    3 DataBit2,
	    4 DataBit3,
	    5 DataBit4,
	    6 DataBit5,
	    7 DataBit6,
	    8 DataBit7,
	  ];
	  t_IRQEnable : BSINT  //! <Type Comment="Interrupt Enable Register" Name="t_IRQEnable"/>
	  [
	    1 ReceivedDataAvail,
	    2 TransmitterHolding,
	    3 ReceiverLineStatus,
	    4 ModemStatus,
	  ];
	  t_IRQIdent : BSINT  //! <Type Comment="Interrupt Indentifier Register" Name="t_IRQIdent"/>
	  [
	    1 IRQPending,
	    2 IRQIdent1,
	    3 IRQIdent2,
	    4 IRQIdent3,  //! <Type Comment="This bit os always 0 in the 16450 Mode" Name="t_IRQIdent.IRQIdent3"/>
	    7 FifoEnabled1,  //! <Type Comment="This bit os always 0 in the 16450 Mode" Name="t_IRQIdent.FifoEnabled1"/>
	    8 FifoEnabled2,  //! <Type Comment="This bit os always 0 in the 16450 Mode" Name="t_IRQIdent.FifoEnabled2"/>
	  ];
	  t_FIFOControl : BSINT  //! <Type Comment="FIFO Control Register" Name="t_FIFOControl"/>
	  [
	    1 FifoEnable,
	    2 RCVRFifoReset,
	    3 XMITFifoReset,
	    4 DMAModeSelect,
	    7 RCVRTriggerLSB,
	    8 RCVRTriggerMSB,
	  ];
	  t_LineControl : BSINT  //! <Type Comment="Line Control Register" Name="t_LineControl"/>
	  [
	    1 WordLength1,
	    2 WordLength2,
	    3 NumberStopBits,
	    4 ParityEnable,
	    5 EvenParitySelect,
	    6 StickParity,
	    7 SetBreak,
	    8 DLAB,
	  ];
	  t_ModemControl : BSINT  //! <Type Comment="Modem Control Register" Name="t_ModemControl"/>
	  [
	    1 DataTerminalReady,
	    2 RequestToSend,
	    3 Out1,
	    4 Out2,
	    5 Loop,
	  ];
	  t_LineStatus : BSINT  //! <Type Comment="Line Status Register" Name="t_LineStatus"/>
	  [
	    1 DataReady,
	    2 OverrunError,
	    3 ParityError,
	    4 FramingError,
	    5 BreakIRQ,
	    6 TransmitterHolding,
	    7 TransmitterEmpty,
	    8 ErrorRCVRFifo,
	  ];
	  t_ModemStatus : BSINT  //! <Type Comment="Modem Status Register" Name="t_ModemStatus"/>
	  [
	    1 DeltaClearToSend,
	    2 DeltaDataSetReady,
	    3 TrailingEdgeRingIndicator,
	    4 DeltaDataCarrierDetect,
	    5 ClearToSend,
	    6 DataSetReady,
	    7 RingIndicator,
	    8 DataCarrierDetect,
	  ];
	  t_AlternateFunction : BSINT  //! <Type Comment="Alternate Function Register" Name="t_AlternateFunction"/>
	  [
	    1 ConcurrentWrite,
	    2 BaudoutSelect,
	    3 RXRDYSelect,
	  ];
#pragma pack(push, 1)
	  t_fifo : STRUCT  //! <Type Public="true" Name="t_fifo"/>
	    Index : UDINT;
	    StartPtr : ^USINT;
	    ActPtr : ^USINT;
	    PtrNextFree : ^USINT;
	    EndOfBuffer : ^USINT;
	    Buffer : ARRAY [0..511] OF USINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_port : STRUCT
	    Register : STRUCT
	      ReceiverBuffer : ^t_Register;  //! <Type Comment="DLAB = 0, Read only" Name="t_port.Register.ReceiverBuffer"/>
	      TransmitterHolding : ^t_Register;  //! <Type Comment="DLAB = 0, Write only" Name="t_port.Register.TransmitterHolding"/>
	      IRQEnable : ^t_IRQEnable;  //! <Type Comment="DLAB = 0" Name="t_port.Register.IRQEnable"/>
	      IRQIdent : ^t_IRQIdent;
	      FIFOControl : ^t_FIFOControl;
	      LineControl : ^t_LineControl;
	      ModemControl : ^t_ModemControl;
	      LineStatus : ^t_LineStatus;
	      ModemStatus : ^t_ModemStatus;
	      Scratch : ^t_Register;
	      DivisorLatchLS : ^t_Register;  //! <Type Comment="DLAB = 1" Name="t_port.Register.DivisorLatchLS"/>
	      DivisorLatchMS : ^t_Register;  //! <Type Comment="DLAB = 1" Name="t_port.Register.DivisorLatchMS"/>
	      AlternateFunctionRegister : ^t_AlternateFunction;  //! <Type Comment="DLAB = 1" Name="t_port.Register.AlternateFunctionRegister"/>
	    END_STRUCT;
	    Info : LSLAPI_SERIALINFO;
	    Mode : DINT;
	    ActError : DINT;
	    TXBuffer : t_fifo;
	    RXBuffer : t_fifo;
	    IRQCount : UDINT;
	    RXDataAvailable : BOOL;
	    WordLength : UDINT;
	    LastSendTime : UDINT;
	    SendTimeOut : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  pt_port : ^t_port;
#pragma pack(push, 1)
	  t_portpointer : STRUCT
	    Com0 : ^DINT;  //! <Type Comment="Dummy" Name="t_portpointer.Com0"/>
	    Com1 : ^t_port;
	    Com2 : ^t_port;
	    Com3 : ^t_port;
	    Com4 : ^t_port;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
  //Clients:
	Com1_IRQ 	: CltCh_DINT;
	Com2_IRQ 	: CltCh_DINT;
	Com3_IRQ 	: CltCh_DINT;
	Com4_IRQ 	: CltCh_DINT;
  //Variables:
		InitRun 	: USINT;
		MyPlace 	: UDINT;
		HWOk 	: BOOL;
		Port : ARRAY [0..3] OF t_port;

		ModeBits : BSINT
		[
		];

		GotIRQ 	: BOOL;
		IRQIdent : BSINT
		[
		];

		IRQ1Connected 	: DINT;
		IRQ2Connected 	: DINT;
		IRQ3Connected 	: DINT;
		IRQ4Connected 	: DINT;
		Port1RXBuffer 	: DINT;
		Port2RXBuffer 	: DINT;
		Port3RXBuffer 	: DINT;
		Port4RXBuffer 	: DINT;
		Profiler 	: s_PROFILER_Time;
		PortPointer 	: t_portpointer;
		pPortPointer 	: ^t_portpointer;
		CSIVariante 	: DINT;
  //Functions:
				//! <Function Comment="Init-Methode of Class" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="This method returns the variante/kennung of the module.&#13;&#10;Has to be overwritten in every module." Name="GetKennung"/>
	FUNCTION VIRTUAL GetKennung
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
				//! <Function Comment="Methode, to check Variante of Module" Name="GetVariante"/>
	FUNCTION VIRTUAL GLOBAL GetVariante
		VAR_OUTPUT
			Ok 	: BOOL;
		END_VAR;
	
	FUNCTION IRQMethodCDIAS;
	
	FUNCTION InitCom
		VAR_INPUT
			Com 	: USINT;
			Baud 	: DINT;
			Wordl 	: DINT;
			Parity 	: DINT;
			Stopb 	: DINT;
			FiFo 	: DINT;
		END_VAR;
	
	FUNCTION TAB BaudTable;
				//! <Function Comment="Returns Info about State of Com" Name="IsInitialized"/>
	FUNCTION GLOBAL IsInitialized
		VAR_INPUT
			Com 	: DINT;
		END_VAR
		VAR_OUTPUT
			Ok 	: DINT;			//! <Variable Comment="-1 = port not available" Name="IsInitialized.Ok"/>
		END_VAR;
				//! <Function Comment="Methode to switch On/Off RTS" Name="RTSOnOff"/>
	FUNCTION GLOBAL RTSOnOff
		VAR_INPUT
			Com 	: USINT;			//! <Variable Comment="Select Com 0-3" Name="RTSOnOff.Com"/>
			State 	: BOOL;			//! <Variable Comment="TRUE = Set RTS&#13;&#10;FALSE = Reset RTS" Name="RTSOnOff.State"/>
		END_VAR
		VAR_OUTPUT
			retValue 	: DINT;			//! <Variable Comment="-1 = port not available&#13;&#10;-2 = port not initialized" Name="RTSOnOff.retValue"/>
		END_VAR;
				//! <Function Comment="Methode to switch On/Off RTS" Name="DTROnOff"/>
	FUNCTION GLOBAL DTROnOff
		VAR_INPUT
			Com 	: USINT;			//! <Variable Comment="Select Com 0-3" Name="DTROnOff.Com"/>
			State 	: BOOL;			//! <Variable Comment="TRUE = Set DTR&#13;&#10;FALSE = Reset DTR" Name="DTROnOff.State"/>
		END_VAR
		VAR_OUTPUT
			retValue 	: DINT;			//! <Variable Comment="-1 = port not available&#13;&#10;-2 = port not initialized" Name="DTROnOff.retValue"/>
		END_VAR;
				//! <Function Comment="Returns State of RTS" Name="rdRTS"/>
	FUNCTION GLOBAL rdRTS
		VAR_INPUT
			Com 	: USINT;			//! <Variable Comment="Select Com 1-4" Name="rdRTS.Com"/>
		END_VAR
		VAR_OUTPUT
			State 	: BOOL;			//! <Variable Comment="State of RTS" Name="rdRTS.State"/>
		END_VAR;
				//! <Function Comment="Returns State of DTR" Name="rdDTR"/>
	FUNCTION GLOBAL rdDTR
		VAR_INPUT
			Com 	: USINT;
		END_VAR
		VAR_OUTPUT
			State 	: BOOL;
		END_VAR;
				//! <Function Comment="Returns State of CTS" Name="rdCTS"/>
	FUNCTION GLOBAL rdCTS
		VAR_INPUT
			Com 	: USINT;
		END_VAR
		VAR_OUTPUT
			State 	: BOOL;
		END_VAR;
				//! <Function Comment="Inits Com with Parameter-Values" Name="StartUser"/>
	FUNCTION GLOBAL StartUser
		VAR_INPUT
			Com 	: USINT;
			Baud 	: DINT;
			Wordl 	: DINT;
			Parity 	: DINT;
			StopB 	: DINT;
			FifoOnOff 	: DINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
				//! <Function Comment="Set RS-Mode of Com" Name="SetMode"/>
	FUNCTION GLOBAL SetMode
		VAR_INPUT
			Com 	: USINT;
			Mode 	: DINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
				//! <Function Comment="Methode to Close Com" Name="CloseCom"/>
	FUNCTION GLOBAL CloseCom
		VAR_INPUT
			Com 	: DINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
				//! <Function Comment="Get Infos about Com" Name="GetInfo"/>
	FUNCTION GLOBAL GetInfo
		VAR_INPUT
			Com 	: DINT;
			Info 	: ^LSLAPI_SERIALINFO;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
				//! <Function Comment="Methode, to get last Error of Com" Name="GetLastError"/>
	FUNCTION GLOBAL GetLastError
		VAR_INPUT
			Com 	: DINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
				//! <Function Comment="Methode to Send Data" Name="Ser_Send"/>
	FUNCTION GLOBAL Ser_Send
		VAR_INPUT
			Com 	: USINT;
			Buffer 	: pVoid;
			Bufferlength 	: UDINT;
			WrLen 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
				//! <Function Comment="Get Send Status" Name="GetSendStatus"/>
	FUNCTION GLOBAL GetSendStatus
		VAR_INPUT
			Com 	: USINT;
		END_VAR
		VAR_OUTPUT
			to_Send 	: UDINT;
		END_VAR;
				//! <Function Comment="Methode clears ReceiveBuffer" Name="ClearRecvBuffer"/>
	FUNCTION GLOBAL ClearRecvBuffer
		VAR_INPUT
			Com 	: USINT;
		END_VAR
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
				//! <Function Comment="Returns State of ReceiveBuffer" Name="GetRecvStatus"/>
	FUNCTION GLOBAL GetRecvStatus
		VAR_INPUT
			Com 	: USINT;
		END_VAR
		VAR_OUTPUT
			Length 	: UDINT;
		END_VAR;
				//! <Function Comment="Get Pointer to Receive-Buffer" Name="GetRecvPointer"/>
	FUNCTION GLOBAL GetRecvPointer
		VAR_INPUT
			Com 	: USINT;
		END_VAR
		VAR_OUTPUT
			Buffer_ptr 	: pVoid;
		END_VAR;
				//! <Function Comment="Methode to receive one Character" Name="RecvChar"/>
	FUNCTION GLOBAL RecvChar
		VAR_INPUT
			Com 	: USINT;
			Buffer 	: pVoid;
		END_VAR
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
				//! <Function Comment="Methode, to readout whole ReceiveBuffer" Name="RecvBlock"/>
	FUNCTION GLOBAL RecvBlock
		VAR_INPUT
			Com 	: USINT;
			Buffer 	: pVoid;
			RdLength 	: UDINT;
			RdLen 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			ret0 	: DINT;
		END_VAR;
				//! <Function Comment="Methode, to create own ReceiveBuffer" Name="SetRcvBuffer"/>
	FUNCTION GLOBAL SetRcvBuffer
		VAR_INPUT
			Com 	: USINT;
			RCVBuffer 	: pVoid;
			BufferLength 	: UDINT;
		END_VAR
		VAR_OUTPUT
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION SendData
		VAR_INPUT
			Com 	: USINT;
		END_VAR;
	
	FUNCTION GetData
		VAR_INPUT
			Com 	: USINT;
		END_VAR;
	
	FUNCTION CheckSendTimeout
		VAR_INPUT
			pPort 	: ^t_port;
		END_VAR
		VAR_OUTPUT
			Occured 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CSI022_Base::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_CSI022_BASE
2$UINT, 46$UINT, (SIZEOF(::CSI022_Base))$UINT, 
0$UINT, 4$UINT, 0$UINT, 
TO_UDINT(2593821542), "CSI022_Base", //Class
TO_UDINT(1800499398), "HwBaseCDIAS", 2$UINT, 56$UINT, //Baseclass
//Servers:
//Clients:
(::CSI022_Base.Com1_IRQ.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(657481852), "Com1_IRQ", 
(::CSI022_Base.Com2_IRQ.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1620056748), "Com2_IRQ", 
(::CSI022_Base.Com3_IRQ.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1576022812), "Com3_IRQ", 
(::CSI022_Base.Com4_IRQ.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4023447308), "Com4_IRQ", 
END_FUNCTION


#define USER_CNT_CSI022_Base 30

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CSI022_Base] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CSI022_Base::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= HwBaseCDIAS::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= HwBaseCDIAS::State.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, HwBaseCDIAS::State.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CSI022_Base;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #GetKennung();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[29]		:= #GetVariante();

#pragma warning (default : 74)
	HwBaseCDIAS::State.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HwBaseCDIAS::State.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#ifdef _LSL_TARGETARCH_ARM
#pragma message("======= HW class unsuitable for ARM =======")
#endif

FUNCTION VIRTUAL GLOBAL CSI022_Base::Init
  VAR
    sz_name	    : ARRAY[0..255] OF CHAR;
  END_VAR
  
//============================ Profiler start======================================================
#ifdef DM_Profiler
  Profiler.sum 	:= 0;
  Profiler.run 	:= 0;
  Profiler._max := 0;
  Profiler._min := 16#ffffffff;
  Profiler.init := OS_readmicrosec();
#endif
//============================ Profiler end========================================================

  //init work pointers-----------------------------------------------------------------------------------------wocpet001
  pPortPointer := #PortPointer;
  PortPointer.Com1 := #Port[0];
  PortPointer.Com2 := #Port[1];
  PortPointer.Com3 := #Port[2];
  PortPointer.Com4 := #Port[3];
  
#ifdef DEACTIVATED_LSL
  IF Place.Read() = DEACTIVATED_LSL THEN
    State.uiIO_Flags := 0;
    State.uiIO_Flags.NoHW := 1;
    State.uiIO_Flags.PhysicAccessOff := 1;
    return;
  END_IF;
#endif

  //--------------------------------------------------------------------------------------------------------------------

  if InitRun = 0 then
  
    HWBaseCDIAS::Init();
  
    if GetVariante() = 1 then

      MyPlace	:= Place * 16#100;

      //module only works on CDIAS
      if connection <> 0 then     
        
        Trace("To insure a correct functionality of the CSI021 it has to be placed on the CDIAS Bus of the CPU !!! Object:");
        _GetObjName(this, #sz_name[0]);
        Trace(#sz_name[ 0 ]);
        
        State.uiIO_Flags                  := 0;
        State.uiIO_Flags.PhysicAccessOff  := 1;
        return;      
      end_if;

      //install IRQ
      MasterConnect.AddCDiasIrq(1, #IRQMethodCDIAS(), this);
      
      State.uiIO_Flags := 0;
      HWOk := TRUE;
      
    else
      State.uiIO_Flags:=0;
      if ( Kennung = 255 ) then
        State.uiIO_Flags.NoHW := 1;
      else	
        State.uiIO_Flags.WrongHW := 1;
      end_if;
      State.uiIO_Flags.PhysicAccessOff :=1;
    end_if;
    
  end_if;
  
  InitRun += 1;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CSI022_Base::GetVariante
  VAR_OUTPUT
    Ok	: BOOL;
  END_VAR
  VAR
    Variante : USINT;
  END_VAR
  
  if kennung = CSIKENNUNG then
    Variante := 16#FF;
    MasterConnect.I2CReadOneByte(AdressCDIAS:=(place$UINT*16#100)+3, pData:=#Variante); 
    if Variante = CSI022VARIANTE then
      Ok := 1;
      CSIVariante := CSI022VARIANTE;
    else
      Ok := 0;
    end_if;
  else
    Ok := 0;
  end_if;

END_FUNCTION


FUNCTION CSI022_Base::IRQMethodCDIAS
#ifndef _LSL_TARGETARCH_ARM
//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  SAVE_FLG();
  CLI();											//damit keine Interrupts die Messung stören
  
  Profiler.start := OS_ReadMicroSec();
  if ( ( Profiler.start - Profiler.init ) > DM_ProfilerDelay ) then
    Profiler.initfl := 0;
  else
    Profiler.initfl := 1;
  end_if;
#endif	
//============================ Profiler end========================================================

//  SAVE_FLG();
//  CLI();
       
  if GotIRQ = FALSE then

    //do we have an IRQ
    IRQIdent := (IOSegmentByte + IRQMODULE)^;

    if (IRQIdent AND 2#1111) then
      GotIRQ := TRUE;
    else
      GotIRQ := FALSE;
    end_if;
    
//IRQ-Handling----------------------------------------------
    while GotIRQ = TRUE do
    
      if IRQIdent AND 2#1 then  //COM1
      
        Com1_IRQ += 1;        
        if Port[0].Info.initialized then
          Port[0].IRQCount += 1;
  
          GetData(Com := 1);

          if Port[0].RXDataAvailable & IRQ1Connected then
            Com1_IRQ.Write(input := Port1RXBuffer);
            Port[0].RXDataAvailable := FALSE;
          end_if;
          
        end_if; 
     
      end_if;
   
//---------------------------------------------------------- 
   
      if IRQIdent AND 2#10 then //COM2

        Com2_IRQ += 1;   
        if Port[1].Info.initialized then
          
          Port[1].IRQCount += 1;

          GetData(Com := 2);
          
          if Port[1].RXDataAvailable & IRQ2Connected then
            Com2_IRQ.Write(input := Port2RXBuffer);
            Port[1].RXDataAvailable := FALSE;
          end_if;
          
        end_if;
      
      end_if;

//----------------------------------------------------------

      if IRQIdent AND 2#100 then

        Com3_IRQ += 1;
        if Port[2].Info.initialized then
          Port[2].IRQCount += 1;
          
          GetData(Com := 3);
          
          if Port[2].RXDataAvailable & IRQ3Connected then
            Com3_IRQ.Write(input := Port3RXBuffer);
            Port[2].RXDataAvailable := FALSE;
          end_if;
        end_if;     
           
      end_if;

//----------------------------------------------------------

      if IRQIdent AND 2#1000 then

        Com4_IRQ += 1;
        if Port[3].Info.initialized then
          Port[3].IRQCount += 1;

          GetData(Com := 4);
          
          if Port[3].RXDataAvailable & IRQ4Connected then
            Com4_IRQ.Write(input := Port4RXBuffer);
            Port[3].RXDataAvailable := FALSE;
          end_if;
        end_if; 

      end_if;

      //readout register to quit the latched IRQ
      IRQIdent := (IOSegmentByte + IRQMODULE)^;
      
      //do we have another IRQ
      IRQIdent := (IOSegmentByte + IRQMODULE)^;

      if (IRQIdent AND 2#1111) then
        GotIRQ := TRUE;
      else
        GotIRQ := FALSE;
      end_if;
      
    end_while;
    
//END IRQ-Handling------------------------------------------

  end_if;
 
 
//  RESTORE_FLG();
 
//============================ Profiler start======================================================
#ifdef  DM_Profiler								
  
  if ( Profiler.initfl = 0 ) then

    Profiler.stop := OS_ReadMicroSec();
    Profiler.diff := Profiler.stop - Profiler.start - DM_CPUconstant;
    Profiler.sum += Profiler.diff;
    Profiler.run += 1;

    if ( Profiler.diff < Profiler._min ) then
      Profiler._min := Profiler.diff;
    end_if;

    if ( Profiler.diff > Profiler._max ) then
      Profiler._max := Profiler.diff;
    end_if;

    Profiler.avg := Profiler.sum * 100 / Profiler.run;

  end_if;
//  STI();
  RESTORE_FLG();
#endif
//============================ Profiler end======================================================== 
#endif
 
END_FUNCTION


FUNCTION CSI022_Base::InitCom
  VAR_INPUT
    Com 	: USINT;
    Baud 	: DINT;
    Wordl 	: DINT;
    Parity 	: DINT;
    Stopb 	: DINT;
    FiFo 	: DINT;
  END_VAR
  VAR
    OffsetAct	: UDINT;
    Merker		: BSINT;
    Teiler		: UDINT;
    pPort     : ^t_port;
  END_VAR

  //pPort := #Port[Com - 1];
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;
  

  case Com of
    1:	OffsetAct := CSI022_APORT1;
    2:	OffsetAct := CSI022_APORT2;
    3:	OffsetAct := CSI022_APORT3;
    4:	OffsetAct := CSI022_APORT4;
  end_case;

  //get Pointer to Register
  pPort^.Register.ReceiverBuffer             := (IOSegmentByte + OffsetAct + RECEIVERBUFFEROFFSET)$^t_Register;
  pPort^.Register.TransmitterHolding         := (IOSegmentByte + OffsetAct + TRANSMITTERHOLDINGOFFSET)$^t_Register;
  pPort^.Register.IRQEnable                  := (IOSegmentByte + OffsetAct + IRQENABLEOFFSET)$^t_IRQEnable;
  pPort^.Register.IRQIdent                   := (IOSegmentByte + OffsetAct + IRQIDENTOFFSET)$^t_IRQIdent;
  pPort^.Register.FIFOControl                := (IOSegmentByte + OffsetAct + FIFOCONTROLOFFSET)$^t_FIFOControl;
  pPort^.Register.LineControl                := (IOSegmentByte + OffsetAct + LINECONTROLOFFSET)$^t_LineControl;
  pPort^.Register.ModemControl               := (IOSegmentByte + OffsetAct + MODEMCONTROLOFFSET) $^t_ModemControl;
  pPort^.Register.LineStatus                 := (IOSegmentByte + OffsetAct + LINESTATUSOFFSET)$^t_LineStatus;
  pPort^.Register.ModemStatus                := (IOSegmentByte + OffsetAct + MODEMSTATUSOFFSET)$^t_ModemStatus;
  pPort^.Register.Scratch                    := (IOSegmentByte + OffsetAct + SCRATCHOFFSET)$^t_Register;
  pPort^.Register.DivisorLatchLS             := (IOSegmentByte + OffsetAct + DIVISORLATCHLSOFFSET)$^t_Register;
  pPort^.Register.DivisorLatchMS             := (IOSegmentByte + OffsetAct + DIVISORLATCHMSOFFSET)$^t_Register;
  pPort^.Register.AlternateFunctionRegister  := (IOSegmentByte + OffsetAct + ALTERNATEFUNCTIONOFFSET)$^t_AlternateFunction;
  
  pPort^.Info.Baudrate := Baud$UINT;
  Teiler := (#BaudTable() + 4 + Baud * 4)^$UDINT;               //actual baudrate

 
  pPort^.Register.LineControl^.DLAB  := 1;                       //to access DivisorLatch
  pPort^.Register.DivisorLatchLS^    := Teiler$USINT;            //Baud Low
  pPort^.Register.DivisorLatchMS^    := ((#Teiler) + 1)^$USINT;  //Baud High

  //line control register
  case Parity of
    0:  //Parity_None
        Merker := PARITY_NONE;
    1:  //Parity_Odd
        Merker := PARITY_ODD;
    2:  //Parity_Even
        Merker := PARITY_EVEN;
    3:  //Parity_Mark
        Merker := PARITY_MARK;
    4:  //Parity_Space
        Merker := PARITY_SPACE;
  end_case;

  pPort^.WordLength := Wordl$UDINT;

  Merker := Merker OR ((Wordl$USINT - 5) AND 2#11);
  Stopb -= 1;
  if Stopb then
    Merker.3 := 1;  //activate StopBit
  end_if;
  pPort^.Register.LineControl^ := Merker$USINT;
 
  //Init TXBuffer
  pPort^.TXBuffer.Index        := 0;
  pPort^.TXBuffer.ActPtr       := #pPort^.TXBuffer.Buffer[0];
  pPort^.TXBuffer.StartPtr     := #pPort^.TXBuffer.Buffer[0];
  pPort^.TXBuffer.PtrNextFree  := #pPort^.TXBuffer.Buffer[0];
  pPort^.TXBuffer.EndOfBuffer  := #pPort^.TXBuffer.Buffer[0] + sizeof(pPort^.RXBuffer.Buffer) - 1;
  
  //Init RXBuffer
  pPort^.RXBuffer.Index        :=  0;
  pPort^.RXBuffer.ActPtr       := #pPort^.RXBuffer.Buffer[0];
  pPort^.RXBuffer.StartPtr     := #pPort^.RXBuffer.Buffer[0];
  pPort^.RXBuffer.PtrNextFree  := #pPort^.RXBuffer.Buffer[0];
  pPort^.RXBuffer.EndOfBuffer  := #pPort^.RXBuffer.Buffer[0] + sizeof(pPort^.RXBuffer.Buffer) - 1;

  //Init Info
  pPort^.Info.comportnum     := Com;
  
  pPort^.Info.IRQNum         := 0;
  pPort^.Info.IOPort         := Com;
  pPort^.Info.Ptr_RecvBuffer := #pPort^.RXBuffer.Buffer;
  pPort^.Info.Ptr_SendBuffer := #pPort^.TXBuffer.Buffer;
  pPort^.IRQCount            := 0;

  pPort^.Info.Initialized := TRUE;
  
  case Com of
    1:  IRQ1Connected := IsClientConnected(#Com1_IRQ);  
        Port1RXBuffer := #(Port[0].RXBuffer.Buffer)$DINT;
        
    2:  IRQ2Connected := IsClientConnected(#Com2_IRQ);
        Port2RXBuffer := #(Port[1].RXBuffer.Buffer)$DINT;
        
    3:  IRQ3Connected := IsClientConnected(#Com3_IRQ);
        Port3RXBuffer := #(Port[2].RXBuffer.Buffer)$DINT;    
            
    4:  IRQ4Connected := IsClientConnected(#Com4_IRQ);
        Port4RXBuffer := #(Port[3].RXBuffer.Buffer)$DINT;
        Port4RXBuffer := ((#Port[3] + 24)$^DINT)^;
   
  end_case;

 //prepare Com for TTY
   pPort^.Register.LineControl^.DLAB  := 0;                       //to access DivisorLatch
 
   (*Port[Com - 1].Register.IRQEnable^   := 2#00000111; //BLEERN 03 16.12.09
   Port[Com - 1].Register.FIFOControl^ := TRIGGERLEVELHIGH; //BLEERN 03 16.12.09*)
   
   SetMode(Com := Com, Mode := 232);

END_FUNCTION


FUNCTION TAB CSI022_Base::BaudTable

//Register  Baudrate  ClientValue
//-------------------------------
   3840$UDINT  //000300$UDINT,  0
   1920$UDINT  //000600$UDINT,  1
    960$UDINT  //001200$UDINT,  2
    480$UDINT  //002400$UDINT,  3
    240$UDINT  //004800$UDINT,  4
    120$UDINT  //009600$UDINT,  5
     80$UDINT  //014400$UDINT,  6
     60$UDINT  //019200$UDINT,  7
     30$UDINT  //038400$UDINT,  8
     20$UDINT  //056000$UDINT,  9
     10$UDINT  //115200$UDINT, 10

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::RTSOnOff
  VAR_INPUT
    Com 	  : USINT;
    State 	: BOOL;
  END_VAR
  VAR_OUTPUT
    retValue 	: DINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
 
  if HWOK then
    if Com >= 1 & Com <= 4 then
      //wocpet001
      (*if Port[Com - 1].Info.Initialized then
        Port[Com - 1].Register.ModemControl^.RequestToSend := State; 
      else
        Port[Com - 1].ActError := SERERROR_NOHANDLE;
        retValue := Port[Com - 1].ActError;
      end_if;*)
      
      if pPort^.Info.Initialized then
        pPort^.Register.ModemControl^.RequestToSend := State;
        retValue := SERERROR_NONE;
      else  
        pPort^.ActError := SERERROR_NOHANDLE;
        retValue := pPort^.ActError;
      end_if;
      //wocpet001 end
      
    else
      retValue := SERERROR_COMNUM;
    end_if;  
  else
    retValue := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::rdRTS
  VAR_INPUT
    Com 	: USINT;
  END_VAR
  VAR_OUTPUT
    State 	: BOOL;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
  
  if HWOk & Com >= 1 & Com <= 4 then
    //wocpet001
    (*if Port[Com - 1].Info.initialized then
      State := Port[Com - 1].Register.ModemControl^.RequestToSend;*)

    if pPort^.Info.Initialized then
      State := pPort^.Register.ModemControl^.RequestToSend;
    //wocpet001 end
    else
      State := FALSE;
    end_if;
  else
    State := FALSE;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::DTROnOff
  VAR_INPUT
    Com 	: USINT;
    State 	: BOOL;
  END_VAR
  VAR_OUTPUT
    retValue 	: DINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if HWOk then
    if Com >= 1 & Com <= 4 then
      if pPort^.Info.Initialized then
        pPort^.Register.ModemControl^.DataTerminalReady := State;
        retValue := SERERROR_NONE;
      else
        pPort^.ActError := SERERROR_NOHANDLE;
        retValue := pPort^.ActError;    
      end_if;
    else  
      retValue := SERERROR_COMNUM;
    end_if;
  else
    retValue := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::rdDTR
  VAR_INPUT
    Com		  : USINT;
  END_VAR
  VAR_OUTPUT
    State		: BOOL;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
  
  if HWOk & Com >= 1 & Com <= 4 then
    if pPort^.Info.initialized then
      State := pPort^.Register.ModemControl^.DataTerminalReady;
    else
      State := FALSE;
    end_if;
  else
    State := FALSE;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::rdCTS
  VAR_INPUT
    Com			: USINT;
  END_VAR
  VAR_OUTPUT
    State		: BOOL;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if HWOk & Com >= 1 & Com <= 4 then
    if pPort^.Info.initialized then
      State := pPort^.Register.ModemStatus^.ClearToSend;
    else
      State := FALSE;
    end_if;
  else
    State := FALSE;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::StartUser
  VAR_INPUT
    Com			    : USINT;
    Baud		    : DINT;
    WordL		    : DINT;
    Parity	    : DINT;
    StopB		    : DINT;
    FifoOnOff		: DINT;
  END_VAR
  VAR_OUTPUT
    ErrorCode		: DINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if HWOk then
    if Com >= 1 & Com <= 4 then
      if Baud >= 0 & Baud <= 10 then
        if Wordl >= 5 & Wordl <= 8 then
          if Parity >= 0 & Parity <= 4 then
            if StopB = 1 | StopB = 2 then
              if FifoOnOff = 0 | FifoOnOff = 1 then
                IF ( CSIVariante = CSI022VARIANTE & Baud > 4 & ( Com = 3 | Com = 3 ) ) | 
                   ( CSIVariante = CSI023VARIANTE & Baud > 3 & Com = 3) THEN
                  pPort^.ActError := SERERROR_BAUDRATE;
                  ErrorCode := pPort^.ActError;
                ELSE
                  InitCom(Com     := Com, 
                          Baud    := Baud, 
                          WordL   := Wordl, 
                          Parity  := Parity, 
                          StopB   := StopB, 
                          FiFo    := FifoOnOff);
                  //Port[Com].ActError := SERERROR_NONE;
                  pPort^.ActError := SERERROR_NONE;
                  ErrorCode := pPort^.ActError;
                END_IF;
                
              else
                //Port[Com].ActError := SERERROR_NOTAVAIL;
                pPort^.ActError := SERERROR_NOTAVAIL;
                ErrorCode := pPort^.ActError;
              end_if;
            else
              //Port[Com].ActError  := SERERROR_STOPBIT;
              pPort^.ActError  := SERERROR_STOPBIT;
              ErrorCode := pPort^.ActError;
            end_if;
          else
            //Port[Com].ActError := SERERROR_PARITY;
            pPort^.ActError := SERERROR_PARITY;
            ErrorCode := pPort^.ActError;
          end_if;
        else
          //Port[Com].ActError := SERERROR_WORDLEN;
          pPort^.ActError := SERERROR_WORDLEN;
          ErrorCode := pPort^.ActError;
        end_if;
      else
        //Port[Com].ActError := SERERROR_BAUDRATE;
        pPort^.ActError := SERERROR_BAUDRATE;
        ErrorCode := pPort^.ActError;
      end_if;
    else
      ErrorCode := SERERROR_COMNUM;
    end_if;
  else
    //Port[Com].ActError := SERERROR_NOTAVAIL;
    pPort^.ActError := SERERROR_NOTAVAIL;
    ErrorCode := pPort^.ActError;
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL CSI022_Base::IsInitialized
  VAR_INPUT
    Com		: DINT;
  END_VAR
  VAR_OUTPUT
    Ok		: DINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if HWOk then  
    if Com >= 1 & Com <= 4 then
      Ok := pPort^.Info.Initialized;
    else
      Ok := SERERROR_COMNUM;
    end_if;
  else
    Ok := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::GetLastError
  VAR_INPUT
    Com		: DINT;
  END_VAR
  VAR_OUTPUT
    ErrorCode		: DINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR
 
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if HWOk then
    if Com >= 1 & Com <= 4 then
      if CheckSendTimeout(pPort) then
        ErrorCode := SERERROR_SENDERROR;
      else
        ErrorCode := pPort^.ActError;     
      end_if;
    else
      ErrorCode := SERERROR_COMNUM;
    end_if;
  else
    ErrorCode := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::GetInfo
  VAR_INPUT
    Com			: DINT;
    Info		: ^LSLAPI_SERIALINFO;
  END_VAR
  VAR_OUTPUT
    ErrorCode		: DINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR


  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if HWOk then
    if Com >= 1 & Com <= 4 then
      info^ := pPort^.Info;
      ErrorCode := SERERROR_NONE;
    else
      ErrorCode := SERERROR_COMNUM;
    end_if;
  else
    ErrorCode := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::GetSendStatus
	VAR_INPUT
		Com 	: USINT;
	END_VAR
	VAR_OUTPUT
		to_Send 	: UDINT;
	END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
  
  if HWOk & Com >= 1 & Com <= 4 then
    if pPort^.Info.initialized then
    
      to_Send  := pPort^.TXBuffer.Index;
    else
      to_Send := 0;
    end_if;
  else
    to_Send := 0;
  end_if;
  
END_FUNCTION

#pragma warning(disable:76);
#pragma warning(disable:73);
#pragma warning(disable:72);
FUNCTION GLOBAL CSI022_Base::ClearRecvBuffer
  VAR_INPUT
    Com			: USINT;
  END_VAR
  VAR_OUTPUT
    ret0		: DINT;
  END_VAR
  VAR
  	pPort   : ^t_port;
  END_VAR
#ifndef _LSL_TARGETARCH_ARM
  if HWOk then
    if Com >= 1 & Com <= 4 then
      
      pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
      
      if pPort^.Info.initialized then
        SAVE_FLG();//BLEERN 11 18.12.09
        CLI();//BLEERN 11 18.12.09
        pPort^.RXBuffer.Index := 0;
        pPort^.RXBuffer.ActPtr := pPort^.RXBuffer.StartPtr;
        pPort^.RXBuffer.PtrNextFree := pPort^.RXBuffer.ActPtr;
        //STI();//BLEERN 11 18.12.09
        RESTORE_FLG();//BLEERN 11 18.12.09
        ret0 := SERERROR_NONE;
      else
        pPort^.ActError := SERERROR_NOHANDLE; 
        ret0 := pPort^.ActError;
      end_if;
    else
      ret0 := SERERROR_COMNUM;
    end_if;
  else
    ret0 := SERERROR_NOTAVAIL;
  end_if;
#endif

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::GetRecvStatus
  VAR_INPUT
    Com			: USINT;
  END_VAR
  VAR_OUTPUT
    Length		: UDINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if Com >= 1 & Com <= 4 then
    
    if pPort^.Info.initialized then
      Length := pPort^.RXBuffer.Index;
    else
      Length := 0;
    end_if;
  else
    Length := 0;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::RecvChar
  VAR_INPUT
    Com		    : USINT;
    Buffer		: pVoid;
  END_VAR
  VAR_OUTPUT
    ret0		: DINT;
  END_VAR
  VAR
    Length	:	UDINT;
  END_VAR

	Length := 1;
	ret0 := RecvBlock(Com, Buffer, 1, #length);

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::GetRecvPointer
  VAR_INPUT
    Com		: USINT;
  END_VAR
  VAR_OUTPUT
    Buffer_ptr		: pVoid;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if Com >= 1 & Com <= 4 then
    if pPort^.Info.initialized then
      Buffer_ptr	:= #pPort^.RXBuffer.Buffer$Void;
    else
    	Buffer_ptr := NIL;
    end_if;
  else
    Buffer_ptr := NIL;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::SetRcvBuffer
  VAR_INPUT
    Com			      : USINT;
    RCVBuffer		  : pVoid;
    BufferLength	: UDINT;
  END_VAR
  VAR_OUTPUT
    ErrorCode		  : DINT;
  END_VAR
  VAR
  	pPort         : ^t_port;
  END_VAR

#ifndef _LSL_TARGETARCH_ARM
  if HWOk then
    if Com >= 1 & Com <= 4 then
      
      pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
    
      if pPort^.Info.initialized then
        SAVE_FLG(); //BLEERN 11 18.12.09
        CLI();
        pPort^.RXBuffer.Index              := 0;
        pPort^.RXBuffer.ActPtr             := RCVBuffer$^USINT;
        pPort^.RXBuffer.StartPtr           := RCVBuffer$^USINT;
        pPort^.RXBuffer.PtrNextFree        := pPort^.RXBuffer.ActPtr;
        pPort^.RXBuffer.EndOfBuffer$UDINT  := RCVBuffer$UDINT + BufferLength - 1;
        //STI(); //BLEERN 11.18.12.09
        RESTORE_FLG(); //BLEERN 11.18.12.09
        ErrorCode := SERERROR_NONE;
      else
        pPort^.ActError := SERERROR_NOHANDLE;
        ErrorCode := pPort^.ActError;
      end_if;
    else
      ErrorCode := SERERROR_COMNUM;
    end_if;
  else
    ErrorCode := SERERROR_NOTAVAIL;
  end_if;
#endif

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::Ser_Send
  VAR_INPUT
    Com		        : USINT;
    Buffer		    : Pvoid;
    Bufferlength  : UDINT;
    WrLen		      : ^UDINT;
  END_VAR
  VAR_OUTPUT
    ret0		: DINT;
  END_VAR
  VAR
    RestLength  : UDINT;
    pPort       : ^t_port;
    actError    : DINT; //BLEERN 13 18.12.09 - Error will be saved temporary to be "thread safe"
    oldIndex    : UDINT; //BLEERN 26.01.2010 - Daten dürfen nur einmal gesendet werden
  END_VAR
#ifndef _LSL_TARGETARCH_ARM 
  if HWOk then
    if Com >= 1 & Com <= 4 then
          
      pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
      
      if pPort^.Info.initialized then
        
        actError := 0; //BLEERN 10 18.12.09
        
        if CheckSendTimeout(pPort) then
        
          // reset send buffer, because sending failed

          SAVE_FLG();
          CLI();

          //Init TXBuffer
          pPort^.TXBuffer.Index        := 0;
          pPort^.TXBuffer.ActPtr       := #pPort^.TXBuffer.Buffer[0];
          pPort^.TXBuffer.StartPtr     := #pPort^.TXBuffer.Buffer[0];
          pPort^.TXBuffer.PtrNextFree  := #pPort^.TXBuffer.Buffer[0];
          pPort^.TXBuffer.EndOfBuffer  := #pPort^.TXBuffer.Buffer[0] + sizeof(pPort^.RXBuffer.Buffer) - 1;

          RESTORE_FLG();
        end_if;

        if (Bufferlength > ((pPort^.TXBuffer.EndOfBuffer$UDINT - pPort^.TXBuffer.StartPtr$UDINT) - pPort^.TXBuffer.Index + 1)) | (Bufferlength < 0) then //BLEERN 12 18.12.09 &???? Vllt doch ein |????

          actError := SERERROR_SENDERROR;//BLEERN 10 18.12.09
          
        else

          SAVE_FLG(); //BLEERN 11 18.12.09
          CLI();
           
          oldIndex := pPort^.TXBuffer.Index;//BLEERN 26.01.2010
           
          RestLength := 0;
          
          //Buffer too small for the whole data
          if (pPort^.TXBuffer.PtrNextFree + Bufferlength) > (pPort^.TXBuffer.EndOfBuffer) then 
            
            RestLength := pPort^.TXBuffer.EndOfBuffer$UDINT - pPort^.TXBuffer.PtrNextFree$UDINT + 1;
            
            _memcpy(ptr1 := pPort^.TXBuffer.PtrNextFree, 
                    ptr2 := Buffer, 
                    cntr := RestLength);
            Bufferlength -= RestLength;
            Buffer       += RestLength;
            
         
            pPort^.TXBuffer.PtrNextFree  := pPort^.TXBuffer.StartPtr;  
            pPort^.TXBuffer.Index        += RestLength;//BLEERN 25.01.2010

          end_if;
          
          //load the rest of the send-data into the buffer 
          _memcpy(ptr1 := pPort^.TXBuffer.PtrNextFree, 
                  ptr2 := Buffer, 
                  cntr := Bufferlength);
          pPort^.TXBuffer.PtrNextFree  += Bufferlength;  
          pPort^.TXBuffer.Index        += Bufferlength;
          
          //correct pointer
          if pPort^.TXBuffer.PtrNextFree > pPort^.TXBuffer.EndOfBuffer then
            pPort^.TXBuffer.PtrNextFree := pPort^.TXBuffer.StartPtr;
          end_if;

          if WrLen <> NIL then
            WrLen^ := Bufferlength + RestLength;
          end_if;
          
          IF oldIndex = 0 THEN //BLEERN 26.01.2010
            SendData(Com := Com);
          END_IF; //BLEERN 26.01.2010
           
          //STI();//BLEERN 11 18.12.09
          RESTORE_FLG();//BLEERN 11 18.12.09
          
        end_if; 
        
        //ret0 := pPort^.ActError;//BLEERN 10 18.12.09

      else
//        pPort^.ActError := SERERROR_NOHANDLE;
        actError := SERERROR_NOHANDLE;
//        ret0 := pPort^.ActError;
      end_if;
      pPort^.ActError := ret0 := actError;
    else
      ret0 := SERERROR_COMNUM;
    end_if;
  else
    ret0 := SERERROR_NOTAVAIL;
  end_if;
  
#endif  

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::RecvBlock
  VAR_INPUT
    Com		    : USINT;
    Buffer		: pVoid;
    RdLength  : UDINT;
    RdLen		  : ^UDINT;
  END_VAR
  VAR_OUTPUT
    ret0		: DINT;
  END_VAR
  VAR
  	pPort   :^t_port;
  END_VAR
#ifndef _LSL_TARGETARCH_ARM
  if HWOk then
    if Com >= 1 & Com <= 4 then
      
      pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001
      
      if pPort^.Info.initialized then     
        if pPort^.ActError = SERERROR_NONE then
          if RdLength then
          
            SAVE_FLG(); //BLEERN 11 18.12.09
            CLI();
            
            if pPort^.RXBuffer.Index < RdLength then  
              RdLength := pPort^.RXBuffer.Index;          
            end_if;

            if RdLength then
            
              //copy into User Buffer
              _memcpy(ptr1 := Buffer, 
                      ptr2 := #pPort^.RXBuffer.Buffer$void, 
                      cntr := RdLength);      
            
              if RdLength = pPort^.RXBuffer.Index then
              
                ClearRecvBuffer(Com := Com);
               
              else
              
                pPort^.RXBuffer.Index -= RdLength;
                
                _memcpy(ptr1 := pPort^.RXBuffer.StartPtr$pvoid, 
                        ptr2 := pPort^.RXBuffer.StartPtr$pvoid + rdLength, 
                        cntr := pPort^.RXBuffer.Index);
                                        
                pPort^.RXBuffer.ActPtr       := pPort^.RXBuffer.StartPtr + pPort^.RXBuffer.Index;
                pPort^.RXBuffer.PtrNextFree  := pPort^.RXBuffer.ActPtr;
              end_if;
            
            else
            
              pPort^.ActError := SERERROR_RECVERROR;
            
            end_if;
            
            //STI();//BLEERN 11 18.12.09
            RESTORE_FLG();//BLEERN 11 18.12.09
            
            if RdLen <> NIL then
              RdLen^ := RdLength;
            end_if;
          
          else
            pPort^.ActError := SERERROR_PARAMETER;
          end_if;   
          
          ret0 := pPort^.ActError;
          
        else
          ret0 := pPort^.ActError;
          pPort^.ActError := 0;
        end_if;

      else        
        pPort^.ActError := SERERROR_NOHANDLE;
        ret0 := pPort^.ActError;
      end_if;
    else
      ret0 := SERERROR_COMNUM;
    end_if;
  else
    ret0 := SERERROR_NOTAVAIL;
  end_if;
#endif

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::CloseCom
  VAR_INPUT
    Com		: DINT;
  END_VAR
  VAR_OUTPUT
    ErrorCode		: DINT;
  END_VAR
  VAR
  	pPort    : ^t_port;
  END_VAR

  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  if HWOk then
    if Com >= 1 & Com <= 4 then
      pPort^.Info.initialized := FALSE;
      ErrorCode := SERERROR_NONE;
    else
      ErrorCode := SERERROR_COMNUM;
    end_if;
  else
    ErrorCode := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


FUNCTION GLOBAL CSI022_Base::SetMode
  VAR_INPUT
    Com			: USINT;
    Mode		: DINT;
  END_VAR
  VAR_OUTPUT
    ErrorCode		: DINT;
  END_VAR
  VAR
  	ud_IRQTime  : UDINT;
    sz_name	    : ARRAY[ 0..255 ] OF CHAR;
  	pPort    : ^t_port;
  END_VAR
  
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^;  //wocpet001

  ErrorCode := SERERROR_NONE;

  if HWOk & pPort^.Info.initialized then
    
    CASE Com OF
    
    1:
     
      case Mode of
      
        422:
          pPort^.Register.IRQEnable^   := 2#00000011;
          pPort^.Register.FIFOControl^ := TRIGGERLEVELHIGH;
          pPort^.Mode := Mode;
        
          modebits := modebits AND NOT(2#11) OR RS422;
          
        485:
          pPort^.Register.IRQEnable^   := 2#00000101;
          pPort^.Register.FIFOControl^ := TRIGGERLEVELLOW;
          pPort^.Mode := Mode;

          modebits := modebits AND NOT(2#11) OR RS485;
          
        232:
          pPort^.Register.IRQEnable^   := 2#00000111;
          pPort^.Register.FIFOControl^ := TRIGGERLEVELHIGH;
          pPort^.Mode := 232;
          
          modebits := modebits AND NOT(2#11) OR RS232;
          
        else //False input, mode not supported
          ErrorCode := SERERROR_GENERAL;
          return;
      
      end_case;
      
      (IOSegmentByte + ModeSelectOffset)^ := modebits;
           
      //check performance
      (IOSegmentByte + IRQModule)^ := 2#110;    //activate IRQ

      ud_IRQTime := ops.tAbsolute;
      while(((IOSegmentByte + IRQModule)^ and 2#1111) <> 0) do	//clear all interrupts
        if( ops.tAbsolute - ud_IRQTime > 10 )then				        //if there are still interrupts pending after 10ms -> trace
          Trace("The CSI-Class is likely to be flooded with interrupts. Please check:");
          _GetObjName( this, #sz_name[ 0 ] );
          trace( #sz_name[ 0 ] );	
          exit;
        end_if;
      end_while;
                 
    2: 

      case Mode of
      
        422:
          pPort^.Register.IRQEnable^   := 2#00000011;
          pPort^.Register.FIFOControl^ := TRIGGERLEVELHIGH;
          pPort^.Mode := Mode;
        
          modebits := modebits AND NOT(2#1100) OR (RS422 SHL 2);

        485:
          pPort^.Register.IRQEnable^   := 2#00000101;
          pPort^.Register.FIFOControl^ := TRIGGERLEVELLOW;
          pPort^.Mode := Mode;

          modebits := modebits AND NOT(2#1100) OR (RS485 SHL 2);        

        232:
          pPort^.Register.IRQEnable^   := 2#00000111;
          pPort^.Register.FIFOControl^ := TRIGGERLEVELHIGH;
          pPort^.Mode := 232;
          
          modebits := modebits AND NOT(2#1100) OR (RS232 SHL 2);
          
        else //False input, mode not supported
          ErrorCode := SERERROR_GENERAL;
          return;
      
      end_case;
      
      (IOSegmentByte + ModeSelectOffset)^ := modebits;

      //check performance
      (IOSegmentByte + IRQModule)^ := 2#110;    //activate IRQ

      ud_IRQTime := ops.tAbsolute;
      while(((IOSegmentByte + IRQModule)^ and 2#1111) <> 0) do	//clear all interrupts
        if( ops.tAbsolute - ud_IRQTime > 10 )then				        //if there are still interrupts pending after 10ms -> trace
          Trace("The CSI-Class is likely to be flooded with interrupts. Please check:");
          _GetObjName( this, #sz_name[ 0 ] );
          trace( #sz_name[ 0 ] );	
          exit;
        end_if;
      end_while;

    //BLEERN 08 17.12.09

    3,4:
        
      pPort^.Register.IRQEnable^   := 2#00000111;
      pPort^.Register.FIFOControl^ := TRIGGERLEVELHIGH;
      pPort^.Mode := 232;
      
      (*modebits := modebits AND NOT(2#1100) OR (RS232 SHL 2);
      (IOSegmentByte + ModeSelectOffset)^ := modebits;*) //BLEERN 29.01.2010

      //check performance
      (IOSegmentByte + IRQModule)^ := 2#110;    //activate IRQ

      ud_IRQTime := ops.tAbsolute;
      while(((IOSegmentByte + IRQModule)^ and 2#1111) <> 0) do	//clear all interrupts
        if( ops.tAbsolute - ud_IRQTime > 10 )then				        //if there are still interrupts pending after 10ms -> trace
          Trace("The CSI-Class is likely to be flooded with interrupts. Please check:");
          _GetObjName( this, #sz_name[ 0 ] );
          trace( #sz_name[ 0 ] );		
          exit;
        end_if;
      end_while;

    ELSE
      ErrorCode := SERERROR_COMNUM;
    END_CASE;
  else
    IF pPort^.Info.initialized = 0 THEN
      TRACE("HW-Class CSI: StartUser must be called before SetRSMode! Please check:");
      _GetObjName( this, #sz_name[ 0 ] );
      trace( #sz_name[ 0 ] );      
    END_IF;
  
    ErrorCode := SERERROR_NOTAVAIL;
  end_if;

END_FUNCTION


FUNCTION CSI022_Base::SendData
	VAR_INPUT
		Com 	: USINT;
	END_VAR
  VAR
    ByteCounter : USINT;
    pPort       : ^t_port;
  END_VAR
  
  //pPort := #Port[Com - 1];
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^; //wocpet001
  
//  if pPort^.TXBuffer.ActPtr > pPort^.TXBuffer.EndOfBuffer then
//    pPort^.TXBuffer.ActPtr := pPort^.TXBuffer.StartPtr;
//  end_if;  
  
  if pPort^.TXBuffer.ActPtr <> pPort^.TXBuffer.PtrNextFree then

    // RTS is used to switch on the driver in RS485 mode
    // (RTS has no contextualized meaning, CTS is not used)
    if pPort^.Mode = 485 then

      if pPort^.TXBuffer.ActPtr > pPort^.TXBuffer.EndOfBuffer then
        pPort^.TXBuffer.ActPtr := pPort^.TXBuffer.StartPtr;
      end_if;

      pPort^.Register.ModemControl^.RequestToSend := 1;
      // write only 1 byte into the fifo, next byte after we receiveing (IRQ) the send-data

      pPort^.Register.TransmitterHolding^ :=  pPort^.TXBuffer.ActPtr^;
      
      //pPort^.TXBuffer.Index  -= 1;
      //pPort^.TXBuffer.ActPtr += 1;
      ((pPort + t_port.TXBuffer.Index)$^UDINT)^ -= 1;          
      ((pPort + t_port.TXBuffer.ActPtr)$^pVoid)^ += 1;             

    else
      // write 15 bytes into the fifo (which has place for 16 bytes)
      // because the interrupt is triggered when the last byte is about to be sent
      if pPort^.Register.LineStatus^ AND 2#1100000 then
      
        for ByteCounter := 0 to 14 do
        
          if pPort^.TXBuffer.Index > 0 then
          
            if pPort^.TXBuffer.ActPtr > pPort^.TXBuffer.EndOfBuffer then
              pPort^.TXBuffer.ActPtr := pPort^.TXBuffer.StartPtr;
            end_if;

            pPort^.Register.TransmitterHolding^ :=  pPort^.TXBuffer.ActPtr^;
            
            //pPort^.TXBuffer.Index  -= 1;
            //pPort^.TXBuffer.ActPtr += 1;
            ((pPort + t_port.TXBuffer.Index)$^UDINT)^ -= 1;          
            ((pPort + t_port.TXBuffer.ActPtr)$^pVoid)^ += 1;             
          else     
            exit;//ByteCounter := 15;      
          end_if;
     
        end_for; 

      end_if;
    end_if;
    
    // remember the time we last sent for timeout surveillance
    pPort^.LastSendTime := ops.tAbsolute;

  end_if;

END_FUNCTION


FUNCTION CSI022_Base::GetData
	VAR_INPUT
		Com 	: USINT;
	END_VAR
#ifndef _LSL_TARGETARCH_ARM      
  VAR

    Dummy     : USINT;
    DataAvail : BOOL;
    pPort     : ^t_port;
  END_VAR

  //pPort := #Port[Com - 1];
  pPort := (pPortPointer + (sizeof(UDINT) * Com) )$^pt_port^; //wocpet001

  case (pPort^.Register.IRQIdent^ AND 2#1110) SHR 1 of
    
    IRQTRANSMITTERHOLDINGEMPTY:

      SendData(Com := Com); //send data: 232/422, IRQ is deactivated for 485
      
    IRQRECEIVEDDATAAVAILABLE, IRQCHARACTERTIMEOUTINDICATION:     

//      Dummy := pPort^.Register.LineStatus^.ParityError;
//      
//      if Dummy = 0 then
      Dummy := pPort^.Register.LineStatus^;
      
      if Dummy$t_LineStatus.ParityError = 0 then

        if pPort^.Mode = 485 then
                                    
          if pPort^.RXBuffer.ActPtr > pPort^.RXBuffer.EndOfBuffer then              
            pPort^.RXBuffer.ActPtr := pPort^.RXBuffer.StartPtr;
            pPort^.RXBuffer.Index  := 0;
          end_if;

          pPort^.RXBuffer.ActPtr^      := pPort^.Register.ReceiverBuffer^;
          //pPort^.RXBuffer.ActPtr       += 1;
          ((pPort + t_port.RXBuffer.ActPtr)$^pVoid)^ += 1;          
          //pPort^.RXBuffer.Index        += 1;

          ((pPort + t_port.RXBuffer.Index)$^UDINT)^ += 1;
          
          pPort^.RXBuffer.PtrNextFree  := pPort^.RXBuffer.ActPtr;
          
          pPort^.RXDataAvailable  := TRUE; 
          
          if pPort^.TXBuffer.ActPtr <> pPort^.TXBuffer.PtrNextFree 
             & pPort^.TXBuffer.Index > 0 //BLEERN 26.01.2010
          then
            //Caller of SendData must ensure that there is data to be sent! - not possible within sendData: bus would not be turned off!
            SendData(Com := Com); //send next byte
          else
            Dummy := pPort^.Register.ModemControl^;
            Dummy$t_ModemControl.RequestToSend := 0;
            pPort^.Register.ModemControl^ := Dummy; //turn bus off
          end_if;

        else

          DataAvail := TRUE;
          while DataAvail = TRUE do
                      
            if pPort^.RXBuffer.ActPtr > pPort^.RXBuffer.EndOfBuffer then
              pPort^.RXBuffer.ActPtr := pPort^.RXBuffer.StartPtr;  
              pPort^.RXBuffer.Index  := 0;   
            end_if;
              
            pPort^.RXBuffer.ActPtr^      := pPort^.Register.ReceiverBuffer^;
            //pPort^.RXBuffer.ActPtr       += 1;
            ((pPort + t_port.RXBuffer.ActPtr)$^pVoid)^ += 1;
            //pPort^.RXBuffer.Index        += 1;
            ((pPort + t_port.RXBuffer.Index)$^UDINT)^ += 1;
            pPort^.RXBuffer.PtrNextFree  := pPort^.RXBuffer.ActPtr;

            pPort^.RXDataAvailable  := TRUE; 

            Dummy := pPort^.Register.LineStatus^;
            if Dummy$t_LineStatus.DataReady = 0 then             
//            if pPort^.Register.LineStatus^.DataReady = 0 then             
              DataAvail := FALSE;
            end_if;

          end_while;
                   
        end_if;
       
      else
        pPort^.ActError := SERERROR_PARITY;
      end_if;
      
    IRQRECEIVERLINESTATUS:

      Dummy := pPort^.Register.LineStatus^;  //read register to quit IRQ
      
     IRQMODEMSTATUS:

      Dummy := pPort^.Register.ModemStatus^; //read register to quit IRQ

  end_case;
#endif

END_FUNCTION
#pragma warning(default:76);
#pragma warning(default:73);
#pragma warning(default:72);


FUNCTION CSI022_Base::CheckSendTimeout
	VAR_INPUT
		pPort 	: ^t_port;
	END_VAR
	VAR_OUTPUT
		Occured 	: BOOL;
	END_VAR
  VAR
  	ByteCount : UDINT;
    BaudValue : UDINT;
  END_VAR

  // get the timeout for a send depending on the mode and the baudrate
  if pPort^.SendTimeOut = 0 then
        
    if pPort^.Mode = 485 then
      ByteCount := 1;
    else
      ByteCount := 15;
    end_if;
    
    case pPort^.Info.Baudrate of
      SERUSERBAUD_300:    BaudValue :=    300;
      SERUSERBAUD_600:    BaudValue :=    600;
      SERUSERBAUD_1200:   BaudValue :=   1200;
      SERUSERBAUD_2400:   BaudValue :=   2400;
      SERUSERBAUD_4800:   BaudValue :=   4800;
      SERUSERBAUD_9600:   BaudValue :=   9600;
      SERUSERBAUD_14400:  BaudValue :=  14400;
      SERUSERBAUD_19200:  BaudValue :=  19200;
      SERUSERBAUD_38400:  BaudValue :=  38400;
      SERUSERBAUD_56000:  BaudValue :=  56000;
      SERUSERBAUD_115200: BaudValue := 115200;
    end_case;
    
    // calculate send timeout in ms (we triple the normal sending time), but it's gotta be at least 50ms
    pPort^.SendTimeOut := 3 * 1000 * ByteCount / (BaudValue / pPort^.WordLength );
    
    if pPort^.SendTimeOut < 50 then
      pPort^.SendTimeOut := 50;
    end_if;
  end_if;

  Occured := (pPort^.TXBuffer.Index > 0) & ((ops.tAbsolute - pPort^.LastSendTime) > pPort^.SendTimeOut);

END_FUNCTION


FUNCTION VIRTUAL CSI022_Base::GetKennung
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR

  output := CSIKENNUNG;
  
END_FUNCTION
