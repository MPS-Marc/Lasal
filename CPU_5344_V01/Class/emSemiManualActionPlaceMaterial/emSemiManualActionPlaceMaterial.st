//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "emSemiManualActionPlaceMaterial"
	Revision           = "1.0"
	GUID               = "{CA744E59-A7F0-4BB3-8FF6-1AB586D1DBE3}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(690,1560)">
	<Channels>
		<Server Name="parActionWindow1" GUID="{48601B76-FD26-43C1-AF48-A1FA60779544}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeCloseWindow" GUID="{A3ABC147-B224-4FB3-89FF-F4958FC55310}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="setOk" GUID="{C9501267-7556-470A-B160-664B2BE5402E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="ctrlClamp" Required="false" Internal="false"/>
		<Client Name="ctrlWindow" Required="false" Internal="false"/>
		<Client Name="iControlClamp" Required="true" Internal="false"/>
		<Client Name="multipleClamps" Required="true" Internal="true"/>
	</Channels>
	<Network Name="emSemiManualActionPlaceMaterial">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{44601B7C-5F25-4E36-AA43-C4C6E356ECEE}"
				Class      = "emBase"
				Position   = "(308,150)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="cmdWaitReset"/>
					<Server Name="ErrorNr"/>
					<Server Name="includesUnit"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stprAction"/>
					<Server Name="stprMoving"/>
					<Server Name="stprState"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateCompleted"/>
					<Server Name="thisIsUnit"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
			<Object
				Name       = "multipleClamps"
				GUID       = "{40E57DAB-C65D-437C-9340-70034CF82E05}"
				Class      = "cmMultipleCil"
				Position   = "(360,1230)"
				Visualized = "true"
				CyclicTime = "10 ms">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="parBetw1and2Out"/>
					<Server Name="parBetw2and1In"/>
					<Server Name="parBetw2and3Out"/>
					<Server Name="parBetw3and2In"/>
					<Server Name="parBetw3and4Out"/>
					<Server Name="parBetw4and3In"/>
					<Server Name="parDontSetToAutoAlways" Value="0"/>
					<Server Name="state"/>
					<Server Name="stsGoal"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsPos"/>
					<Client Name="ctrlCil1"/>
					<Client Name="ctrlCil2"/>
					<Client Name="ctrlCil3"/>
					<Client Name="ctrlCil4"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1246,210),(1074,240),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1246,270),(1074,300),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1246,330),(1074,360),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1246,390),(1074,420),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1246,450),(1074,480),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1246,510),(1074,540),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1246,570),(1074,600),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1246,630),(1074,660),"/>
			<Connection Source="this.stprAction" Destination="_base.stprAction" Vertices="(1246,690),(1074,780),"/>
			<Connection Source="this.stprMoving" Destination="_base.stprMoving" Vertices="(1246,750),(1074,840),"/>
			<Connection Source="this.stprState" Destination="_base.stprState" Vertices="(1246,810),(1074,900),"/>
			<Connection Source="this.stsStateCompleted" Destination="_base.stsStateCompleted" Vertices="(1246,870),(1074,960),"/>
			<Connection Source="this.thisIsUnit" Destination="_base.thisIsUnit" Vertices="(1246,930),(1074,1200),"/>
			<Connection Source="this.includesUnit" Destination="_base.includesUnit" Vertices="(1246,990),(1074,1260),"/>
			<Connection Source="this.multipleClamps" Destination="multipleClamps.ClassSvr"/>
			<Connection Source="multipleClamps.nwEmOrUnit" Destination="_base.ClassSvr" Vertices="(360,1320),(300,1320),(300,120),(1080,120),(1074,240),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(308,240),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(308,300),(38,270),"/>
			<Connection Source="multipleClamps.id" Destination="this.id" Vertices="(360,1380),(270,1380),(270,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using emBase

emSemiManualActionPlaceMaterial : CLASS
: emBase
  //Servers:
	parActionWindow1 	: SvrCh_DINT;
	setOk 	: SvrCh_DINT;
	parTimeCloseWindow 	: SvrCh_UDINT;
  //Clients:
	multipleClamps 	: CltChCmd_cmMultipleCil;
	ctrlWindow 	: CltChCmd_ScreenCtrl;
	ctrlClamp 	: CltChCmd_cmMultipleCil;
	iControlClamp 	: CltCh_DINT;
  //Variables:
		clampIsConnected 	: DINT;
		screenIsConnected 	: DINT;
		stsPosClamp 	: cilPos;
		oldbuttonClamp 	: DINT;
		timerCloseWindow 	: strTimer;
  //Functions:
	
	FUNCTION VIRTUAL execHmiCmd4;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL execResetting;
	
	FUNCTION VIRTUAL execStarting;
	
	FUNCTION VIRTUAL execExecute;
	
	FUNCTION VIRTUAL execHeld;
	
	FUNCTION VIRTUAL execUnHolding;
	
	FUNCTION VIRTUAL execSuspended;
	
	FUNCTION VIRTUAL execUnSuspending;
	
	FUNCTION Prescan1;
	
	FUNCTION VIRTUAL runAction;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using cmMultipleCil
#pragma usingLtd ScreenCtrl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB emSemiManualActionPlaceMaterial::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_EMSEMIMANUALACTIONPLACEMATERIAL
1$UINT, 0$UINT, (SIZEOF(::emSemiManualActionPlaceMaterial))$UINT, 
3$UINT, 4$UINT, 0$UINT, 
TO_UDINT(3127818471), "emSemiManualActionPlaceMaterial", //Class
TO_UDINT(2572249677), "emBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::emSemiManualActionPlaceMaterial.parActionWindow1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3286711284), "parActionWindow1", 
(::emSemiManualActionPlaceMaterial.setOk.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3892422583), "setOk", 
(::emSemiManualActionPlaceMaterial.parTimeCloseWindow.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(302284101), "parTimeCloseWindow", 
//Clients:
(::emSemiManualActionPlaceMaterial.multipleClamps.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2975039459), "multipleClamps", TO_UDINT(3389912646), "cmMultipleCil", 0$UINT, 0$UINT, 
(::emSemiManualActionPlaceMaterial.ctrlWindow.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3889148129), "ctrlWindow", TO_UDINT(4196661951), "ScreenCtrl", 0$UINT, 0$UINT, 
(::emSemiManualActionPlaceMaterial.ctrlClamp.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2380244622), "ctrlClamp", TO_UDINT(3389912646), "cmMultipleCil", 0$UINT, 0$UINT, 
(::emSemiManualActionPlaceMaterial.iControlClamp.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3561163754), "iControlClamp", 
END_FUNCTION


#define USER_CNT_emSemiManualActionPlaceMaterial 41

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_emSemiManualActionPlaceMaterial] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION emSemiManualActionPlaceMaterial::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= emBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_emSemiManualActionPlaceMaterial;
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #execHmiCmd4();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #execResetting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #execStarting();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[23]		:= #execExecute();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[27]		:= #execHeld();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[28]		:= #execUnHolding();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[34]		:= #execSuspended();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[35]		:= #execUnSuspending();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[40]		:= #runAction();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parActionWindow1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parActionWindow1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	setOk.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF setOk.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeCloseWindow.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeCloseWindow.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// RVDL class to do both auto and manual action for a cilinder. 
// this is based on emMAnualactionPlacematerial originaly used for 4284 trafiroad by JdK which was modified for 4468 Nijburg products

// simple class to make it possible to activate window with code
// if window is activated try to go to hold

// RVDL 8-8-2019 Error 1 = action not recognized
// First action is for open/close cycle of the gripper
// second action is to release material on completion of production program
// RVDL 27-9-2019 change window control from datachannel to object channel

// RVDL 2-10-2019 so this class is suitable for both manual action as well an automatic control.

// RVDl 18-10-2019 Added button control to hmicmd4 so clamp can be controlled via button while in manual mode

// errornr 1: unkown action from calculation
// errornr 51: place material by hand

FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::Init1
  
  //check connected equipment
  IF initDone=0 THEN
    clampIsConnected:=IsClientConnected(input:=#ctrlClamp);
    screenIsConnected:=IsClientConnected(input:=#ctrlWindow);
    initDone:=1;
  END_IF;
  
END_FUNCTION 

FUNCTION emSemiManualActionPlaceMaterial::Prescan1
  
  iControlClamp := iControlClamp.Read();  
  timerCloseWindow:= runTimer(Active:=stprState = 0 & pmlCom.sts.state = UnSuspending, iMem:=timerCloseWindow, TimerTime:=parTimeCloseWindow, Pause:=FALSE);    
  
  //get position of cilinder
  IF clampIsConnected=1 THEN
    stsPosClamp:=ctrlClamp.stsPos;
  ELSE
    stsPosClamp := cilNotConnected;
  END_IF;

END_FUNCTION

FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::work
  
  Prescan1();


  IF pmlCom.cmd.state= Execute & stprAction>=30 & stprAction <=35 THEN // only go to suspended in third action
    pmlCom.sts.stateReq.ID:=id;
    pmlCom.sts.stateReq.state:=Suspending;
  END_IF;
  
END_FUNCTION
FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execExecute

  runAction();

  IF stprAction=0 THEN
     stprState:=1000; //only state completed if action is done
  ELSE
     stprState:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execUnSuspending
 
  //during unsuspending just send clamp back to last position it was sended by a S-line, or if manual action was active wait until clamp closed
  CASE stprState OF
  
  0: //restart action
    IF actionLine.actione <> 0 THEN //only if we have a s-line with an action
      IF actionLine.actione = 3 THEN
        // check if clamp is at right pos before we go to Execute
        IF  stsPosClamp = cilOut | stsPosClamp = cilNotConnected THEN 
          IF screenIsConnected= 0 | (ctrlWindow.ActWindow = -1 & timerCloseWindow.done) THEN
            stprAction :=0;
          ELSIF timerCloseWindow.done THEN
            ctrlWindow.CloseWindow:=1;
          END_IF;
        resetAlarm();
        ELSE
          stprAction :=30;
        END_IF;
        stprState:= 1000;        
      ELSE
        stprAction:=1;
        stprState+=1;
      END_IF;
    ELSE
      stprState+=2;
    END_IF;
    
  1: //wait until action is done
    runAction(); //just go to last s-line position/wait until clamp closed
    IF stprAction= 0 THEN
      stprState+=1;
    END_IF;
    
  2: //done
    stprState:=1000;
    
  1000: //ready
  
  ELSE
    stprState:= 0;
  
  END_CASE;
 
 
 
END_FUNCTION


FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execUnHolding

  execUnSuspending();

END_FUNCTION


FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execResetting
 //RVDL 31-7-2019 here we reset the gripper on PU1. although the gripper is mounted on Pu1 is is still controlled through a manual action.
 
 CASE stprState OF
  
  0: //reset steppers
    stprAction:=0;
    IF pmlCom.cmd.reRun= 0 THEN
      _memset(dest:=#actionLine, usByte:=0, cntr:=sizeof(actionLine)); //JdK 15-8-2022 remove all old running information
      stprState+=1;
    ELSE
      stprState+=2; //don't open clamp if rerun is active JdK 21-10-2019
    END_IF;
    
  1: //open clamp
    IF clampIsConnected=0 | stsPosClamp= cilIn THEN
      stprState+=1;
    ELSE
      ctrlClamp.csMoveIn();
    END_IF;
     
  2: //done
    stprState:=1000;
    
  1000: //ready   
  
 END_CASE;
  
END_FUNCTION


FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execHeld
 
  execExecute();
 
  
END_FUNCTION

FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::runAction

  CASE stprAction OF
  
  1: // check what to do
    CASE actionLine.actione OF
    
    CILDICHT: 
      stprAction:=10; // action for auto clamping
     
    CILOPEN: 
      stprAction:=20; // action for auto release clamp
      
    3:   
      stprAction:=30; //action for manual clamping at start of production
    
    ELSE
      giveAlarm(errorNr:=1);
    END_CASE;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

  10: //RVLD 2-10-2019 Action to auto Clamp Material
    IF stsPosClamp=cilOut | stsPosClamp=cilNotConnected THEN
      stprAction +=1;
    ELSIF clampIsConnected= 1 THEN
      ctrlClamp.csMoveOut();
    END_IF;
 
  11: //done
    stprAction:=0;
      
      
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

  20: //RVLD 8-8-2019 Action to auto release Material
    IF stsPosClamp=cilIn | stsPosClamp=cilNotConnected THEN
      stprAction +=1;
    ELSIF clampIsConnected= 1 THEN
      ctrlClamp.csMoveIn();
    END_IF;
    
  21: //done
      stprAction:=0;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
/// manual action for clamping material at start production

  30: //set window
    IF screenIsConnected THEN
      IF ctrlWindow.ActWindow <> parActionWindow1 THEN // don't open windows again
        ctrlWindow.ReqWindow.Write(input:=parActionWindow1);
      ELSE
        ctrlWindow.CloseWindow.Write(input:=-1);
      END_IF;
    ELSE //IT 4-3-2022 give alarm instead of a message to inform the operator
      giveAlarm(errorNr:=51);
    END_IF;
    setOk:=0;
    stprAction+=1;

  31: // Check if we want to open or close the clamp
    IF iControlClamp =1 & oldbuttonClamp =0 THEN
      IF stsPosClamp =cilNotConnected THEN
        stprAction +=3;
      ELSIF stsPosClamp =cilin THEN
        stprAction +=1;
      ELSIF stsPosClamp =cilOut THEN
        stprAction +=2;
      END_IF;
    END_IF;
  
  32: //  grip material. 
    IF stsPosClamp=cilOut | stsPosClamp=cilNotConnected THEN
      stprAction +=2;
      setOk :=1;
    ELSIF clampIsConnected= 1 THEN
      ctrlClamp.csMoveOut();
    END_IF;


  33: // release material.
    IF stsPosClamp=cilIn | stsPosClamp=cilNotConnected THEN
      stprAction +=1;
      setOk :=0;
    ELSIF clampIsConnected= 1 THEN
      ctrlClamp.csMoveIn();
    END_IF;
  
  34: //close window
    IF screenIsConnected= 0 | ctrlWindow.ActWindow=-1 THEN
      IF clampIsConnected= 0 THEN
        stprAction := 0; //that's it
      ELSE
        stprAction:= 31; //possible to open/close clamp again
      END_IF;
    ELSE
      stprAction+=1;
      ctrlWindow.CloseWindow.Write(input:=-1);
    END_IF;  
  
  35: //wait some time before trying to close window again
    IF timerCloseWindow.done THEN
      stprAction-= 1;
    END_IF;
    
    
  END_CASE;
  
   oldbuttonClamp:=iControlClamp; //Evaluate the Button for the Gripper to prevent loop
  
END_FUNCTION







FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execHmiCmd4
  IF pmlCom.sts.mode = manual & clampIsConnected=1 THEN // action works only in manual and has clamps connected
    IF stprAction = 0 THEN  // toggle between action depending on pos cil
      IF stsPosClamp = cilIn THEN
        ctrlClamp.csMoveOut();
      ELSE
        ctrlClamp.csMoveIn();
      END_IF;
    END_IF;
  END_IF;
END_FUNCTION


FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execStarting

  IF pmlCom.cmd.reRun= 1 THEN
    execUnSuspending(); //do same thing as during unsuspending, send back to last S-line position
  ELSE
    _memset(dest:=#actionLine, usByte:=0, cntr:=sizeof(actionLine));
    execResetting(); //just open clamps
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL emSemiManualActionPlaceMaterial::execSuspended
  //execExecute();
END_FUNCTION
