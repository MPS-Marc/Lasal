//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "cmCil"
	Revision           = "1.0"
	GUID               = "{7212EFFB-3DF9-4D2C-88F5-0DCC182FBF96}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "500 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(480,840)">
	<Channels>
		<Server Name="parTimeToIn" GUID="{8CF351F3-47CC-4ED9-90E4-1ED04D7FBE2D}" Visualized="true" Initialize="true" DefValue="500" WriteProtected="false" Retentive="File"/>
		<Server Name="parTimeToOut" GUID="{ABBB6994-961C-475A-B0B9-B5F8B42C2D1A}" Visualized="true" Initialize="true" DefValue="500" WriteProtected="false" Retentive="File"/>
		<Server Name="stsPos" GUID="{C4A020E7-01FB-4ADD-A1DD-807CB5AE9D20}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="actual position of cilinder"/>
		<Client Name="iEsIn" Required="false" Internal="false" Comment="optional endswitch for pos in"/>
		<Client Name="iEsOut" Required="false" Internal="false" Comment="optional endswitch for position out"/>
		<Client Name="iLivePos" Required="false" Internal="false" Comment="optional actual pos to check with"/>
		<Client Name="oIn" Required="false" Internal="false" Comment="optional output for position in"/>
		<Client Name="oOut" Required="false" Internal="false" Comment="optional output for position out"/>
		<Client Name="sCheckLimitForIn" Required="false" Internal="false" Comment="check pos before sending in"/>
		<Client Name="sCheckLimitForOut" Required="false" Internal="false" Comment="check pos before sending out"/>
		<Client Name="sInIsUnstable" Required="false" Internal="false" Comment="if active, change pos in unknown if interlocked and pos is in"/>
		<Client Name="sMaxFreePos" Required="false" Internal="false" Comment="maximum value of live pos to be ok with sending in/out"/>
		<Client Name="sMinFreePos" Required="false" Internal="false" Comment="minimum value of live pos to be ok with sending in/out"/>
		<Client Name="sOutIsUnstable" Required="false" Internal="false" Comment="if active, change pos in unknown if interlocked and pos is out"/>
		<Client Name="sTimeOut" Required="false" Internal="false" DefValue="15000" Comment="moste cils should be at position within 15 seconds"/>
	</Channels>
	<RevDoku>
		<Owner/>
		<Dokumentation Revision="0.2&#13;&#10;" Date="2020-03-10" Author="TP" Description="No time if sTimeOut is null"/>
		<Dokumentation Revision="0.1" Date="2019-10-29" Author="JdK" Description="time-out disconnected from time to in/out"/>
	</RevDoku>
	<Network Name="cmCil">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{A2A2590C-31EB-4985-8F3A-030102C00F85}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

cmCil : CLASS
: cmBase
  //Servers:
	stsPos 	: SvrCh_cilPos;
	parTimeToIn 	: SvrCh_UDINT;
	parTimeToOut 	: SvrCh_UDINT;
  //Clients:
	iEsIn 	: CltCh_DINT;
	iEsOut 	: CltCh_DINT;
	oIn 	: CltCh_DINT;
	oOut 	: CltCh_DINT;
	iLivePos 	: CltCh_DINT;
	sMaxFreePos 	: CltCh_DINT;
	sMinFreePos 	: CltCh_DINT;
	sCheckLimitForIn 	: CltCh_DINT;
	sCheckLimitForOut 	: CltCh_DINT;
	sInIsUnstable 	: CltCh_DINT;
	sOutIsUnstable 	: CltCh_DINT;
	sTimeOut 	: CltCh_UDINT;
  //Variables:
		esInConnected 	: DINT;
		esOutConnected 	: DINT;
		timerIn 	: strTimer;
		timerOut 	: strTimer;
		timeOutTimer 	: strTimer;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL execHmiCmd1;
	
	FUNCTION VIRTUAL execHmiCmd3;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION VIRTUAL GLOBAL csMoveIn;
	
	FUNCTION VIRTUAL GLOBAL csMoveOut;
	
	FUNCTION VIRTUAL moveIn;
	
	FUNCTION VIRTUAL moveOut;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB cmCil::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CMCIL
1$UINT, 0$UINT, (SIZEOF(::cmCil))$UINT, 
3$UINT, 12$UINT, 0$UINT, 
TO_UDINT(2617417482), "cmCil", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::cmCil.stsPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3335286665), "stsPos", 
(::cmCil.parTimeToIn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2461638760), "parTimeToIn", 
(::cmCil.parTimeToOut.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1346674050), "parTimeToOut", 
//Clients:
(::cmCil.iEsIn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3777916184), "iEsIn", 
(::cmCil.iEsOut.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3308403), "iEsOut", 
(::cmCil.oIn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(878218036), "oIn", 
(::cmCil.oOut.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(843014518), "oOut", 
(::cmCil.iLivePos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(178957654), "iLivePos", 
(::cmCil.sMaxFreePos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(500077139), "sMaxFreePos", 
(::cmCil.sMinFreePos.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(482478311), "sMinFreePos", 
(::cmCil.sCheckLimitForIn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2147118737), "sCheckLimitForIn", 
(::cmCil.sCheckLimitForOut.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2496173300), "sCheckLimitForOut", 
(::cmCil.sInIsUnstable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4278698072), "sInIsUnstable", 
(::cmCil.sOutIsUnstable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(290730568), "sOutIsUnstable", 
(::cmCil.sTimeOut.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2648932282), "sTimeOut", 
END_FUNCTION


#define USER_CNT_cmCil 23

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_cmCil] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION cmCil::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_cmCil;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #execHmiCmd1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #execHmiCmd3();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #csMoveIn();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #csMoveOut();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[21]		:= #moveIn();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[22]		:= #moveOut();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stsPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeToIn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeToIn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parTimeToOut.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parTimeToOut.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 12-8-2022: also give alarms if sensors are changing unexpected

// JdK 29-10-2019: added time out timer to disconnect time to in and to out from alarm

// JdK 17-5-2019 class cil, created for library icm project 4284 TraffiRoad 
// goal is to send cilinder in of out, and check on time or on endswitch
// Alarm errornrs:
//                  1: time out in
//                  2: time out out
//                  3: both sensors are active
//                  4: es in gone without reason
//                  5: es out appeared without reason
//                  6: es out gone without reason
//                  7: es in appeared without reason

// HMI cmd1: move in, HMI cmd3: move out

FUNCTION VIRTUAL GLOBAL cmCil::csMoveIn

  //if in auto or service send to in
  IF pmlCom.sts.mode=auto | pmlCom.sts.mode= service THEN 
    moveIn();
  END_IF;
  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmCil::csMoveOut

  //if in auto or service send to out
  IF pmlCom.sts.mode=auto | pmlCom.sts.mode= service THEN 
    moveOut();
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL cmCil::execHmiCmd1

  //if in right mode this method is called if HMIcmd gets this request
  moveIn();
  
END_FUNCTION


FUNCTION VIRTUAL cmCil::execHmiCmd3

  //if in right mode this method is called if HMIcmd gets this request
  moveOut();

END_FUNCTION


FUNCTION VIRTUAL cmCil::moveIn

  IF pmlCom.sts.isInterlocked=0 & (sCheckLimitForIn= 0 | (iLivePos<=sMaxFreePos & iLivePos>=sMinFreePos)) THEN //changing only allowed if not interlocked and position ok
    IF stsPos <> cilMovingIn & stsPos <> cilIn THEN
      stsPos:=cilMovingIn;
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmCil::moveOut

  IF pmlCom.sts.isInterlocked=0 & (sCheckLimitForOut= 0 | (iLivePos<=sMaxFreePos & iLivePos>=sMinFreePos)) THEN //changing only allowed if not interlocked and position ok
    IF stsPos <> cilMovingOut & stsPos <> cilOut THEN //only if not already in position
      stsPos:=cilMovingOut;
    END_IF;
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL cmCil::work

  CASE stsPos OF
  
  cilUnknown: //just wait for command move in or move out, if es is active move to that side
    IF iEsIn=1 & iEsOut=0 & pmlCom.cmd.simulation<>allSimu & stsInAlarm=0 THEN
      stsPos:=cilIn;
    ELSIF iEsIn=0 & iEsOut=1 & pmlCom.cmd.simulation<>allSimu & stsInAlarm=0 THEN
      stsPos:=cilOut;
    ELSIF iEsIn=1 & iEsOut=1 & pmlCom.cmd.simulation<>allSimu THEN
      giveAlarm(errorNr:=3);
    END_IF;
    
  cilIn:
    IF (((esInConnected=1 & iEsIn=0) | (esOutConnected=1 & iEsOut=1)) & pmlCom.cmd.simulation<>allSimu & timerIn.done) | (pmlCom.sts.isInterlocked=1 & sInIsUnstable=1) THEN //JdK 18-1-2022: only check es after timer is done
      (*JdK 20-12-2021 still dont give alarm for this*)
      IF (esInConnected= 1 & iEsIn= 0) & stsIsInterlocked= 0 THEN
        giveAlarm(errorNr:=4);
      ELSIF (esOutConnected= 1 & iEsOut= 1) & stsIsInterlocked= 0 THEN
        giveAlarm(errorNr:=5);
      END_IF;
      stsPos:=cilUnknown; //go back to pos unkown if something is wrong with the endswitches, of during interlock
    ELSE
      oIn:=1;
    END_IF;
    
  cilOut:
    IF (((esOutConnected=1 & iEsOut=0) | (esInConnected=1 & iEsIn=1)) & pmlCom.cmd.simulation<>allSimu & timerOut.done) | (pmlCom.sts.isInterlocked=1 & sOutIsUnstable=1) THEN //JdK 18-1-2022: only check es after timer is done     
      (*JdK 20-12-2021 still dont give alarm for this*)
      IF (esOutConnected= 1 & iEsOut= 0) & stsIsInterlocked= 0  THEN
        giveAlarm(errorNr:=6);
      ELSIF (esInConnected=1 & iEsIn= 1) & stsIsInterlocked= 0 THEN
        giveAlarm(errorNr:=7);
      END_IF;
      stsPos:=cilUnknown; //go back to pos unkown if something is wrong with the endswitches, of during interlock
    ELSE
      oOut:=1;
    END_IF;
        
  cilMovingOut:
    oOut:=1; //during moving to out always send to out
    IF pmlCom.sts.isInterlocked= 1 THEN
      stsPos:=cilUnknown; //during interlock, stop sending to out
    ELSIF timerOut.Done=1 | (iEsOut=1 & iEsIn=0 & esOutConnected=1) THEN
      IF (iEsOut=1 | esOutConnected=0 | pmlCom.cmd.simulation =allSimu) & iEsIn=0 THEN
        stsPos:=cilOut; //position change to out if time is done, only if es isn't connected or during simulation
      ELSIF timeOutTimer.done & sTimeOut > 0 THEN //TP 10-03-2020 don't time out als timer is zerro
        giveAlarm(errorNr:=2);
        stsPos:=cilUnknown;
      END_IF;
    END_IF;
    
  cilMovingIn:
    oIn:=1; //during moving to in always send to in
    IF pmlCom.sts.isInterlocked= 1 THEN
      stsPos:=cilUnknown; //if interlocked stop sending to in
    ELSIF timerIn.Done=1 | (iEsIn=1 & iEsOut=0 & esInConnected=1) THEN
      IF (iEsIn=1 | esInConnected=0 | pmlCom.cmd.simulation=allSimu) & iEsOut=0 THEN
        stsPos:=cilIn; //simulation or es not used, after timer change to in
      ELSIF timeOutTimer.done & sTimeOut > 0 THEN
        giveAlarm(errorNr:=1); //time out
        stsPos:=cilUnknown;
      END_IF;
    END_IF;
        
  
  END_CASE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL cmCil::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  //read in slow changing values
  sMaxFreePos := sMaxFreePos.Read();
  sMinFreePos := sMinFreePos.Read();
  sCheckLimitForIn := sCheckLimitForIn.Read();
  sCheckLimitForOut := sCheckLimitForOut.Read();
  sInIsUnstable := sInIsUnstable.Read();
  sOutIsUnstable := sOutIsUnstable.Read();
  sTimeOut:= sTimeOut.Read();

  state:= 0;

END_FUNCTION


FUNCTION VIRTUAL cmCil::Init1

  //check if endswitches are connected
  IF initDone = 0 THEN
    esInConnected:=IsClientConnected(#iEsIn);
    esOutConnected:=IsClientConnected(#iEsOut);
    sInIsUnstable:=sInIsUnstable.Read(); //don't wait for first background before reading this
    sOutIsUnstable:=sOutIsUnstable.Read();
    sTimeOut:= sTimeOut.Read();
    initDone:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmCil::preScanOverride

//preScan reads in al values before handling the actions

  //first read in all values
  IF esInConnected THEN
    iEsIn:=iEsIn.Read();
  END_IF;
  IF esOutConnected THEN
    iEsOut:=iEsOut.Read();
  END_IF;
  iLivePos:=iLivePos.Read();
  
  //then call timers
  timerIn:=runTimer(Active:=(stsPos=cilMovingIn | stsPos= cilIn), iMem:=timerIn, TimerTime:=parTimeToIn, Pause:=FALSE); //JdK 18-1-2022 let timer go on, so we also can use it to control sensors gone
  timerOut:=runTimer(Active:=(stsPos=cilMovingOut | stsPos= cilOut), iMem:=timerOut, TimerTime:=parTimeToOut, Pause:=FALSE);
  timeOutTimer:= runTimer(Active:=(stsPos=cilMovingIn | stsPos= cilMovingOut), iMem:=timeOutTimer, TimerTime:=sTimeOut, Pause:=FALSE);
  
  //every cycle set outputs to 0, set them again if asked
  oIn:=0;
  oOut:=0;


END_FUNCTION


FUNCTION VIRTUAL cmCil::postScanOverride

  //write outputs
  oIn.Write(input:=oIn);
  oOut.Write(input:=oOut);
  
  //check alarmstatus
  IF _Alarm.AlarmActief THEN
    stsInAlarm:=1;
  ELSE
    stsInAlarm:=0;
  END_IF;
  

END_FUNCTION
