//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "checkReleaseYservoSaw"
	Revision           = "0.0"
	GUID               = "{99A5ED27-3EA9-4EFA-BCCB-48FC2F20A199}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(642,120)">
	<Channels>
		<Server Name="overruleCheck" GUID="{20E4AB7B-A605-4B6A-92AA-0489FD4DD876}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="releaseServo" GUID="{0901A5D6-624D-4629-BEBF-F573923CC282}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="ctrlServo" Required="true" Internal="false"/>
		<Client Name="iHydroPumpOn" Required="true" Internal="false"/>
		<Client Name="iOperationsDone" Required="true" Internal="false"/>
	</Channels>
	<Network Name="checkReleaseYservoSaw">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{4178DC79-A171-4DB3-A24B-16B28500578D}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

checkReleaseYservoSaw : CLASS
: cmBase
  //Servers:
	releaseServo 	: SvrCh_DINT;
	overruleCheck 	: SvrCh_DINT;
  //Clients:
	ctrlServo 	: CltChCmd_cmServo;
	iOperationsDone 	: CltCh_DINT;
	iHydroPumpOn 	: CltCh_DINT;
  //Variables:
		ok1 	: DINT;
		ok2 	: DINT;
		ok3 	: DINT;
		ok4 	: DINT;
		ok5 	: DINT;
		ok6 	: DINT;
		movesNegative 	: DINT;
		movesPositive 	: DINT;
		reqOperAllowed 	: DINT;
		tmpMinPos 	: DINT;
		tmpMaxPos 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL releaseServo::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd cmServo


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB checkReleaseYservoSaw::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CHECKRELEASEYSERVOSAW
0$UINT, 0$UINT, (SIZEOF(::checkReleaseYservoSaw))$UINT, 
2$UINT, 3$UINT, 0$UINT, 
TO_UDINT(3059845464), "checkReleaseYservoSaw", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::checkReleaseYservoSaw.releaseServo.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(39189928), "releaseServo", 
(::checkReleaseYservoSaw.overruleCheck.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3432355606), "overruleCheck", 
//Clients:
(::checkReleaseYservoSaw.ctrlServo.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2859050432), "ctrlServo", TO_UDINT(3985303601), "cmServo", 1$UINT, 0$UINT, 
(::checkReleaseYservoSaw.iOperationsDone.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1789203248), "iOperationsDone", 
(::checkReleaseYservoSaw.iHydroPumpOn.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3331417159), "iHydroPumpOn", 
END_FUNCTION


#define USER_CNT_checkReleaseYservoSaw 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_checkReleaseYservoSaw] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION checkReleaseYservoSaw::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_checkReleaseYservoSaw;
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	releaseServo.pMeth			:= StoreMethod( #releaseServo::Read(), #M_NO_F() );
	IF releaseServo.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	overruleCheck.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF overruleCheck.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 20-11-2019 several releases for several servo's 4255



FUNCTION VIRTUAL GLOBAL checkReleaseYservoSaw::releaseServo::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR


  movesNegative:= ctrlServo.stsPos >= (ctrlServo.reqPos + 20); //20 because of possible overshoot
  movesPositive:= ctrlServo.stsPos <= (ctrlServo.reqPos - 20); //20 because of possible overshoot
  reqOperAllowed:= 0;
  iOperationsDone:= iOperationsDone.Read();
  iHydroPumpOn:= iHydroPumpOn.Read();
  
  
  ok1:= iOperationsDone; //only allowed to move is saw is up
  ok2:= iHydroPumpOn; //also hydropump should be on, because else brakes can't be released
  ok3:= 1;
  ok4:= 1;
  ok5:= 1;
  ok6:= 1;


  IF (ok1 & ok2 & ok3 & ok4 & ok5 & ok6) | overruleCheck THEN
    releaseServo:= 1;
  ELSE
    releaseServo:= 0;
    IF ok1= 0 THEN
      giveAlarm(errorNr:=1);
    ELSIF ok2= 0 THEN
      giveAlarm(errorNr:=2);
    ELSIF ok3= 0 THEN
      giveAlarm(errorNr:=3);
    ELSIF ok4= 0 THEN
      giveAlarm(errorNr:=4);
    ELSIF ok5= 0 THEN
      giveAlarm(errorNr:=5);
    ELSIF ok6= 0 THEN
      giveAlarm(errorNr:=6);      
    END_IF;
  END_IF;

	output := releaseServo;

END_FUNCTION
