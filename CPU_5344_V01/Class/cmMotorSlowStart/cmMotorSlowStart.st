//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "cmMotorSlowStart"
	Revision           = "1.0"
	GUID               = "{BF99479B-533F-42E2-A558-FFE6DB0D664A}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,1140)">
	<Channels>
		<Server Name="cycleHeatUp" GUID="{84AE8211-7B6E-47A1-803C-C09C71E88A61}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="parMinimumTimeFeedback" GUID="{EC90C51E-0B99-44B6-86F0-F7E3E68D015C}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="sParStartingSteps" GUID="{7538C6A1-F267-4D78-BE76-B50B5E459F5C}" Visualized="false" Initialize="true" DefValue="4" WriteProtected="false" Retentive="false"/>
		<Server Name="sParTimeProStep" GUID="{BF00A3BE-3659-4E49-AD98-5F8A7D6B0DCC}" Visualized="false" Initialize="true" DefValue="1200000" WriteProtected="false" Retentive="false"/>
		<Server Name="sParTimeWarmAgain" GUID="{672CC52B-2A9E-47CF-A5C2-10EEBCB73839}" Visualized="false" Initialize="true" DefValue="3600000" WriteProtected="false" Retentive="false"/>
		<Server Name="stprHeatUp" GUID="{F69639C6-5BC1-45AF-B4CE-9774C45226A5}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="iMotorStandStill" Required="false" Internal="false"/>
		<Client Name="iToolOk" Required="true" Internal="false"/>
		<Client Name="oCooling" Required="true" Internal="false"/>
		<Client Name="sparDisableCooling" Required="false" Internal="false"/>
	</Channels>
	<Network Name="cmMotorSlowStart">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{371698C2-3913-4A4B-906C-9B3067775925}"
				Class      = "cmMotor"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="parMinTimeBetweenRev"/>
					<Server Name="parSpeed"/>
					<Server Name="parStartingTime" Value="2000"/>
					<Server Name="parTimeOutTime" Value="20000"/>
					<Server Name="state"/>
					<Server Name="stsBwd"/>
					<Server Name="stsFwd"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Server Name="stsStateRun"/>
					<Client Name="id"/>
					<Client Name="iFeedback"/>
					<Client Name="iHWAlarm"/>
					<Client Name="iThermFailure"/>
					<Client Name="nwEmOrUnit"/>
					<Client Name="oBwd"/>
					<Client Name="oFwd"/>
					<Client Name="oSpeed"/>
					<Client Name="sInvertFeedback"/>
					<Client Name="sInvertHWAlarm"/>
					<Client Name="sInvertThermFailure"/>
					<Client Name="sMaxSpeedIn" Value="1000"/>
					<Client Name="sMaxSpeedOut" Value="10000"/>
					<Client Name="sMinSpeedIn" Value="0"/>
					<Client Name="sMinSpeedOut" Value="0"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,450),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,510),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,630),"/>
			<Connection Source="this.stsStateRun" Destination="_base.stsStateRun" Vertices="(1036,690),(864,690),"/>
			<Connection Source="this.parTimeOutTime" Destination="_base.parTimeOutTime" Vertices="(1036,750),(864,750),"/>
			<Connection Source="this.parStartingTime" Destination="_base.parStartingTime" Vertices="(1036,810),(864,810),"/>
			<Connection Source="this.parMinTimeBetweenRev" Destination="_base.parMinTimeBetweenRev" Vertices="(1036,870),(864,870),"/>
			<Connection Source="this.parSpeed" Destination="_base.parSpeed" Vertices="(1036,930),(864,930),"/>
			<Connection Source="this.stsFwd" Destination="_base.stsFwd" Vertices="(1036,990),(864,990),"/>
			<Connection Source="this.stsBwd" Destination="_base.stsBwd" Vertices="(1036,1050),(864,1050),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.iThermFailure" Destination="this.iThermFailure" Vertices="(218,330),(38,330),"/>
			<Connection Source="_base.iHWAlarm" Destination="this.iHWAlarm" Vertices="(218,390),(38,390),"/>
			<Connection Source="_base.iFeedback" Destination="this.iFeedback" Vertices="(218,450),(38,450),"/>
			<Connection Source="_base.oFwd" Destination="this.oFwd" Vertices="(218,510),(38,510),"/>
			<Connection Source="_base.oBwd" Destination="this.oBwd" Vertices="(218,570),(38,570),"/>
			<Connection Source="_base.oSpeed" Destination="this.oSpeed" Vertices="(218,630),(38,630),"/>
			<Connection Source="_base.sInvertThermFailure" Destination="this.sInvertThermFailure" Vertices="(218,690),(38,690),"/>
			<Connection Source="_base.sInvertHWAlarm" Destination="this.sInvertHWAlarm" Vertices="(218,750),(38,750),"/>
			<Connection Source="_base.sInvertFeedback" Destination="this.sInvertFeedback" Vertices="(218,810),(38,810),"/>
			<Connection Source="_base.sMinSpeedOut" Destination="this.sMinSpeedOut" Vertices="(218,870),(38,870),"/>
			<Connection Source="_base.sMaxSpeedOut" Destination="this.sMaxSpeedOut" Vertices="(218,930),(38,930),"/>
			<Connection Source="_base.sMinSpeedIn" Destination="this.sMinSpeedIn" Vertices="(218,990),(38,990),"/>
			<Connection Source="_base.sMaxSpeedIn" Destination="this.sMaxSpeedIn" Vertices="(218,1050),(38,1050),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmMotor

cmMotorSlowStart : CLASS
: cmMotor
  //Servers:
	sParStartingSteps 	: SvrCh_DINT;
	sParTimeProStep 	: SvrCh_UDINT;
	sParTimeWarmAgain 	: SvrCh_UDINT;
	parMinimumTimeFeedback 	: SvrCh_UDINT;
	stprHeatUp 	: SvrCh_DINT;
	cycleHeatUp 	: SvrCh_DINT;
  //Clients:
	oCooling 	: CltCh_DINT;
	sparDisableCooling 	: CltCh_DINT;
	iMotorStandStill 	: CltCh_DINT;
	iToolOk 	: CltCh_DINT;
  //Variables:
		timerHeatAgain 	: strTimer;
		timerHeatUp 	: strTimer;
		timerMinimumFeedback 	: strTimer;
		tmpHeatingNeeded 	: DINT;
		tmpSpeed 	: DINT;
		HeatingSpeed 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL work;
	
	FUNCTION heatUp;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB cmMotorSlowStart::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CMMOTORSLOWSTART
1$UINT, 0$UINT, (SIZEOF(::cmMotorSlowStart))$UINT, 
6$UINT, 4$UINT, 0$UINT, 
TO_UDINT(1312878299), "cmMotorSlowStart", //Class
TO_UDINT(2708248773), "cmMotor", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::cmMotorSlowStart.sParStartingSteps.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2517981556), "sParStartingSteps", 
(::cmMotorSlowStart.sParTimeProStep.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3612812254), "sParTimeProStep", 
(::cmMotorSlowStart.sParTimeWarmAgain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4206303306), "sParTimeWarmAgain", 
(::cmMotorSlowStart.parMinimumTimeFeedback.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(460114946), "parMinimumTimeFeedback", 
(::cmMotorSlowStart.stprHeatUp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3906556150), "stprHeatUp", 
(::cmMotorSlowStart.cycleHeatUp.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2039533527), "cycleHeatUp", 
//Clients:
(::cmMotorSlowStart.oCooling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3961188511), "oCooling", 
(::cmMotorSlowStart.sparDisableCooling.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1905412572), "sparDisableCooling", 
(::cmMotorSlowStart.iMotorStandStill.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3927365515), "iMotorStandStill", 
(::cmMotorSlowStart.iToolOk.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(760978864), "iToolOk", 
END_FUNCTION


#define USER_CNT_cmMotorSlowStart 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_cmMotorSlowStart] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION cmMotorSlowStart::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmMotor::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_cmMotorSlowStart;
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParStartingSteps.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParStartingSteps.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParTimeProStep.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParTimeProStep.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParTimeWarmAgain.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParTimeWarmAgain.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parMinimumTimeFeedback.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parMinimumTimeFeedback.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprHeatUp.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprHeatUp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	cycleHeatUp.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF cycleHeatUp.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 25-9-2019 class motor slow start, created for library icm project 4255 (derived from CM motor, only starting is different)
// goal is to control motor, difference is this motor needs to do a startup session with a percentage of the speed
// Alarm errornrs:
//                  1: thermicall failure
//                  2: controller failure
//                  3: time-out feedback
//                  4: feedback gone during running
//                  5: speed in out of borders

// HMI cmd1: start run FWD, cmd2: start run Bwd, stop: stop running

//  extra error: nr 6: tool not ok

FUNCTION VIRTUAL cmMotorSlowStart::work

  iToolOk:= iToolOk.Read();

  IF pmlCom.sts.isInterlocked & stsStateRun<>moOff THEN //at interlock, always stop motor
    stsStateRun:=moOff;
  END_IF;

  CASE stsStateRun OF
  
    moOff: //just do nothing, 
    iMotorStandStill:=iMotorStandStill.Read();
    IF tmpHWAlarm= 0 & tmpThermFailure= 0 &  iMotorStandStill= 0 THEN //try to slow down motor earlier if possible
//      oSpeed:=0;
//      oSpeed.Write(input:=oSpeed);
//      oFwd:= stsBwd=0;
//      oBwd:= stsBwd;
    END_IF;
    
    moChangeDir: //wait until change direction is allowed
      IF (timerFwdStopped.done=1 | stsFwd=1) & (timerBwdStopped.done=1 | stsBwd=1) THEN
        IF tmpHWAlarm = 0 THEN
          stsStateRun:=moWaitFeedback;
        ELSE
          giveAlarm(errorNr:=2);
          stsStateRun:=moOff;
        END_IF;
      END_IF;
    
    moWaitFeedback: //wait for feedback, only if not in simu and if feedback is connected
      IF pmlCom.cmd.simulation=allSimu | feedbackConnected=0 | timerMinimumFeedback.done | tmpHeatingNeeded= 1 THEN
        stsStateRun:=moStarting;
      ELSIF timerFeedback.done THEN
        giveAlarm(errorNr:=3);
        stsStateRun:=moOff;
      ELSIF iToolOk= 0 THEN //also check if tool is ok
        giveAlarm(errorNr:=6);
        stsStateRun:=moOff;        
      END_IF;
      oFwd:=stsFwd;
      oBwd:=stsBwd;
    
    moStarting: //wait certain time, until motor is running fast and stable enough
      IF pmlCom.cmd.simulation<>allSimu & tmpHeatingNeeded= 0 & feedbackConnected=1 & tmpFeedback=0 THEN
        giveAlarm(errorNr:=4); //feedback gone during running
        stsStateRun:=moOff;
      ELSIF tmpHWAlarm THEN
        giveAlarm(errorNr:=2); //hardware not ok
        stsStateRun:=moOff;
      ELSIF iToolOk= 0 THEN //also check if tool is ok
        giveAlarm(errorNr:=6);
        stsStateRun:=moOff;
      ELSIF timerHeatAgain.done= 0 & stprHeatUp< 9 THEN //run heat up cycle
        heatUp();
      ELSIF stprHeatUp = 9 THEN
        stprHeatUp:= 10;
        stsStateRun:=moWaitFeedback;
      ELSIF timerStarting.done | stprHeatUp= 10 THEN
        stprHeatUp:= 10;
        stsStateRun:=moRunning;
      END_IF;
      oFwd:=stsFwd;
      oBwd:=stsBwd;
    
    moRunning: //run untill method stop is called
      IF pmlCom.cmd.simulation<>allSimu & feedbackConnected=1 & tmpFeedback=0 THEN
        giveAlarm(errorNr:=4); //feedback gone during running
        stsStateRun:=moOff;
      ELSIF tmpHWAlarm THEN
        giveAlarm(errorNr:=2); //hardware not ok
        stsStateRun:=moOff;
      ELSIF iToolOk= 0 THEN //also check if tool is ok
        giveAlarm(errorNr:=6);
        stsStateRun:=moOff;        
      END_IF;
      oFwd:=stsFwd;
      oBwd:=stsBwd;  
  
  END_CASE;
  
  //run timers heating 
  timerHeatAgain := runTimer(Active:=(stprHeatUp=10 & oFwd= 0 & oBwd= 0), iMem:=timerHeatAgain, TimerTime:=sParTimeWarmAgain, Pause:=0);
  timerHeatUp:= runTimer(Active:=stprHeatUp=2, iMem:=timerHeatUp, TimerTime:=sParTimeProStep, Pause:=0);

  //timer minimumfeedback
  timerMinimumFeedback:= runTimer(Active:=(tmpFeedback & stsStateRun=moWaitFeedback), iMem:=timerMinimumFeedback, TimerTime:=parMinimumTimeFeedback, Pause:=0);

  tmpHeatingNeeded:= timerHeatAgain.done | stprHeatUp<> 10;

  //if required, reset stprHeatUp
  IF timerHeatAgain.done= 1 | (stprHeatUp>0 & stprHeatUp<10 & stsStateRun<> moStarting) THEN
    stprHeatUp:=0;
  END_IF;

  //done here to use as much from standard motor as possible
  sparDisableCooling:= sparDisableCooling.Read();
  oCooling:=sparDisableCooling=0 & (oFwd= 1 | oBwd= 1) & stsStateRun<> moStarting;
  oCooling.Write(input:=oCooling);

END_FUNCTION


FUNCTION cmMotorSlowStart::heatUp

  //run heat up cycle
  CASE stprHeatUp OF
    
    0: //set things right for heating up
      tmpSpeed:= parSpeed;
      cycleHeatUp:= 1;
      stprHeatUp+=1;
      
    1: //start with cycle
      HeatingSpeed:=(cycleHeatUp*sMaxSpeedIn)/sParStartingSteps;
      updateSpeed(speed:=(HeatingSpeed));
      stprHeatUp+=1;
      
    2: //wait until timer is done
      IF timerHeatUp.done= 1 THEN
        stprHeatUp+=1;
      END_IF;
      
    3: //check if we should do it again
      IF cycleHeatUp < sParStartingSteps THEN
        cycleHeatUp+=1;
        stprHeatUp:=1;
      ELSE
        updateSpeed(speed:=tmpSpeed); //write back starting speed
        stprHeatUp:= 9;
      END_IF;
      
    9: //between step
      
    10: //just wait
    
    
  END_CASE;

END_FUNCTION
