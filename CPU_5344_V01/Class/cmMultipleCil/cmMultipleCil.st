//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "cmMultipleCil"
	Revision           = "0.0"
	GUID               = "{62A5167D-33E7-49F4-B291-7C3DCEC5C00F}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(480,840)">
	<Channels>
		<Server Name="parBetw1and2Out" GUID="{163FF85F-7523-4F34-9CF7-FE48383F0343}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parBetw2and1In" GUID="{26C4DF68-EAF1-41C5-816A-AD9DEEFA737D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parBetw2and3Out" GUID="{E4950FD6-1980-4F8D-ABBE-AAE70130FF0F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parBetw3and2In" GUID="{C3BC6EEC-62FD-4349-8397-1535E8CA4913}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parBetw3and4Out" GUID="{70B32361-6167-4A3C-9F63-9362EDA62353}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parBetw4and3In" GUID="{70319571-E984-44BD-96AB-139F736E8327}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="File"/>
		<Server Name="parDontSetToAutoAlways" GUID="{265DF946-E6FE-4E65-8B40-90466D6BE81A}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false"/>
		<Server Name="stsGoal" GUID="{EE436E1D-DF4E-4AAB-BC6F-74A787FDE395}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsPos" GUID="{FB3B8EB4-EA47-46F1-BBFB-A8DA65A586A2}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="actual position of cilinder"/>
		<Client Name="ctrlCil1" Required="false" Internal="false"/>
		<Client Name="ctrlCil2" Required="false" Internal="false"/>
		<Client Name="ctrlCil3" Required="false" Internal="false"/>
		<Client Name="ctrlCil4" Required="false" Internal="false"/>
	</Channels>
	<Network Name="cmMultipleCil">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{1BEEB5C8-6DAE-45F2-A0EC-074097910ABB}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

cmMultipleCil : CLASS
: cmBase
  //Servers:
	stsPos 	: SvrCh_cilPos;
	stsGoal 	: SvrCh_cilPos;
	parBetw4and3In 	: SvrCh_UDINT;
	parBetw3and2In 	: SvrCh_UDINT;
	parBetw2and1In 	: SvrCh_UDINT;
	parBetw1and2Out 	: SvrCh_UDINT;
	parBetw2and3Out 	: SvrCh_UDINT;
	parBetw3and4Out 	: SvrCh_UDINT;
	parDontSetToAutoAlways 	: SvrCh_DINT;
  //Clients:
	ctrlCil1 	: CltChCmd_cmCil;
	ctrlCil2 	: CltChCmd_cmCil;
	ctrlCil3 	: CltChCmd_cmCil;
	ctrlCil4 	: CltChCmd_cmCil;
  //Variables:
		timer4and3in 	: strTimer;
		timer3and2in 	: strTimer;
		timer2and1in 	: strTimer;
		timer1and2out 	: strTimer;
		timer2and3out 	: strTimer;
		timer3and4out 	: strTimer;
		cil1Connected 	: DINT;
		cil2Connected 	: DINT;
		cil3Connected 	: DINT;
		cil4Connected 	: DINT;
		oldPmlCmdMode 	: eModePML;
		oldStsGoal 	: cilPos;
		stsPosCil1 	: cilPos;
		stsPosCil2 	: cilPos;
		stsPosCil3 	: cilPos;
		stsPosCil4 	: cilPos;
  //Functions:
	
	FUNCTION VIRTUAL execHmiCmd1;
	
	FUNCTION VIRTUAL execHmiCmd3;
	
	FUNCTION VIRTUAL work;
	
	FUNCTION VIRTUAL Init1;
	
	FUNCTION VIRTUAL preScanOverride;
	
	FUNCTION VIRTUAL postScanOverride;
	
	FUNCTION GLOBAL csMoveIn;
	
	FUNCTION GLOBAL csMoveOut;
	
	FUNCTION moveIn;
	
	FUNCTION moveOut;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd cmCil


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB cmMultipleCil::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CMMULTIPLECIL
0$UINT, 0$UINT, (SIZEOF(::cmMultipleCil))$UINT, 
9$UINT, 4$UINT, 0$UINT, 
TO_UDINT(3389912646), "cmMultipleCil", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::cmMultipleCil.stsPos.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3335286665), "stsPos", 
(::cmMultipleCil.stsGoal.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2364541480), "stsGoal", 
(::cmMultipleCil.parBetw4and3In.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1030621776), "parBetw4and3In", 
(::cmMultipleCil.parBetw3and2In.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4178271977), "parBetw3and2In", 
(::cmMultipleCil.parBetw2and1In.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1564142340), "parBetw2and1In", 
(::cmMultipleCil.parBetw1and2Out.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2293603255), "parBetw1and2Out", 
(::cmMultipleCil.parBetw2and3Out.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3196517169), "parBetw2and3Out", 
(::cmMultipleCil.parBetw3and4Out.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(4026254102), "parBetw3and4Out", 
(::cmMultipleCil.parDontSetToAutoAlways.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1942965162), "parDontSetToAutoAlways", 
//Clients:
(::cmMultipleCil.ctrlCil1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(840403672), "ctrlCil1", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::cmMultipleCil.ctrlCil2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2870926178), "ctrlCil2", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::cmMultipleCil.ctrlCil3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3692686324), "ctrlCil3", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
(::cmMultipleCil.ctrlCil4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1115520599), "ctrlCil4", TO_UDINT(2617417482), "cmCil", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_cmMultipleCil 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_cmMultipleCil] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION cmMultipleCil::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_cmMultipleCil;
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #execHmiCmd1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #execHmiCmd3();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #work();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #Init1();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #preScanOverride();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #postScanOverride();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stsPos.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stsPos.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parBetw4and3In.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parBetw4and3In.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parBetw3and2In.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parBetw3and2In.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parBetw2and1In.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parBetw2and1In.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parBetw1and2Out.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parBetw1and2Out.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parBetw2and3Out.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parBetw2and3Out.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parBetw3and4Out.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parBetw3and4Out.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parDontSetToAutoAlways.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parDontSetToAutoAlways.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 3-6-2019 class multiple cil, created for library icm project 4284 TraffiRoad 
// goal is to control multiple cils (max 4), to in, nr 4 is done as first, then nr 3, etc. To out the other way around

// because this is a cm with a few cm's under it, the states are collected from the cils, the cmd's are sended to the cils


// HMI cmd1: move in, HMI cmd3: move out


FUNCTION GLOBAL cmMultipleCil::csMoveIn

  //if in auto or service send to in
  IF pmlCom.sts.mode=auto | pmlCom.sts.mode= service THEN 
    moveIn();
  END_IF;
  
  
END_FUNCTION


FUNCTION GLOBAL cmMultipleCil::csMoveOut

  //if in auto or service send to out
  IF pmlCom.sts.mode=auto | pmlCom.sts.mode= service THEN 
    moveOut();
  END_IF;
  
END_FUNCTION


FUNCTION VIRTUAL cmMultipleCil::execHmiCmd1

  //if in right mode this method is called if HMIcmd gets this request
  moveIn();
  
END_FUNCTION


FUNCTION VIRTUAL cmMultipleCil::execHmiCmd3

  //if in right mode this method is called if HMIcmd gets this request
  moveOut();

END_FUNCTION


FUNCTION cmMultipleCil::moveIn

  stsGoal:=cilIn; //only set goal, do other things in cyclic work

END_FUNCTION


FUNCTION cmMultipleCil::moveOut

  stsGoal:=cilOut; //only set goal, do other things in cyclic work
  
END_FUNCTION


FUNCTION VIRTUAL cmMultipleCil::work

  IF stsGoal= cilIn THEN //cil 4 is the first
    IF cil4Connected=1 THEN
      ctrlCil4.csMoveIn();
    END_IF;
    IF cil3Connected=1 & (timer4and3in.done=1 | parBetw4and3In=0) THEN
      ctrlCil3.csMoveIn();
    END_IF;
    IF cil2Connected=1 & (timer3and2in.done=1 | parBetw3and2In=0) THEN
      ctrlCil2.csMoveIn();
    END_IF;
    IF cil1Connected=1 & (timer2and1in.done=1 | parBetw2and1In=0) THEN
      ctrlCil1.csMoveIn();
    END_IF;
  ELSIF stsGoal= cilOut THEN //cil1 as first
    IF cil1Connected=1 THEN
      ctrlCil1.csMoveOut();
    END_IF;
    IF cil2Connected=1 & (timer1and2out.done=1 | parBetw1and2Out=0) THEN
      ctrlCil2.csMoveOut();
    END_IF;
    IF cil3Connected=1 & (timer2and3out.done=1 | parBetw2and3Out=0) THEN
      ctrlCil3.csMoveOut();
    END_IF;
    IF cil4Connected=1 & (timer3and4out.done=1 | parBetw3and4Out=0) THEN
      ctrlCil4.csMoveOut();
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmMultipleCil::Init1

  //check if endswitches are connected
  IF initDone = 0 THEN
    cil1Connected:=IsClientConnected(#ctrlCil1);
    cil2Connected:=IsClientConnected(#ctrlCil2);
    cil3Connected:=IsClientConnected(#ctrlCil3);
    cil4Connected:=IsClientConnected(#ctrlCil4);
    initDone:=1;
  END_IF;

END_FUNCTION


FUNCTION VIRTUAL cmMultipleCil::preScanOverride
  //preScan reads in al values before handling the actions

  //send commands to all cils, but always set them to mode auto, if required also run timers
  oldPmlCmdMode:=pmlCom.cmd.mode;
  IF parDontSetToAutoAlways= 0 THEN //only if we want it always in auto
    pmlCom.cmd.mode:=auto;
  END_IF;
  IF tmpResetAlarms=1 THEN
    pmlCom.cmd.resetAlarms:=1;
  END_IF;
  IF cil1Connected=1 THEN
    stsPosCil1:=ctrlCil1.stsPos;
    ctrlCil1.setPmlCmds(setPmlCom:=pmlCom);
    timer1and2out:=runTimer(Active:=(stsPosCil1=cilOut|stsPosCil1=cilMovingOut), iMem:=timer1and2out, TimerTime:=parBetw1and2Out, Pause:=FALSE);
  ELSE
    timer1and2out.done:=1; //always set timer to true
    stsPosCil1:=cilNotConnected;
  END_IF;
  IF cil2Connected=1 THEN
    stsPosCil2:=ctrlCil2.stsPos;
    ctrlCil2.setPmlCmds(setPmlCom:=pmlCom);
    timer2and1in:=runTimer(Active:=(stsPosCil2=cilIn | stsPosCil2=cilMovingIn), iMem:=timer2and1in, TimerTime:=parBetw2and1In, Pause:=FALSE);
    timer2and3out:=runTimer(Active:=(stsPosCil2=cilOut|stsPosCil2=cilMovingOut), iMem:=timer2and3out, TimerTime:=parBetw2and3Out, Pause:=FALSE);
  ELSE
    timer2and1in.done:=1; //always set timer to true
    timer2and3out.done:=1; //always set timer to true
    stsPosCil2:=cilNotConnected;
  END_IF;
  IF cil3Connected=1 THEN
    stsPosCil3:=ctrlCil3.stsPos;
    ctrlCil3.setPmlCmds(setPmlCom:=pmlCom);
    timer3and2in:=runTimer(Active:=(stsPosCil3=cilIn | stsPosCil3=cilMovingIn), iMem:=timer3and2in, TimerTime:=parBetw3and2In, Pause:=FALSE);
    timer3and4out:=runTimer(Active:=(stsPosCil3=cilOut|stsPosCil3=cilMovingOut), iMem:=timer3and4out, TimerTime:=parBetw3and4Out, Pause:=FALSE);
  ELSE
    timer3and2in.done:=1; //always set timer to true
    timer3and4out.done:=1; //always set timer to true
    stsPosCil3:=cilNotConnected;
  END_IF;
  IF cil4Connected=1 THEN
    stsPosCil4:=ctrlCil4.stsPos;
    ctrlCil4.setPmlCmds(setPmlCom:=pmlCom);
    timer4and3in:=runTimer(Active:=(ctrlCil4.stsPos=cilIn | ctrlCil4.stsPos=cilMovingIn), iMem:=timer4and3in, TimerTime:=parBetw4and3In, Pause:=FALSE);
  ELSE
    timer4and3in.done:=1; //always set timer to true
    stsPosCil4:=cilNotConnected;
  END_IF;
  pmlCom.cmd.mode:=oldPmlCmdMode;
  
  
  //set old stsGoal, we need it to check if we processed this variable
  oldStsGoal:=stsGoal;

END_FUNCTION


FUNCTION VIRTUAL cmMultipleCil::postScanOverride
  //check alarmstatus
  IF _Alarm.AlarmActief | 
        (cil1Connected=1 & ctrlCil1.stsInAlarm=1) | 
        (cil2Connected=1 & ctrlCil2.stsInAlarm=1) |
        (cil3Connected=1 & ctrlCil3.stsInAlarm=1) |
        (cil4Connected=1 & ctrlCil4.stsInAlarm=1) THEN
    pmlCom.sts.inAlarm:=1;
  ELSE
    pmlCom.sts.inAlarm:=0;
  END_IF;
  
  //check status
  IF (stsPosCil1=cilIn | stsPosCil1=cilNotConnected) & (stsPosCil2=cilIn | stsPosCil2=cilNotConnected) & (stsPosCil3=cilIn | stsPosCil3=cilNotConnected) & (stsPosCil4=cilIn | stsPosCil4=cilNotConnected) &
      (stsPosCil1=cilIn | stsPosCil2=cilIn | stsPosCil3=cilIn | stsPosCil4=cilIn) THEN
    stsPos:=cilIn;
  ELSIF (stsPosCil1=cilOut | stsPosCil1=cilNotConnected) & (stsPosCil2=cilOut | stsPosCil2=cilNotConnected) & (stsPosCil3=cilOut | stsPosCil3=cilNotConnected) & (stsPosCil4=cilOut | stsPosCil4=cilNotConnected) &
      (stsPosCil1=cilOut | stsPosCil2=cilOut | stsPosCil3=cilOut | stsPosCil4=cilOut) THEN
    stsPos:=cilOut;
  ELSIF (stsPosCil1=cilIn | stsPosCil1=cilMovingIn | stsPosCil1=cilNotConnected) & (stsPosCil2=cilIn | stsPosCil2=cilMovingIn | stsPosCil2=cilNotConnected) & 
     (stsPosCil3=cilIn | stsPosCil3=cilMovingIn | stsPosCil3=cilNotConnected) & (stsPosCil4=cilIn | stsPosCil4=cilMovingIn | stsPosCil4=cilNotConnected) &
      (stsPosCil1=cilMovingIn | stsPosCil2=cilMovingIn | stsPosCil3=cilMovingIn | stsPosCil4=cilMovingIn) THEN
    stsPos:=cilMovingIn;    
  ELSIF (stsPosCil1=cilOut | stsPosCil1=cilMovingOut | stsPosCil1=cilNotConnected) & (stsPosCil2=cilOut | stsPosCil2=cilMovingOut | stsPosCil2=cilNotConnected) & 
     (stsPosCil3=cilOut | stsPosCil3=cilMovingOut | stsPosCil3=cilNotConnected) & (stsPosCil4=cilOut | stsPosCil4=cilMovingOut | stsPosCil4=cilNotConnected) &
      (stsPosCil1=cilMovingOut | stsPosCil2=cilMovingOut | stsPosCil3=cilMovingOut | stsPosCil4=cilMovingOut) THEN
    stsPos:=cilMovingOut;    
  END_IF;
  
  //reset stsGoal
  IF stsGoal=stsPos | (stsGoal=oldStsGoal & pmlCom.sts.mode=manual) THEN //reset goal if goal is reached, or always if in manual mode, and goal was the same during prescan
    stsGoal:=cilUnKnown;
  END_IF;

END_FUNCTION
