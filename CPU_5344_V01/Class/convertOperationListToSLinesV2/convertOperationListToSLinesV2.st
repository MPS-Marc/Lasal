//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "convertOperationListToSLinesV2"
	Revision           = "1.0"
	GUID               = "{C729417A-4249-492A-BAEC-8F88DDEF1932}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(660,780)">
	<Channels>
		<Server Name="convertDone" GUID="{36C87181-A9D5-4D14-A94D-17515A61989F}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="elapsedTime" GUID="{A59FB396-53C5-443C-B187-A4A472851CA5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="parWaitForSawBeforeClampingOutput" GUID="{5CFA8C05-FCDC-4090-ABA2-C27F220BA9D9}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false"/>
		<Server Name="startConvert" GUID="{03E7D920-34EE-46F5-87AA-E0CC8046A6A8}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprConvert" GUID="{DF999539-7DB1-4077-821A-9C77480E40DE}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="ctrlOperationList" Required="true" Internal="false"/>
		<Client Name="ctrlSettings" Required="true" Internal="false"/>
		<Client Name="ctrlSLineList" Required="true" Internal="false"/>
		<Client Name="iMaxPosOutputWagon" Required="false" Internal="false"/>
		<Client Name="iMinPosOutputWagon" Required="false" Internal="false"/>
		<Client Name="iMinPosX1" Required="true" Internal="false"/>
		<Client Name="iWorkSpeed" Required="false" Internal="false"/>
		<Client Name="oUpdateList" Required="true" Internal="false"/>
		<Client Name="oUpdateList2" Required="true" Internal="false"/>
	</Channels>
	<Network Name="convertOperationListToSLinesV2">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{FE83481F-606E-40A1-9245-71E25DD3CD32}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

convertOperationListToSLinesV2 : CLASS
: cmBase
  //Servers:
	stprConvert 	: SvrCh_DINT;
	startConvert 	: SvrCh_DINT;
	convertDone 	: SvrCh_DINT;
	elapsedTime 	: SvrCh_UDINT;
	parWaitForSawBeforeClampingOutput 	: SvrCh_DINT;
  //Clients:
	ctrlSettings 	: CltChCmd_dbSettings;
	ctrlOperationList 	: CltChCmd_calcOperationListV2;
	ctrlSLineList 	: CltChCmd_GlobalList;
	oUpdateList2 	: CltCh_DINT;
	oUpdateList 	: CltCh_DINT;
	iMinPosX1 	: CltCh_DINT;
	iWorkSpeed 	: CltCh_DINT;
	iMaxPosOutputWagon 	: CltCh_DINT;
	iMinPosOutputWagon 	: CltCh_DINT;
  //Variables:
		tmpTime 	: UDINT;
		bitMaskBus : BDINT
		[
		];

		wrLine 	: DINT;
		rdLine 	: DINT;
		tmpLine 	: SRegelInfo;
		emptyLine 	: SRegelInfo;
		tmpOperationLine 	: calcOperationListV2::calcLine;
		tmppLastOperationLine 	: calcOperationListV2::calcLine;
		tmpNextOperationLine 	: calcOperationListV2::calcLine;
		currentOrder 	: DINT;
		tmpXpos 	: DINT;
		overtakeDone 	: DINT;
		nrProd 	: DINT;
		waitUnits 	: Units;
		lastYPos 	: DINT;
		tmpClosedBUClamps 	: Units;
		tmpClampUnits 	: Units;
		tmpClampUnits2 	: Units;
		wasteStopDone 	: DINT;
		lastDrillDiamBu2 	: DINT;
		lastDrillDiamBu3 	: DINT;
		wagonAlreadySendedBack 	: DINT;
		tmpRemoveWasteWithOutput 	: DINT;
		tmpProdLengthRemove 	: DINT;
		tmpPosOutputForFrontWaste 	: DINT;
		lastX2Pos 	: DINT;
		tmpWorkSpeed 	: DINT;
		tmpActione 	: DINT;
		tmpOvertakeUnit 	: Units;
		tmpRemoveLength 	: DINT;
		av1AlreadyControlled 	: DINT;
		tmpWasteLength 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION startCmd;
	
	FUNCTION loadMaterial;
	
	FUNCTION cmdsFromList;
	
	FUNCTION endCmd;
	
	FUNCTION closeOperationClamps
		VAR_INPUT
			iOperationUnits 	: Units;
			iXPos 	: DINT;
		END_VAR
		VAR_OUTPUT
			units 	: Units;
		END_VAR;
	
	FUNCTION openOperationClamps
		VAR_INPUT
			iOperationUnits 	: Units;
		END_VAR;
	
	FUNCTION convertOperationToUnit
		VAR_INPUT
			operation 	: calcOperationListV2::calcOperations;
		END_VAR
		VAR_OUTPUT
			units 	: Units;
		END_VAR;
	
	FUNCTION writeLine
		VAR_INPUT
			line 	: SRegelInfo;
		END_VAR;
	
	FUNCTION moveWithX2
		VAR_INPUT
			distance 	: DINT;
		END_VAR;
	
	FUNCTION sendWagonBack;
	
	FUNCTION calcClampsToClose
		VAR_INPUT
			iOperationUnits 	: Units;
			iXpos 	: DINT;
		END_VAR
		VAR_OUTPUT
			clamps 	: Units;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL startConvert::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd calcOperationListV2
#pragma usingLtd dbSettings
#pragma usingLtd GlobalList


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB convertOperationListToSLinesV2::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CONVERTOPERATIONLISTTOSLINESV2
1$UINT, 0$UINT, (SIZEOF(::convertOperationListToSLinesV2))$UINT, 
5$UINT, 9$UINT, 0$UINT, 
TO_UDINT(3277871537), "convertOperationListToSLinesV2", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::convertOperationListToSLinesV2.stprConvert.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1340546349), "stprConvert", 
(::convertOperationListToSLinesV2.startConvert.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(343252092), "startConvert", 
(::convertOperationListToSLinesV2.convertDone.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1402992849), "convertDone", 
(::convertOperationListToSLinesV2.elapsedTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1280260988), "elapsedTime", 
(::convertOperationListToSLinesV2.parWaitForSawBeforeClampingOutput.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(663349628), "parWaitForSawBeforeClampingOutput", 
//Clients:
(::convertOperationListToSLinesV2.ctrlSettings.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(928794703), "ctrlSettings", TO_UDINT(3270182861), "dbSettings", 0$UINT, 0$UINT, 
(::convertOperationListToSLinesV2.ctrlOperationList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2847067112), "ctrlOperationList", TO_UDINT(3979889133), "calcOperationListV2", 1$UINT, 0$UINT, 
(::convertOperationListToSLinesV2.ctrlSLineList.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2252125553), "ctrlSLineList", TO_UDINT(2390595228), "GlobalList", 0$UINT, 0$UINT, 
(::convertOperationListToSLinesV2.oUpdateList2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1685857285), "oUpdateList2", 
(::convertOperationListToSLinesV2.oUpdateList.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(417772813), "oUpdateList", 
(::convertOperationListToSLinesV2.iMinPosX1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1950608727), "iMinPosX1", 
(::convertOperationListToSLinesV2.iWorkSpeed.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2284745096), "iWorkSpeed", 
(::convertOperationListToSLinesV2.iMaxPosOutputWagon.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3780407028), "iMaxPosOutputWagon", 
(::convertOperationListToSLinesV2.iMinPosOutputWagon.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(4108302854), "iMinPosOutputWagon", 
END_FUNCTION


#define USER_CNT_convertOperationListToSLinesV2 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_convertOperationListToSLinesV2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION convertOperationListToSLinesV2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_convertOperationListToSLinesV2;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprConvert.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprConvert.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startConvert.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startConvert::Write() );
	IF startConvert.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	convertDone.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF convertDone.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	parWaitForSawBeforeClampingOutput.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF parWaitForSawBeforeClampingOutput.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 24-2-2020: changed for 4484
// JdK 18-6-2019: convertOperationListToSLinesV2 created for 4284 Traffiroad/standard library
// goal is to convert the simpel operation list (with all operation in right order etc.) to an list of s lines
// here we have to give commands for loading, unloading, movements etc. 

// although this class isn't an real cm we can use the oppurtunitys of a cm base

// errornr 1 tm 10, none of the clamps for this units are closed
// errornr 11, command to remove product without acceptable way of doing it
// errornr 12, no valid diam for drill operation
// errornr 13, to much drill diams in assembly
// errornr 14, wagon sended back to early
// errornr 15, moving material to magazin doesn't fit

FUNCTION VIRTUAL GLOBAL convertOperationListToSLinesV2::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  CASE stprConvert OF
  
  0: //wait for start
    
  1: //empty sline list, and reset some stuff
    ctrlSLineList.clearAll();
    currentOrder+=1; //just a counter to check the number of the order after starting the plc
    wrLine:=0;
    rdLine:=0;
    lastYPos:=FAULTVALUE;
    _memset(dest:=#emptyLine, usByte:=0, cntr:=sizeof(emptyLine));
    emptyLine.x1Pos:=FAULTVALUE;
    emptyLine.y1Pos:=FAULTVALUE;
    emptyLine.z1Pos:=FAULTVALUE;
    emptyLine.zy1Angle:=FAULTVALUE;
    emptyLine.xz1Angle:=FAULTVALUE;
    emptyLine.xy1Angle:=FAULTVALUE;
    _memset(dest:=#tmppLastOperationLine, usByte:=0, cntr:=sizeof(tmppLastOperationLine));
    _memset(dest:=#tmpLine, usByte:=0, cntr:=sizeof(tmpLine));
    lastDrillDiamBu2:= -1;
    lastDrillDiamBu3:= -1;
    overtakeDone:=0;
    wagonAlreadySendedBack:= 0;
    av1AlreadyControlled:= 0;
    tmpRemoveWasteWithOutput:= 0;
    tmpOperationLine:=ctrlOperationList.getLineFromList(nr:=rdLine);
    tmpNextOperationLine:=ctrlOperationList.getLineFromList(nr:=rdLine+1);
    iMinPosX1:= iMinPosX1.Read();
    iMaxPosOutputWagon:= iMaxPosOutputWagon.Read();
    iMinPosOutputWagon:= iMinPosOutputWagon.Read();
    IF IsClientConnected(#iWorkSpeed) THEN
      iWorkSpeed:=iWorkSpeed.Read();
      IF iWorkSpeed> 0 THEN //prefare to use workspeed from profile db
        tmpWorkSpeed:=iWorkSpeed;
      END_IF;
    ELSE
      tmpWorkSpeed:= ctrlSettings.workingXSpeed;
    END_IF;
    stprConvert+=1;
    
  2: //add starting commands
    startCmd();
    loadMaterial();
    stprConvert+=1;
    
  3: //convert list
    cmdsFromList();
    stprConvert+=1;
    
  4: //add end commands
    endCmd();
    stprConvert+=1;
    
  5: //check if everything was ok, if it was, set done bit
    IF stsInAlarm=0 THEN
      convertDone:=1;
    ELSE
      convertDone:=0;
    END_IF;
    oUpdateList.Write(input:=0);
    oUpdateList2.Write(input:=0);
    elapsedTime:=OPS.tAbsolute-tmpTime;
    stprConvert:=0;
  
  END_CASE;

  state:=0;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL convertOperationListToSLinesV2::startConvert::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
	
  IF stprConvert= 0 THEN
    tmpTime:=ops.tAbsolute;
    resetAlarm(); //if calc is started, reset the alarms
    convertDone:=-1;
    stprConvert:=1;
    startConvert:= 1;
  ELSE
    startConvert:= 0;
  END_IF;  
	result := startConvert;

END_FUNCTION


FUNCTION convertOperationListToSLinesV2::startCmd

  //just give start command
  tmpLine.Amount:= tmpOperationLine.operationId; //put amount to do in amount of start line, amount is stored in operation id
  tmpLine.Command:= STARTCOM;
  tmpLine.x1Pos:= 999999; //just a value
  writeLine(line:=tmpLine);

END_FUNCTION


FUNCTION convertOperationListToSLinesV2::loadMaterial

  //first operation line is already in memory, for testMiterSawTwoDrills only do manual loading material, and start pressure rol
  
//  //move wagon up
//  tmpLine.Command:= UNITSTARTCOM;
//  tmpLine.Units.PU1:= 1; //input wagon is always pu1
//  tmpLine.actione:= 3; //means wagon up
//  tmpLine.x1Pos:= tmpOperationLine.xPos;
//  writeLine(line:=tmpLine);
  
  //move wagon to loading pos
  tmpLine.Command:= UNITMOVECOM;
  tmpLine.Units.PU1:= 1; 
  tmpLine.x1Pos:= tmpOperationLine.xPos;
  tmpLine.speed:= 1000; //full speed
  writeLine(line:=tmpLine);
  
    //wait until wagon is ready // 5-9-2019 RVDL
  tmpLine.Command:= WAITOPERATIONCOM;
  tmpLine.Units:= Units.PU1;
  writeLine(line:=tmpLine);  

  //start loading magazine, before starting, wait until preparing is done
//  tmpLine.Command:= WAITOPERATIONCOM;
//  tmpLine.Units.AV1:= 1;
//  writeLine(line:=tmpLine);  
  tmpLine.Command:= UNITSTARTCOM;
  tmpLine.Units.AV1:= 1;
  tmpLine.actione:= 3; //depends on machine, but here its ask operator to place material and close the clamp
  tmpLine.x1Pos:= tmpOperationLine.xPos-ctrlSettings.freeSpaceLoadMaterial-ctrlSettings.lengthGripProfile;
  writeLine(line:=tmpLine);
  

  
  
//  //wait untill wagon is back and up
//  tmpLine.Command:= WAITOPERATIONCOM;
//  tmpLine.Units.PU1:= 1;
//  writeLine(line:=tmpLine);
//  
//  //send wagon down
//  tmpLine.Command:= UNITSTARTCOM;
//  tmpLine.Units.PU1:= 1;
//  tmpLine.actione:= 4; //means wagon down
//  writeLine(line:=tmpLine);
//  
//  //wait until both wagon and av1 are ready
    tmpLine.Command:= WAITOPERATIONCOM;
    tmpLine.Units:= units.AV1+Units.PU1; //RVDL 19-11-2019wait for wagon and gripper to be ready
    writeLine(line:=tmpLine);
//  
//  //grip profile, position is xpos of loading operation line minus the free space (of course) and the length in the settings
//  tmpLine.Command:= UNITMOVECOM;
//  tmpLine.Units.PU1:= 1;
//  tmpLine.speed:= ctrlSettings.slowXSpeed;
//  tmpLine.actione:= CILDICHT; //grip material
//  tmpLine.x1Pos:= tmpOperationLine.xPos-ctrlSettings.freeSpaceLoadMaterial-ctrlSettings.lengthGripProfile;
//  writeLine(line:=tmpLine);
//  
//  //and wait for it
//  tmpLine.Command:= WAITOPERATIONCOM;
//  tmpLine.Units:= Units.PU1;
//  writeLine(line:=tmpLine);
//  
//  //stop gripperfunction input rollers and wait for it
//  tmpLine.Command:= UNITSTARTCOM;
//  tmpLine.Units.AV1:= 1;
//  tmpLine.actione:= 3; //means stop gripper function
//  writeLine(line:=tmpLine);
//  tmpLine.Command:= WAITOPERATIONCOM;
//  tmpLine.Units:= Units.AV1;
//  writeLine(line:=tmpLine);
  
  IF ctrlSettings.UsePressureroll THEN // RVDL 19-12-2019  added start for pressure roll
     //start pressure roll
    tmpLine.Command:= UNITSTARTCOM;
    tmpLine.Units.CL9:= 1;
    tmpLine.actione:= 3; 
    writeLine(line:=tmpLine);    
  end_if;
  
  
  //for some machines something has to be done with the input magazine, like sending rollers back or something, but not here
  //for 4284 we send rollers back after complete assembly is produced
  

  
END_FUNCTION

FUNCTION convertOperationListToSLinesV2::cmdsFromList

//now get all operation lines from calculation and convert them to slines

  FOR rdLine:=1 TO DEFMAXCALCLIST DO //line 0 is readed at start
    tmppLastOperationLine:=tmpOperationLine;
    tmpOperationLine:=tmpNextOperationLine;
    tmpNextOperationLine:=ctrlOperationList.getLineFromList(nr:=rdLine+1); //we only need to read in the next one, the others we already have in other positions
       
    IF tmpOperationLine.operations <> 0 THEN //check if line has some working information in it
    
      // Set actions in sregelinfo based on calclist info for removing products (before moving wagon)
(* IT 02-06-2022: no output for 5286      IF (tmpOperationLine.operations.removeProduct | tmpOperationLine.operations.WasteStop) &  tmpOperationLine.outputId = 100 THEN
         tmpLine.actione:= CILDICHT; // // Close table before moving wagon to action with opening table and pushing material
         tmpLine.Command:= UNITSTARTCOM;
         tmpLine.Units:= Units.AV2;
         writeLine(line:=tmpLine);
         tmpLine.Command:= WAITOPERATIONCOM;
         tmpLine.Units:= Units.AV2;
         writeLine(line:=tmpLine);
      ELSIF (tmpOperationLine.operations.removeProduct | tmpOperationLine.operations.WasteStop) & tmpOperationLine.outputId = CILOPEN THEN
         tmpLine.actione:= CILOPEN; // Open table before moving wagon to push material into bin
         tmpLine.Command:= UNITSTARTCOM;
         tmpLine.Units:= Units.AV2;
         writeLine(line:=tmpLine);
         tmpLine.Command:= WAITOPERATIONCOM;
         tmpLine.Units:= Units.AV2;
         writeLine(line:=tmpLine);
      END_IF; *)
      
      waitUnits:=0; //at the begin of each line, remove waitunits
      tmpOvertakeUnit:=0;
      IF overtakeDone THEN  
        waitUnits:=waitUnits+Units.DoWithOutput;
        tmpOvertakeUnit:=Units.DoWithOutput;
      END_IF;
      
      
//send sawangle and clamps to right position, and do other stuff needed before sawing
//      IF tmpOperationLine.operations.BU1_saw= 1 THEN //tp there is no mare sawing in angle
//   
//        tmpLine.Command:= UNITMOVECOM;
//        tmpLine.speed:= 1000; //max speed to go to pos
//        tmpLine.xy1Angle:= tmpOperationLine.sawAngle;
//
//        tmpLine.Units:= Units.BU1 + tmpOvertakeUnit;
//        writeLine(line:=tmpLine);
//        waitUnits.BU1:= 1;
//          
//      END_IF;     

      
      (*IF tmpOperationLine.operations.Bu2_mill1 THEN 
        IF lastDrillDiamBu2 <> tmpOperationLine.ToolId THEN
         tmpLine.Command:= UNITMOVECOM;
         //tmpLine.actione := TOOLCHANGE;  
         tmpLine.toolID:= tmpOperationLine.ToolId;
         tmpLine.Units:= Units.BU2 + tmpOvertakeUnit;
         writeLine(line:=tmpLine);
         
         lastDrillDiamBu2:= tmpOperationLine.ToolId;    
         
         tmpLine.Command:= WAITOPERATIONCOM;
         tmpLine.Units:= waitUnits + Units.bu2;
         writeLine(line:=tmpLine);         

        END_IF;
      
        tmpLine.Command:= UNITMOVECOM;
        tmpLine.speed:= 1000;
        tmpLine.y1Pos:= tmpOperationLine.MillPosses[1].ypos;
        tmpLine.x1Pos:= tmpOperationLine.MillPosses[1].xpos ;
        tmpLine.toolID:= tmpOperationLine.ToolId;
        tmpLine.Units:= Units.BU2 + tmpOvertakeUnit;
        writeLine(line:=tmpLine);
        waitUnits.BU2:= 1; //wait after moving material
      END_IF;*)

      (*IF tmpOperationLine.operations.Bu3_mill2 THEN //for both bu3 and bu5 send bu3 to right y position
        IF lastDrillDiamBu3 <> tmpOperationLine.ToolId THEN
         tmpLine.Command:= UNITMOVECOM;
         //tmpLine.actione := TOOLCHANGE;  
         tmpLine.toolID:= tmpOperationLine.ToolId;
         tmpLine.Units:= Units.BU3 + tmpOvertakeUnit;
         writeLine(line:=tmpLine);
         
         lastDrillDiamBu3:= tmpOperationLine.ToolId;
         
         tmpLine.Command:= WAITOPERATIONCOM;
         tmpLine.Units:= waitUnits + Units.bu3;
         writeLine(line:=tmpLine);         

        END_IF;
        
        tmpLine.Command:= UNITMOVECOM;
        tmpLine.speed:= 1000;
        tmpLine.y1Pos:= tmpOperationLine.MillPosses[2].ypos;
        tmpLine.toolID:= tmpOperationLine.ToolId;
        tmpLine.Units:= Units.BU3 + tmpOvertakeUnit;
        tmpLine.toolID:= tmpOperationLine.ToolId;
        writeLine(line:=tmpLine);
        waitUnits.BU3:= 1;
      END_IF;*)
      
       //TP 24-11-2020 before moving go to suspend, if in semi auto, else just go on
      if tmpNextOperationLine.operations.bu1_saw then//only do by operations
        tmpLine.Command:= UNITSTARTCOM;
        tmpLine.actione:= 100;
        tmpLine.Units:= Units.AV3;
        writeLine(line:=tmpLine);
        tmpLine.Command:=WAITOPERATIONCOM;
        tmpLine.Units:=Units.AV3;
        writeLine(line:=tmpLine);
      end_if;
      
      
      //do movement itself, only for different positions
      IF tmpOperationLine.xPos <> tmppLastOperationLine.xPos then// | (tmppLastOperationLine.operations.BU1_saw=1 (*& ctrlEmSaw.parEnableRetractInputSide=1*)) THEN //if retraction is active, means wagon is replaced, so do movement again
        IF wagonAlreadySendedBack= 0 THEN //for last sawing, wagon is already sended back, but we still need to remove the material
          IF overtakeDone THEN
            moveWithX2(distance:=tmppLastOperationLine.xPos-tmpOperationLine.xPos); //distance to move is difference between last and actual pos
          ELSE
            tmpLine.Command:= UNITMOVECOM;
            tmpLine.x1Pos:= tmpOperationLine.xPos;
            tmpLine.Units:=Units.PU1;
            if tmpOperationLine.operations.FirstInAssemb then//tp if firste in the asmble slow speed
              tmpLine.speed:=ctrlSettings.slowXSpeed;
            else
              tmpLine.speed:=tmpWorkSpeed;
            end_if;
            writeLine(line:=tmpLine);
            
            tmpLine.Command:= WAITOPERATIONCOM;
            tmpLine.Units:= waitUnits + Units.PU1;
            writeLine(line:=tmpLine);
            
          END_IF;

        ELSE
          IF tmpNextOperationLine.operations<>0 THEN
            giveAlarm(errorNr:=14);
          END_IF;
        END_IF;
      ELSIF waitUnits > 0 THEN //move commando given, so give also wait commando (only for preparation of units)
        tmpLine.Command:= WAITOPERATIONCOM;
        tmpLine.Units:= waitUnits;
        writeLine(line:=tmpLine);      
      END_IF;
      
      
      //check if we have to do some bu operation, 
      waitUnits:= convertOperationToUnit(operation:=tmpOperationLine.operations); 
      IF waitUnits<> 0 THEN //because converting only gives back the bu's, check if it's not 0 is enough
        IF overtakeDone THEN
          waitUnits.DoWithOutput:=1; //set bit that tells to do work with output
        END_IF;
      
        //check if we have to close clamps, and if we have to, close them
        tmpClosedBUClamps:= closeOperationClamps(iOperationUnits:=waitUnits, iXPos:=tmpOperationLine.xPos);
      
        
        IF tmpOperationLine.operations.FirstInAssemb THEN
          tmpActione:=FIRSTINASSEMBLY;
        ELSIF tmpOperationLine.operations.LastInAssemb THEN
          tmpActione:=LASTINASSEMBLY;
        ELSE
          tmpActione:=BETWEENINASSEMBLY;
        END_IF;       
        
        IF tmpOperationLine.operations.BU1_saw THEN
          IF tmpOperationLine.operations.EndSaw THEN //for endsawing also tell if it's the last operation
            tmpActione:= LASTINASSEMBLY;
          END_IF;
//          tmpLine.speed:= ctrlOperationList.actSawSpeed;
        END_IF; 
        
               //TP 12-11-2020 send sawangle and clamps to right position, and do other stuff needed before sawing
        IF tmpOperationLine.operations.BU1_saw= 1 THEN
     
//          tmpLine.Command:= UNITMOVECOM;
//          tmpLine.speed:= 1000; //max speed to go to pos
//          tmpLine.xy1Angle:= tmpOperationLine.sawAngle;

//          tmpLine.Units:= Units.BU1 + tmpOvertakeUnit;
//          writeLine(line:=tmpLine);
//          waitUnits.BU1:= 1;
//          tmpLine.Command:= WAITOPERATIONCOM;
//          tmpLine.Units:= waitUnits;
//          writeLine(line:=tmpLine);
//          
        END_IF;    
        
        //give real operation command
        tmpLine.Command:= UNITSTARTCOM;
        //tmpLine.xy1Angle:= tmpOperationLine.sawAngle; //RVDL added sawangle to startcom for inpos check by mitersaw
        tmpLine.Units:= waitUnits;

        
        IF tmpOperationLine.operations.FirstInAssemb THEN
          tmpLine.actione:=FIRSTINASSEMBLY;
        ELSIF tmpOperationLine.operations.LastInAssemb THEN
          tmpLine.actione:=LASTINASSEMBLY;
        ELSE
          tmpLine.actione:=BETWEENINASSEMBLY;
        END_IF;

        IF tmpLine.Units.BU1 & tmpOperationLine.operations.EndSaw THEN //for endsawing also tell if it's the last operation
          tmpLine.actione:= LASTINASSEMBLY;
        END_IF;
        
        writeLine(line:=tmpLine);
        
        IF tmpOperationLine.operations.FirstInAssemb & ctrlSettings.openPressureRollAtFirstOperation THEN // open guidingroll before first sawing//don't use for 4791
          tmpLine.Command:= UNITSTARTCOM;
          tmpLine.actione:= CILOPEN;
          tmpLine.Units:= Units.CL9;          
          writeLine(line:=tmpLine);
          
          tmpLine.Command:=WAITOPERATIONCOM;
          tmpLine.Units:=Units.CL9;
          writeLine(line:=tmpLine);
        END_IF;
        
    
        //also wait for operation, 
        tmpLine.Command:= WAITOPERATIONCOM;
        tmpLine.Units:= waitUnits;
        writeLine(line:=tmpLine);
      
        //after operation is done, open clamps
        IF tmpNextOperationLine.xPos= tmpOperationLine.xPos THEN //only open clamps we don't need to be closed next time
          tmpClampUnits:= calcClampsToClose(iOperationUnits:= convertOperationToUnit(operation:=tmpNextOperationLine.operations), iXpos:=tmpNextOperationLine.xPos);
          tmpClampUnits:= tmpClosedBUClamps XOR tmpClampUnits; //filter out double clamps
          tmpClosedBUClamps:= tmpClampUnits AND tmpClosedBUClamps; //only open the closed clamps, so filter out new clamps for next operation
        END_IF;
        openOperationClamps(iOperationUnits:=tmpClosedBUClamps);
      
      END_IF;
      
      
      
      // Set action in sregelinfo based on calclist info for removing products or waste via output table (after moving wagon)
      (* IT 02-06-2022: no output table for 5286 IF (tmpOperationLine.operations.removeProduct | tmpOperationLine.operations.WasteStop) THEN
         IF tmpOperationLine.outputId = 100 THEN // remove via output table
            IF ctrlOperationList.giveNextOutputOperation(startNr:=rdLine)=1 THEN // Table should be closed afterwards
               tmpLine.Command:= UNITSTARTCOM;
               tmpLine.actione:= 11; // Remove material with pusher: open table, push material, retract pusher and close table
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);
               tmpLine.Command:= WAITOPERATIONCOM;
               tmpLine.actione:= 11;
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);  
            ELSE
               tmpLine.Command:= UNITSTARTCOM;
               tmpLine.actione:= 21; // Remove material with pusher: open table, push material, retract pusher and remain open
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);
               tmpLine.Command:= WAITOPERATIONCOM;
               tmpLine.actione:= 21;
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);
            END_IF;
         ELSE // remove via output bin
            IF ctrlOperationList.giveNextOutputOperation(startNr:=rdLine)=1 THEN // Table should be closed afterwards
               tmpLine.Command:= UNITSTARTCOM;
               tmpLine.actione:= 12; // Close table
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);
               tmpLine.Command:= WAITOPERATIONCOM;
               tmpLine.actione:= 12;
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);  
            ELSE
               tmpLine.Command:= UNITSTARTCOM;
               tmpLine.actione:= 22; // Keep table open
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);
               tmpLine.Command:= WAITOPERATIONCOM;
               tmpLine.actione:= 22;
               tmpLine.Units:= Units.AV2;
               writeLine(line:=tmpLine);
            END_IF;
         END_IF;
      END_IF;   *)
          
                     
      // Evaluate whether table should be closed after latest remove action of product or waste  
      IF overtakeDone= 0 & (tmpOperationLine.operations.wasteStop= 1 | tmpOperationLine.operations.removeProduct= 1) THEN //if there was a wastestop or product removal, send command to close waste bin, but only if overtake isn't done already   
         
         //Last action : close table and send wagon back
         IF tmpNextOperationLine.xPos= 0 & tmpNextOperationLine.operations= 0 THEN 
        (* IT 02-06-2022: no output table for 5286tmpLine.Command:= UNITSTARTCOM;
            tmpLine.actione:= CILDICHT; // Close table
            tmpLine.Units:= Units.AV2;
            writeLine(line:=tmpLine);
            tmpLine.Command:= WAITOPERATIONCOM;
            tmpLine.actione:= CILDICHT;
            tmpLine.Units:= Units.AV2;
            writeLine(line:=tmpLine); 
         *)

            sendWagonBack();
         END_IF;
      
         IF tmpOperationLine.operations.TakeOver= 1 THEN //command to do production from here with outputwagon
           //not yet programmed, because traffiroad 4284 only has one production wagon
           overtakeDone:=1;
         END_IF;
      END_IF;
    
    ELSE
      rdLine:=DEFMAXCALCLIST+1; //stop after one empty line
    END_IF;
    
  END_FOR;


END_FUNCTION

FUNCTION convertOperationListToSLinesV2::endCmd

  IF wagonAlreadySendedBack= 0 THEN  
    sendWagonBack();
  END_IF;
  
  //then just give stop command
  tmpLine.Command:= STOPCOM;
  writeLine(line:=tmpLine);

END_FUNCTION


FUNCTION convertOperationListToSLinesV2::closeOperationClamps
	VAR_INPUT
		iOperationUnits 	: Units;
		iXPos 	: DINT;
	END_VAR
	VAR_OUTPUT
		units 	: Units;
	END_VAR

  tmpClampUnits:= calcClampsToClose(iOperationUnits:=iOperationUnits, iXpos:=iXPos);
  

  

  //check for each unit if at least one of the clamps is closed
  IF iOperationUnits.BU1 & (tmpClampUnits AND ctrlSettings.clsBU1)<=0 & ctrlSettings.clsBU1>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=1);
  END_IF;
  IF iOperationUnits.BU2 & (tmpClampUnits AND ctrlSettings.clsBU2)<=0 & ctrlSettings.clsBU2>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=2);
  END_IF;
  IF iOperationUnits.BU3 & (tmpClampUnits AND ctrlSettings.clsBU3)<=0 & ctrlSettings.clsBU3>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=3);
  END_IF;
  IF iOperationUnits.BU4 & (tmpClampUnits AND ctrlSettings.clsBU4)<=0 & ctrlSettings.clsBU4>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=4);
  END_IF;
  IF iOperationUnits.BU5 & (tmpClampUnits AND ctrlSettings.clsBU5)<=0 & ctrlSettings.clsBU5>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=5);
  END_IF;
  IF iOperationUnits.BU6 & (tmpClampUnits AND ctrlSettings.clsBU6)<=0 & ctrlSettings.clsBU6>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=6);
  END_IF;
  IF iOperationUnits.BU7 & (tmpClampUnits AND ctrlSettings.clsBU7)<=0 & ctrlSettings.clsBU7>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=7);
  END_IF;
  IF iOperationUnits.BU8 & (tmpClampUnits AND ctrlSettings.clsBU8)<=0 & ctrlSettings.clsBU8>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=8);
  END_IF;
  IF iOperationUnits.BU9 & (tmpClampUnits AND ctrlSettings.clsBU9)<=0 & ctrlSettings.clsBU9>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=9);
  END_IF;
  IF iOperationUnits.BU10 & (tmpClampUnits AND ctrlSettings.clsBU10)<=0 & ctrlSettings.clsBU10>0 THEN //none of clamps is closed
    giveAlarm(errorNr:=10);
  END_IF;
 
  units:= tmpClampUnits; //give back closed clamps
 
  //check if at leat one clamp is closed
  IF tmpClampUnits> 0 THEN
    IF iOperationUnits.DoWithOutput THEN
      tmpClampUnits.DoWithOutput:= 1;
    END_IF;
    tmpLine.Command:= UNITSTARTCOM;
    tmpLine.actione:= CILDICHT;
    tmpLine.Units:= tmpClampUnits;
    writeLine(line:=tmpLine);
    
    //and of course write waiting line
    tmpLine.Command:= WAITOPERATIONCOM;
    tmpLine.Units:= tmpClampUnits;
    writeLine(line:=tmpLine);
  END_IF;
  
 
  
END_FUNCTION


FUNCTION convertOperationListToSLinesV2::openOperationClamps
	VAR_INPUT
		iOperationUnits 	: Units;
	END_VAR

  //just give command to close clamps and to wait for them, but only if there is info
  IF iOperationUnits >0 THEN
    tmpLine.Command:= UNITSTARTCOM;
    tmpLine.actione:= CILOPEN;
    tmpLine.Units:= iOperationUnits;
    writeLine(line:=tmpLine);
    
    tmpLine.Command:= WAITOPERATIONCOM;
    tmpLine.Units:= iOperationUnits;
    writeLine(line:=tmpLine);
  END_IF;

END_FUNCTION


FUNCTION convertOperationListToSLinesV2::convertOperationToUnit
	VAR_INPUT
		operation 	: calcOperationListV2::calcOperations;
	END_VAR
	VAR_OUTPUT
		units 	: Units;
	END_VAR

  //method to change bits in operation to bits in units, is only for bit 1 to 10, the BU's, other info is skipped
  bitMaskBus:=1023; //first 10 bits, is 1024-1
  units:= operation AND bitMaskBus;
  
  

END_FUNCTION

FUNCTION convertOperationListToSLinesV2::writeLine
	VAR_INPUT
		line 	: SRegelInfo;
	END_VAR
  
  line.Rnr:= wrLine;
  line.level:= currentOrder;
  ctrlSLineList.writeLine(Nr:=wrLine, Regel:=line);
  wrLine+=1;
  tmpLine:=emptyLine;
  

END_FUNCTION


FUNCTION convertOperationListToSLinesV2::moveWithX2
	VAR_INPUT
		distance 	: DINT;
	END_VAR

  //4284 don't use X2 wagon, so it's not yet programmed
  tmpLine.x1Pos:=distance;
  tmpLine.Command:= WAITOPERATIONCOM;
  tmpLine.Units:= waitUnits; //but we want to be sure waiting is also for the unit that transferred the bu's to the right position
  writeLine(line:=tmpLine);

END_FUNCTION


FUNCTION convertOperationListToSLinesV2::sendWagonBack
 
 IF ctrlSettings.PushMaterialToMinPos THEN
    tmpLine.Command:= UNITMOVECOM;
    tmpLine.x1Pos:= iMinPosX1;
    tmpLine.Units:= Units.PU1;
    tmpLine.speed:= tmpWorkSpeed;
    writeLine(line:=tmpLine);
    tmpLine.Command:= WAITOPERATIONCOM;
    tmpLine.Units:= Units.PU1;
    writeLine(line:=tmpLine);
  END_IF;
  
  //reset pressure roll 
  IF ctrlSettings.UsePressureroll THEN 
    tmpLine.Command:= UNITSTARTCOM;
    tmpLine.Units.CL9:= 1;
    tmpLine.actione:= CILOPEN; 
    writeLine(line:=tmpLine);
  END_IF;

  
//  //send wagon back to minimum pos wagon can be up//TP don't have this for henken 4642
//  tmpLine.Command:= UNITMOVECOM;
//  tmpLine.x1Pos:= ctrlSettings.minPosWagonUp;
//  tmpLine.speed:= 1000;
//  tmpLine.Units:= Units.PU1;
//  writeLine(line:=tmpLine);
//  tmpLine.Command:= WAITOPERATIONCOM;
//  tmpLine.Units:= Units.PU1;
//  writeLine(line:=tmpLine);
//  
//  //send wagon up
//  tmpLine.Command:= UNITSTARTCOM;
//  tmpLine.Units.PU1:= 1;
//  tmpLine.actione:= 3; //means wagon up
//  writeLine(line:=tmpLine);  
  
  
  tmpNextOperationLine:=ctrlOperationList.getLineFromList(nr:=0); //loadingpos is at line 0
  tmpLine.Command:= UNITMOVECOM;
  tmpLine.x1Pos:= tmpNextOperationLine.xPos;
  tmpLine.speed:= 1000; //no material, go full speed
  tmpLine.Units:= Units.PU1;
  writeLine(line:=tmpLine);

  wagonAlreadySendedBack:= 1;

  




END_FUNCTION

FUNCTION convertOperationListToSLinesV2::calcClampsToClose
	VAR_INPUT
		iOperationUnits 	: Units;
		iXpos 	: DINT;
	END_VAR
	VAR_OUTPUT
		clamps 	: Units;
	END_VAR
  
  clamps:=0;
  
  
  IF iOperationUnits.DoWithOutput= 0 THEN //for working with input, check if front of material is smaller then the minimum position of the clamp
    clamps.CL1:=((iOperationUnits AND ctrlSettings.usedUnitsCl1)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl1) & (iXPos>ctrlSettings.maxPosCl1);
    clamps.CL2:=((iOperationUnits AND ctrlSettings.usedUnitsCl2)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl2);// & (iXPos>ctrlSettings.maxPosCl2);
    clamps.CL3:=((iOperationUnits AND ctrlSettings.usedUnitsCl3)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl3) & (iXPos>ctrlSettings.maxPosCl3);
    clamps.CL4:=((iOperationUnits AND ctrlSettings.usedUnitsCl4)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl4) & (iXPos>ctrlSettings.maxPosCl4);
    clamps.CL5:=((iOperationUnits AND ctrlSettings.usedUnitsCl5)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl5) & (iXPos>ctrlSettings.maxPosCl5);
    clamps.CL6:=((iOperationUnits AND ctrlSettings.usedUnitsCl6)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl6) & (iXPos>ctrlSettings.maxPosCl6);
    clamps.CL7:=((iOperationUnits AND ctrlSettings.usedUnitsCl7)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl7) & (iXPos>ctrlSettings.maxPosCl7);
    clamps.CL8:=((iOperationUnits AND ctrlSettings.usedUnitsCl8)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl8) & (iXPos>ctrlSettings.maxPosCl8);
    clamps.CL9:=((iOperationUnits AND ctrlSettings.usedUnitsCl9)>0)&((iXPos-ctrlOperationList.stsActInputLength)<=ctrlSettings.minPosCl9) & (iXPos>ctrlSettings.maxPosCl9);
  

  
  ELSE //for working with the output, check of the end of the material is 
    clamps.CL1:=((iOperationUnits AND ctrlSettings.usedUnitsCl1)>0)&(iXPos>ctrlSettings.maxPosCl1);
    clamps.CL2:=((iOperationUnits AND ctrlSettings.usedUnitsCl2)>0)&(iXPos>ctrlSettings.maxPosCl2);
    clamps.CL3:=((iOperationUnits AND ctrlSettings.usedUnitsCl3)>0)&(iXPos>ctrlSettings.maxPosCl3);
    clamps.CL4:=((iOperationUnits AND ctrlSettings.usedUnitsCl4)>0)&(iXPos>ctrlSettings.maxPosCl4);
    clamps.CL5:=((iOperationUnits AND ctrlSettings.usedUnitsCl5)>0)&(iXPos>ctrlSettings.maxPosCl5);
    clamps.CL6:=((iOperationUnits AND ctrlSettings.usedUnitsCl6)>0)&(iXPos>ctrlSettings.maxPosCl6);
    clamps.CL7:=((iOperationUnits AND ctrlSettings.usedUnitsCl7)>0)&(iXPos>ctrlSettings.maxPosCl7);
    clamps.CL8:=((iOperationUnits AND ctrlSettings.usedUnitsCl8)>0)&(iXPos>ctrlSettings.maxPosCl8);
    clamps.CL9:=((iOperationUnits AND ctrlSettings.usedUnitsCl9)>0)&(iXPos>ctrlSettings.maxPosCl9);
  
  END_IF;
END_FUNCTION

