//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "calcOperationListV2"
	Revision           = "1.0"
	GUID               = "{0B290D5B-FD46-4634-A1F0-1108ABAD4257}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "true"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(630,1560)">
	<Channels>
		<Server Name="calcDone" GUID="{DA15745C-1C64-49C8-8AA8-B43844F970EE}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="elapsedTime" GUID="{6FA9E306-5B73-4DDC-8FA9-4E58C6147BEE}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="restLength" GUID="{5FC26B10-AAC3-44D9-9EBB-9B709F6D637B}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="sParFrontEndFlipAllowed" GUID="{1CA57F95-9EC9-4DA8-B9C2-7E38B57F3109}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="true" Retentive="false"/>
		<Server Name="sParMiterSaw" GUID="{9B03AB7F-257E-4545-A5C1-459A60C2CA0B}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="true" Retentive="false"/>
		<Server Name="sParTurnPointAtOutputSide" GUID="{EC4EBD62-CC44-473F-9C47-E9842044359C}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="false" Retentive="false"/>
		<Server Name="sParUpDownFlipAllowed" GUID="{FE3D97E5-40E7-4436-9875-BB1D73705B39}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="true" Retentive="false"/>
		<Server Name="sParYposTurnPoint" GUID="{1B75AA5E-6C3F-4644-A029-6B5C511BE19F}" Visualized="false" Initialize="true" DefValue="0" WriteProtected="false" Retentive="File"/>
		<Server Name="startCalc" GUID="{DE51B393-D45A-4F97-84DD-56FDB01C1DC7}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stprCalc" GUID="{2B4FA048-43FE-486C-8CFA-CACE0ACA009B}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="stsActInputLength" GUID="{1EF0D930-8588-4410-8DBB-401E1C770703}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsActProductHeigth" GUID="{511B6956-D788-41AB-BF2F-9B0D9C85BF31}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsActProductWidth" GUID="{B02A6842-ECA0-42E7-B06D-B6BFED717A39}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsElapsedTime" GUID="{B1860F1E-E8F9-4F0F-B677-261BD1CD54D0}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsMaterialBehindGuiding" GUID="{774CA138-894F-4C31-8DBF-CF4F532097E0}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="stsUsedUnits" GUID="{6515CE5D-9363-443D-AB31-995B04F0A454}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="tmpDontCombine" GUID="{215E7464-F8C4-419B-B270-CD4BEDE08FEE}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="tmpDontSort" GUID="{E8DD3063-5F25-4956-A17C-0972F462867E}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="ctrlAssemblyDb" Required="true" Internal="false"/>
		<Client Name="ctrlMillProgDb" Required="false" Internal="false"/>
		<Client Name="ctrlProductDb" Required="true" Internal="false"/>
		<Client Name="ctrlSettings" Required="true" Internal="false"/>
		<Client Name="CtrlTool" Required="false" Internal="false"/>
		<Client Name="iMaxPosX1" Required="true" Internal="false"/>
		<Client Name="iMaxPosX2" Required="false" Internal="false"/>
		<Client Name="iMaxPosXMill1" Required="true" Internal="false"/>
		<Client Name="iMiddleStartPosMill1X" Required="false" Internal="false"/>
		<Client Name="iMinPosX1" Required="true" Internal="false"/>
		<Client Name="iMinPosXMill1" Required="true" Internal="false"/>
		<Client Name="oRpmMill1" Required="false" Internal="false"/>
		<Client Name="oRpmMill2" Required="false" Internal="false"/>
	</Channels>
	<Network Name="calcOperationListV2">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C6B5A1AC-A7DB-4C69-836D-0FEBEAEAD113}"
				Class      = "cmBase"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="cmdHMI"/>
					<Server Name="ErrorNr"/>
					<Server Name="mode"/>
					<Server Name="state"/>
					<Server Name="stsHMI_RunsAllowed"/>
					<Server Name="stsInAlarm"/>
					<Server Name="stsIsInterlocked"/>
					<Client Name="id"/>
					<Client Name="nwEmOrUnit"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(1036,210),(864,210),"/>
			<Connection Source="this.state" Destination="_base.state" Vertices="(1036,270),(864,270),"/>
			<Connection Source="this.mode" Destination="_base.mode" Vertices="(1036,330),(864,330),"/>
			<Connection Source="this.cmdHMI" Destination="_base.cmdHMI" Vertices="(1036,390),(864,390),"/>
			<Connection Source="this.stsInAlarm" Destination="_base.stsInAlarm" Vertices="(1036,450),(864,510),"/>
			<Connection Source="this.stsIsInterlocked" Destination="_base.stsIsInterlocked" Vertices="(1036,510),(864,570),"/>
			<Connection Source="this.stsHMI_RunsAllowed" Destination="_base.stsHMI_RunsAllowed" Vertices="(1036,570),(864,630),"/>
			<Connection Source="this.ErrorNr" Destination="_base.ErrorNr" Vertices="(1036,630),(864,690),"/>
			<Connection Source="_base.nwEmOrUnit" Destination="this.nwEmOrUnit" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.id" Destination="this.id" Vertices="(218,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using cmBase

calcOperationListV2 : CLASS
: cmBase
	TYPE
	  calcOperations : BDINT  //! <Type Public="true" Name="calcOperations"/>
	  [
	    1 Bu1_saw,
	    2 Bu2_mill1,
	    3 Bu3_mill2,
	    4 Bu4,
	    5 Bu5,
	    6 Bu6,
	    7 Bu7,
	    8 Bu8,
	    9 Bu9,
	    10 Bu10,
	    11 FrontSaw,
	    12 EndSaw,
	    13 FirstInAssemb,
	    14 LastInAssemb,
	    15 CL1,
	    16 CL2,
	    17 CL3,
	    18 CL4,
	    19 CL5,
	    20 WasteStop,
	    21 WastePiece,
	    22 TakeOver,
	    23 loadingMaterial,
	    24 removeProduct,
	    25 tmpRemoveProduct,
	    26 x1GoAway,
	    27 wasteStopEndWaste,
	    28 removeWithOutput,
	    29 Bit29,
	    30 Bit30,
	    31 millAtOtherEnd,
	    32 optimDone,
	  ];
#pragma pack(push, 1)
	  xyPosMill : STRUCT
	    xPos : DINT;
	    yPos : DINT;
	    id : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  calcLine : STRUCT  //! <Type Public="true" Name="calcLine"/>
	    xPos : DINT;
	    yPos : DINT;
	    zPos : DINT;
	    operationId : DINT;
	    outputId : DINT;
	    ToolId : DINT;
	    sawAngle : DINT;
	    operations : calcOperations;
	    productLength : DINT;
	    MillPosses : ARRAY [1..2] OF xyPosMill;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  options : STRUCT  //! <Type Public="true" Name="options"/>
	    doFrontWaste : DINT;
	    doEndWaste : DINT;
	    wasteAtFront : DINT;
	    destroyBigWaste : DINT;
	    takeOverActive : DINT;
	    sortOperations : DINT;
	    combineOperations : DINT;
	    miterSaw : DINT;
	    wasteStopActive : DINT;
	    wasteStopForEndWasteActive : DINT;
	    MaxlengthForBin : DINT;
	    MaxLengthForTable : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	stprCalc 	: SvrCh_DINT;
	startCalc 	: SvrCh_DINT;
	calcDone 	: SvrCh_DINT;
	stsUsedUnits 	: SvrCh_Units;
	stsActInputLength 	: SvrCh_DINT;
	stsActProductWidth 	: SvrCh_DINT;
	stsActProductHeigth 	: SvrCh_DINT;
	stsMaterialBehindGuiding 	: SvrCh_DINT;
	stsElapsedTime 	: SvrCh_DINT;
	sParTurnPointAtOutputSide 	: SvrCh_DINT;
	sParUpDownFlipAllowed 	: SvrCh_DINT;
	sParFrontEndFlipAllowed 	: SvrCh_DINT;
	sParMiterSaw 	: SvrCh_DINT;
	sParYposTurnPoint 	: SvrCh_DINT;
	elapsedTime 	: SvrCh_UDINT;
	tmpDontSort 	: SvrCh_DINT;
	tmpDontCombine 	: SvrCh_DINT;
	restLength 	: SvrCh_DINT;
  //Clients:
	ctrlAssemblyDb 	: CltChCmd_AssemblyDbV2;
	ctrlProductDb 	: CltChCmd_ProductsDbV2;
	ctrlMillProgDb 	: CltChCmd_MillingProgsDbV2;
	ctrlSettings 	: CltChCmd_dbSettings;
	CtrlTool 	: CltChCmd_ToolsDb;
	iMinPosX1 	: CltCh_DINT;
	iMaxPosX1 	: CltCh_DINT;
	iMaxPosX2 	: CltCh_DINT;
	iMaxPosXMill1 	: CltCh_DINT;
	iMinPosXMill1 	: CltCh_DINT;
	iMiddleStartPosMill1X 	: CltCh_DINT;
	oRpmMill1 	: CltCh_DINT;
	oRpmMill2 	: CltCh_DINT;
  //Variables:
		o 	: options;
		calcList : ARRAY [0..defMaxCalcList] OF calcLine;

		emptyCalcLine 	: calcLine;
		tmpCalcPoint 	: calcLine;
		actAssembly 	: AssemblyDbV2::tRecipeData;
		TmpAssembly 	: AssemblyDbV2::tRecipeData;
		actProduct 	: ProductsDbV2::tRecipeData;
		foundProg 	: DINT;
		cntr 	: DINT;
		startAngle 	: DINT;
		endAngle 	: DINT;
		lastSawAngle 	: DINT;
		tmpTime 	: UDINT;
		nrCalcList 	: DINT;
		nrProdInAssembly 	: DINT;
		tmpProdPos 	: REAL;
		tmpOperationPos 	: REAL;
		calcProdLength 	: REAL;
		iProdNr 	: DINT;
		iProdAmount 	: DINT;
		iOpNr 	: DINT;
		iOpAmount 	: DINT;
		tmpUpDownFlipActive 	: DINT;
		tmpFrontEndFlipActive 	: DINT;
		tmpValue 	: DINT;
		tmpOperations 	: calcOperations;
		tmpZOperation 	: DINT;
		tmpYOperation 	: DINT;
		lastProductLength 	: DINT;
		lastSawPos 	: REAL;
		sizeOfEndPiece 	: DINT;
		tmpWaste 	: DINT;
		tmpMoveDistance 	: DINT;
		startNrMove 	: DINT;
		actFrontWaste 	: DINT;
		wastePieces 	: DINT;
		minPosTakeOverForX1 	: DINT;
		maxPosTakeOverForX2 	: DINT;
		iTmpEnd 	: DINT;
		iRead 	: DINT;
		iEnd 	: DINT;
		nrOptimizer 	: DINT;
		nrInList 	: DINT;
		tmpOptimed 	: DINT;
		tmpMillProg 	: MillingProgsDbV2::tRecipeData;
		tmpToolProg 	: ToolsDb::tRecipeData;
		tmpId 	: DINT;
		tmpMillXpos 	: REAL;
		tmpX2PosMill 	: DINT;
		tmpMillYpos 	: DINT;
		tmpMovingXMill 	: DINT;
		TmpMaxPosXMill1 	: DINT;
		useAngle 	: DINT;
		RestlengteOn 	: DINT;
		TimerRest 	: strTimer;
		TmpLoadpos 	: REAL;
		tmpNrCalc 	: DINT;
		xPosTest 	: DINT;
		tmpOffsetOutput 	: DINT;
		tmpProductLength 	: DINT;
		OffsetOutputProd 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION fillCalcList;
	
	FUNCTION writeCalcList
		VAR_INPUT
			xPos 	: REAL;
			yPos 	: DINT;
			x2Pos 	: DINT;
			operationId 	: DINT;
			outputId 	: DINT;
			productLength 	: DINT;
			sawAngle 	: DINT;
			useUnit 	: calcOperations;
			ToolId 	: DINT;
		END_VAR;
	
	FUNCTION fillFrontWaste;
	
	FUNCTION toolComp
		VAR_INPUT
			angle 	: DINT;
		END_VAR
		VAR_OUTPUT
			comp 	: REAL;
		END_VAR;
	
	FUNCTION widthComp
		VAR_INPUT
			angle 	: DINT;
			width 	: DINT;
		END_VAR
		VAR_OUTPUT
			comp 	: REAL;
		END_VAR;
	
	FUNCTION checkTurning;
	
	FUNCTION fillInBetweenSawing;
	
	FUNCTION fillOperations;
	
	FUNCTION fillProductEndSaw
		VAR_INPUT
			isLastProduct 	: DINT;
		END_VAR;
	
	FUNCTION fillOperation
		VAR_INPUT
			operation 	: calcOperations;
			xPos 	: REAL;
			yPos 	: DINT;
			zPos 	: DINT;
			id 	: DINT;
		END_VAR;
	
	FUNCTION checkWasteSawPosition;
	
	FUNCTION destroyBigWaste;
	
	FUNCTION moveForTurnPointNotAtZero;
	
	FUNCTION addOutputTableOperations;
	
	FUNCTION addOvertake;
	
	FUNCTION sortList;
	
	FUNCTION combineOperations;
	
	FUNCTION GLOBAL getLineFromList
		VAR_INPUT
			nr 	: DINT;
		END_VAR
		VAR_OUTPUT
			line 	: calcLine;
		END_VAR;
	
	FUNCTION GLOBAL giveNextOutputOperation
		VAR_INPUT
			startNr 	: DINT;
		END_VAR
		VAR_OUTPUT
			nextIsTable 	: DINT;
		END_VAR;
	
	FUNCTION addLastOperations;
	
	FUNCTION VIRTUAL GLOBAL startCalc::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL restLength::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL restLength::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd AssemblyDbV2
#pragma usingLtd dbSettings
#pragma usingLtd MillingProgsDbV2
#pragma usingLtd ProductsDbV2
#pragma usingLtd ToolsDb


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB calcOperationListV2::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CALCOPERATIONLISTV2
1$UINT, 0$UINT, (SIZEOF(::calcOperationListV2))$UINT, 
18$UINT, 13$UINT, 0$UINT, 
TO_UDINT(3979889133), "calcOperationListV2", //Class
TO_UDINT(1325959504), "cmBase", 1$UINT, 0$UINT, //Baseclass
//Servers:
(::calcOperationListV2.stprCalc.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1823240883), "stprCalc", 
(::calcOperationListV2.startCalc.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1509108252), "startCalc", 
(::calcOperationListV2.calcDone.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1081695783), "calcDone", 
(::calcOperationListV2.stsUsedUnits.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(321158690), "stsUsedUnits", 
(::calcOperationListV2.stsActInputLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1700613911), "stsActInputLength", 
(::calcOperationListV2.stsActProductWidth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4108725813), "stsActProductWidth", 
(::calcOperationListV2.stsActProductHeigth.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3243229636), "stsActProductHeigth", 
(::calcOperationListV2.stsMaterialBehindGuiding.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3373588075), "stsMaterialBehindGuiding", 
(::calcOperationListV2.stsElapsedTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(802146314), "stsElapsedTime", 
(::calcOperationListV2.sParTurnPointAtOutputSide.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(421453736), "sParTurnPointAtOutputSide", 
(::calcOperationListV2.sParUpDownFlipAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(459461999), "sParUpDownFlipAllowed", 
(::calcOperationListV2.sParFrontEndFlipAllowed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3134888615), "sParFrontEndFlipAllowed", 
(::calcOperationListV2.sParMiterSaw.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(314966340), "sParMiterSaw", 
(::calcOperationListV2.sParYposTurnPoint.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(1025130069), "sParYposTurnPoint", 
(::calcOperationListV2.elapsedTime.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1280260988), "elapsedTime", 
(::calcOperationListV2.tmpDontSort.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(458676534), "tmpDontSort", 
(::calcOperationListV2.tmpDontCombine.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3930996665), "tmpDontCombine", 
(::calcOperationListV2.restLength.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2249898333), "restLength", 
//Clients:
(::calcOperationListV2.ctrlAssemblyDb.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4058139899), "ctrlAssemblyDb", TO_UDINT(2560758913), "AssemblyDbV2", 1$UINT, 0$UINT, 
(::calcOperationListV2.ctrlProductDb.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3386981057), "ctrlProductDb", TO_UDINT(1214555786), "ProductsDbV2", 1$UINT, 0$UINT, 
(::calcOperationListV2.ctrlMillProgDb.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(966174109), "ctrlMillProgDb", TO_UDINT(2538437693), "MillingProgsDbV2", 0$UINT, 0$UINT, 
(::calcOperationListV2.ctrlSettings.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(928794703), "ctrlSettings", TO_UDINT(3270182861), "dbSettings", 0$UINT, 0$UINT, 
(::calcOperationListV2.CtrlTool.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4274898702), "CtrlTool", TO_UDINT(3718559786), "ToolsDb", 0$UINT, 0$UINT, 
(::calcOperationListV2.iMinPosX1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1950608727), "iMinPosX1", 
(::calcOperationListV2.iMaxPosX1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2451784374), "iMaxPosX1", 
(::calcOperationListV2.iMaxPosX2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(187306764), "iMaxPosX2", 
(::calcOperationListV2.iMaxPosXMill1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1682406419), "iMaxPosXMill1", 
(::calcOperationListV2.iMinPosXMill1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4097076473), "iMinPosXMill1", 
(::calcOperationListV2.iMiddleStartPosMill1X.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(613340782), "iMiddleStartPosMill1X", 
(::calcOperationListV2.oRpmMill1.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1390355230), "oRpmMill1", 
(::calcOperationListV2.oRpmMill2.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3419828900), "oRpmMill2", 
END_FUNCTION


#define USER_CNT_calcOperationListV2 19

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_calcOperationListV2] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION calcOperationListV2::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= cmBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= cmBase::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, cmBase::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_calcOperationListV2;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	cmBase::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF cmBase::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	stprCalc.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF stprCalc.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	startCalc.pMeth			:= StoreMethod( #M_RD_DIRECT(), #startCalc::Write() );
	IF startCalc.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	calcDone.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF calcDone.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParTurnPointAtOutputSide.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParTurnPointAtOutputSide.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	sParYposTurnPoint.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF sParYposTurnPoint.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	tmpDontSort.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF tmpDontSort.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	tmpDontCombine.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF tmpDontCombine.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	restLength.pMeth			:= StoreMethod( #restLength::Read(), #restLength::Write() );
	IF restLength.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// JdK 24-11-2020 changed about turning 0 point, because it's undoable to do that at the end, so every sawing the right sawangle is used depending on the side of the turningpoint of the machine

// JdK 25-3-2020 calcOperationListv2 created for test mitersaw with two drills (test for new MPS control)
// goal is to make a clean and understandable calc


// calculation is always done from a big position to a smaller one, operations are filled in from first product sawing pos/product before end pos
// of course calculation isn't a control module, but we can use  standard things from it, so why not use it as base?

// errornr 1: no product in assembly
// errornr 2: operation outside borders of product
// errornr 3: overtake doesn't fit
// errornr 4: position not reacheble by X1 wagon
// errornr 5: width and or height doesn't match
// errornr 6: rest material under 0
// errornr 7: milling doesn't fit
// errornr 8: calclines dont fit in calclist
// errornr 9: some products needs wastebin, others outputmagazine, can't be mixed up
// errornr 10: given sawingangle of 0* is no option




FUNCTION VIRTUAL GLOBAL calcOperationListV2::startCalc::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	startCalc := input;
  IF stprCalc= 0 THEN
    startCalc := 1;
    tmpTime:=ops.tAbsolute;
    resetAlarm(); //if calc is started, reset the alarms
    calcDone:=-1;
    stprCalc:=1;
    RestlengteOn:=0;
  ELSE
    startCalc:= 0;
  END_IF;  
	result := startCalc;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL calcOperationListV2::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  CASE stprCalc OF
  
  0: //just wait for start
  
  1: //set options, and set some stuff to 0
    o.doFrontWaste:= ctrlSettings.doFrontWaste;
    o.doEndWaste:= ctrlSettings.DoEndWaste;
    o.wasteAtFront:= ctrlSettings.allWasteAtFront;
    IF o.wasteAtFront = 1 THEN // MR: when waste at front, frontsawing required.
       o.doFrontWaste := 1;
       ctrlSettings.doFrontWaste := 1;
    END_IF;
    o.destroyBigWaste:= ctrlSettings.moveBigWasteToMagazin=0;
    o.takeOverActive:= ctrlSettings.overTakeActive;
    o.sortOperations:= tmpDontSort=0;
    o.combineOperations:= tmpDontCombine=0 & ctrlSettings.combineOperations=1;
    o.miterSaw:= sParMiterSaw;
    o.wasteStopActive:= ctrlSettings.noWasteStop= 0;
    o.wasteStopForEndWasteActive:= o.wasteStopActive & o.doEndWaste & ctrlSettings.wasteStopForEndWaste;
    stsMaterialBehindGuiding:= 0; //for some machines there can be material behind the backguiding, for different angels we have to compensate for this
    nrCalcList:=0;
    nrProdInAssembly:=0;
    actFrontWaste:= 0;
    stprCalc+= 1;
    // MR
    o.MaxlengthForBin:=ctrlSettings.maxLengthForWasteBin; //iMaxlengthForBin.Read();
    
  2: //check if there is info in assembly
    actAssembly:=ctrlAssemblyDb.GetRecipe(id:=TO_DINT(ctrlAssemblyDb.RecipeId));
    foundProg:=0;
    
    FOR cntr:=0 TO cAssemDbMaxProdLines-1 DO
      IF actAssembly.recipeList[cntr].amount>0 & actAssembly.recipeList[cntr].productId>0 THEN
        actProduct:=ctrlProductDb.GetRecipe(id:=actAssembly.recipeList[cntr].productId);
        stsActProductWidth:=actProduct.productWidth;
        stsActProductHeigth:=actProduct.productHeight;
        //set angles
        IF o.miterSaw THEN
          StartAngle:= actProduct.startAngle;
          EndAngle:= actProduct.endAngle;
          IF startAngle <> 900 THEN
            o.doFrontWaste:= 1; //always do frontwaste if startangle <> 900
          END_IF;
        ELSE
          startAngle:= 900;
          endAngle:= 900;
        END_IF;
        stsActInputLength:=actAssembly.InputLength;
        cntr:= CASSEMDBMAXPRODLINES;
        foundProg:=1;
      END_IF;
    END_FOR;
    IF foundProg=0 & RestlengteOn=0 THEN
      giveAlarm(errorNr:=1);
      calcDone:= 0;
      stprCalc:=0;
    ELSE
      _memset(dest:=#calcList[0], usByte:=0, cntr:=sizeof(calcList));
      _memset(dest:=#emptyCalcLine, usByte:=0, cntr:=sizeof(emptyCalcLine));
      iMinPosX1:=iMinPosX1.Read();
      iMaxPosX1:=iMaxPosX1.Read();
      iMinPosXMill1:= iMinPosXMill1.Read();
      iMaxPosXMill1:= iMaxPosXMill1.Read();
      oRpmMill1:= 0;
      oRpmMill2:= 0;
      stprCalc+=1;
    END_IF;
    
  3: //now fill calclist, check waste position (means move to the end if waste should be at the front), and check if we should saw the waste in little pieces
    fillCalcList();
    checkWasteSawPosition();
    IF o.destroyBigWaste= 1 THEN
      destroyBigWaste();
    END_IF;
    stprCalc+= 1;
    
  4: //do recalculations of x-positions for special saw situations
    IF sParYposTurnPoint<> 0 THEN
      moveForTurnPointNotAtZero();
    END_IF;
    stprCalc+= 1;
    
  5: //add outputoperations and overtake, then do sorting off lines
    //JdK 24-11-2020 don't add outputoperations for 4642 addOutputOperations();
    IF o.takeOverActive THEN
      addOvertake();
    END_IF;
    IF o.sortOperations & RestlengteOn = 0 THEN
      sortList();
//      IF o.combineOperations THEN //JdK 19-11-2020 don't combine operations for 4642
//        stprCalc+= 1;
//      ELSE
        stprCalc+= 1;
//      END_IF;
    ELSE
      stprCalc+= 2;
    END_IF;
    
  6: //sort list, add output operations, combine operations and sort list
    sortList();
    addOutputTableOperations();
    //combineOperations();
    sortList();
    stprCalc+= 1;
    
  7: //check if there was an alarm
    IF stsInAlarm= 0 THEN
      oRpmMill1.Write(input:=oRpmMill1);
      oRpmMill2.Write(input:=oRpmMill2);
      calcDone:=1;
    ELSE
      calcDone:=0;
    END_IF;
    elapsedTime:=ops.tAbsolute-tmpTime;
    stprCalc:=0;
    RestlengteOn:=0;
    
    
  
  
  END_CASE;

  state:= 0;
  TimerRest:= runTimer(Active:=RestlengteOn = 0, iMem:=TimerRest, TimerTime:=5000, Pause:=FALSE);

END_FUNCTION


FUNCTION calcOperationListV2::fillCalcList

  //method to put every operation into the list
  tmpProdPos:=actAssembly.InputLength; //tmpProdPos is position inputwagon should have for this operation, always start at input length
  
  //start with loading material
  TmpLoadpos:=tmpProdPos+ctrlSettings.freeSpaceLoadMaterial+ctrlSettings.offsetTakeIn;
  if TmpLoadpos > iMaxPosX1 then
    TmpLoadpos:=iMaxPosX1;
  end_if;
  writeCalcList(xPos:=TmpLoadpos, 
                yPos:=0, x2Pos:=0, 
                operationId:=actAssembly.AmountTodo, //use this variable to store amount to do
                outputId:=0, productLength:=0, sawAngle:= 900, useUnit:=calcOperations.loadingMaterial, toolid:=0);
  
  //if it's in the settings do a wastestop for the waste of the length before
  IF o.wasteStopForEndWasteActive=1 THEN 
    writeCalcList(xPos:=tmpProdPos +ctrlSettings.offsetWasteStop, 
                  yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, sawAngle:= 900, 
               useUnit:=calcOperations.WasteStop+calcOperations.wasteStopEndWaste, toolid:=0); 
  END_IF;

  fillFrontWaste();


  //general stuff for assembly is done, now loop through all different products
  FOR iProdNr:=0 TO CASSEMDBMAXPRODLINES DO
  
    //check if there is an amount to do in this prod
    IF actAssembly.recipeList[iProdNr].amount> 0 THEN //at least one of this products is required
    
      //first get product data
      actProduct:=ctrlProductDb.GetRecipe(id:=actAssembly.recipeList[iProdNr].productId);
      if RestlengteOn = 0 then
        IF actProduct.productHeight<>stsActProductHeigth | actProduct.productWidth<> stsActProductWidth THEN //check if height and width are all the same
          giveAlarm(errorNr:=5);
          exit;
        END_IF;    
        IF O.miterSaw= 1 & (actProduct.startAngle= 0 | actProduct.endAngle= 0) THEN //check if angles are valid
          giveAlarm(errorNr:=10);
          exit;
        END_IF; 
      end_if;
      
      FOR iProdAmount:=1 TO actAssembly.recipeList[iProdNr].amount DO //fill for amount we should do product in assembly
        //get product info, do this every time, because is product is turned, this info maybe changed
        IF o.miterSaw THEN
          StartAngle:= actProduct.startAngle;
          EndAngle:= actProduct.endAngle; 
        ELSE
          startAngle:= 900;
          endAngle:= 900;
        END_IF;
        calcProdLength:= TO_REAL(actProduct.length); //use tmp var because if we turn product also the calc length changes
        
        tmpUpDownFlipActive:= 0; //before checking turning, always write those pars to 0
        tmpFrontEndFlipActive:= 0;        
        IF sParFrontEndFlipAllowed=1 | sParUpDownFlipAllowed=1 THEN  //only check turning if one of the turning options is available
          checkTurning(); //if product is turned, parameters for this are changed in checkTurning
        END_IF;
        
        //check if we have to do in betweeen sawing
        IF startAngle<> lastSawAngle THEN
          fillInBetweenSawing();
        END_IF;
        
        //now do operations
        if RestlengteOn = 0 then
          fillOperations();
        end_if;
        
        //end do endsaw
        fillProductEndSaw(isLastProduct:=(iProdAmount=actAssembly.recipeList[iProdNr].amount & actAssembly.recipeList[iProdNr+1].amount=0));//Tp was 1, this so be null
        
        nrProdInAssembly+=1;
        

        
      END_FOR;
      lastProductLength:=actProduct.length; //value needed for calculation take over
      
    ELSE
      IF iProdNr= 0 THEN
        giveAlarm(errorNr:=1); //give alarm no data
        exit;
      END_IF;
      EXIT;
    
    END_IF;
  
  END_FOR;
  lastSawPos:= tmpProdPos;


END_FUNCTION


FUNCTION calcOperationListV2::writeCalcList
	VAR_INPUT
		xPos 	: REAL;
		yPos 	: DINT;
		x2Pos 	: DINT;
		operationId 	: DINT;
		outputId 	: DINT;
		productLength 	: DINT;
		sawAngle 	: DINT;
		useUnit 	: calcOperations;
		ToolId 	: DINT;
	END_VAR
  
  if RestlengteOn = 0 then
    //use automaticly counting nrCalcList
    IF (xPos > iMaxPosX1 | (xPos < iMinPosX1 & o.takeOverActive=0) | xPos < iMinPosX1)  THEN //check if position is available by wagon, MR: xPos <= 0: iMinPosX1 substituted for zero
      giveAlarm(errorNr:=4);
    END_IF;

    calcList[nrCalcList].xPos:=to_dint(xPos);
    IF useUnit.Bu2_mill1 THEN
      calcList[nrCalcList].MillPosses[1].xPos:= x2Pos;
      calcList[nrCalcList].MillPosses[1].yPos:= yPos; //y is always startpoint in heigth/width for milling
      calcList[nrCalcList].MillPosses[1].id:= operationId;
    END_IF;
    IF useUnit.Bu3_mill2 THEN
      //no x movement for this one calcList[nrCalcList].MillPosses[2].xPos:= x2Pos;
      calcList[nrCalcList].MillPosses[2].yPos:= yPos; //y is always startpoint in heigth/width for milling
      calcList[nrCalcList].MillPosses[2].id:= operationId;
    END_IF;  
    calcList[nrCalcList].yPos:=yPos;
    calcList[nrCalcList].zPos:=0; //don't use z pos when mills are involved
    calcList[nrCalcList].operationId:=operationId;
    calcList[nrCalcList].operations:=useUnit;
    calcList[nrCalcList].productLength:=productLength;
    calcList[nrCalcList].outputId:=outputId;
    calcList[nrCalcList].sawAngle:=sawAngle;
    calcList[nrCalcList].ToolId:=ToolId;
    IF nrCalcList < DEFMAXCALCLIST THEN
      nrCalcList+=1;
    ELSE
      giveAlarm(errorNr:=8);
    END_IF;
  end_if;

END_FUNCTION


FUNCTION calcOperationListV2::fillFrontWaste

  // check if we have frontwaste, if we have, fill it and calculate position of operation
  IF o.doFrontWaste=1 | startAngle<> 900 THEN //if startangle is not 90 degree we always have to do a front sawing
  
    IF sParTurnPointAtOutputSide THEN //if turning point at outputside, use other saw angle for toolcompensation
      useAngle:= endAngle;
    ELSE
      useAngle:= startAngle;
    END_IF;
  
    tmpProdPos:=tmpProdPos-ctrlSettings.minFrontWaste-toolComp(angle:=useAngle);
    actFrontWaste:= stsActInputLength- TO_DINT(tmpProdPos);
    
    IF StartAngle > 900 THEN //also add width compensation
      tmpProdPos-= widthComp(angle:=startAngle, width:=stsActProductWidth);
    ELSIF StartAngle < 900 THEN //compensate for material behind back guiding machine
      tmpProdPos-= widthComp(angle:=StartAngle, width:=stsMaterialBehindGuiding);
    END_IF;
    
    writeCalcList(xPos:=tmpProdPos, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, sawAngle:= StartAngle,
               useUnit:=calcOperations.BU1_saw+calcOperations.FrontSaw, toolid:=0);
       
      
    //frontsawing also requires waste stop
    IF o.wasteStopActive= 1 THEN
       writeCalcList(xPos:=tmpProdPos+ctrlSettings.offsetWasteStop, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=actFrontWaste, sawAngle:= 900,
                 useUnit:=calcOperations.WasteStop+calcOperations.FrontSaw, toolid:=0); // MR: 23-12-2020, operation FrontSaw added, used for output table  
    END_IF;
    
    lastSawAngle:= StartAngle;
  ELSE
    lastSawAngle:= 900; //no sawing means angle is 90degree
  END_IF;
    




END_FUNCTION


FUNCTION calcOperationListV2::toolComp
	VAR_INPUT
		angle 	: DINT;
	END_VAR
	VAR_OUTPUT
		comp 	: REAL;
	END_VAR
  VAR
  	tmpAngle: REAL;
  END_VAR

  //method to calculate compensation for sawingblade
  tmpAngle:= to_real((abs(900-angle))/10) * PIVALUE / 180;   //recalculate angle sawing to angle between sawingblade and backguiding. calc in rads
  IF tmpAngle <> 0 THEN
    comp:= to_real(ctrlSettings.sawWidth) / COS(tmpAngle);
  ELSE //only if input angle is 90*, so then compensation = toolwidth
    comp:= ctrlSettings.sawWidth;
  END_IF;

END_FUNCTION


FUNCTION calcOperationListV2::widthComp
	VAR_INPUT
		angle 	: DINT;
		width 	: DINT;
	END_VAR
	VAR_OUTPUT
		comp 	: REAL;
	END_VAR
  VAR
  	tmpAngle: REAL;
  END_VAR

  //method to calculate compensation for material under angle
  IF angle < 900 & angle > 0 THEN
    tmpAngle:= to_real(900-angle)/10 * PIVALUE / 180; //calculate angle to radials
    comp:= to_real(width) * tan(tmpAngle);
  ELSIF angle > 900 & angle < 1800 THEN
    tmpAngle:= to_real(1800-angle)/10 * PIVALUE / 180; //calculate angle to radials, other side of angle bow is easier to calc with
    comp:=TO_REAL(width) * tan(tmpAngle);
  ELSE
    comp:= 0;
  END_IF;
  
END_FUNCTION


FUNCTION calcOperationListV2::checkTurning
  
  //method to check if we should turn the product, can be updown, or front end
  
  //up down flip means turn around lengthline, so front stays at the front and end at the end, but up becomes down vice versa
  IF sParUpDownFlipAllowed=1 & actProduct.upDownFlipAllowed= 1 THEN //check if up/down flip can be done
    IF startAngle<> 900 & startAngle<> lastSawAngle & (1800- startAngle)= lastSawAngle THEN //so only if angle isn't90degree (because turning this way doesn't make sense then) and turning makes it fit, then turn
      startAngle:= 1800-startAngle;
      endAngle:= 1800-endAngle;
      tmpUpDownFlipActive:= 1;
    END_IF;
  END_IF;
  
  //front end flip means we turn over widthline, up stays up and down stays down, but front and end change positions
  IF tmpUpDownFlipActive=0 & sParFrontEndFlipAllowed=1 & actProduct.frontEndFilpAllowed= 1 THEN //check if front/end flip can be done
    IF startAngle<> lastSawAngle & ((*1800-*)endAngle)=lastSawAngle THEN //only if angles aren't already fitting, and turning makes them fit
      tmpValue:= startAngle;
      startAngle:= endAngle;
      endAngle:= tmpValue; // startAngle;
      tmpFrontEndFlipActive:= 1;
    END_IF;
  END_IF;
  
  //calculate new length
  IF tmpUpDownFlipActive= 1 | tmpFrontEndFlipActive= 1 THEN //how we flip it doesn't matter for change in product length at side of backguiding
    //calculate new prodlength at side of backguiding
    IF StartAngle < 900 THEN //extra lenth by angle moves from opposite to backguiding pos, so add it
      calcProdLength+= widthComp(angle:=StartAngle, width:=stsActProductWidth);
    ELSIF StartAngle > 900 THEN //extra length by angle moves from backguiding to opposite pos, so distract it
      calcProdLength-= widthComp(angle:=StartAngle, width:=stsActProductWidth);
    END_IF; //90* means no widthCompensation
    //endsawing works other way around
    IF EndAngle < 900 THEN //extra length by angle moves from backguiding to opposite pos, so distract it 
      calcProdLength-= widthComp(angle:=endAngle, width:=stsActProductWidth);
    ELSIF EndAngle > 900 THEN //extra lenth by angle moves from opposite to backguiding pos, so add it
      calcProdLength+= widthComp(angle:=endAngle, width:=stsActProductWidth);
    END_IF; //90* means no widthCompensation        
  END_IF;  

END_FUNCTION


FUNCTION calcOperationListV2::fillInBetweenSawing
//if the next product has another startangle then the last saw angle, do an extra sawing, this method fills this extra sawing
// check is done before calling this method, so we always do this in between sawing

  //there are a few situations where the in between piece is quite different
  IF lastSawAngle= 900 THEN //simple situation, only compensate for start angle
    IF startAngle > 900 THEN //means angle moves into product before, so do product compensation
      tmpProdPos -= widthComp(angle:=startAngle, width:=stsActProductWidth);
    ELSIF startAngle < 900 THEN //means material behind back guiding moves into product before, so do compensation for this
      tmpProdPos -= widthComp(angle:=startAngle, width:=stsMaterialBehindGuiding);
    END_IF;
  ELSIF startAngle= 900 THEN //also simple situation, only compensate for last angle
    IF lastSawAngle < 900 THEN //means last angle moves into new product, so do product compensation
      tmpProdPos -= widthComp(angle:=lastSawAngle, width:=stsActProductWidth);
    ELSIF lastSawAngle > 900 THEN //means material behind back guiding moves into new product, so compensate this
      tmpProdPos -= widthComp(angle:=lastSawAngle, width:=stsMaterialBehindGuiding);
    END_IF;
  ELSIF startAngle > 900 & lastSawAngle < 900 THEN //means both sides point into each other on product side, so do compensation for both sides
    tmpProdPos -= widthComp(angle:=startAngle, width:=stsActProductWidth);
    tmpProdPos -= widthComp(angle:=lastSawAngle, width:=stsActProductWidth);
  ELSIF startAngle < 900 & lastSawAngle > 900 THEN //means both back side points into each other, so compensate for material behind back guiding on both sides
    tmpProdPos -= widthComp(angle:=startAngle, width:=stsMaterialBehindGuiding);
    tmpProdPos -= widthComp(angle:=lastSawAngle, width:=stsMaterialBehindGuiding);   
  ELSIF startAngle > 900 & lastSawAngle > 900 THEN //both angles are in same direction, so only distract difference in compensation on product side
    tmpProdPos -= abs(widthComp(angle:=startAngle, width:=stsActProductWidth)-widthComp(angle:=lastSawAngle, width:=stsActProductWidth));
  ELSIF startAngle < 900 & lastSawAngle < 900 THEN //both angles are in same direction, so only distract difference in compensation for material behind back guiding
    tmpProdPos -= abs(widthComp(angle:=startAngle, width:=stsMaterialBehindGuiding)-widthComp(angle:=lastSawAngle, width:=stsMaterialBehindGuiding));
  END_IF;
      
  //distract toolwidth and the in between piece
  IF sParTurnPointAtOutputSide THEN  //if turning point at outputside, use other saw angle for toolcompensation
    useAngle:= endAngle;
  ELSE
    useAngle:= startAngle;
  END_IF;  
  
  tmpProdPos-= (toolComp(angle:=useAngle) + ctrlSettings.lengthBetweenPiece);
  
  //and do the real filling
  writeCalcList(xPos:=tmpProdPos, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0,
             productLength:=actProduct.length, sawAngle:= StartAngle, useUnit:=calcOperations.BU1_saw+calcOperations.WastePiece, toolid:=0);       
             
  //and fill in waste stop
  IF o.wasteStopActive THEN
    writeCalcList(xPos:=tmpProdPos+ctrlSettings.offsetWasteStop, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0,
               productLength:=actProduct.length, sawAngle:= StartAngle, useUnit:=calcOperations.WasteStop, toolid:=0);  
  END_IF;
    


END_FUNCTION


FUNCTION calcOperationListV2::fillOperations
//method to calculate all positions of operations

  
  FOR iOpNr:=0 TO CPRODDBMAXOPERATIONLINES DO
    IF actProduct.operations[iOpNr].operations> 0 & actProduct.operations[iOpNr].amount> 0 THEN //only if there is an unit selected, and amount > 0
      FOR iOpAmount:=0 TO actProduct.operations[iOpNr].amount-1 DO //do operation for required amount
        IF tmpFrontEndFlipActive= 0 & tmpUpDownFlipActive= 0 THEN //means normal way
          tmpOperationPos:=tmpProdPos-to_real(actProduct.operations[iOpNr].xPos+iOpAmount*actProduct.operations[iOpNr].pitch);
          IF tmpOperationPos < tmpProdPos-actProduct.length THEN //check if operation is within borders product
            giveAlarm(errorNr:=2);
          END_IF;
          tmpOperations:= actProduct.operations[iOpNr].operations;
          tmpZOperation:= actProduct.operations[iOpNr].zPos;
          tmpYOperation:= actProduct.operations[iOpNr].yPos;
        ELSIF tmpUpDownFlipActive= 1 THEN
          tmpOperationPos:=tmpProdPos-to_real(actProduct.operations[iOpNr].xPos+iOpAmount*actProduct.operations[iOpNr].pitch);
          IF tmpOperationPos < tmpProdPos-actProduct.length THEN //check if operation is within borders product
            giveAlarm(errorNr:=2);
          END_IF;          
          IF StartAngle < 900 THEN //means extra productlength by angle changed from opposite to backguiding, so distract extra pos
            tmpOperationPos-= widthComp(angle:=StartAngle, width:=stsActProductWidth);
          ELSIF StartAngle > 900 THEN //means extra productlength by angle changed from backguiding to opposite, so add this extra pos to get right position of operation
            tmpOperationPos+= widthComp(angle:=StartAngle, width:=stsActProductWidth);
          END_IF;
          tmpOperations:= actProduct.operations[iOpNr].operations;
          tmpZOperation:= actProduct.operations[iOpNr].zPos;
          tmpYOperation:= stsActProductWidth - actProduct.operations[iOpNr].yPos; //in horizontal direction, we have to flip the position        
          //we also have to flip the units we use, but because this is a virtual machine we can't do this
          //JdK 19-11-2020 for 4642 just use same bu's
//          IF tmpOperations.Bu2_mill1=1 & tmpOperations.bu4=0 THEN //if bu2 and bu4 are oposite
//            tmpOperations.Bu2_mill1:= 0;
//            tmpOperations.BU4:= 1;
//          ELSIF tmpOperations.Bu2_mill1=0 | tmpOperations.BU5= 1 THEN
//            tmpOperations.Bu2_mill1:= 0;
//            tmpOperations.BU4:= 1;          
//          END_IF;
//          IF tmpOperations.Bu3_mill2= 1 & tmpOperations.BU5= 0 THEN //if bu3 and bu5 are oposite
//            tmpOperations.Bu3_mill2:= 0;
//            tmpOperations.BU5:= 1;
//          ELSIF tmpOperations.Bu3_mill2= 0 & tmpOperations.BU5= 1 THEN 
//            tmpOperations.Bu3_mill2:= 1;
//            tmpOperations.BU5:= 0;
//          END_IF;
        ELSIF tmpFrontEndFlipActive= 1 THEN
          tmpOperationPos:=tmpProdPos-to_real(actProduct.length+(actProduct.operations[iOpNr].xPos+iOpAmount*actProduct.operations[iOpNr].pitch));
          IF tmpOperationPos > tmpProdPos THEN //check if operation is within borders product
            giveAlarm(errorNr:=2);
          END_IF;          
          IF StartAngle < 900 THEN //means extra productlength by angle changed from opposite to backguiding, so distract extra pos
            tmpOperationPos-= widthComp(angle:=StartAngle, width:=stsActProductWidth);
          ELSIF StartAngle > 900 THEN //means extra productlength by angle changed from backguiding to opposite, so add this extra pos to get right position of operation
            tmpOperationPos+= widthComp(angle:=StartAngle, width:=stsActProductWidth);
          END_IF;
          IF endAngle < 900 THEN //means extra productlength by angle changed from opposite to backguiding, so add extra pos
            tmpOperationPos+= widthComp(angle:=endAngle, width:=stsActProductWidth);
          ELSIF endAngle > 900 THEN //means extra productlength by angle changed from backguiding to opposite, so distract this extra pos to get right position of operation
            tmpOperationPos-= widthComp(angle:=endAngle, width:=stsActProductWidth);
          END_IF;          
          
          tmpOperations:= actProduct.operations[iOpNr].operations;
          tmpZOperation:= actProduct.operations[iOpNr].zPos;
          tmpYOperation:= actProduct.operations[iOpNr].yPos;
          //we also have to flip the horizontal units we use, but because this is a virtual machine we can't do this
            //JdK 19-11-2020 for 4642 just use same bu's
//          IF tmpOperations.Bu2_mill1=1 & tmpOperations.bu4=0 THEN //if bu2 and bu4 are oposite, and horizontal
//            tmpOperations.Bu2_mill1:= 0;
//            tmpOperations.BU4:= 1;
//          ELSIF tmpOperations.Bu2_mill1=0 | tmpOperations.BU4= 1 THEN
//            tmpOperations.Bu2_mill1:= 0;
//            tmpOperations.BU4:= 1;          
//          END_IF;
    
        END_IF;

        fillOperation(operation:=tmpOperations, 
                           xPos:=tmpOperationPos, 
                           yPos:=tmpYOperation, 
                           zPos:=tmpZOperation, 
                             id:=actProduct.operations[iOpNr].operationId);
      END_FOR;
    ELSE //operation data not availble in this line, skip other operations
      iOpNr:= CPRODDBMAXOPERATIONLINES+1; //stop it
    END_IF;
  END_FOR;


END_FUNCTION


FUNCTION calcOperationListV2::fillProductEndSaw
	VAR_INPUT
		isLastProduct 	: DINT;
	END_VAR
// method fillProductEndSaw is to calculate position of endsaw and check if we should add one 

  tmpProdPos:= tmpProdPos-calcProdLength; //always distract recalculated product length
  sizeOfEndPiece:= TO_DINT(tmpProdPos);
  
  IF isLastProduct=0 | (o.doEndWaste=1 | endAngle<>900 | (o.doFrontWaste=0 & o.wasteAtFront=0 & tmpProdPos<>0.0)) THEN //means endsawing needed
    
    IF sParTurnPointAtOutputSide THEN //if turning point at outputside, use other saw angle for toolcompensation
      useAngle:= endAngle;
    ELSE
      useAngle:= startAngle;
    END_IF;    
    
    tmpProdPos-= toolComp(angle:=useAngle);
    sizeOfEndPiece:= TO_DINT(tmpProdPos);
    //store product ID into operation ID
    writeCalcList(xPos:=tmpProdPos, yPos:=0, x2Pos:=0, operationId:=actAssembly.recipeList[iProdNr].productId, outputId:=actProduct.operationId1,   //fill in how we should remove the product 
               productLength:=actProduct.length, sawAngle:= EndAngle, useUnit:=calcOperations.BU1_saw, toolid:=0);        //put startangle in x2 pos, we need this one for correction on the turning point
    
    //check if it still fits
    IF endAngle< 900 THEN //means product is bigger then point of start sawing
      sizeOfEndPiece-= TO_DINT(widthComp(angle:=endAngle, width:=stsActProductWidth));
      IF ((sizeOfEndPiece < ctrlSettings.minEndWaste) | (sizeOfEndPiece < ctrlSettings.minEndWasteAngle) )& RestlengteOn =0 THEN
        giveAlarm(errorNr:=6);
      END_IF;
    ELSIF endAngle> 900 THEN //means material behind back guiding is bigger then point of start sawing
      sizeOfEndPiece-= TO_DINT(widthComp(angle:=endAngle, width:=stsMaterialBehindGuiding));
      IF ((sizeOfEndPiece < ctrlSettings.minEndWaste) | (sizeOfEndPiece < ctrlSettings.minEndWasteAngle) )& RestlengteOn =0 THEN
        giveAlarm(errorNr:=6);      
      END_IF;
    ELSE
      IF tmpProdPos < ctrlSettings.minEndWaste & ctrlSettings.doEndWaste & RestlengteOn =0 THEN
        giveAlarm(errorNr:=6);
      END_IF;    
    END_IF;
    lastSawAngle:= EndAngle;//tP  12-11-2020 add lastsawing
  ELSE //check if it still fits
    IF tmpProdPos< 0 & RestlengteOn =0 THEN
      giveAlarm(errorNr:=6);
    END_IF;
  END_IF;
  

END_FUNCTION


FUNCTION calcOperationListV2::fillOperation
	VAR_INPUT
		operation 	: calcOperations;
		xPos 	: REAL;
		yPos 	: DINT;
		zPos 	: DINT;
		id 	: DINT;
	END_VAR
  VAR
  	toolDiam 	: DINT; //JdK 19-10-2020 don't know yet where to get toolDiam from
  END_VAR

  //toolDiam:= 100;

  //impossible to add saw operation

  //set each operation with right offset in list
  TmpMaxPosXMill1:=iMaxPosXMill1;

//  IF operation.Bu2_mill1 THEN
//    tmpMillProg:= ctrlMillProgDb.GetRecipe(id:=id);
//    tmpToolProg:= CtrlTool.GetRecipe(id:=tmpMillProg.ToolId);//Tp 18-11-2020 get tool id
//    toolDiam:= tmpToolProg.diameter;
//    
//    //mill is always started from left (input) side off middle
//    iMiddleStartPosMill1X:= iMiddleStartPosMill1X.Read();
//    tmpX2PosMill:= iMiddleStartPosMill1X + (tmpMillProg.xDimension/2) - (toolDiam/2) - tmpMillProg.offsetForXmovement; //use offset for manipulation of start position, but normal take half of the dimension plus the middle as a startpos (JdK 19-11-2020)
//    
//     tmpMillxpos:= xPos+iMiddleStartPosMill1X- (toolDiam/2);//(*tmpX2PosMill *)+ (tmpMillProg.xDimension/2) - (toolDiam/2) ;//Jdk 27-11-2020. just take x pos mill tmpMillXpos:= xPos+ tmpX2PosMill+(toolDiam/2) ; //JdK 19-11-2020 just take start mill x pos + half tool diam as offset-tmpMillProg.startX-tmpMillProg.offsetForXmovement;//start as much as possible at max pos
//    //JdK 19-11-2020 old way of working tmpX2PosMill:= TmpMaxPosXMill1-tmpMillProg.offsetForXmovement;
//   
//    //JdK 19-11-2020 not for 4642
////    IF operation.millAtOtherEnd= 1 THEN //means do it as close as possible to the saw
////      tmpMovingXMill:=TmpMaxPosXMill1-iMinPosXMill1-tmpMillProg.xDimension+toolDiam+tmpMillProg.offsetForXmovement;
////      IF tmpX2PosMill-tmpMovingXMill< iMinPosXMill1 THEN
////        tmpMovingXMill:= tmpX2PosMill-iMinPosXMill1;
////      END_IF;
////      tmpMillXpos-= tmpMovingXMill;
////      tmpX2PosMill-= tmpMovingXMill;
////    END_IF;
//  
//    CASE tmpMillProg.yToolComp OF
//    
//    noComp:
//      tmpMillYpos:= yPos+tmpMillProg.startY;
//      
//    compPositiveMovement:
//      tmpMillYpos:= yPos+tmpMillProg.startY+(toolDiam/2); //add tool diam, because toolcomp should be in direction of first movement
//      
//    compNegativeMovement:
//      tmpMillYpos:= yPos+tmpMillProg.startY-(toolDiam/2); //other way around
//    
//    END_CASE;
//
//    IF (tmpMillProg.xDimension-toolDiam) < (tmpX2PosMill-iMinPosXMill1) & tmpX2PosMill <= TmpMaxPosXMill1 THEN //check if milling fits
//      writeCalcList(xPos:=tmpMillXpos, 
//                    yPos:=tmpMillYpos, 
//                    x2Pos:=tmpX2PosMill, 
//                    operationId:=id, 
//                    outputId:=0, 
//                    productLength:=actProduct.length, 
//                    sawAngle:=0, 
//                    useUnit:=calcOperations.Bu2_mill1, 
//                    toolid:=tmpMillProg.ToolId);
//    ELSE
//      giveAlarm(errorNr:=7);
//    END_IF;
//    IF oRpmMill1= 0 THEN //only set rpm for first milling
//      oRpmMill1:= tmpMillProg.reqRPM;
//    END_IF;
//    
//  END_IF;

  IF operation.Bu2_mill1 THEN
    tmpMillProg:= ctrlMillProgDb.GetRecipe(id:=id);
    tmpToolProg:= CtrlTool.GetRecipe(id:=tmpMillProg.ToolId);//Tp 18-11-2020 get tool id
    toolDiam:= tmpToolProg.diameter;
  
    CASE tmpMillProg.yToolComp OF
    
    noComp:
      tmpMillYpos:= yPos+tmpMillProg.startY;
      
    compPositiveMovement:
      tmpMillYpos:= yPos+tmpMillProg.startY+(toolDiam/2); //add tool diam, because toolcomp should be in direction of first movement
      
    compNegativeMovement:
      tmpMillYpos:= yPos+tmpMillProg.startY-(toolDiam/2); //other way around
    
    END_CASE;

    IF tmpMillProg.xDimension-toolDiam= 0 | tmpMillProg.xDimension-toolDiam/2= 0 THEN //check if milling fits
      writeCalcList(xPos:=xPos+TO_REAL(ctrlSettings.offsetBu3), 
                    yPos:=tmpMillYpos, 
                    x2Pos:=0, 
                    operationId:=id, 
                    outputId:=0, 
                    productLength:=actProduct.length, 
                    sawAngle:=0, 
                    useUnit:=calcOperations.Bu2_mill1, 
                    toolid:=tmpMillProg.ToolId);
    ELSE
      giveAlarm(errorNr:=7);
    END_IF;
    IF oRpmMill2= 0 THEN //only set rpm for first milling
      oRpmMill2:= tmpMillProg.reqRPM;
    END_IF;

  END_IF;

  
END_FUNCTION


FUNCTION calcOperationListV2::checkWasteSawPosition
//method to check if we need to move all positions, because when filling calclist everything is done from minimal front waste
//if we need all waste at front, or if there is a frontsawing but no waste sawing we need to move everything
//also if we have no frontwaste and no endwaste, and all waste need te be at the front, we need to add a frontsawing (needed at right place in calclist)

  IF endAngle <> 900 & ctrlSettings.minEndWasteAngle > ctrlSettings.minEndWaste THEN
    tmpWaste:= ctrlSettings.minEndWasteAngle;
  ELSE
    tmpWaste:= ctrlSettings.minEndWaste;
  END_IF;

  IF (o.wasteAtFront & ((sizeOfEndPiece > tmpWaste | (O.doEndWaste=0 & endAngle=900 & tmpProdPos>0))) | //move if waste should be at front and endwaste is bigger then should be, or if there is restlength and no endsawing
            (o.doFrontWaste=1 & o.doEndWaste=0 & endAngle=900 & tmpProdPos>0))| RestlengteOn =1 THEN  //also if there is no endwaste but there is a front waste
  
    o.wasteAtFront:= 1; //even if it's because of no end waste, write this one to 1 so we know the waste is at the beginning
  
    IF o.wasteStopForEndWasteActive THEN //check where to start with moving the positions
      startNrMove:= 2; //don't move intake off material and removing of endwaste
    ELSE
      startNrMove:= 1; //don't move intake off material
    END_IF;  
    
    IF o.doEndWaste= 0 & endAngle=900 THEN //move to zero
      tmpMoveDistance:=TO_DINT(tmpProdPos); //just move the rest above 0 
    ELSE
      tmpMoveDistance:=TO_DINT(tmpProdPos-tmpWaste); //move the rest above the waste piece
    END_IF;
  
    //replace all xpositions

    FOR cntr:= startNrMove TO nrCalcList-1 DO
      calcList[cntr].xPos-= tmpMoveDistance;//tp do - instate af + 
      // MR: Update length of front waste piece, used for removing via output table
      IF calcList[cntr].operations.WasteStop & calcList[cntr].operations.FrontSaw THEN
         // MR: Check whether trying to shift wastestop position to position wagon cannot reach, if so, remove this wastestop
         IF calcList[cntr].xPos < iMinPosX1 THEN     
            calcList[cntr]:=emptyCalcLine;
            // give warning: waste stop removed?
         ELSE
            // MR: Update length material
            calcList[cntr].productLength += tmpMoveDistance;
         END_IF;
      END_IF; 
    END_FOR;
    
    //change value off tmpProdPos, same for last saw pos
    tmpProdPos-= tmpMoveDistance;// JdK 5-1-2021: + changed into - because we make it smaller
    lastSawPos-= tmpMoveDistance;
  
    //check if we should add frontwaste
    IF o.doFrontWaste= 0 THEN //if we are here, we should add frontwaste, if there is no frontwaste add one, and do it at the right position in the list
      IF O.wasteStopActive THEN
        tmpValue:= 2; //move everything two spots, because we also need waste stop
      ELSE
        tmpValue:= 1; //only move it one spot
      END_IF;
      FOR cntr:= 0 TO nrCalcList-startNrMove DO
        if nrCalcList-cntr-tmpValue > 0 then//TP 10-11-2020 don't do if smaller dan zero
          calcList[nrCalcList-cntr]:= calcList[nrCalcList-cntr-tmpValue]; //move all points in calclist until start nr move one place 
        end_if;
      END_FOR;
      tmpValue:= nrCalcList; //store nrCalcList because it's use in writeCalcList to store the data at the right place
      nrCalcList+= tmpValue; //there's one dataset more, or two
      //tmpValue:= nrCalcList; //store nrCalcList because it's use in writeCalcList to store the data at the right place
      o.doFrontWaste:=1;
   
      writeCalcList(xPos:=tmpMoveDistance, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, sawAngle:= 900, //fill frontsawing at position where we move everything to
           useUnit:=calcOperations.BU1_saw+calcOperations.FrontSaw, toolid:=0);
           
           
      actFrontWaste:= tmpMoveDistance; // MR: van wie? Klopt dit?    
      IF o.wasteStopActive THEN
        writeCalcList(xPos:=tmpMoveDistance+ctrlSettings.offsetWasteStop, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=(stsActInputLength- tmpMoveDistance), sawAngle:= 900, //MR: added productlength
             useUnit:=calcOperations.WasteStop, toolid:=0);
      END_IF;
           
      
      
      nrCalcList:= tmpValue; //set old value back
    END_IF;
    
    
  END_IF; 

END_FUNCTION


FUNCTION calcOperationListV2::destroyBigWaste
//method to check if waste is bigger then maximum, and if it's bigger, destroy it

  IF o.wasteAtFront=1 THEN //if waste is at front, this parameter is always true
    IF actFrontWaste> ctrlSettings.maxLengthWaste & actFrontWaste>0 & ctrlSettings.maxLengthWaste>0 THEN //destroy waste at front if it's to big
      wastePieces:= actFrontWaste/ctrlSettings.maxLengthWaste;
      IF actFrontWaste MOD ctrlSettings.maxLengthWaste > 0 THEN //also for rest there need  to be another piece
        wastePieces+= 1;
      END_IF;
      tmpWaste:= actFrontWaste/ wastePieces; //length of waste piece
      
      //now add the waste piece sawings, we need one sawing less then the number of pieces
      FOR cntr:=1 TO wastePieces-1 DO
        writeCalcList(xPos:=(stsActInputLength-(cntr*tmpWaste)), 
                      yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, 
                  sawAngle:=900,    //waste sawing always at 90 degree
                   useUnit:=calcOperations.Bu1_saw+calcOperations.WastePiece, toolid:=0);
        IF o.wasteStopActive THEN
          writeCalcList(xPos:=stsActInputLength-(cntr*tmpWaste)+ctrlSettings.offsetWasteStop, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, sawAngle:= 900, 
               useUnit:=calcOperations.WasteStop, toolid:=0);
        END_IF;
        
      END_FOR;
    END_IF;
  ELSE //waste is at the end
    IF tmpProdPos > ctrlSettings.maxLengthWaste & ctrlSettings.maxLengthWaste> 0 THEN //check if its to big, but don't divide by 0
      wastePieces:= TO_DINT(tmpProdPos)/ctrlSettings.maxLengthWaste;
      IF TO_DINT(tmpProdPos) MOD ctrlSettings.maxLengthWaste > 0 THEN //also for rest there need  to be another piece
        wastePieces+= 1;
      END_IF;
      tmpWaste:= TO_DINT(tmpProdPos)/ wastePieces; //length of waste piece
      
      //now add the waste piece sawings, we need one sawing less then the number of pieces
      FOR cntr:=1 TO wastePieces-1 DO
        writeCalcList(xPos:=(tmpProdPos+(cntr*tmpWaste)), 
                      yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, 
                  sawAngle:=900,    //waste sawing always at 90 degree
                   useUnit:=calcOperations.Bu1_saw+calcOperations.WastePiece, toolid:=0);
        IF o.wasteStopActive THEN
          writeCalcList(xPos:=tmpProdPos+(cntr*tmpWaste)+ctrlSettings.offsetWasteStop, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, sawAngle:= 900, 
               useUnit:=calcOperations.WasteStop, toolid:=0);
        END_IF;
        
      END_FOR;      
      
    END_IF;
  END_IF;

END_FUNCTION


FUNCTION calcOperationListV2::moveForTurnPointNotAtZero
// move for turn point not at zero, method to compensate for mechanical issues in turningpoint
// only sawing positions has to be changed, is necessary because it's sometimes hard to solve it mechanically

VAR
	tmpAngle: REAL;
END_VAR


  FOR cntr:= 0 TO nrCalcList-1 DO
  
    IF calcList[cntr].operations.Bu1_saw= 1 THEN
      IF sParYposTurnPoint >0 THEN //means turning point if before backguiding
        IF calcList[cntr].sawAngle > 900 THEN
          tmpAngle:= to_real(1800-calcList[cntr].sawAngle)/10 * PIVALUE / 180; //calculate angle to radials, other side of angle bow is easier to calc with
          tmpMoveDistance:= TO_DINT(tan(tmpAngle)*TO_REAL(sParYposTurnPoint));
          calcList[cntr].xPos+= tmpMoveDistance; //saw is going in direction of inputside, distance should be bigger
        ELSIF calcList[cntr].sawAngle < 900 THEN //don't do a thing if angle is 90*
          tmpAngle:= to_real(calcList[cntr].sawAngle)/10 * PIVALUE / 180; //calculate angle to radials, other side of angle bow is easier to calc with
          tmpMoveDistance:= TO_DINT(tan(tmpAngle)*TO_REAL(sParYposTurnPoint));
          calcList[cntr].xPos-= tmpMoveDistance; //saw is going in direction of outputside, distance should be smaller
        END_IF;
      ELSE //turning point behind back guiding, same calculation, but subtract and add are turned around
        IF calcList[cntr].sawAngle > 900 THEN
          tmpAngle:= to_real(1800-calcList[cntr].sawAngle)/10 * PIVALUE / 180; //calculate angle to radials, other side of angle bow is easier to calc with
          tmpMoveDistance:= TO_DINT(tan(tmpAngle)*TO_REAL(sParYposTurnPoint));
          calcList[cntr].xPos-= tmpMoveDistance; //saw is going in direction of inputside, distance should be bigger
        ELSIF calcList[cntr].sawAngle < 900 THEN //don't do a thing if angle is 90*
          tmpAngle:= to_real(calcList[cntr].sawAngle)/10 * PIVALUE / 180; //calculate angle to radials, other side of angle bow is easier to calc with
          tmpMoveDistance:= TO_DINT(tan(tmpAngle)*TO_REAL(sParYposTurnPoint));
          calcList[cntr].xPos+= tmpMoveDistance; //saw is going in direction of outputside, distance should be smaller
        END_IF;        
      END_IF;
    END_IF;
  END_FOR;


END_FUNCTION


FUNCTION calcOperationListV2::addOutputTableOperations
VAR
	tmpOutputID: DINT;
END_VAR
  
  
  // MR: 22-12-2020. Adds operations for removing products and waste pieces based on length of material: removed via pusher on output table or falling into bin by opening table
  
  // Waste stop last piece of material
  IF (ctrlSettings.offsetWasteStop >= iMinPosX1) & o.wasteStopActive THEN
     // Write wastestop with length of piece
     writeCalcList(xPos:=ctrlSettings.offsetWasteStop, 
             yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=TO_DINT(lastSawPos), sawAngle:= 900, 
             useUnit:=calcOperations.WasteStop, toolid:=0); 
  END_IF;  
  
  // Set offset output product equal to offset wastestop
  OffsetOutputProd := ctrlSettings.offsetWasteStop;
  
  
  // Add removing product/waste piece to calclist
  FOR tmpNrCalc:=0 TO DEFMAXCALCLIST DO

    IF (calcList[tmpNrCalc].operations.BU1_saw= 1  & calcList[tmpNrCalc].operations.FrontSaw= 0 &
          calcList[tmpNrCalc].operations.WastePiece= 0) //if sawing is product sawing, we have to remove the product
          | calcList[tmpNrCalc].operations.WasteStop = 1  THEN // if waste piece, we have to remove it (offset in position already added above)
  
       // Remove products
       IF (calcList[tmpNrCalc].operations.BU1_saw= 1  & calcList[tmpNrCalc].operations.FrontSaw= 0 &
          calcList[tmpNrCalc].operations.WastePiece= 0) & (calcList[tmpNrCalc].xPos+OffsetOutputProd) >= iMinPosX1 THEN // Check whether position for removing material is available
       
       
          // Next product length larger than offset = distance saw - table, move sawed product over distance offset to remove
          IF calcList[tmpNrCalc].productLength >= o.MaxlengthForBin THEN 
             // Product should be removed with moving table and pusher 
             tmpOutputID := 100;
             // Push material on table with moving wagon and remove material with pusher
             writeCalcList(xPos:=calcList[tmpNrCalc].xPos+OffsetOutputProd,   
                        yPos:=0, 
                       x2Pos:=0, 
                 operationId:=calcList[tmpNrCalc].operationId, 
                    outputId:=tmpOutputID, 
               productLength:=calcList[tmpNrCalc].productLength,
                    sawAngle:=calcList[cntr].sawAngle,
                     useUnit:=calcOperations.removeProduct,
                      toolid:=0);                        
          ELSE
             // Product should fall in waste bin, open table after sawing, next sawing cycle will push material further
             tmpOutputID := CILOPEN; // Open table (before moving wagon to this position)
             xPosTest := calcList[tmpNrCalc].xPos;
             writeCalcList(xPos:=xPosTest+OffsetOutputProd, 
                        yPos:=0, 
                       x2Pos:=0, 
                 operationId:=calcList[tmpNrCalc].operationId, 
                    outputId:=tmpOutputID, 
               productLength:=calcList[tmpNrCalc].productLength,
                    sawAngle:=calcList[cntr].sawAngle,
                     useUnit:=calcOperations.removeProduct,
                      toolid:=0);                     
          END_IF;
       
       END_IF;
    

       // Remove waste pieces
       IF calcList[tmpNrCalc].operations.WasteStop = 1 THEN

          // Next product length larger than offset = distance saw - table, move sawed product over distance offset to remove
          IF calcList[tmpNrCalc].productLength >= o.MaxlengthForBin THEN  
             // Product should be removed with moving table and pusher, add outputid to current line 
             tmpOutputID := 100;
             // Push material on table with moving wagon and remove material with pusher
             calcList[tmpNrCalc].outputId:=tmpOutputID;                      
          ELSE
             // Product should fall in waste bin, open table after sawing, next sawing cycle will push material further
             tmpOutputID := CILOPEN; // Open table (before moving wagon to this position)
             calcList[tmpNrCalc].outputId:=tmpOutputID; //add outputid to current line                                   
          END_IF;
       
       END_IF; 
    
    END_IF;
    
  END_FOR;
 
END_FUNCTION


FUNCTION calcOperationListV2::addOvertake
  //add take-over/transfer operation 
  //calculate possible positions
  
  iMinPosX1:=iMinPosX1.Read();
  iMaxPosX2:=iMaxPosX2.Read();
  minPosTakeOverForX1:=iMinPosX1+10; //just minimum place of input wagon, with a litte extra for safety, no need to go to the edge
  maxPosTakeOverForX2:=iMaxPosX2+lastProductLength+TO_DINT(lastSawPos)-ctrlSettings.minLengthProdInGripperX2; //length of last product + length of last waste piece should be longer then position of gripper and minimum length in gripper
  
  IF maxPosTakeOverForX2 < minPosTakeOverForX1 THEN
    giveAlarm(errorNr:=3);
  ELSE
    tmpOperationPos:= ctrlSettings.optimumTakeOverPos; //choose optimum take over position, but check on min and max
    IF tmpOperationPos > maxPosTakeOverForX2 THEN
      tmpOperationPos := maxPosTakeOverForX2;
    ELSIF tmpOperationPos < minPosTakeOverForX1 THEN
      tmpOperationPos := minPosTakeOverForX1;
    END_IF;
    writeCalcList(xPos:=tmpOperationPos, yPos:=0, x2Pos:=0, operationId:=0, outputId:=0, productLength:=0, sawAngle:= 900,  useUnit:=calcOperations.TakeOver, toolid:=0);
  END_IF;
  
END_FUNCTION


FUNCTION calcOperationListV2::sortList
//function to sort all operations on x-pos from large to small

  iTmpEnd:=DEFMAXCALCLIST-1;
  FOR iRead:=0 TO iTmpEnd DO
    IF calcList[iRead].xPos = 0 & calcList[iRead].operations = 0 THEN //means empty
      iEnd:=iRead-1;
      iRead:=iTmpEnd;
    END_IF;
  END_FOR;
  //check if there is data, else don't bubble
  IF iEnd > 1 THEN
    iTmpEnd:=iEnd-1;
    
    REPEAT
      FOR iRead:=0 to iTmpEnd DO
        IF calcList[iRead].xPos < calcList[iRead+1].xPos THEN
          tmpCalcPoint:=calcList[iRead];
          calcList[iRead]:=calcList[iRead+1];
          calcList[iRead+1]:=tmpCalcPoint;
        END_IF;
      END_FOR; 
      iTmpEnd-=1;
    UNTIL iTmpEnd<=0 END_REPEAT;
    
  END_IF;  
  
END_FUNCTION


FUNCTION calcOperationListV2::combineOperations
//check if operations can be moved so we can do them together

  nrOptimizer:=0;
  
  
  //first step is check if we can move operations to the same x-pos, we only change x posses here
  //we do this twice, one time only with operations on fixed positions, after that with operations that can move
  //we start at the end
//

// JdK 19-11-2020: don't move mill for 4642

//  FOR cntr:=1 TO nrCalcList-1 DO 
//    nrInList:=nrCalcList-cntr;
//    
//    IF calcList[nrInList].operations.BU1_saw | calcList[nrInList].operations.WasteStop THEN //some fixed point operations
//      FOR i:= 1 TO 100 DO //check if operations before can be changed to this position
//        IF nrInList-i >= 1 THEN //of course stop if we are below one, first is taking in material (pos 0)
//          
//          tmpOptimed:= 0;
//          IF calcList[nrInList-i].operations.Bu2_mill1= 1 THEN //check for drill1, this one can be moved to, 
//            tmpMillProg:= ctrlMillProgDb.GetRecipe(id:=calcList[nrInList-i].MillPosses[1].id);
//            IF (calcList[nrInList-i].xPos-calcList[nrInList].xPos)< 
//                               (calcList[nrInList-i].MillPosses[1].xPos-tmpMillProg.offsetForXmovement-iMinPosXMill1-tmpMillProg.xDimension) THEN //means enough space to move to next x pos
//              calcList[nrInList-i].xPos:= calcList[nrInList].xPos; //write new x pos 
//              calcList[nrInList-i].MillPosses[1].xPos-= calcList[nrInList-i].xPos- calcList[nrInList].xPos; //change start pos milling
//              calcList[nrInList-i].operations.optimDone:= 1;
//              tmpOptimed:= 1;
//            END_IF;
//          END_IF;
//        ELSE
//          i:= 101;
//        END_IF;
//      END_FOR;
//    END_IF;
//
//  END_FOR;

  sortList();



  FOR cntr:=0 TO DEFMAXCALCLIST-1 DO //check if we can put operations together, possible changes in x pos are already done

    IF calcList[cntr].operations = 0 THEN //if nothing to do, stop
      cntr:= DEFMAXCALCLIST;
    ELSE
      FOR i:=1 TO 10 DO //not only see if next operations can be together, but also look to about 10 others, but stop if xpos isn't same anymore
        
        tmpOptimed:=0;
        
        IF calcList[cntr].xPos = calcList[cntr+i].xPos & //at same x pos
           (calcList[cntr].operations.Bu2_mill1=0 | calcList[cntr+i].operations.Bu2_mill1=0 ) &
           (calcList[cntr].operations.Bu3_mill2=0 | calcList[cntr+i].operations.Bu3_mill2=0 )  THEN //only one milling at the same line
              
          IF calcList[cntr].operations.Bu2_mill1  THEN //copy stuff for milling units
            calcList[cntr+i].MillPosses[1]:= calcList[cntr].MillPosses[1];
            calcList[cntr+i].operationId:= calcList[cntr].operationId;
          END_IF;
          
          IF calcList[cntr].operations.Bu3_mill2  THEN //copy stuff for milling units
            calcList[cntr+i].MillPosses[2]:= calcList[cntr].MillPosses[2];
            calcList[cntr+i].operationId:= calcList[cntr].operationId;
          END_IF;          
           
          IF calcList[cntr].operations.BU1_saw THEN
            calcList[cntr+i].outputId:= calcList[cntr].outputId; //if sawing, use output ID and angle
            calcList[cntr+i].sawAngle:= calcList[cntr].sawAngle;
          END_IF;
          
          IF calcList[cntr].operations.removeProduct THEN //copy stuff for output
            calcList[cntr+i].outputId:= calcList[cntr].outputId;
          END_IF;
          
          calcList[cntr+i].operations:= calcList[cntr].operations OR calcList[cntr+i].operations;
          
          
          calcList[cntr]:=emptyCalcLine;
          
          FOR iRead:= cntr TO DEFMAXCALCLIST-1 DO //and move emptied line to end of list
            calcList[iRead]:=calcList[iRead+1];
          END_FOR;
          nrOptimizer+=1;
          tmpOptimed:= 1;
          
        ELSIF calcList[cntr].xPos <> calcList[cntr+i].xPos THEN
        
          i:= 10;
        
        END_IF;
          

        IF nrOptimizer <= 10000 & tmpOptimed= 1 THEN //don't do this to long
          cntr-=1; //check again if next pos is the same
          nrOptimizer+= 1;
          i:=10;//start again
        END_IF;
      
      END_FOR;
    END_IF;

  END_FOR;

  nrOptimizer:=0;
  FOR cntr:=0 TO DEFMAXCALCLIST-1 DO //check if we can put take over together with other operation
    IF calcList[cntr].operations = calcOperations.TakeOver THEN //only if take over is on it's own in the list
      IF calcList[cntr+1].xPos >= ctrlSettings.minTakeOverPos & calcList[cntr+1].xPos >= minPosTakeOverForX1 THEN //add takeover to next line, means smaller x1 pos

        calcList[cntr+1].operations.TakeOver:=1;

        FOR iRead:=cntr TO DEFMAXCALCLIST-1 DO //also move empty calcpoint to end of list
          calcList[iRead]:=calcList[iRead+1];
        END_FOR;        

      ELSIF cntr >= 1 & calcList[cntr-1].xPos <= ctrlSettings.maxTakeOverPos & calcList[cntr-1].xPos <= maxPosTakeOverForX2 THEN //add takeover to line before, means bigger x1 pos

        calcList[cntr-1].operations.TakeOver:=1;

        FOR iRead:=cntr TO DEFMAXCALCLIST-1 DO //also move empty calcpoint to end of list
          calcList[iRead]:=calcList[iRead+1];
        END_FOR;        
              
      END_IF;
      
    END_IF;

  END_FOR;

END_FUNCTION


FUNCTION GLOBAL calcOperationListV2::getLineFromList
	VAR_INPUT
		nr 	: DINT;
	END_VAR
	VAR_OUTPUT
		line 	: calcLine;
	END_VAR
  
  IF nr>=0 & nr<=DEFMAXCALCLIST THEN
    line:= calcList[nr];
  ELSE
    _memset(dest:=#line, usByte:=0, cntr:=sizeof(line));
  END_IF;
  
END_FUNCTION


FUNCTION GLOBAL calcOperationListV2::giveNextOutputOperation
	VAR_INPUT
		startNr 	: DINT;
	END_VAR
	VAR_OUTPUT
		nextIsTable 	: DINT;
	END_VAR

 nextIsTable:=-1; 

  IF calcDone= 1 THEN
    FOR cntr:=startNr+1 TO DEFMAXCALCLIST DO
      IF (calcList[cntr].operations.WasteStop = 1 | calcList[cntr].operations.removeProduct= 1) & calcList[cntr].outputId= 100  THEN //output with table
        nextIsTable:=1;
        cntr:= DEFMAXCALCLIST+1;
      ELSIF (calcList[cntr].operations.WasteStop= 1 | calcList[cntr].operations.removeProduct= 1) & calcList[cntr].outputId= CILOPEN THEN //outputwith wastebin
        nextIsTable:= 0;
        CNTR:= DEFMAXCALCLIST+1;
      ELSIF calcList[cntr].operations= 0 THEN
        cntr:= DEFMAXCALCLIST+1;
      END_IF;
    END_FOR;

    IF nextIsTable= -1 THEN //no operation found. means start at begin in list to find first removing operation
      FOR cntr:=1 TO DEFMAXCALCLIST DO
        IF (calcList[cntr].operations.WasteStop= 1 | calcList[cntr].operations.removeProduct= 1) & calcList[cntr].outputId= 100 THEN //output with table
          nextIsTable:=1;
          cntr:= DEFMAXCALCLIST+1;
        ELSIF (calcList[cntr].operations.WasteStop= 1 | calcList[cntr].operations.removeProduct= 1) & calcList[cntr].outputId= CILOPEN THEN //remove product with wastebin
          nextIsTable:= 0;
          CNTR:= DEFMAXCALCLIST+1;
        ELSIF calcList[cntr].operations= 0 THEN
          cntr:= DEFMAXCALCLIST+1;
          nextIsTable:= 1;
        END_IF;
      END_FOR;    
    END_IF; 


  ELSE
    nextIsTable:=0;
  END_IF;


END_FUNCTION


FUNCTION calcOperationListV2::addLastOperations
  VAR
    firstDoneBu1: DINT; // RVDL 10-1-2020 added Bu1 for pressure roll
    firstDoneBu2: DINT;
    firstDoneBu3: DINT;
    firstDoneBu4: DINT;
    firstDoneBu5: DINT;
    firstDoneBu6: DINT;
    lastDoneBu1: DINT;
    lastDoneBu2: DINT;
    lastDoneBu3: DINT;
    lastDoneBu4: DINT;
    lastDoneBu5: DINT;
    lastDoneBu6: DINT;
  END_VAR


  firstDoneBu1:=0; // RVDL 10-1-2020 added Bu1 for pressure roll
  firstDoneBu2:=0;
  firstDoneBu3:=0;
  firstDoneBu4:=0;
  firstDoneBu5:=0;
  firstDoneBu6:=0;
  lastDoneBu1:=0;
  lastDoneBu2:=0;
  lastDoneBu3:=0;
  lastDoneBu4:=0;
  lastDoneBu5:=0;
  lastDoneBu6:=0;
  
  FOR nrCalcList:=DEFMAXCALCLIST TO 0 BY -1 DO
    IF lastDoneBu1=0 & calcList[nrCalcList].operations.BU1_saw=1 THEN
      calcList[nrCalcList].operations.EndSaw:= 1;
      lastDoneBu1:= 1;
    END_IF;
    IF lastDoneBu2=0 & calcList[nrCalcList].operations.Bu2_mill1=1 THEN
      calcList[nrCalcList].operations.LastInAssemb:= 1;
      lastDoneBu2:= 1;
    END_IF;
    IF lastDoneBu3=0 & calcList[nrCalcList].operations.Bu3_mill2=1 THEN
      calcList[nrCalcList].operations.LastInAssemb:= 1;
      lastDoneBu3:= 1;
    END_IF;
    IF lastDoneBu4=0 & calcList[nrCalcList].operations.Bu4=1 THEN
      calcList[nrCalcList].operations.LastInAssemb:= 1;
      lastDoneBu4:= 1;
    END_IF;
    IF lastDoneBu5=0 & calcList[nrCalcList].operations.Bu5=1 THEN
      calcList[nrCalcList].operations.LastInAssemb:= 1;
      lastDoneBu5:= 1;
    END_IF;
    IF lastDoneBu6=0 & calcList[nrCalcList].operations.Bu6=1 THEN
      calcList[nrCalcList].operations.LastInAssemb:= 1;
      lastDoneBu6:= 1;
    END_IF;
  END_FOR;

  FOR nrCalcList:=0 TO DEFMAXCALCLIST DO
    // RVDL 10-1-2020 added BU1 for the purpose to control pressure roll right before first sawing
    IF firstDoneBu1= 0 & calcList[nrCalcList].operations.BU1_saw THEN
      calcList[nrCalcList].operations.FirstInAssemb:=1;
      firstDoneBu1:=1;
    END_IF; 
  
    IF firstDoneBu2= 0 & calcList[nrCalcList].operations.Bu2_mill1=1 THEN
      calcList[nrCalcList].operations.FirstInAssemb:=1;
      firstDoneBu2:=1;
    END_IF; 
    IF firstDoneBu3= 0 & calcList[nrCalcList].operations.Bu3_mill2=1 THEN
      calcList[nrCalcList].operations.FirstInAssemb:=1;
      firstDoneBu3:=1;
    END_IF; 
    IF firstDoneBu4= 0 & calcList[nrCalcList].operations.Bu4=1 THEN
      calcList[nrCalcList].operations.FirstInAssemb:=1;
      firstDoneBu4:=1;
    END_IF; 
    IF firstDoneBu5= 0 & calcList[nrCalcList].operations.Bu5=1 THEN
      calcList[nrCalcList].operations.FirstInAssemb:=1;
      firstDoneBu5:=1;
    END_IF; 
    IF firstDoneBu6= 0 & calcList[nrCalcList].operations.Bu6=1 THEN
      calcList[nrCalcList].operations.FirstInAssemb:=1;
      firstDoneBu6:=1;
    END_IF; 
  END_FOR;
  
  //fill in used units, to make it possible to start motors at starting
  stsUsedUnits:= 0;
  IF lastDoneBu1 THEN
    stsUsedUnits.BU1:= 1;
  END_IF;
  IF firstDoneBu2 | lastDoneBu2 THEN
    stsUsedUnits.BU2:= 1;
  END_IF;
  IF firstDoneBu3 | lastDoneBu3 THEN
    stsUsedUnits.BU3:= 1;
  END_IF;
  IF firstDoneBu4 | lastDoneBu4 THEN
    stsUsedUnits.BU4:= 1;
  END_IF;
  IF firstDoneBu5 | lastDoneBu5 THEN
    stsUsedUnits.BU5:= 1;
  END_IF;
  IF firstDoneBu6 | lastDoneBu6 THEN
    stsUsedUnits.BU6:= 1;
  END_IF;  
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL calcOperationListV2::restLength::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR
  
  
  actAssembly:=ctrlAssemblyDb.GetRecipe(id:=TO_DINT(ctrlAssemblyDb.RecipeId));
  if actAssembly.recipeList[0].amount>0 & actAssembly.recipeList[0].productId>0 & actAssembly.inputLength>0 then
    if (actAssembly<> TmpAssembly | TimerRest.done) & RestlengteOn = 0  then
      RestlengteOn:=1;
      TmpAssembly:=actAssembly;
      stprCalc:=1;
    end_if;
    restLength:=tmpMoveDistance;
  else
    RestlengteOn:= 0;
    restLength:=FAULTVALUE;
  end_if;
   
	output := restLength;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL calcOperationListV2::restLength::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	restLength := input;
  restLength.Read();
	result := restLength;

END_FUNCTION
